---
layout: post
title: "Quelques réflexions sur le BASIC du PHC-25"
date: 2025-06-14 8:00
comments: true
tags: [ phc25, retro, 8bits, basic ]
---

Le basic du PHC-25 est à l'image de l'ordinateur lui-même, il laisse un goût
amer. On a la sensation d'être passé pas loin de quelque chose de très bien.
Mais il y a trop de problèmes. Voici un (très) rapide tour d'horizon.

<!-- more -->

## Restriction des noms de variable
Le problème le plus important selon moi est la limitation de la longueur des
noms de variable à **deux caractères**. Ce qui va entrainer une profusion de
`c1`, `c2`, `c3`, etc. Bref, le PHC-25 devrait réussir à rendre un programme
assembleur plus expressif qu'un programme BASIC.

Peut-être pire, on peut malgré tout utiliser les noms qu'on veut. C'est à dire
que `po`, `poire` et `pomme` seront en fait la même variable ! Et dans un
langage où toutes les variables sont globales ça ne peut que mal se passer.

_(Pour être honnête il me semble que le PHC-25 n'est pas le seul à faire ça.)_

## Pas de _vrai_ nombres entiers
Dans la plupart des BASIC les variables numériques sont d'office des nombres à
virgule. Et le PHC-25 ne déroge pas à la règle. Mais bien souvent on peut «typer»
une variable pour qu'elle ne contienne que des nombres entiers. Ça permet généralement un
gain de performance, par exemple sur des boucles. Et la performance sur les ordinateurs 8 bits est
un souci permanent.

Malheureusement il n'y a pas de variables entières dans le BASIC du PHC-25.
Et c'est d'autant plus décevant que le manuel affirme que c'est possible,
alors que non :(

## Modes graphiques incompréhensibles
Un seul mot pour qualifier les modes graphiques en BASIC : frustration.
Pour comprendre, il faut un Bac+15.

Un exemple parmi tant d'autres : en mode `screen 2` la résolution est de
64x48 pixels. L'instruction pour allumer un pixel est `PSET(x,y),c` (où c est la couleur).
On s'attend donc à ce que le pixel en haut à gauche s'allume avec
`PSET(0,0),c`, son copain de droite avec `PSET(1,0),c` et le pixel en bas à droite
avec `PSET(63,47),c`. Mais non. Beaucoup trop simple ! On devra utiliser les coordonnées
comme si on était en haute résolution (256x192). Donc pour allumer le pixel de
coordonnées (63,47) en basse résolution il faudra faire un `PSET(255,191),c`.
C'est tellement évident ! Et comme un pixel basse résolution est en réalité un
bloc de 4 pixels (haute résolution) de coté, il y a 16 coordonnées différentes
pour allumer le même pixel en basse résolution. Si ce qui précède n'a aucun sens
pour vous, pas d'inquiétude : ça n'a de sens pour personne.

## Le son
Sur le papier, ça promet du lourd : un véritable synthétiseur 3 voix.
Une instruction `SOUND`, complexe, mais qui permet de programmer le synthé avec précision.
Et une instruction `PLAY`, plus simple, qui permet de programmer facilement des petites
mélodies sur 1, 2, ou 3 voix.
Mais là encore, un problème va venir tout péter. La gestion du synthé en BASIC s'avère
incapable d'assurer la synchronisation entre les 3 voix. Au bout de quelques secondes plus
rien n'est en place et ça devient un supplice pour les oreilles.

## Quelques instructions intéressantes

Malgré des défauts évidents, tout n'est pas à jeter dans ce basic. Comme par exemple l'instruction `TIME` qui
compte le temps écoulé depuis l'allumage de l'ordi.
On peut aussi citer `PAINT`, pour colorier l'intérieur d'une figure. Ou encore `STICK` et `STRIG`
qui s'occupent de gérer un joystick.

## Conclusion
C'est plaisant de déterrer cette machine oubliée le temps d'une _game jam_,
mais je pense qu'après ça, je m'empresserai de l'oublier à nouveau ;)
