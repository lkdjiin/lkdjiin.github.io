<!DOCTYPE html>
<html lang="fr"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://lkdjiin.github.io/atom.xml" title="Xavier Nayrac" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Xavier Nayrac</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">À propos</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Comment écrire un framework de test pour Ruby</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2016-11-02T09:06:00+01:00" itemprop="datePublished">02 November 2016
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>Si vous souhaitez comprendre le fonctionnement d’un framework de test, si vous
voulez écrire votre propre framework et que vous ressentiez le besoin d’un coup
de pouce, cet article est fait pour vous. Nous verrons étape par étape comment écrire
une telle chose. Le framework que nous réaliserons tiendra en quelques dizaines de
lignes de Ruby et pourra être utilisé comme une base pour vos futures
réalisations.</p>

<p><img class="center" src="/images/colorful-test-tubes.jpg" /></p>

<!-- more -->

<h2 id="par-où-commencer-">Par où commencer ?</h2>

<p>Pour ce genre de problématique, je trouve qu’il est plus simple de partir d’un
exemple concret du <strong>langage</strong>, de l’<strong>API</strong>, que l’on souhaite obtenir. Dans notre
cas, nous pouvons déjà écrire quelques tests même si nous ne pouvons pas encore
les faire tourner.</p>

<p>Voici 3 tests pour une classe Rover. Classe qui aura une position x,y et une
direction :</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="c1"># fichier test_rover.rb final.</span>

<span class="nb">require</span> <span class="s1">'rover'</span>

<span class="k">class</span> <span class="nc">TestRover</span> <span class="o">&lt;</span> <span class="no">Tasty</span><span class="o">::</span><span class="no">Unit</span>

  <span class="k">def</span> <span class="nf">test_it_has_a_position</span>
    <span class="n">rover</span> <span class="o">=</span> <span class="no">Rover</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">rover</span><span class="p">.</span><span class="nf">position</span> <span class="o">==</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">test_it_has_a_direction_by_default</span>
    <span class="n">rover</span> <span class="o">=</span> <span class="no">Rover</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">rover</span><span class="p">.</span><span class="nf">direction</span> <span class="o">==</span> <span class="s1">'north'</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">test_it_has_a_given_direction</span>
    <span class="n">rover</span> <span class="o">=</span> <span class="no">Rover</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">'west'</span><span class="p">)</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">rover</span><span class="p">.</span><span class="nf">direction</span> <span class="o">==</span> <span class="s1">'west'</span><span class="p">)</span>
  <span class="k">end</span>

<span class="k">end</span></code></pre></figure>

<p>J’ai cherché à faire au plus simple. Tout se passe à l’intérieur d’une classe.
Ça nous permettra d’hériter facilement de certains comportements, comme la
méthode <code class="language-plaintext highlighter-rouge">assert</code> qui sera définit dans la classe <code class="language-plaintext highlighter-rouge">Tasty::Unit</code>.</p>

<p>Chaque méthode qui commence par <code class="language-plaintext highlighter-rouge">test_</code> représente un test, et <code class="language-plaintext highlighter-rouge">assert</code> se
contente de vérifier si son argument est vrai ou faux.</p>

<p>On lancera le programme avec le nom d’un fichier de test, par exemple
<code class="language-plaintext highlighter-rouge">tasty test_rover.rb</code>. Mais par souci de simplicité, nous nous contenterons
d’utiliser directement l’interpréteur Ruby de cette manière :
<code class="language-plaintext highlighter-rouge">ruby tasty.rb test_rover.rb</code>.</p>

<p>Voici ce que j’imagine en terme d’affichage :</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ruby tasty.rb test_rover.rb
ok - test_it_has_a_position
not ok - test_it_has_a_given_direction
&lt;&lt; ERROR REPORT GOES HERE &gt;&gt;
ok - test_it_has_a_direction_by_default
</code></pre></div></div>

<p>Le nom d’un test est précédé de “ok” si il a réussi, ou de “not ok” si il a
échoué. Le rapport d’erreur est affiché aussitôt après une ligne “not ok”.</p>

<h2 id="retrouver-la-classe-de-test">Retrouver la classe de test</h2>

<p>Commençons par le plus simple, définissons une classe Rover dans un fichier
<code class="language-plaintext highlighter-rouge">rover.rb</code> :</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="c1"># fichier rover.rb</span>

<span class="k">class</span> <span class="nc">Rover</span>
<span class="k">end</span></code></pre></figure>

<p>Puis définissons notre premier test, dans un fichier <code class="language-plaintext highlighter-rouge">test_rover.rb</code>. Ce
premier test va nous guider pendant un bout de temps :</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="c1"># fichier test_rover.rb</span>

<span class="nb">require_relative</span> <span class="s1">'rover'</span>

<span class="k">class</span> <span class="nc">TestRover</span> <span class="o">&lt;</span> <span class="no">Tasty</span><span class="o">::</span><span class="no">Unit</span>

  <span class="k">def</span> <span class="nf">test_it_has_a_position</span>
    <span class="n">rover</span> <span class="o">=</span> <span class="no">Rover</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">rover</span><span class="p">.</span><span class="nf">position</span> <span class="o">==</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
  <span class="k">end</span>

<span class="k">end</span></code></pre></figure>

<p>Maintenant, dans un fichier <code class="language-plaintext highlighter-rouge">tasty.rb</code>, définissons le namespace Tasty et une
classe principale. Nous initialiserons cette classe avec le nom de fichier
passé en argument sur la ligne de commande. Nous afficherons un message
temporaire pour nous assurer que nous sommes sur la bonne voie :</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="c1"># fichier tasty.rb</span>

<span class="k">module</span> <span class="nn">Tasty</span>

  <span class="k">class</span> <span class="nc">Main</span>
    <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
      <span class="nb">puts</span> <span class="s2">"Testing </span><span class="si">#{</span><span class="n">filename</span><span class="si">}</span><span class="s2">"</span>
    <span class="k">end</span>
  <span class="k">end</span>

<span class="k">end</span>

<span class="n">main</span> <span class="o">=</span> <span class="no">Tasty</span><span class="o">::</span><span class="no">Main</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="no">ARGV</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span></code></pre></figure>

<p>L’essai est concluant :</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ruby tasty.rb test_rover.rb
Testing test_rover.rb
</code></pre></div></div>

<p>Tant qu’on y est, mieux vaut définir tout de suite la classe <code class="language-plaintext highlighter-rouge">Tasty::Unit</code>,
voici à quoi devrait ressembler votre fichier <code class="language-plaintext highlighter-rouge">tasty.rb</code> :</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="c1"># fichier tasty.rb</span>

<span class="k">module</span> <span class="nn">Tasty</span>

  <span class="k">class</span> <span class="nc">Unit</span>
  <span class="k">end</span>

  <span class="k">class</span> <span class="nc">Main</span>
    <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
      <span class="nb">puts</span> <span class="s2">"Testing </span><span class="si">#{</span><span class="n">filename</span><span class="si">}</span><span class="s2">"</span>
    <span class="k">end</span>
  <span class="k">end</span>

<span class="k">end</span>

<span class="n">main</span> <span class="o">=</span> <span class="no">Tasty</span><span class="o">::</span><span class="no">Main</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="no">ARGV</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span></code></pre></figure>

<p>Passons maintenant au sujet principal de cette section : nous devons retrouver
le nom de la classe de test, à savoir <code class="language-plaintext highlighter-rouge">TestRover</code>, depuis la classe
<code class="language-plaintext highlighter-rouge">Tasty::Main</code>. Pour ce faire nous pourrions écrire un parser qui
analyserait le contenu du fichier passé en argument. Ou bien nous pouvons
compter sur les facilités d’introspection du langage Ruby. Je parie volontiers
sur cette seconde solution. Nous laisserons Ruby charger et parser le fichier de
test pour nous. Nous chargerons le fichier de la même manière qu’un autre, avec
un <code class="language-plaintext highlighter-rouge">require</code>. Puis nous utilerons <code class="language-plaintext highlighter-rouge">Object.constants</code> pour accéder à toutes les
constantes définies jusqu’ici (une classe est représentée par une constante) :</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">module</span> <span class="nn">Tasty</span>

  <span class="k">class</span> <span class="nc">Main</span>
    <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
      <span class="nb">require</span> <span class="no">File</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="no">Dir</span><span class="p">.</span><span class="nf">pwd</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
      <span class="nb">puts</span> <span class="no">Object</span><span class="p">.</span><span class="nf">constants</span>
    <span class="k">end</span>
  <span class="k">end</span>

<span class="k">end</span></code></pre></figure>

<p>Si vous lancez ce programme, vous verrez une liste de toutes les constantes
définies, dont celle que nous cherchons, <code class="language-plaintext highlighter-rouge">TestRover</code> :</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ruby tasty.rb test_rover.rb 
Object
Module
Class
BasicObject
...
SimpleDelegator
Tasty
Rover
TestRover # &lt;============================
RUBYGEMS_ACTIVATION_MONITOR
</code></pre></div></div>

<p>Attention, il s’agit d’un tableau de symboles. Vous pouvez vous en convaincre
en changeant de méthode d’affichage. Remplacez <code class="language-plaintext highlighter-rouge">puts</code> par <code class="language-plaintext highlighter-rouge">p</code> :</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
  <span class="nb">require</span> <span class="no">File</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="no">Dir</span><span class="p">.</span><span class="nf">pwd</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
  <span class="nb">p</span> <span class="no">Object</span><span class="p">.</span><span class="nf">constants</span>
<span class="k">end</span></code></pre></figure>

<p>Vous pouvez voir qu’il s’agit de symboles :</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ruby tasty.rb test_rover.rb 
[:Object, :Module, :Class, :BasicObject, :Kernel, :NilClass, :NIL, :Data,
...
:SimpleDelegator, :Tasty, :Rover, :TestRover, :RUBYGEMS_ACTIVATION_MONITOR]
</code></pre></div></div>

<p>Nous pouvons sélectionner uniquement les classes commençant par <code class="language-plaintext highlighter-rouge">Test</code> :</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="c1"># fichier tasty.rb</span>

<span class="k">module</span> <span class="nn">Tasty</span>

  <span class="k">class</span> <span class="nc">Unit</span>
  <span class="k">end</span>

  <span class="k">class</span> <span class="nc">Main</span>
    <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
      <span class="nb">require</span> <span class="no">File</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="no">Dir</span><span class="p">.</span><span class="nf">pwd</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
      <span class="nb">p</span> <span class="no">Object</span><span class="p">.</span><span class="nf">constants</span><span class="p">.</span><span class="nf">select</span> <span class="p">{</span> <span class="o">|</span><span class="nb">name</span><span class="o">|</span> <span class="nb">name</span><span class="p">.</span><span class="nf">to_s</span><span class="p">.</span><span class="nf">start_with?</span><span class="p">(</span><span class="s1">'Test'</span><span class="p">)</span> <span class="p">}</span>
    <span class="k">end</span>
  <span class="k">end</span>

<span class="k">end</span>

<span class="n">main</span> <span class="o">=</span> <span class="no">Tasty</span><span class="o">::</span><span class="no">Main</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="no">ARGV</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span></code></pre></figure>

<p>Nous avons réduit le tableau aux seules classes de test. Nous en avons une
seule ici, mais nous pourrions très bien en avoir plusieurs :</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ruby tasty.rb test_rover.rb 
[:TestRover]
</code></pre></div></div>

<p>Il y a une convention qui est à l’oeuvre : seule une classe de test peut
commencer par <code class="language-plaintext highlighter-rouge">Test</code>. Ça n’est pas un bien grand sacrifice, et nous pourrions
y remédier si besoin.</p>

<h2 id="les-méthodes-de-test">Les méthodes de test</h2>

<p>La prochaine étape consistera à récupérer les méthodes qui sont dans la classe
de test, et à les lancer.</p>

<p>Un peu de recherche, dans une session irb et avec la <a href="http://ruby-doc.org/">documentation Ruby</a>,
nous montrera que nous pouvons transformer un symbole en une classe, et aussi
instancier cette classe, à l’aide de <code class="language-plaintext highlighter-rouge">Object.const_get</code> :</p>

<figure class="highlight"><pre><code class="language-irb" data-lang="irb"><span class="go">$ irb
&gt;&gt; :Module
:Module
&gt;&gt; Object.const_get(:Module)
Module &lt; Object
&gt;&gt; Object.const_get(:Module).new
</span><span class="c">#&lt;Module:0x0055e0036e5580&gt;</span></code></pre></figure>

<p>On peut donc transformer notre tableau de symboles selon cette méthode :</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">Main</span>
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
    <span class="nb">require</span> <span class="no">File</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="no">Dir</span><span class="p">.</span><span class="nf">pwd</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
    <span class="n">classes</span> <span class="o">=</span> <span class="no">Object</span><span class="p">.</span><span class="nf">constants</span><span class="p">.</span><span class="nf">select</span> <span class="p">{</span> <span class="o">|</span><span class="nb">name</span><span class="o">|</span> <span class="nb">name</span><span class="p">.</span><span class="nf">to_s</span><span class="p">.</span><span class="nf">start_with?</span><span class="p">(</span><span class="s1">'Test'</span><span class="p">)</span> <span class="p">}</span>
    <span class="n">classes</span><span class="p">.</span><span class="nf">map!</span> <span class="p">{</span> <span class="o">|</span><span class="nb">name</span><span class="o">|</span> <span class="no">Object</span><span class="p">.</span><span class="nf">const_get</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span> <span class="p">}</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre></figure>

<p>Retournons dans une session irb pour voir comment obtenir les méthodes d’une
classe quelconque.  Définissons une classe <code class="language-plaintext highlighter-rouge">C</code> avec une méthode
<code class="language-plaintext highlighter-rouge">method_in_class_c</code> pour les besoins de la cause :</p>

<figure class="highlight"><pre><code class="language-irb" data-lang="irb"><span class="go">$ irb
&gt;&gt; class C
&gt;&gt;   def method_in_class_c; end
&gt;&gt; end</span></code></pre></figure>

<p>La méthode <code class="language-plaintext highlighter-rouge">instance_methods</code> appliquée sur une classe liste les méthodes de
cette classe. Nous retrouvons notre méthode <code class="language-plaintext highlighter-rouge">method_in_class_c</code>, parmi plein
d’autres :</p>

<figure class="highlight"><pre><code class="language-irb" data-lang="irb"><span class="go">&gt;&gt; puts C.instance_methods
method_in_class_c # &lt;--------------------
methods
singleton_methods
protected_methods
private_methods
public_methods
instance_of?
</span><span class="c">...</span></code></pre></figure>

<p>D’où viennent ces autres méthodes ? Ce sont les méthodes héritées ou incluses.
Pour restreindre les méthodes à celles définies dans la classe C, nous devons
utiliser un artifice :</p>

<figure class="highlight"><pre><code class="language-irb" data-lang="irb"><span class="go">&gt;&gt; puts C.instance_methods(false)
method_in_class_c</span></code></pre></figure>

<p>Nous pouvons nous servir de ce nouveau savoir pour lister les méthodes de test :</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="c1"># fichier tasty.rb</span>

<span class="k">module</span> <span class="nn">Tasty</span>

  <span class="k">class</span> <span class="nc">Unit</span>
  <span class="k">end</span>

  <span class="k">class</span> <span class="nc">Main</span>
    <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
      <span class="nb">require</span> <span class="no">File</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="no">Dir</span><span class="p">.</span><span class="nf">pwd</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
      <span class="n">classes</span> <span class="o">=</span> <span class="no">Object</span><span class="p">.</span><span class="nf">constants</span><span class="p">.</span><span class="nf">select</span> <span class="p">{</span> <span class="o">|</span><span class="nb">name</span><span class="o">|</span> <span class="nb">name</span><span class="p">.</span><span class="nf">to_s</span><span class="p">.</span><span class="nf">start_with?</span><span class="p">(</span><span class="s1">'Test'</span><span class="p">)</span> <span class="p">}</span>
      <span class="n">classes</span><span class="p">.</span><span class="nf">map!</span> <span class="p">{</span> <span class="o">|</span><span class="nb">name</span><span class="o">|</span> <span class="no">Object</span><span class="p">.</span><span class="nf">const_get</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span> <span class="p">}</span>
      
      <span class="n">classes</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">c</span><span class="o">|</span>
        <span class="n">c</span><span class="p">.</span><span class="nf">instance_methods</span><span class="p">(</span><span class="kp">false</span><span class="p">).</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">m</span><span class="o">|</span>
          <span class="nb">puts</span> <span class="n">m</span>
        <span class="k">end</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>

<span class="k">end</span>

<span class="n">main</span> <span class="o">=</span> <span class="no">Tasty</span><span class="o">::</span><span class="no">Main</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="no">ARGV</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span></code></pre></figure>

<p>Nous l’avons trouvé :</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ruby tasty.rb test_rover.rb 
test_it_has_a_position
</code></pre></div></div>

<p>Il reste à lancer chaque test en se servant de la méthode <a href="http://ruby-doc.org/core-2.3.1/Object.html#method-i-send">send</a> sur une
instance de la classe de test. Nous ferons cela ailleurs que dans le
constructeur de la classe Tasty::Main. Dans une méthode <code class="language-plaintext highlighter-rouge">run</code> par exemple, ça
sera plus propre :</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="c1"># fichier tasty.rb</span>

<span class="k">module</span> <span class="nn">Tasty</span>

  <span class="k">class</span> <span class="nc">Unit</span>
  <span class="k">end</span>

  <span class="k">class</span> <span class="nc">Main</span>
    <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
      <span class="nb">require</span> <span class="no">File</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="no">Dir</span><span class="p">.</span><span class="nf">pwd</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
      <span class="vi">@classes</span> <span class="o">=</span> <span class="no">Object</span><span class="p">.</span><span class="nf">constants</span><span class="p">.</span><span class="nf">select</span> <span class="p">{</span> <span class="o">|</span><span class="nb">name</span><span class="o">|</span> <span class="nb">name</span><span class="p">.</span><span class="nf">to_s</span><span class="p">.</span><span class="nf">start_with?</span><span class="p">(</span><span class="s1">'Test'</span><span class="p">)</span> <span class="p">}</span>
      <span class="vi">@classes</span><span class="p">.</span><span class="nf">map!</span> <span class="p">{</span> <span class="o">|</span><span class="nb">name</span><span class="o">|</span> <span class="no">Object</span><span class="p">.</span><span class="nf">const_get</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span> <span class="p">}</span>
    <span class="k">end</span>

    <span class="k">def</span> <span class="nf">run</span>
      <span class="vi">@classes</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">class_under_test</span><span class="o">|</span>
        <span class="n">instance</span> <span class="o">=</span> <span class="n">class_under_test</span><span class="p">.</span><span class="nf">new</span>
        <span class="n">class_under_test</span><span class="p">.</span><span class="nf">instance_methods</span><span class="p">(</span><span class="kp">false</span><span class="p">).</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">m</span><span class="o">|</span>
          <span class="n">instance</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
        <span class="k">end</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>

<span class="k">end</span>

<span class="n">main</span> <span class="o">=</span> <span class="no">Tasty</span><span class="o">::</span><span class="no">Main</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="no">ARGV</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">main</span><span class="p">.</span><span class="nf">run</span></code></pre></figure>

<p>Alors, et si on lançait les tests :</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ruby tasty.rb test_rover.rb 
test_rover.rb:6:in `initialize':
  wrong number of arguments (given 2, expected 0) (ArgumentError)
  from test_rover.rb:6:in `new'
  from test_rover.rb:6:in `test_it_has_a_position'
</code></pre></div></div>

<p>Déçu ? Vous ne devriez pas, ça a parfaitement fonctionné. Le programme nous dit
qu’en ligne 6 du fichier <code class="language-plaintext highlighter-rouge">test_rover.rb</code> nous tentons d’initialiser un rover
avec 2 arguments alors que la méthode <code class="language-plaintext highlighter-rouge">initialize</code> de rover attends 0
arguments. Voyons cette fameuse ligne 6, dans le test nous cherchons à
initialiser un rover avec des coordonnées x et y :</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">rover</span> <span class="o">=</span> <span class="no">Rover</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span></code></pre></figure>

<p>Et comme notre classe <code class="language-plaintext highlighter-rouge">Rover</code> est déséspérement vide, il est normal que Ruby
crashe.</p>

<h2 id="passons-le-premier-test">Passons le premier test</h2>

<p>Dotons la méthode <code class="language-plaintext highlighter-rouge">Rover#initialize</code> de deux arguments, comme attendu :</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="c1"># fichier rover.rb</span>
<span class="k">class</span> <span class="nc">Rover</span>
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre></figure>

<p>Et le programme nous emmène au prochain problème :</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ruby tasty.rb test_rover.rb 
test_rover.rb:7:in `test_it_has_a_position': undefined method `position'
for #&lt;Rover:0x0055778cf43a90&gt; (NoMethodError)
</code></pre></div></div>

<p>On en vient facilement à bout en ajoutant la méthode <code class="language-plaintext highlighter-rouge">Rover#position</code> :</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="c1"># fichier rover.rb</span>
<span class="k">class</span> <span class="nc">Rover</span>
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">position</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre></figure>

<p>L’erreur suivante est beaucoup plus intéressante :</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ruby tasty.rb test_rover.rb 
test_rover.rb:7:in `test_it_has_a_position': undefined method `assert'
for #&lt;TestRover:0x00558edbe7a828&gt; (NoMethodError)
</code></pre></div></div>

<p>Nous devons coder <code class="language-plaintext highlighter-rouge">assert</code> de telle manière qu’elle produise une erreur si son
argument est différent de <code class="language-plaintext highlighter-rouge">true</code>.  Et pour que les classes de test puissent y
accéder, nous la placerons dans <code class="language-plaintext highlighter-rouge">Tasty::Unit</code>. Nous utiliserons aussi une erreur
custom, <code class="language-plaintext highlighter-rouge">AssertionError</code> :</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">module</span> <span class="nn">Tasty</span>

  <span class="k">class</span> <span class="nc">AssertionError</span> <span class="o">&lt;</span> <span class="no">StandardError</span>
  <span class="k">end</span>

  <span class="k">class</span> <span class="nc">Unit</span>
    <span class="k">def</span> <span class="nf">assert</span><span class="p">(</span><span class="n">boolean</span><span class="p">)</span>
      <span class="k">raise</span> <span class="no">AssertionError</span> <span class="k">unless</span> <span class="n">boolean</span>
    <span class="k">end</span>
  <span class="k">end</span>

<span class="k">end</span></code></pre></figure>

<p>Nous y sommes presque. La méthode <code class="language-plaintext highlighter-rouge">assert</code> est codée et produit l’erreur attendue :</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ruby tasty.rb test_rover.rb 
tasty.rb:8:in `assert': Tasty::AssertionError (Tasty::AssertionError)
  from test_rover.rb:7:in `test_it_has_a_position'
</code></pre></div></div>

<p>Que se passerait-il si nous implémentions <code class="language-plaintext highlighter-rouge">Rover</code> de telle manière qu’elle
passe le test ?</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="c1"># fichier rover.rb</span>
<span class="k">class</span> <span class="nc">Rover</span>
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="vi">@x</span> <span class="o">=</span> <span class="n">x</span>
    <span class="vi">@y</span> <span class="o">=</span> <span class="n">y</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">position</span>
    <span class="p">[</span><span class="vi">@x</span><span class="p">,</span> <span class="vi">@y</span><span class="p">]</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre></figure>

<p>Et bien rien. Il ne se passe rien.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ruby tasty.rb test_rover.rb 
$ # &lt;---- Cruelle absence d'affichage
</code></pre></div></div>

<p>En l’occurence, ce rien signifie quand même que nous avons réussi cette
partie !  Le test est passé ! Ajoutons un petit quelque chose pour être tenu au
courant :</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">module</span> <span class="nn">Tasty</span>
  <span class="k">class</span> <span class="nc">Main</span>
    <span class="k">def</span> <span class="nf">run</span>
      <span class="vi">@classes</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">class_under_test</span><span class="o">|</span>
        <span class="n">instance</span> <span class="o">=</span> <span class="n">class_under_test</span><span class="p">.</span><span class="nf">new</span>
        <span class="n">class_under_test</span><span class="p">.</span><span class="nf">instance_methods</span><span class="p">(</span><span class="kp">false</span><span class="p">).</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">m</span><span class="o">|</span>
          <span class="n">instance</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
          <span class="nb">puts</span> <span class="s2">"ok - </span><span class="si">#{</span><span class="n">m</span><span class="si">}</span><span class="s2">"</span> <span class="c1"># &lt;---------------</span>
        <span class="k">end</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre></figure>

<p>Et c’est la victoire :</p>

<figure class="highlight"><pre><code class="language-raw" data-lang="raw">$ ruby tasty.rb test_rover.rb 
ok - test_it_has_a_position</code></pre></figure>

<h2 id="les-autres-tests">Les autres tests</h2>

<p>Ajoutons le second test, mais plaçons le avant le premier (!) pour observer un
phénomène curieux :</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="c1"># fichier test_rover.rb</span>
<span class="nb">require_relative</span> <span class="s1">'rover'</span>

<span class="k">class</span> <span class="nc">TestRover</span> <span class="o">&lt;</span> <span class="no">Tasty</span><span class="o">::</span><span class="no">Unit</span>
  
  <span class="k">def</span> <span class="nf">test_it_has_a_direction_by_default</span>
    <span class="n">rover</span> <span class="o">=</span> <span class="no">Rover</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">rover</span><span class="p">.</span><span class="nf">direction</span> <span class="o">==</span> <span class="s1">'north'</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">test_it_has_a_position</span>
    <span class="n">rover</span> <span class="o">=</span> <span class="no">Rover</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">rover</span><span class="p">.</span><span class="nf">position</span> <span class="o">==</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
  <span class="k">end</span>

<span class="k">end</span></code></pre></figure>

<p>Le programme reporte bien le nouveau problème qui se trouve dans la méthode
<code class="language-plaintext highlighter-rouge">test_it_has_a_direction_by_default</code> mais il n’y a aucune mention de
<code class="language-plaintext highlighter-rouge">test_it_has_a_position</code> qui fonctionnait pourtant bien.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ruby tasty.rb test_rover.rb 
test_rover.rb:7:in `test_it_has_a_direction_by_default': undefined method
`direction' for #&lt;Rover:0x0055a03b444db0 @x=3, @y=2&gt; (NoMethodError)
</code></pre></div></div>

<p>Lorsqu’une erreur se produit dans <code class="language-plaintext highlighter-rouge">Tasty::Main#run</code>, le programme s’arrête
purement et simplement. Ce n’est pas du tout ce que nous voulons. Nous voulons
qu’une erreur soit rapportée, et que le programme continue en traitant le test
suivant. Commençons par remanier un peu la méthode <code class="language-plaintext highlighter-rouge">run</code> en la splittant en
deux parties :</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">Main</span>
  <span class="k">def</span> <span class="nf">run</span>
    <span class="vi">@classes</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">under_test</span><span class="o">|</span>
      <span class="n">instance</span> <span class="o">=</span> <span class="n">under_test</span><span class="p">.</span><span class="nf">new</span>
      <span class="n">under_test</span><span class="p">.</span><span class="nf">instance_methods</span><span class="p">(</span><span class="kp">false</span><span class="p">).</span><span class="nf">each</span> <span class="p">{</span> <span class="o">|</span><span class="n">m</span><span class="o">|</span> <span class="n">run_test</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="p">}</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">run_test</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="nb">method</span><span class="p">)</span>
    <span class="n">instance</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="nb">method</span><span class="p">)</span>
    <span class="nb">puts</span> <span class="s2">"ok - </span><span class="si">#{</span><span class="n">m</span><span class="si">}</span><span class="s2">"</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre></figure>

<p>Nous pouvons alors <em>attraper</em> les erreurs facilement dans la méthode <code class="language-plaintext highlighter-rouge">run_test</code> :</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby">  <span class="k">def</span> <span class="nf">run_test</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="nb">method</span><span class="p">)</span>
    <span class="n">instance</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="nb">method</span><span class="p">)</span>
    <span class="nb">puts</span> <span class="s2">"ok - </span><span class="si">#{</span><span class="nb">method</span><span class="si">}</span><span class="s2">"</span>
  <span class="k">rescue</span> <span class="o">=&gt;</span> <span class="n">ex</span>
    <span class="nb">puts</span> <span class="s2">"not ok - </span><span class="si">#{</span><span class="nb">method</span><span class="si">}</span><span class="s2">"</span>
    <span class="nb">puts</span> <span class="n">ex</span><span class="p">.</span><span class="nf">inspect</span>
    <span class="nb">puts</span> <span class="n">ex</span><span class="p">.</span><span class="nf">backtrace</span>
  <span class="k">end</span></code></pre></figure>

<p>Et voilà le résultat, nous affichons à la fois les tests qui passent et ceux
qui échouent :</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ruby tasty.rb test_rover.rb 
not ok - test_it_has_a_direction_by_default
#&lt;NoMethodError: undefined method `direction' for #&lt;Rover:0x0055a7709c03c0 @x=3, @y=2&gt;&gt;
test_rover.rb:7:in `test_it_has_a_direction_by_default'
...
ok - test_it_has_a_position
</code></pre></div></div>

<p>En dotant <code class="language-plaintext highlighter-rouge">Rover</code> de la méthode <code class="language-plaintext highlighter-rouge">position</code> qui suit, les tests passent :</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">def</span> <span class="nf">position</span>
  <span class="s1">'north'</span>
<span class="k">end</span></code></pre></figure>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ruby tasty.rb test_rover.rb 
ok - test_it_has_a_direction_by_default
ok - test_it_has_a_position
</code></pre></div></div>

<p>Faire passer le 3ème test implique seulement d’implémenter la classe <code class="language-plaintext highlighter-rouge">Rover</code> de
façon correcte. Il n’y a rien à ajouter ou à modifier dans notre framework
<code class="language-plaintext highlighter-rouge">Tasty</code>.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Nous venons d’écrire un framework de test en quelques dizaines de lignes de
code grâce aux facultés d’introspection de Ruby. C’est maintenant à votre tour
de jouer en l’améliorant.  Voici quelques idées :</p>

<ul>
  <li>Faire jouer les tests dans un ordre aléatoire</li>
  <li>Afficher une ligne de résultat final : <code class="language-plaintext highlighter-rouge">X tests, Y errors</code></li>
  <li>La sortie console devrait se faire en couleur, les lignes “ok” en vert, les
lignes “not ok” en rouges, et le reste en normal</li>
  <li>Écrire <code class="language-plaintext highlighter-rouge">ok - it has a position</code> plutôt que <code class="language-plaintext highlighter-rouge">ok - test_it_has_a_position</code></li>
  <li>Faire en sorte que des classes autres que celles de test puissent commencer par <code class="language-plaintext highlighter-rouge">Test</code>.</li>
  <li>Le must pour un compilateur, c’est d’être écrit dans son langage. Faire
pareil ici : tester Tasty avec Tasty</li>
</ul>

<p>Pour finir, voici le code complet :</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="c1"># fichier rover.rb</span>
<span class="k">class</span> <span class="nc">Rover</span>
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="s1">'north'</span><span class="p">)</span>
    <span class="vi">@x</span> <span class="o">=</span> <span class="n">x</span>
    <span class="vi">@y</span> <span class="o">=</span> <span class="n">y</span>
    <span class="vi">@direction</span> <span class="o">=</span> <span class="n">direction</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">position</span>
    <span class="p">[</span><span class="vi">@x</span><span class="p">,</span> <span class="vi">@y</span><span class="p">]</span>
  <span class="k">end</span>

  <span class="nb">attr_reader</span> <span class="ss">:direction</span>
<span class="k">end</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="c1"># fichier test_rover.rb</span>
<span class="nb">require_relative</span> <span class="s1">'rover'</span>

<span class="k">class</span> <span class="nc">TestRover</span> <span class="o">&lt;</span> <span class="no">Tasty</span><span class="o">::</span><span class="no">Unit</span>

  <span class="k">def</span> <span class="nf">test_it_has_a_direction_by_default</span>
    <span class="n">rover</span> <span class="o">=</span> <span class="no">Rover</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">rover</span><span class="p">.</span><span class="nf">direction</span> <span class="o">==</span> <span class="s1">'north'</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">test_it_has_a_position</span>
    <span class="n">rover</span> <span class="o">=</span> <span class="no">Rover</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">rover</span><span class="p">.</span><span class="nf">position</span> <span class="o">==</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">test_it_has_a_given_direction</span>
    <span class="n">rover</span> <span class="o">=</span> <span class="no">Rover</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">'west'</span><span class="p">)</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">rover</span><span class="p">.</span><span class="nf">direction</span> <span class="o">==</span> <span class="s1">'west'</span><span class="p">)</span>
  <span class="k">end</span>

<span class="k">end</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="c1"># fichier tasty.rb</span>
<span class="k">module</span> <span class="nn">Tasty</span>

  <span class="k">class</span> <span class="nc">AssertionError</span> <span class="o">&lt;</span> <span class="no">StandardError</span>
  <span class="k">end</span>

  <span class="k">class</span> <span class="nc">Unit</span>
    <span class="k">def</span> <span class="nf">assert</span><span class="p">(</span><span class="n">boolean</span><span class="p">)</span>
      <span class="k">raise</span> <span class="no">AssertionError</span> <span class="k">unless</span> <span class="n">boolean</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">class</span> <span class="nc">Main</span>
    <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
      <span class="nb">require</span> <span class="no">File</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="no">Dir</span><span class="p">.</span><span class="nf">pwd</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
      <span class="vi">@classes</span> <span class="o">=</span> <span class="no">Object</span><span class="p">.</span><span class="nf">constants</span><span class="p">.</span><span class="nf">select</span> <span class="p">{</span> <span class="o">|</span><span class="nb">name</span><span class="o">|</span> <span class="nb">name</span><span class="p">.</span><span class="nf">to_s</span><span class="p">.</span><span class="nf">start_with?</span><span class="p">(</span><span class="s1">'Test'</span><span class="p">)</span> <span class="p">}</span>
      <span class="vi">@classes</span><span class="p">.</span><span class="nf">map!</span> <span class="p">{</span> <span class="o">|</span><span class="nb">name</span><span class="o">|</span> <span class="no">Object</span><span class="p">.</span><span class="nf">const_get</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span> <span class="p">}</span>
    <span class="k">end</span>

    <span class="k">def</span> <span class="nf">run</span>
      <span class="vi">@classes</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">under_test</span><span class="o">|</span>
        <span class="n">instance</span> <span class="o">=</span> <span class="n">under_test</span><span class="p">.</span><span class="nf">new</span>
        <span class="n">under_test</span><span class="p">.</span><span class="nf">instance_methods</span><span class="p">(</span><span class="kp">false</span><span class="p">).</span><span class="nf">each</span> <span class="p">{</span> <span class="o">|</span><span class="n">m</span><span class="o">|</span> <span class="n">run_test</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="p">}</span>
      <span class="k">end</span>
    <span class="k">end</span>

    <span class="k">def</span> <span class="nf">run_test</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="nb">method</span><span class="p">)</span>
      <span class="n">instance</span><span class="p">.</span><span class="nf">send</span><span class="p">(</span><span class="nb">method</span><span class="p">)</span>
      <span class="nb">puts</span> <span class="s2">"ok - </span><span class="si">#{</span><span class="nb">method</span><span class="si">}</span><span class="s2">"</span>
    <span class="k">rescue</span> <span class="o">=&gt;</span> <span class="n">ex</span>
      <span class="nb">puts</span> <span class="s2">"not ok - </span><span class="si">#{</span><span class="nb">method</span><span class="si">}</span><span class="s2">"</span>
      <span class="nb">puts</span> <span class="n">ex</span><span class="p">.</span><span class="nf">message</span>
      <span class="nb">puts</span> <span class="n">ex</span><span class="p">.</span><span class="nf">backtrace</span>
    <span class="k">end</span>
  <span class="k">end</span>

<span class="k">end</span>

<span class="n">main</span> <span class="o">=</span> <span class="no">Tasty</span><span class="o">::</span><span class="no">Main</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="no">ARGV</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">main</span><span class="p">.</span><span class="nf">run</span></code></pre></figure>

<p>Bons tests ! À plus tard.</p>


  </div>

  <br/>
  <br/>
  <div style="text-align: center">/ / / / / / / / / /</div>
  <br/>
  <br/>

  <div style="text-align: center">
    
      <a href="/blog/2016/08/04/comment-mettre-a-jour-un-package-r/" title="Article précédent: Comment mettre à jour un package R">&laquo; Comment mettre à jour un package R</a> ---//---
    
    
      <a href="/blog/2016/11/11/bug-de-la-version-graphique-de-vim-sur-debian-sid/" title="Article suivant: Bug de la version graphique de Vim sur Debian Sid">Bug de la version graphique de Vim sur Debian Sid &raquo;</a>
    
  </div>

  <br/>
  <br/><div id="disqus_thread"></div>
  <script>
    var disqus_config = function () {
      this.page.url = 'http://lkdjiin.github.io/blog/2016/11/02/comment-ecrire-un-framework-de-test-pour-ruby/';
      this.page.identifier = 'http://lkdjiin.github.io/blog/2016/11/02/comment-ecrire-un-framework-de-test-pour-ruby/';
    };

    (function() {
      var d = document, s = d.createElement('script');

      s.src = 'https://confessionsdeveloppeur.disqus.com/embed.js';

      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript><a class="u-url" href="/blog/2016/11/02/comment-ecrire-un-framework-de-test-pour-ruby/" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <div>
    <p class="rss-subscribe">s'abonner <a href="/atom.xml">via RSS</a></p>
    </div>

    <h2 class="footer-heading">Xavier Nayrac</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">
            Copyright 2013 - 2021
            </li><li><a class="u-email" href="mailto:"></a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list">

  <li>
    <a href="https://github.com/lkdjiin">
      <img src="/images/github.png" />
      <span class="username">lkdjiin</span>
    </a>
  </li>

  <li>
    <a href="https://www.twitter.com/lkdjiin">
      <img src="/images/twitter.png" />
      <span class="username">lkdjiin</span>
    </a>
  </li>

  <li>
    <a href="/atom.xml">
      <img src="/images/atom.png" />
      <span class="username">RSS</span>
    </a>
  </li>
</ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Dev accro au TDD, Rubyiste mais pas que, musicien, maker, créateur d&#39;effets pour guitare, heureux utilisateur de Vim.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
