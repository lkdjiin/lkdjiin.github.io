<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : tutoriel | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/tutoriel/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2013-11-15T10:32:13+01:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Racket pour les Rubyists 7: Module basique]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/11/15/racket-pour-les-rubyists-7-module-basique/"/>
    <updated>2013-11-15T10:18:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/11/15/racket-pour-les-rubyists-7-module-basique</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>La dernière fois, on a écrit notre <a href="http://lkdjiin.github.io/blog/2013/11/11/racket-pour-les-rubyists-6-une-premiere-fonction/">première fonction en Racket</a>. Et avant
d'écrire des tests unitaires pour pouvoir la passer à la moulinette du
<em>refactoring</em>, il faut explorer un peu les modules Racket.</p>

<!-- more -->


<h2>La notion de module en Racket</h2>

<p>Jusqu'ici on a utilisé le REPL, il est temps maintenant de mettre notre
code dans un fichier. Voyons le programme suivant, à mettre dans un
fichier <code>foo.rkt</code>:</p>

<p>``` racket foo.rkt</p>

<h1>lang racket</h1>

<p>(define (times-2 n)
  (* 2 n))</p>

<p>(define (times-3 n)
  (* 3 n))</p>

<p>(provide times-2)
```</p>

<p>Vous reconnaissez la définition de deux fonctions: <code>times-2</code> et <code>times-3</code>
qui multiplient respectivements leur argument par 2 et par 3. En plus de ça,
il y a trois éléments nouveaux:</p>

<h3>Spécification d'un dialecte</h3>

<p>La ligne <code>#lang racket</code> spécifie à Racket le dialecte utilisé. Il y en a
plein et je n'utiliserais que celui-ci. Il faudra penser à toujours placé
cette ligne au début de chaque fichier.</p>

<h3>Convention de nommage</h3>

<p>Un petit exemple vaut mieux qu'un long discours:</p>

<pre><code>thisIsJavaConvention

this_is_ruby_convention

this-is-racket-convention
</code></pre>

<h3>La fonction provide</h3>

<p>La fonction <code>provide</code>, qu'on peut placer n'importe où dans le fichier (donc
au début ou à la fin), permet <em>d'exporter</em> les fonctions données en
argument. Les autres fonctions (celle qui ne sont pas données à <code>provide</code>)
sont visible dans le fichier, mais pas à l'extérieur. Autrement dit,
<code>provide</code> permet de spécifier l'API, les fonctions publiques.</p>

<h2>Utilisation d'un module</h2>

<p>Dans le REPL, <em>démaré dans le même dossier que le fichier &ldquo;foo.rkt&rdquo;</em>,
on utilise la fonction <code>require</code>:</p>

<pre><code>-&gt; (require "foo.rkt")
</code></pre>

<p>On peut maintenant utiliser la fonction <em>publique</em> <code>times-2</code>:</p>

<pre><code>-&gt; (times-2 9)
18
</code></pre>

<p>Et comme attendu, on ne peut pas utiliser <code>times-3</code>:</p>

<pre><code>-&gt; (times-3 9)
; times-3: undefined;
;  cannot reference undefined identifier
</code></pre>

<h2>Comparaison avec les modules Ruby</h2>

<p>Voici le pendant du fichier <code>foo.rkt</code> écrit en Ruby:</p>

<p>``` ruby foo.rb
module Foo
  class &lt;&lt; self</p>

<pre><code>def times_2(n)
  2 * n
end

private

def times_3(n)
  3 * n
end
</code></pre>

<p>  end
end
```</p>

<p>Et voici comment on s'en sert dans une session irb:</p>

<p>``` irb</p>

<blockquote><blockquote><p>require &ldquo;foo&rdquo;
LoadError: cannot load such file &mdash; foo
require &ldquo;./foo&rdquo;
true
Foo.times_2 9
18
Foo.times_3 9
NoMethodError: private method `times_3' called for Foo:Module
```</p></blockquote></blockquote>

<p>Le comportement est assez similaire. Petite différence, Ruby oblige à définir
le fichier requis par rapport au dossier courant alors que Racket le fait
automatiquement (ok, j'aurais pu utiliser <code>require_relative</code>…).</p>

<p>Mais la <strong>grande différence</strong> est qu'un module Ruby définit un espace
de nom, pas un module Racket. <em>À l'heure actuelle je ne sais pas si Racket
possède un mécanisme pour les espaces de nom, je n'en suis pas encore là,
mais j'espère que oui…</em></p>

<p>La prochaine fois, on verra comment faire des tests unitaires simples en
Racket.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Apprendre Ruby en faisant des maths 7: Tests unitaires simples]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/11/14/apprendre-ruby-en-faisant-des-maths-7-tests-unitaires-simples/"/>
    <updated>2013-11-14T13:22:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/11/14/apprendre-ruby-en-faisant-des-maths-7-tests-unitaires-simples</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Si vous voulez vraiment apprendre Ruby, vous <em>devriez</em> aussi apprendre
à faire des tests automatisés: c'est le meilleur moyen d'avoir confiance
en son code. Et la question se pose de savoir quel framework utiliser ?
Il en existe plusieurs: unit/test, minitest, RSpec, Shoulda, Cucumber et
j'en oublie… Chaque développeur a ses préférences, et c'est bien normal.</p>

<p><code>&lt;opinion&gt;</code></p>

<p>Mais souvent les développeurs ont aussi des convictions, ce qui est parfois
problématique. Un framework de test est un outil, comme tant d'autres.
Un outil X peut être parfait pour telle application et bien moins bon pour
telle autre application. Autrement dit, <strong>LE</strong> framework de test n'existe
pas. Quand vous en aurez testé quelques uns, vous aurez une préférence,
d'accord, pas de soucis. Mais s'il vous plait, avant d'avoir une conviction,
attendez d'en avoir <em>utilisé</em> 3 ou 4, et chacun dans différents types de
projet.</p>

<p><code>&lt;/opinion&gt;</code></p>

<!-- more -->


<p>Aujourd'hui on va apprendre à tester le module créé <a href="http://lkdjiin.github.io/blog/2013/11/01/apprendre-ruby-en-faisant-des-maths-6-methodes-utilitaires-et-module/">la dernière fois</a>
à l'aide du framework test/unit. Pas parce que ce framework est le
meilleur, pas parce que j'ai une préférence pour ce framework mais parce qu'il
est livré avec Ruby et qu'il ne necessite donc pas d'installation.</p>

<h2>Le fichier de test</h2>

<p>Voici le code à mettre dans un fichier nommé <code>tc_number.rb</code>:</p>

<p>``` ruby tc_number.rb
require_relative &ldquo;number&rdquo;
require &ldquo;test/unit&rdquo;</p>

<p>class TestNumber &lt; Test::Unit::TestCase
  def test_divisors</p>

<pre><code>assert_equal [1, 2, 4, 8], Number.divisors(4)
</code></pre>

<p>  end
end
```</p>

<p>Le fichier <code>tc_number.rb</code> contient le code pour tester notre module <code>Number</code>,
qui est dans le fichier <code>number.rb</code>. Veillez à garder les deux fichiers dans
le même dossier.</p>

<h2>Explications</h2>

<p>Voici les explications, ligne par ligne:</p>

<pre><code>require_relative "number"
</code></pre>

<p>On charge notre module <code>Number</code>.</p>

<pre><code>require "test/unit"
</code></pre>

<p>On charge la bibliothèque <code>test/unit</code>, qui contient plusieurs classes/modules
et méthodes qui vont nous permettre d'écrire nos tests.</p>

<pre><code>class TestNumber &lt; Test::Unit::TestCase
</code></pre>

<p>On crée une classe <code>TestNumber</code>. Vous remarquez que c'est le nom de notre
module à tester, préfixé par Test. Cette classe hérite de
<code>Test::Unit::TestCase</code>. Si vous ne savez pas encore ce qu'est une classe,
dites vous que c'est un module un peu spécial. Si vous ne savez pas
encore ce qu'est l'héritage, ce n'est pas grave.</p>

<pre><code>def test_divisors
</code></pre>

<p>On définit un test de la méthode <code>divisors</code>, à travers la méthodes
<code>test_divisors</code>. Vous remarquez que c'est le nom de notre méthode à tester,
préfixé par <code>test_</code>.</p>

<pre><code>assert_equal [1, 2, 4, 8], Number.divisors(4)
</code></pre>

<p>Voici enfin le test proprement dit. La méthode <code>assert_equal</code> s'assure
que ses deux arguments sont égaux. On veut savoir si <code>Number.divisors(4)</code>
est bien égal à l'Array (la liste) <code>[1, 2, 3, 4]</code>, <em>ce qui est faux</em>.</p>

<h2>Utilisation</h2>

<p>Voici la sortie:</p>

<pre><code>[~]⇒ ruby tc_number.rb 
Run options: 

# Running tests:

F

Finished tests in 0.002405s, 415.8087 tests/s, 415.8087 assertions/s.

  1) Failure:
test_divisors(TestNumber) [tc_number.rb:6]:
&lt;[1, 2, 4, 8]&gt; expected but was
&lt;[1, 2, 4]&gt;.

1 tests, 1 assertions, 1 failures, 0 errors, 0 skips
</code></pre>

<p>La section <code>1) Failure:</code> est particulièrement intéressante et nous indique
que la liste <code>[1, 2, 3, 4]</code> était attendue, mais que c'est la liste
<code>[1, 2, 4]</code> qui a été reçue.</p>

<p>Si on corrige notre test:</p>

<p>``` ruby tc_number.rb
require_relative &ldquo;number&rdquo;
require &ldquo;test/unit&rdquo;</p>

<p>class TestNumber &lt; Test::Unit::TestCase
  def test_divisors</p>

<pre><code>assert_equal [1, 2, 4], Number.divisors(4)
</code></pre>

<p>  end
end
```</p>

<p>Cette fois-ci la sortie nous indique que tout va bien:</p>

<pre><code>[~]⇒ ruby tc_number.rb 
Run options: 

# Running tests:

.

Finished tests in 0.000644s, 1553.5887 tests/s, 1553.5887 assertions/s.

1 tests, 1 assertions, 0 failures, 0 errors, 0 skips
</code></pre>

<h2>Plus de tests</h2>

<p>Nous pouvons ajouter un autre test pour la méthode <code>divisors</code>:</p>

<p>``` ruby
  def test_divisors</p>

<pre><code>assert_equal [1, 2, 4], Number.divisors(4)
assert_equal [1, 17], Number.divisors(17)
</code></pre>

<p>  end
```</p>

<p>Mais aussi tester les autres méthodes de notre module, selon le même
modèle:</p>

<p>``` ruby tc_number.rb
require_relative &ldquo;number&rdquo;
require &ldquo;test/unit&rdquo;</p>

<p>class TestNumber &lt; Test::Unit::TestCase
  def test_divisors</p>

<pre><code>assert_equal [1, 2, 4], Number.divisors(4)
assert_equal [1, 17], Number.divisors(17)
</code></pre>

<p>  end</p>

<p>  def test_proper_divisors</p>

<pre><code>assert_equal [1, 2], Number.proper_divisors(4)
assert_equal [1], Number.proper_divisors(17)
</code></pre>

<p>  end</p>

<p>  def test_sum_of_proper_divisors</p>

<pre><code>assert_equal 3, Number.sum_of_proper_divisors(4)
assert_equal 1, Number.sum_of_proper_divisors(17)
</code></pre>

<p>  end
end
```</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Racket pour les rubyists 6: Une première fonction]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/11/11/racket-pour-les-rubyists-6-une-premiere-fonction/"/>
    <updated>2013-11-11T20:41:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/11/11/racket-pour-les-rubyists-6-une-premiere-fonction</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Grâce à ce qu'on a appris depuis <a href="http://lkdjiin.github.io/blog/2013/11/03/racket-pour-les-rubyists-definir-une-fonction/">le début</a> de cette série d'articles,
il est enfin temps de traduire la méthode Ruby suivante en Racket:</p>

<p><code>ruby
def divisors(n)
  (1..n).select {|i| n % i == 0}
end
</code></p>

<!-- more -->


<h2>Une première fonction Racket</h2>

<p>Sans plus attendre, voici une traduction en Racket, qui suit le modèle
du <a href="http://lkdjiin.github.io/blog/2013/11/10/racket-pour-les-rubyists-5-definitions-imbriquees/">dernier article</a>:</p>

<p>``` racket
(define (divisors n)
  ; Is i a divisor of n?
  (define (divisor? i)</p>

<pre><code>(= 0 (remainder n i)))
</code></pre>

<p>  (filter divisor? (range 1 (+ n 1))))
```</p>

<p>Voici la fonction en action:</p>

<pre><code>-&gt; (divisors 1)
'(1)
-&gt; (divisors 8)
'(1 2 4 8)
-&gt; (divisors 17)
'(1 17)
-&gt; (divisors 171)
'(1 3 9 19 57 171)
</code></pre>

<p>Alors ça fait pas mal de code Racket comparé au code Ruby, mais attention de ne
pas juger le langage sur ce seul exemple. D'abord l'opérateur <code>..</code> de Ruby et
ses <em>blocks</em> permettent une syntaxe incroyablement concise, ensuite je
vous rappelle que <em>j'apprends</em> Racket, et que donc j'ai peut-être raté des
trucs…</p>

<p>Vous remarquez que je me suis senti obligé de commenté la fonction imbriquée
<code>divisor?</code>, ce qui n'est pas bon signe. Je suis un adepte du code court,
sous-entendu: une fonction devrait faire une seule chose. Or il me semble
qu'ici la fonction <code>divisors</code> fait trois choses:</p>

<ol>
<li>Elle regarde si un nombre i est un diviseur de n.</li>
<li>Elle produit une liste de 1 à n inclus.</li>
<li>Enfin, elle produit la liste des diviseurs de n.</li>
</ol>


<p>Donc <code>divisors</code> est un bon candidat au refactoring. Mais avant ça il va
falloir parler des tests unitaires avec Racket. Et avant de parler des
tests unitaires, il va falloir aborder la notion de module Racket. Si
ces sujets vous intéressent, restez à l'écoute de ce blog, c'est pour
bientôt.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Racket pour les rubyists 5: Définitions imbriquées]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/11/10/racket-pour-les-rubyists-5-definitions-imbriquees/"/>
    <updated>2013-11-10T21:17:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/11/10/racket-pour-les-rubyists-5-definitions-imbriquees</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Après avoir vu l'utilisation de la fonction <code>filter</code>, on passe aux
définitions de fonctions imbriquées en Racket, ce qui nous permet de
survoler la portée des variables.</p>

<!-- more -->


<h2>Fonctions Racket imbriquées</h2>

<p>Avec Racket les définitions de fonction peuvent s'imbriquer les unes dans les
autres.  Autrement dit, on peut définir une fonction B à l'intérieur d'une
fonction A. Dans l'exemple suivant, la fonction <code>bar</code> est définie à
l'intérieur de la fonction <code>foo</code>:</p>

<p>``` racket
(define (foo x)
  (define (bar y)</p>

<pre><code>(+ y 2))
</code></pre>

<p>  (bar x))
```</p>

<p>Dans le code ci-dessus, <code>bar</code> est une fonction qui ajoute 2 à son argument.
La fonction englobante <code>foo</code> appelle <code>bar</code> et donc son rôle est aussi d'ajouter
2 à son argument, comme on peut le voir dans la session racket suivante:</p>

<pre><code>-&gt; (foo 10)
12
</code></pre>

<p>Il est important de comprendre que <code>bar</code> est définie à l'intérieur de <code>foo</code>,
et donc <code>bar</code> est <em>indéfinie</em> à l'extérieur de <code>foo</code>:</p>

<pre><code>-&gt; (bar 10)
; bar: undefined;
;  cannot reference undefined identifier
</code></pre>

<h2>Méthodes Ruby imbriquées</h2>

<p>Ruby se comporte différement. Il permet bien de définir une méthode à
l'intérieur d'une autre:</p>

<p>``` irb</p>

<blockquote><blockquote><p>def foo(x)
  def bar(y)</p>

<pre><code>y + 2
</code></pre>

<p>  end
  bar x
end
nil
foo 10
12
```</p></blockquote></blockquote>

<p>Mais à la différence du comportement de Racket, la méthode Ruby <code>bar</code> est
<em>visible</em> à l'extérieur de <code>foo</code>:</p>

<p>``` irb</p>

<blockquote><blockquote><p>bar 10
12
```</p></blockquote></blockquote>

<p>Et c'est tout à fait normal. Il s'agit là d'une différence entre fonction
et méthode: une méthode est attachée à un objet.</p>

<h2>Retour à Racket</h2>

<p>La méthode <code>foo</code> peut être simplifiée. La revoici:</p>

<p>``` racket
(define (foo x)
  (define (bar y)</p>

<pre><code>(+ y 2))
</code></pre>

<p>  (bar x))
```</p>

<p>Pour la simplifier, il suffit de comprendre que l'argument <code>x</code> est <em>visible</em>
dans la fonction <code>bar</code>:</p>

<p>``` racket
(define (foo x)
  (define (bar)</p>

<pre><code>(+ x 2))
</code></pre>

<p>  (bar))
```</p>

<p>Évidemment, la vraie simplification serait celle-ci:</p>

<p><code>racket
(define (foo x)
  (+ x 2))
</code></p>

<p>Mais cet article parle de fonctions imbriquées…</p>

<p>La prochaine fois on réunira tout ce qu'on a appris jusqu'ici pour enfin
traduire en Racket la méthode Ruby suivante:</p>

<p><code>ruby
def divisors(n)
  (1..n).select {|i| n % i == 0}
end
</code></p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Racket pour les Rubyists 4: La fonction filter]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/11/09/racket-pour-les-rubyists-4-la-fonction-filter/"/>
    <updated>2013-11-09T18:39:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/11/09/racket-pour-les-rubyists-4-la-fonction-filter</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Aprés avoir vu comment faire un <a href="http://lkdjiin.github.io/blog/2013/11/08/racket-pour-les-rubyists-3-trouver-les-diviseurs/">test d'égalité</a>
en Racket, on s'intéresse aujourd'hui à la fonction <code>filter</code>, en la
comparant à la méthode Ruby <code>select</code>.</p>

<!-- more -->


<h2>select vs filter</h2>

<p>Pour obtenir les nombres impairs d'une liste, voici comment on pourrait
faire en Ruby:</p>

<p><code>ruby
[1, 2, 3, 4].select {|i| i.odd? } #=&gt; [1, 3]
</code></p>

<p>D'une manière générale, on a:</p>

<pre><code>liste.select bloc
</code></pre>

<p>Et voici la façon de faire en Racket:</p>

<p><code>racket
(filter odd? '(1 2 3 4)) ;=&gt; '(1 3)
</code></p>

<p>Qu'on généralise en:</p>

<pre><code>(filter fonction liste)
</code></pre>

<p>Comme Ruby, Racket place un point d'interrogation à la fin du nom d'une
fonction qui retourne vrai ou faux. <code>odd?</code> s'utilise ainsi:</p>

<p><code>racket
(odd? 1) ;=&gt; #t
(odd? 2) ;=&gt; #f
</code></p>

<p>On voit que dans <code>(filter odd? '(1 2 3 4))</code>, chaque élément de la liste est
fourni <em>implicitement</em> à la fonction <code>odd?</code>. De plus, on ne mets pas de
parenthèses autour de <code>odd?</code> car on ne veut pas l'évaluer mais seulement
fournir la référence. C'est quelque chose sur lequel je reviendrais souvent
et qu'il faudra expliquer plus en détail.</p>

<p>La prochaine fois on parlera des fonctions imbriquées en Racket.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
