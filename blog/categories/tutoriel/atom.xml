<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : tutoriel | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/tutoriel/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2013-11-08T19:22:21+01:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Racket pour les rubyists 2: Produire une suite de nombre]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/11/06/racket-pour-les-rubyists-2-produire-une-suite-de-nombre/"/>
    <updated>2013-11-06T19:10:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/11/06/racket-pour-les-rubyists-2-produire-une-suite-de-nombre</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>La <a href="http://lkdjiin.github.io/blog/2013/11/03/racket-pour-les-rubyists-definir-une-fonction/">dernière fois</a>
on a vu comment définir une fonction en Racket. Aujourd'hui on va essayer
de traduire la méthode Ruby suivante:</p>

<p><code>ruby
def divisors(n)
  (1..n).select {|i| n % i == 0}
end
</code></p>

<!-- more -->


<p>Tout d'abord, j'ai envie découper cette méthode en trois parties plus petites:</p>

<ol>
<li><code>1..n</code>, pour produire une suite de nombre.</li>
<li><code>select</code>, qui est la méthode utilisée pour conserver/supprimer certains
éléments.</li>
<li><code>n % i == 0</code>, qui est un test pour savoir si i est un diviseur de n.</li>
</ol>


<h2>Produire une suite de nombre</h2>

<p>On s'intéresse d'abord à la 1ère partie. Racket possède la fonction <code>range</code>,
qui produit une liste de nombre. En fournissant un seul argument, n, <code>range</code>
produit une liste de 0 à n <em>non-inclus</em>:</p>

<pre><code>-&gt; (range 4)
'(0 1 2 3)
</code></pre>

<p>En fournissant deux arguments, m et n, <code>range</code> produit une liste de m à n
<em>non-inclus</em>:</p>

<pre><code>-&gt; (range 1 4)
'(1 2 3)
</code></pre>

<p>Pour être exhaustif, il existe une dernière possibilité, avec 3 arguments
m, n et p, pour produire une liste
de m à n <em>non-inclus</em> par pas de p:</p>

<pre><code>-&gt; (range 10 20 3)
'(10 13 16 19)
</code></pre>

<p>Pour produire une liste de m à n <em>inclus</em>, il faut falloir augmenter n de 1:</p>

<pre><code>-&gt; (define n 4)
-&gt; (range 1 (+ n 1))
'(1 2 3 4)
</code></pre>

<p>Vous notez au passage la manière de définir une variable, identique à la
définition d'une méthode, ainsi que la façon dont Racket écrit une liste:</p>

<ul>
<li>entre parenthèses</li>
<li>précédée par un apostrophe</li>
<li>pas de virgule pour séparer les éléments</li>
</ul>


<p>Le prochain article abordera le test d'égalité en Racket.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Racket pour les Rubyists: Définir une fonction]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/11/03/racket-pour-les-rubyists-definir-une-fonction/"/>
    <updated>2013-11-03T15:06:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/11/03/racket-pour-les-rubyists-definir-une-fonction</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Racket est un langage dérivé de Scheme que je suis en train d'apprendre.
Je vais m'inspirer de ma série d'articles
<a href="http://lkdjiin.github.io/blog/2013/10/21/apprendre-ruby-en-faisant-des-maths/">Apprendre Ruby en faisant des maths</a>
pour expliquer les bases de Racket en le comparant à Ruby. Si vous
connaissez un peu Ruby, j'espère que vous n'aurez aucun mal à suivre
ces articles. On commence aujourd'hui avec la définition d'une fonction.</p>

<!-- more -->


<p>J'utiliserais la version 5.3.6 de Racket et la version 2.0 de Ruby.
Au début, on va utiliser le REPL, pour Ruby on a <code>irb</code>, pour Racket on
a <code>racket</code>.</p>

<h2>Définir une fonction</h2>

<p>Racket a des fonctions et Ruby a des méthodes, mais ça ne fait aucune
différence pour l'instant. Voyons comment définir une fonction <code>addition</code>,
qui va calculer et renvoyer la somme de deux arguments, <code>a</code> et <code>b</code>:</p>

<pre><code>[~]⇒ racket
-&gt; (define (addition a b)
     (+ a b))
-&gt; (addition 12 34)
46
</code></pre>

<p>Comparons immédiatement avec la version Ruby:</p>

<pre><code>[~]⇒ irb
&gt;&gt; def addition(a, b)
&gt;&gt;   a + b
&gt;&gt; end
nil
&gt;&gt; addition 12, 34
46
</code></pre>

<p>Première remarque: avec Racket les parenthèses sont <strong>très importantes</strong>.
On est obligé de les utilisées, et de les utilisées correctement.</p>

<p>Deuxième remarque: Ruby utilise la notation <em>infix</em> (<code>a + b</code>) alors que
Racket utilise la notation <em>prefix</em> (<code>+ a b</code>). Étrange au début si vous
n'avez jamais utilisé ce genre de truc, on s'y fait très vite.</p>

<p>Troisième remarque: avec Racket les arguments ne sont pas séparés par des
virgules.</p>

<p>Enfin, Ruby utilise des mots clés (<code>def</code> et <code>end</code>) pour délimiter un
bloc/ensemble d'instructions alors que Racket utilise simplement les
parenthèses.</p>

<p><strong>Exercice</strong>: Sur le même modèle que la fonction <code>addition</code>, définissez et
utilsez les fonctions <code>soustraction</code> et <code>multiplication</code>. Voici les solutions:</p>

<p>``` racket
(define (soustraction a b)
  (&ndash; a b))</p>

<p>(soustraction 17 7)</p>

<p>(define (multiplication a b)
  (* a b))</p>

<p>(multiplication 2 3)
```</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Apprendre Ruby en faisant des maths 6: méthodes utilitaires et module]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/11/01/apprendre-ruby-en-faisant-des-maths-6-methodes-utilitaires-et-module/"/>
    <updated>2013-11-01T21:54:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/11/01/apprendre-ruby-en-faisant-des-maths-6-methodes-utilitaires-et-module</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Dans les articles précédents, nous avons définis trois méthodes:
<code>divisors</code>, <code>proper_divisors</code> et <code>sum_of_proper_divisors</code>.
Ces trois méthodes commencent à former ce qu'on appelle une
collection, ou un ensemble, de méthodes utilitaires. Nous allons
aujourd'hui les regrouper dans un module.</p>

<!-- more -->


<p>Pour l'instant nous n'avons que trois méthodes, et elles portent toutes
sur les nombres. Mais nous allons bientôt en ajouter d'autres, peut-être
beaucoup d'autres. Certaines porteront peut-être sur la géométrie ou les
probabilités ? Il est plus propre de regrouper entre elles les méthodes
qui traitent du même sujet, alors pourquoi attendre ?</p>

<p>Voici comment on peut regrouper nos méthodes au sein du module <code>Number</code>:</p>

<p>``` ruby number.rb
module Number
  def self.divisors(n)</p>

<pre><code>(1..n).select {|i| n % i == 0 }
</code></pre>

<p>  end</p>

<p>  def self.proper_divisors(n)</p>

<pre><code>divisors(n)[0..-2]
</code></pre>

<p>  end</p>

<p>  def self.sum_of_proper_divisors(n)</p>

<pre><code>proper_divisors(n).reduce(:+)
</code></pre>

<p>  end
end
```</p>

<p>Vous voyez que les méthodes sont insérées à l'intérieur de:</p>

<p><code>ruby
module Number
end
</code></p>

<p>Vous voyez aussi qu'on a ajouté <code>self.</code> devant le nom de chaque méthode.
Cela indique à Ruby qu'on veut utiliser ces méthodes sans pour autant
avoir à créer un objet (<em>si vous ne savez pas encore ce qu'est un objet,
ne vous inquiétez pas, nous n'en avons pas besoin pour l'instant</em>).</p>

<p>Voici une seconde manière de regrouper nos méthodes au sein du module <code>Number</code>:</p>

<p>``` ruby number.rb
module Number
  class &lt;&lt; self</p>

<pre><code>def divisors(n)
  (1..n).select {|i| n % i == 0 }
end

def proper_divisors(n)
  divisors(n)[0..-2]
end

def sum_of_proper_divisors(n)
  proper_divisors(n).reduce(:+)
end
</code></pre>

<p>  end
end
```</p>

<p>Cette deuxième syntaxe, qui peut sembler un peu bizarre si vous la
rencontrez pour la première fois, fait exactement la même chose que
la première syntaxe. Avec Ruby, il y a souvent plusieurs façons de dire
une même chose.
Je ne vais pas expliquer cette syntaxe aujourd'hui, mais sachez qu'elle
est très prisée dans la communauté Ruby et que vous la rencontrerez
souvent. Vous pouvez choisir celle que vous voulez.</p>

<p>Notez que, <strong>par convention</strong>, le module Number doit être enregistré
dans le fichier <code>number.rb</code>. Il n'y a pas d'obligation, mais avouez
que ça facilite grandement les choses.</p>

<h2>Comment utiliser un module ?</h2>

<p><strong>Première solution</strong>, vous pouvez écrire votre code à la suite du module:</p>

<p>``` ruby number.rb
module Number
  class &lt;&lt; self</p>

<pre><code>def divisors(n)
  (1..n).select {|i| n % i == 0 }
end

def proper_divisors(n)
  divisors(n)[0..-2]
end

def sum_of_proper_divisors(n)
  proper_divisors(n).reduce(:+)
end
</code></pre>

<p>  end
end</p>

<p>puts Number.sum_of_proper_divisors 8
```</p>

<p>Puis vous lancez le programme:</p>

<pre><code>[~/]⇒ ruby number.rb 
7
</code></pre>

<p><strong>Deuxième solution</strong>, vous lancez irb, <em>dans le même dossier</em> que le fichier
<code>number.rb</code> et vous chargez le module:</p>

<pre><code>[~/]⇒ irb
&gt;&gt; require "./number"
true
&gt;&gt; Number.sum_of_proper_divisors 8
7
</code></pre>

<p><strong>Troisième solution</strong>, vous écrivez un programme dans un fichier séparé, par
exemple <code>test.rb</code>, <em>dans le même dossier</em> que le fichier
<code>number.rb</code>:</p>

<p>``` ruby test.rb
require &ldquo;./number&rdquo;</p>

<p>puts Number.sum_of_proper_divisors 8
```</p>

<p>Puis vous le lancez:</p>

<pre><code>[~/]⇒ ruby test.rb
7
</code></pre>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Apprendre Ruby en faisant des maths 5]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/10/30/apprendre-ruby-en-faisant-des-maths-5/"/>
    <updated>2013-10-30T19:15:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/10/30/apprendre-ruby-en-faisant-des-maths-5</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Jusqu'ici on a écrit une méthode qui calcule les diviseurs d'un nombre et
une seconde méthode qui calcule les diviseurs stricts.
Notre objectif étant de lister les nombres amiables jusqu'à 10 000, il nous
faut maintenant obtenir la <em>somme</em> des diviseurs stricts d'un nombre.</p>

<!-- more -->


<p>Il nous faut donc calculer la somme des nombres qui composent une liste.
Allons y, prenons une liste et plaçons la dans une variable nommée <code>x</code>:</p>

<p>``` irb</p>

<blockquote><blockquote><p>x = [1,2,4]
=> [1, 2, 4]
```</p></blockquote></blockquote>

<p>Nous avons déjà vu la méthode <code>select</code>, qui sélectionne certains éléments
d'une liste ; nous allons voir maintenant la méthode <code>reduce</code>, qui va <em>réduire</em>
les éléments d'une liste à <em>un seul</em> élément:</p>

<p>``` irb</p>

<blockquote><blockquote><p>x.reduce {|sum, int| sum + int}
=> 7
```</p></blockquote></blockquote>

<p>Contrairement à la méthode <code>select</code> qui ne prenait qu'une seule variable
dans le bloc d'instruction, la méthode <code>reduce</code> en prends ici deux:
<code>sum</code> et <code>int</code>. <code>sum</code> joue le rôle d'un accumulateur et contient le résultat
qui sera retourné par la méthode. <code>int</code> fait référence à l'élément de la
liste en cours de traitement, exactement comme avec <code>select</code>. Pour chaque
élément de la liste <code>x</code>, l'instruction <code>sum + int</code> est exécutée.</p>

<p>On peut se demander quelle est la valeur initiale de <code>sum</code> ? Tout simplement
le premier élément de la liste. Et nous ne sommes pas limité aux nombres,
<code>reduce</code> fonctionnera avec ce qu'on veut, par exemple des chaînes de
caractères:</p>

<p>``` irb</p>

<blockquote><blockquote><p>[&ldquo;f&rdquo;, &ldquo;o&rdquo;, &ldquo;o&rdquo;].reduce {|string, letter| string + letter}
=> &ldquo;foo&rdquo;
```</p></blockquote></blockquote>

<p>Ruby permet aussi de simplifier l'écriture dans un cas trivial comme le
notre:</p>

<p>``` irb</p>

<blockquote><blockquote><p>x.reduce(:+)
=> 7
```</p></blockquote></blockquote>

<p>En fait, <code>reduce</code> ne prend pas obligatoirement un bloc. Ci-dessus,
<code>reduce</code> prend
en argument un symbole: <code>:+</code>. <code>+</code> est le nom d'une méthode. Oui, <code>+</code> est
bien une méthode:</p>

<p>``` irb</p>

<blockquote><blockquote><p>1.+(2)
=> 3
```</p></blockquote></blockquote>

<p>Je ne vais pas parler plus des symboles aujourd'hui, sachez seulement
que les deux écritures suivantes font la même chose mais que la seconde
est plus dans l'esprit de Ruby:</p>

<p><code>ruby
x.reduce {|sum, int| sum + int}
x.reduce(:+)
</code></p>

<p>Voilà, on est prêt à implémenter la méthode <code>sum_of_proper_divisors</code>, ce
qui signifie en français «somme des diviseurs stricts»:</p>

<p><code>ruby
def sum_of_proper_divisors(n)
  proper_divisors(n).reduce(:+)
end
</code></p>

<p>Comme la dernière fois, on se sert d'une méthode plus générale
(<code>proper_divisors</code>) pour écrire une méthode plus spécifique.</p>

<p>``` irb</p>

<blockquote><blockquote><p>def divisors(n)
  (1..n).select {|i| n % i == 0 }
end</p>

<p>def proper_divisors(n)
  divisors(n)[0..-2]
end</p>

<p>def sum_of_proper_divisors(n)
  proper_divisors(n).reduce(:+)
end</p>

<p>divisors 8
=> [1, 2, 4, 8]
proper_divisors 8
=> [1, 2, 4]
sum_of_proper_divisors 8
=> 7
```</p></blockquote></blockquote>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Apprendre Ruby en faisant des maths 4]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/10/28/apprendre-ruby-en-faisant-des-maths-4/"/>
    <updated>2013-10-28T16:15:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/10/28/apprendre-ruby-en-faisant-des-maths-4</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>La <a href="http://lkdjiin.github.io/blog/2013/10/25/apprendre-ruby-en-faisant-des-maths-3/">dernière fois</a>,
on a écrit une méthode qui calcule et renvoie les diviseurs d'un nombre n:</p>

<p><code>ruby
def divisors(n)
  (1..n).select {|int| n % int == 0 }
end
</code></p>

<p>Aujourd'hui, on se sert de cette méthode pour en écrire une autre.</p>

<!-- more -->


<p>Après avoir obtenu la liste des diviseurs d'un nombre, je voudrais maintenant
pouvoir obtenir la liste des diviseurs <em>stricts</em> d'un nombre. C'est à dire
tous les diviseurs de n <em>sauf</em> le nombre n lui-même.</p>

<pre><code>diviseurs de 8 :         1 ; 2 ; 4 ; 8
diviseurs stricts de 8 : 1 ; 2 ; 4
</code></pre>

<p>La méthode <code>divisors</code> fait <em>presque</em> ce qu'on veut. Elle renvoie un nombre de
trop, le dernier. On voudrait donc une nouvelle méthode qui renvoie la même
chose que <code>divisors</code>, exepté le dernier élément de la liste. Voyons comment
obtenir juste une partie d'une liste à l'aide d'<code>irb</code>:</p>

<p>``` irb</p>

<blockquote><blockquote><p>def divisors(n)
  (1..n).select {|int| n % int == 0 }
end
liste = divisors 8
=> [1, 2, 4, 8]
```</p></blockquote></blockquote>

<p>On a commencé par reécrire la méthode <code>divisors</code>, puis on a assigné à la
variable <em>liste</em> les diviseurs du nombre 8. Notre liste (qui, je le rappelle
est de type <code>Array</code>) comporte quatre éléments. En Ruby, comme dans beaucoup
d'autres langages, le numéro d'ordre d'un élément d'une liste (qu'on appelle
aussi indice ou index) comme avec zéro. Notre liste à donc 4 éléments, dont
les indexs vont de 0 à 3:</p>

<pre><code>index  élément
  0       1
  1       2
  2       4
  3       8
</code></pre>

<p>Pour obtenir le 1er élément (index 0) je dois écrire:</p>

<p>``` irb</p>

<blockquote><blockquote><p>liste[0]
=> 1
```</p></blockquote></blockquote>

<p>Pour obtenir le 4ème, et dernier, élément (index 3) j'écris:</p>

<p>``` irb</p>

<blockquote><blockquote><p>liste[3]
=> 8
```</p></blockquote></blockquote>

<p>C'est bien joli mais je veux obtenir un <em>ensemble</em> d'élément, et pas un
élément unique comme dans les exemples précédents. Et si on essayait avec
un <code>Range</code> ? On veut les 3 premiers éléments, autrement dit les éléments
d'index 0 à 2:</p>

<p>``` irb</p>

<blockquote><blockquote><p>liste[0..2]
=> [1, 2, 4]
```</p></blockquote></blockquote>

<p>On y est presque ! Effectivement, ce que je veux en réalité ce n'est pas
les éléments de 0 jusqu'à 2, mais les éléments de 0 jusqu'à <em>l'avant-dernier</em>.
Je veux que ça fonctionne quelque soit le nombre d'élément de la liste.
Pour cela, Ruby offre une syntaxe très simple: le dernier élément de la
liste se voit attribuer l'index <code>-1</code>:</p>

<p>``` irb</p>

<blockquote><blockquote><p>liste[0..-1]
=> [1, 2, 4, 8]
```</p></blockquote></blockquote>

<p>Et comme vous l'avez peut-être déjà deviné, l'avant-dernier élément possède
l'index <code>-2</code> (et ainsi de suite…):</p>

<p>``` irb</p>

<blockquote><blockquote><p>liste[0..-2]
=> [1, 2, 4]
```</p></blockquote></blockquote>

<p>Cette fois ça y est, on est prêt à se servir de la méthode <code>divisors</code> comme
d'une base pour construire une nouvelle méthode. Celle-ci va s'appeler
<code>proper_divisors</code>, ce qui signifie «diviseurs stricts» en anglais:</p>

<p>``` irb</p>

<blockquote><blockquote><p>def proper_divisors(n)
  divisors(n)[0..-2]
end
divisors 8
=> [1, 2, 4, 8]
proper_divisors 8
=> [1, 2, 4]
```</p></blockquote></blockquote>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
