<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : tutoriel | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/tutoriel/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2013-11-02T12:14:03+01:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Apprendre Ruby en faisant des maths 6: méthodes utilitaires et module]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/11/01/apprendre-ruby-en-faisant-des-maths-6-methodes-utilitaires-et-module/"/>
    <updated>2013-11-01T21:54:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/11/01/apprendre-ruby-en-faisant-des-maths-6-methodes-utilitaires-et-module</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Dans les articles précédents, nous avons définis trois méthodes:
<code>divisors</code>, <code>proper_divisors</code> et <code>sum_of_proper_divisors</code>.
Ces trois méthodes commencent à former ce qu'on appelle une
collection, ou un ensemble, de méthodes utilitaires. Nous allons
aujourd'hui les regrouper dans un module.</p>

<!-- more -->


<p>Pour l'instant nous n'avons que trois méthodes, et elles portent toutes
sur les nombres. Mais nous allons bientôt en ajouter d'autres, peut-être
beaucoup d'autres. Certaines porteront peut-être sur la géométrie ou les
probabilités ? Il est plus propre de regrouper entre elles les méthodes
qui traitent du même sujet, alors pourquoi attendre ?</p>

<p>Voici comment on peut regrouper nos méthodes au sein du module <code>Number</code>:</p>

<p>``` ruby number.rb
module Number
  def self.divisors(n)</p>

<pre><code>(1..n).select {|i| n % i == 0 }
</code></pre>

<p>  end</p>

<p>  def self.proper_divisors(n)</p>

<pre><code>divisors(n)[0..-2]
</code></pre>

<p>  end</p>

<p>  def self.sum_of_proper_divisors(n)</p>

<pre><code>proper_divisors(n).reduce(:+)
</code></pre>

<p>  end
end
```</p>

<p>Vous voyez que les méthodes sont insérées à l'intérieur de:</p>

<p><code>ruby
module Number
end
</code></p>

<p>Vous voyez aussi qu'on a ajouté <code>self.</code> devant le nom de chaque méthode.
Cela indique à Ruby qu'on veut utiliser ces méthodes sans pour autant
avoir à créer un objet (<em>si vous ne savez pas encore ce qu'est un objet,
ne vous inquiétez pas, nous n'en avons pas besoin pour l'instant</em>).</p>

<p>Voici une seconde manière de regrouper nos méthodes au sein du module <code>Number</code>:</p>

<p>``` ruby number.rb
module Number
  class &lt;&lt; self</p>

<pre><code>def divisors(n)
  (1..n).select {|i| n % i == 0 }
end

def proper_divisors(n)
  divisors(n)[0..-2]
end

def sum_of_proper_divisors(n)
  proper_divisors(n).reduce(:+)
end
</code></pre>

<p>  end
end
```</p>

<p>Cette deuxième syntaxe, qui peut sembler un peu bizarre si vous la
rencontrez pour la première fois, fait exactement la même chose que
la première syntaxe. Avec Ruby, il y a souvent plusieurs façons de dire
une même chose.
Je ne vais pas expliquer cette syntaxe aujourd'hui, mais sachez qu'elle
est très prisée dans la communauté Ruby et que vous la rencontrerez
souvent. Vous pouvez choisir celle que vous voulez.</p>

<p>Notez que, <strong>par convention</strong>, le module Number doit être enregistré
dans le fichier <code>number.rb</code>. Il n'y a pas d'obligation, mais avouez
que ça facilite grandement les choses.</p>

<h2>Comment utiliser un module ?</h2>

<p><strong>Première solution</strong>, vous pouvez écrire votre code à la suite du module:</p>

<p>``` ruby number.rb
module Number
  class &lt;&lt; self</p>

<pre><code>def divisors(n)
  (1..n).select {|i| n % i == 0 }
end

def proper_divisors(n)
  divisors(n)[0..-2]
end

def sum_of_proper_divisors(n)
  proper_divisors(n).reduce(:+)
end
</code></pre>

<p>  end
end</p>

<p>puts Number.sum_of_proper_divisors 8
```</p>

<p>Puis vous lancez le programme:</p>

<pre><code>[~/]⇒ ruby number.rb 
7
</code></pre>

<p><strong>Deuxième solution</strong>, vous lancez irb, <em>dans le même dossier</em> que le fichier
<code>number.rb</code> et vous chargez le module:</p>

<pre><code>[~/]⇒ irb
&gt;&gt; require "./number"
true
&gt;&gt; Number.sum_of_proper_divisors 8
7
</code></pre>

<p><strong>Troisième solution</strong>, vous écrivez un programme dans un fichier séparé, par
exemple <code>test.rb</code>, <em>dans le même dossier</em> que le fichier
<code>number.rb</code>:</p>

<p>``` ruby test.rb
require &ldquo;./number&rdquo;</p>

<p>puts Number.sum_of_proper_divisors 8
```</p>

<p>Puis vous le lancez:</p>

<pre><code>[~/]⇒ ruby test.rb
7
</code></pre>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Apprendre Ruby en faisant des maths 5]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/10/30/apprendre-ruby-en-faisant-des-maths-5/"/>
    <updated>2013-10-30T19:15:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/10/30/apprendre-ruby-en-faisant-des-maths-5</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Jusqu'ici on a écrit une méthode qui calcule les diviseurs d'un nombre et
une seconde méthode qui calcule les diviseurs stricts.
Notre objectif étant de lister les nombres amiables jusqu'à 10 000, il nous
faut maintenant obtenir la <em>somme</em> des diviseurs stricts d'un nombre.</p>

<!-- more -->


<p>Il nous faut donc calculer la somme des nombres qui composent une liste.
Allons y, prenons une liste et plaçons la dans une variable nommée <code>x</code>:</p>

<p>``` irb</p>

<blockquote><blockquote><p>x = [1,2,4]
=> [1, 2, 4]
```</p></blockquote></blockquote>

<p>Nous avons déjà vu la méthode <code>select</code>, qui sélectionne certains éléments
d'une liste ; nous allons voir maintenant la méthode <code>reduce</code>, qui va <em>réduire</em>
les éléments d'une liste à <em>un seul</em> élément:</p>

<p>``` irb</p>

<blockquote><blockquote><p>x.reduce {|sum, int| sum + int}
=> 7
```</p></blockquote></blockquote>

<p>Contrairement à la méthode <code>select</code> qui ne prenait qu'une seule variable
dans le bloc d'instruction, la méthode <code>reduce</code> en prends ici deux:
<code>sum</code> et <code>int</code>. <code>sum</code> joue le rôle d'un accumulateur et contient le résultat
qui sera retourné par la méthode. <code>int</code> fait référence à l'élément de la
liste en cours de traitement, exactement comme avec <code>select</code>. Pour chaque
élément de la liste <code>x</code>, l'instruction <code>sum + int</code> est exécutée.</p>

<p>On peut se demander quelle est la valeur initiale de <code>sum</code> ? Tout simplement
le premier élément de la liste. Et nous ne sommes pas limité aux nombres,
<code>reduce</code> fonctionnera avec ce qu'on veut, par exemple des chaînes de
caractères:</p>

<p>``` irb</p>

<blockquote><blockquote><p>[&ldquo;f&rdquo;, &ldquo;o&rdquo;, &ldquo;o&rdquo;].reduce {|string, letter| string + letter}
=> &ldquo;foo&rdquo;
```</p></blockquote></blockquote>

<p>Ruby permet aussi de simplifier l'écriture dans un cas trivial comme le
notre:</p>

<p>``` irb</p>

<blockquote><blockquote><p>x.reduce(:+)
=> 7
```</p></blockquote></blockquote>

<p>En fait, <code>reduce</code> ne prend pas obligatoirement un bloc. Ci-dessus,
<code>reduce</code> prend
en argument un symbole: <code>:+</code>. <code>+</code> est le nom d'une méthode. Oui, <code>+</code> est
bien une méthode:</p>

<p>``` irb</p>

<blockquote><blockquote><p>1.+(2)
=> 3
```</p></blockquote></blockquote>

<p>Je ne vais pas parler plus des symboles aujourd'hui, sachez seulement
que les deux écritures suivantes font la même chose mais que la seconde
est plus dans l'esprit de Ruby:</p>

<p><code>ruby
x.reduce {|sum, int| sum + int}
x.reduce(:+)
</code></p>

<p>Voilà, on est prêt à implémenter la méthode <code>sum_of_proper_divisors</code>, ce
qui signifie en français «somme des diviseurs stricts»:</p>

<p><code>ruby
def sum_of_proper_divisors(n)
  proper_divisors(n).reduce(:+)
end
</code></p>

<p>Comme la dernière fois, on se sert d'une méthode plus générale
(<code>proper_divisors</code>) pour écrire une méthode plus spécifique.</p>

<p>``` irb</p>

<blockquote><blockquote><p>def divisors(n)
  (1..n).select {|i| n % i == 0 }
end</p>

<p>def proper_divisors(n)
  divisors(n)[0..-2]
end</p>

<p>def sum_of_proper_divisors(n)
  proper_divisors(n).reduce(:+)
end</p>

<p>divisors 8
=> [1, 2, 4, 8]
proper_divisors 8
=> [1, 2, 4]
sum_of_proper_divisors 8
=> 7
```</p></blockquote></blockquote>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Apprendre Ruby en faisant des maths 4]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/10/28/apprendre-ruby-en-faisant-des-maths-4/"/>
    <updated>2013-10-28T16:15:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/10/28/apprendre-ruby-en-faisant-des-maths-4</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>La <a href="http://lkdjiin.github.io/blog/2013/10/25/apprendre-ruby-en-faisant-des-maths-3/">dernière fois</a>,
on a écrit une méthode qui calcule et renvoie les diviseurs d'un nombre n:</p>

<p><code>ruby
def divisors(n)
  (1..n).select {|int| n % int == 0 }
end
</code></p>

<p>Aujourd'hui, on se sert de cette méthode pour en écrire une autre.</p>

<!-- more -->


<p>Après avoir obtenu la liste des diviseurs d'un nombre, je voudrais maintenant
pouvoir obtenir la liste des diviseurs <em>stricts</em> d'un nombre. C'est à dire
tous les diviseurs de n <em>sauf</em> le nombre n lui-même.</p>

<pre><code>diviseurs de 8 :         1 ; 2 ; 4 ; 8
diviseurs stricts de 8 : 1 ; 2 ; 4
</code></pre>

<p>La méthode <code>divisors</code> fait <em>presque</em> ce qu'on veut. Elle renvoie un nombre de
trop, le dernier. On voudrait donc une nouvelle méthode qui renvoie la même
chose que <code>divisors</code>, exepté le dernier élément de la liste. Voyons comment
obtenir juste une partie d'une liste à l'aide d'<code>irb</code>:</p>

<p>``` irb</p>

<blockquote><blockquote><p>def divisors(n)
  (1..n).select {|int| n % int == 0 }
end
liste = divisors 8
=> [1, 2, 4, 8]
```</p></blockquote></blockquote>

<p>On a commencé par reécrire la méthode <code>divisors</code>, puis on a assigné à la
variable <em>liste</em> les diviseurs du nombre 8. Notre liste (qui, je le rappelle
est de type <code>Array</code>) comporte quatre éléments. En Ruby, comme dans beaucoup
d'autres langages, le numéro d'ordre d'un élément d'une liste (qu'on appelle
aussi indice ou index) comme avec zéro. Notre liste à donc 4 éléments, dont
les indexs vont de 0 à 3:</p>

<pre><code>index  élément
  0       1
  1       2
  2       4
  3       8
</code></pre>

<p>Pour obtenir le 1er élément (index 0) je dois écrire:</p>

<p>``` irb</p>

<blockquote><blockquote><p>liste[0]
=> 1
```</p></blockquote></blockquote>

<p>Pour obtenir le 4ème, et dernier, élément (index 3) j'écris:</p>

<p>``` irb</p>

<blockquote><blockquote><p>liste[3]
=> 8
```</p></blockquote></blockquote>

<p>C'est bien joli mais je veux obtenir un <em>ensemble</em> d'élément, et pas un
élément unique comme dans les exemples précédents. Et si on essayait avec
un <code>Range</code> ? On veut les 3 premiers éléments, autrement dit les éléments
d'index 0 à 2:</p>

<p>``` irb</p>

<blockquote><blockquote><p>liste[0..2]
=> [1, 2, 4]
```</p></blockquote></blockquote>

<p>On y est presque ! Effectivement, ce que je veux en réalité ce n'est pas
les éléments de 0 jusqu'à 2, mais les éléments de 0 jusqu'à <em>l'avant-dernier</em>.
Je veux que ça fonctionne quelque soit le nombre d'élément de la liste.
Pour cela, Ruby offre une syntaxe très simple: le dernier élément de la
liste se voit attribuer l'index <code>-1</code>:</p>

<p>``` irb</p>

<blockquote><blockquote><p>liste[0..-1]
=> [1, 2, 4, 8]
```</p></blockquote></blockquote>

<p>Et comme vous l'avez peut-être déjà deviné, l'avant-dernier élément possède
l'index <code>-2</code> (et ainsi de suite…):</p>

<p>``` irb</p>

<blockquote><blockquote><p>liste[0..-2]
=> [1, 2, 4]
```</p></blockquote></blockquote>

<p>Cette fois ça y est, on est prêt à se servir de la méthode <code>divisors</code> comme
d'une base pour construire une nouvelle méthode. Celle-ci va s'appeler
<code>proper_divisors</code>, ce qui signifie «diviseurs stricts» en anglais:</p>

<p>``` irb</p>

<blockquote><blockquote><p>def proper_divisors(n)
  divisors(n)[0..-2]
end
divisors 8
=> [1, 2, 4, 8]
proper_divisors 8
=> [1, 2, 4]
```</p></blockquote></blockquote>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Apprendre Ruby en faisant des maths 3]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/10/25/apprendre-ruby-en-faisant-des-maths-3/"/>
    <updated>2013-10-25T10:02:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/10/25/apprendre-ruby-en-faisant-des-maths-3</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>La <a href="http://lkdjiin.github.io/blog/2013/10/23/apprendre-ruby-en-faisant-des-maths-2/">dernière fois</a>, on a vu comment calculer la liste des diviseurs
d'un nombre avec <code>(1..8).select {|int| 8 % int == 0 }</code>. On va aujourd'hui
faire en sorte que ça fonctionne avec n'importe quel nombre, en écrivant
notre propre méthode.</p>

<!-- more -->


<p>Résumons : pour trouver les diviseurs de 8, j'écris:</p>

<p><code>ruby
(1..8).select {|int| 8 % int == 0 }
</code></p>

<p>et pour trouver les diviseurs de 4, j'écris:</p>

<p><code>ruby
(1..4).select {|int| 4 % int == 0 }
</code></p>

<p>Ce que je veux, c'est une façon de faire plus <em>générale</em>: je veux trouver
les diviseurs pour tout entier <em>n</em>. Essayons donc de remplacer le
nombre recherché par n:</p>

<p>``` irb</p>

<blockquote><blockquote><p>(1..n).select {|int| n % int == 0 }
NoMethodError: undefined method `n' on an instance of Object.
```</p></blockquote></blockquote>

<p>Ruby n'est pas content et nous signale qu'il ne connait pas n. Ok, essayons
alors de définir n d'abord:</p>

<p>``` irb</p>

<blockquote><blockquote><p>n = 8
=> 8
(1..n).select {|int| n % int == 0 }
=> [1, 2, 4, 8]
```</p></blockquote></blockquote>

<p>Cette fois c'est bon. Maintenant vous êtes prêt à définir une méthode:</p>

<p><code>ruby
def divisors(n)
  (1..n).select {|int| n % int == 0 }
end
</code></p>

<p><strong>Pour information, divisors est le mot anglais pour diviseurs.</strong></p>

<p>Une définition de méthode commence par le mot-clé <code>def</code> et se termine par
le mot-clé <code>end</code>. La méthode ci-dessus s'appelle <code>divisors</code> et elle prend
un argument qui est nommé <code>n</code>.</p>

<p>On lance/appelle/exécute une méthode simplement par son nom, sans oublier
son (ses) argument(s). Par exemple <code>divisors 8</code> va calculer et renvoyer la
liste des diviseurs de 8. Voici un exemple d'utilisation lors d'une session
irb:</p>

<p>``` irb</p>

<blockquote><blockquote><p>def divisors(n)
  (1..n).select {|int| n % int == 0 }
end
divisors 8
=> [1, 2, 4, 8]
divisors 4
=> [1, 2, 4]
divisors 417
=> [1, 3, 139, 417]
```</p></blockquote></blockquote>

<p>La prochaine fois nous verrons comment se servir de la méthode <code>divisors</code>
comme d'une base pour construire une autre méthode.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Une tonne de livres sur la programmation]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/10/24/une-tonne-de-livres-sur-la-programmation/"/>
    <updated>2013-10-24T10:22:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/10/24/une-tonne-de-livres-sur-la-programmation</id>
    <content type="html"><![CDATA[<p>Une super initiative de <a href="https://github.com/vhf">vhf</a> sur Github: une
longue, longue, très longue liste de livres sur le développement,
certains libres, tous gratuits.</p>

<!-- more -->


<p>Ils y a plusieurs listes de livres, selon les langues.
Vous trouverez la liste en anglais ici: <a href="https://github.com/vhf/free-programming-books/blob/master/free-programming-books.md">free-programming-books</a>.
Et la liste en français ici: <a href="https://github.com/vhf/free-programming-books/blob/master/free-programming-books-fr.md">free-programming-books-fr</a>.</p>

<p>Comme les listes sont sur Github, vous pouvez très facilement ajouter un
nouveau livre, rectifier un lien, etc.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
