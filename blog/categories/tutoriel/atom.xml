<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : tutoriel | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/tutoriel/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2013-11-14T13:30:00+01:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Apprendre Ruby en faisant des maths 7: Tests unitaires simples]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/11/14/apprendre-ruby-en-faisant-des-maths-7-tests-unitaires-simples/"/>
    <updated>2013-11-14T13:22:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/11/14/apprendre-ruby-en-faisant-des-maths-7-tests-unitaires-simples</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Si vous voulez vraiment apprendre Ruby, vous <em>devriez</em> aussi apprendre
à faire des tests automatisés: c'est le meilleur moyen d'avoir confiance
en son code. Et la question se pose de savoir quel framework utiliser ?
Il en existe plusieurs: unit/test, minitest, RSpec, Shoulda, Cucumber et
j'en oublie… Chaque développeur a ses préférences, et c'est bien normal.</p>

<p><code>&lt;opinion&gt;</code></p>

<p>Mais souvent les développeurs ont aussi des convictions, ce qui est parfois
problématique. Un framework de test est un outil, comme tant d'autres.
Un outil X peut être parfait pour telle application et bien moins bon pour
telle autre application. Autrement dit, <strong>LE</strong> framework de test n'existe
pas. Quand vous en aurez testé quelques uns, vous aurez une préférence,
d'accord, pas de soucis. Mais s'il vous plait, avant d'avoir une conviction,
attendez d'en avoir <em>utilisé</em> 3 ou 4, et chacun dans différents types de
projet.</p>

<p><code>&lt;/opinion&gt;</code></p>

<!-- more -->


<p>Aujourd'hui on va apprendre à tester le module créé <a href="http://lkdjiin.github.io/blog/2013/11/01/apprendre-ruby-en-faisant-des-maths-6-methodes-utilitaires-et-module/">la dernière fois</a>
à l'aide du framework test/unit. Pas parce que ce framework est le
meilleur, pas parce que j'ai une préférence pour ce framework mais parce qu'il
est livré avec Ruby et qu'il ne necessite donc pas d'installation.</p>

<h2>Le fichier de test</h2>

<p>Voici le code à mettre dans un fichier nommé <code>tc_number.rb</code>:</p>

<p>``` ruby tc_number.rb
require_relative &ldquo;number&rdquo;
require &ldquo;test/unit&rdquo;</p>

<p>class TestNumber &lt; Test::Unit::TestCase
  def test_divisors</p>

<pre><code>assert_equal [1, 2, 4, 8], Number.divisors(4)
</code></pre>

<p>  end
end
```</p>

<p>Le fichier <code>tc_number.rb</code> contient le code pour tester notre module <code>Number</code>,
qui est dans le fichier <code>number.rb</code>. Veillez à garder les deux fichiers dans
le même dossier.</p>

<h2>Explications</h2>

<p>Voici les explications, ligne par ligne:</p>

<pre><code>require_relative "number"
</code></pre>

<p>On charge notre module <code>Number</code>.</p>

<pre><code>require "test/unit"
</code></pre>

<p>On charge la bibliothèque <code>test/unit</code>, qui contient plusieurs classes/modules
et méthodes qui vont nous permettre d'écrire nos tests.</p>

<pre><code>class TestNumber &lt; Test::Unit::TestCase
</code></pre>

<p>On crée une classe <code>TestNumber</code>. Vous remarquez que c'est le nom de notre
module à tester, préfixé par Test. Cette classe hérite de
<code>Test::Unit::TestCase</code>. Si vous ne savez pas encore ce qu'est une classe,
dites vous que c'est un module un peu spécial. Si vous ne savez pas
encore ce qu'est l'héritage, ce n'est pas grave.</p>

<pre><code>def test_divisors
</code></pre>

<p>On définit un test de la méthode <code>divisors</code>, à travers la méthodes
<code>test_divisors</code>. Vous remarquez que c'est le nom de notre méthode à tester,
préfixé par <code>test_</code>.</p>

<pre><code>assert_equal [1, 2, 4, 8], Number.divisors(4)
</code></pre>

<p>Voici enfin le test proprement dit. La méthode <code>assert_equal</code> s'assure
que ses deux arguments sont égaux. On veut savoir si <code>Number.divisors(4)</code>
est bien égal à l'Array (la liste) <code>[1, 2, 3, 4]</code>, <em>ce qui est faux</em>.</p>

<h2>Utilisation</h2>

<p>Voici la sortie:</p>

<pre><code>[~]⇒ ruby tc_number.rb 
Run options: 

# Running tests:

F

Finished tests in 0.002405s, 415.8087 tests/s, 415.8087 assertions/s.

  1) Failure:
test_divisors(TestNumber) [tc_number.rb:6]:
&lt;[1, 2, 4, 8]&gt; expected but was
&lt;[1, 2, 4]&gt;.

1 tests, 1 assertions, 1 failures, 0 errors, 0 skips
</code></pre>

<p>La section <code>1) Failure:</code> est particulièrement intéressante et nous indique
que la liste <code>[1, 2, 3, 4]</code> était attendue, mais que c'est la liste
<code>[1, 2, 4]</code> qui a été reçue.</p>

<p>Si on corrige notre test:</p>

<p>``` ruby tc_number.rb
require_relative &ldquo;number&rdquo;
require &ldquo;test/unit&rdquo;</p>

<p>class TestNumber &lt; Test::Unit::TestCase
  def test_divisors</p>

<pre><code>assert_equal [1, 2, 4], Number.divisors(4)
</code></pre>

<p>  end
end
```</p>

<p>Cette fois-ci la sortie nous indique que tout va bien:</p>

<pre><code>[~]⇒ ruby tc_number.rb 
Run options: 

# Running tests:

.

Finished tests in 0.000644s, 1553.5887 tests/s, 1553.5887 assertions/s.

1 tests, 1 assertions, 0 failures, 0 errors, 0 skips
</code></pre>

<h2>Plus de tests</h2>

<p>Nous pouvons ajouter un autre test pour la méthode <code>divisors</code>:</p>

<p>``` ruby
  def test_divisors</p>

<pre><code>assert_equal [1, 2, 4], Number.divisors(4)
assert_equal [1, 17], Number.divisors(17)
</code></pre>

<p>  end
```</p>

<p>Mais aussi tester les autres méthodes de notre module, selon le même
modèle:</p>

<p>``` ruby tc_number.rb
require_relative &ldquo;number&rdquo;
require &ldquo;test/unit&rdquo;</p>

<p>class TestNumber &lt; Test::Unit::TestCase
  def test_divisors</p>

<pre><code>assert_equal [1, 2, 4], Number.divisors(4)
assert_equal [1, 17], Number.divisors(17)
</code></pre>

<p>  end</p>

<p>  def test_proper_divisors</p>

<pre><code>assert_equal [1, 2], Number.proper_divisors(4)
assert_equal [1], Number.proper_divisors(17)
</code></pre>

<p>  end</p>

<p>  def test_sum_of_proper_divisors</p>

<pre><code>assert_equal 3, Number.sum_of_proper_divisors(4)
assert_equal 1, Number.sum_of_proper_divisors(17)
</code></pre>

<p>  end
end
```</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Racket pour les rubyists 6: Une première fonction]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/11/11/racket-pour-les-rubyists-6-une-premiere-fonction/"/>
    <updated>2013-11-11T20:41:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/11/11/racket-pour-les-rubyists-6-une-premiere-fonction</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Grâce à ce qu'on a appris depuis <a href="http://lkdjiin.github.io/blog/2013/11/03/racket-pour-les-rubyists-definir-une-fonction/">le début</a> de cette série d'articles,
il est enfin temps de traduire la méthode Ruby suivante en Racket:</p>

<p><code>ruby
def divisors(n)
  (1..n).select {|i| n % i == 0}
end
</code></p>

<!-- more -->


<h2>Une première fonction Racket</h2>

<p>Sans plus attendre, voici une traduction en Racket, qui suit le modèle
du <a href="http://lkdjiin.github.io/blog/2013/11/10/racket-pour-les-rubyists-5-definitions-imbriquees/">dernier article</a>:</p>

<p>``` racket
(define (divisors n)
  ; Is i a divisor of n?
  (define (divisor? i)</p>

<pre><code>(= 0 (remainder n i)))
</code></pre>

<p>  (filter divisor? (range 1 (+ n 1))))
```</p>

<p>Voici la fonction en action:</p>

<pre><code>-&gt; (divisors 1)
'(1)
-&gt; (divisors 8)
'(1 2 4 8)
-&gt; (divisors 17)
'(1 17)
-&gt; (divisors 171)
'(1 3 9 19 57 171)
</code></pre>

<p>Alors ça fait pas mal de code Racket comparé au code Ruby, mais attention de ne
pas juger le langage sur ce seul exemple. D'abord l'opérateur <code>..</code> de Ruby et
ses <em>blocks</em> permettent une syntaxe incroyablement concise, ensuite je
vous rappelle que <em>j'apprends</em> Racket, et que donc j'ai peut-être raté des
trucs…</p>

<p>Vous remarquez que je me suis senti obligé de commenté la fonction imbriquée
<code>divisor?</code>, ce qui n'est pas bon signe. Je suis un adepte du code court,
sous-entendu: une fonction devrait faire une seule chose. Or il me semble
qu'ici la fonction <code>divisors</code> fait trois choses:</p>

<ol>
<li>Elle regarde si un nombre i est un diviseur de n.</li>
<li>Elle produit une liste de 1 à n inclus.</li>
<li>Enfin, elle produit la liste des diviseurs de n.</li>
</ol>


<p>Donc <code>divisors</code> est un bon candidat au refactoring. Mais avant ça il va
falloir parler des tests unitaires avec Racket. Et avant de parler des
tests unitaires, il va falloir aborder la notion de module Racket. Si
ces sujets vous intéressent, restez à l'écoute de ce blog, c'est pour
bientôt.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Racket pour les rubyists 5: Définitions imbriquées]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/11/10/racket-pour-les-rubyists-5-definitions-imbriquees/"/>
    <updated>2013-11-10T21:17:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/11/10/racket-pour-les-rubyists-5-definitions-imbriquees</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Après avoir vu l'utilisation de la fonction <code>filter</code>, on passe aux
définitions de fonctions imbriquées en Racket, ce qui nous permet de
survoler la portée des variables.</p>

<!-- more -->


<h2>Fonctions Racket imbriquées</h2>

<p>Avec Racket les définitions de fonction peuvent s'imbriquer les unes dans les
autres.  Autrement dit, on peut définir une fonction B à l'intérieur d'une
fonction A. Dans l'exemple suivant, la fonction <code>bar</code> est définie à
l'intérieur de la fonction <code>foo</code>:</p>

<p>``` racket
(define (foo x)
  (define (bar y)</p>

<pre><code>(+ y 2))
</code></pre>

<p>  (bar x))
```</p>

<p>Dans le code ci-dessus, <code>bar</code> est une fonction qui ajoute 2 à son argument.
La fonction englobante <code>foo</code> appelle <code>bar</code> et donc son rôle est aussi d'ajouter
2 à son argument, comme on peut le voir dans la session racket suivante:</p>

<pre><code>-&gt; (foo 10)
12
</code></pre>

<p>Il est important de comprendre que <code>bar</code> est définie à l'intérieur de <code>foo</code>,
et donc <code>bar</code> est <em>indéfinie</em> à l'extérieur de <code>foo</code>:</p>

<pre><code>-&gt; (bar 10)
; bar: undefined;
;  cannot reference undefined identifier
</code></pre>

<h2>Méthodes Ruby imbriquées</h2>

<p>Ruby se comporte différement. Il permet bien de définir une méthode à
l'intérieur d'une autre:</p>

<p>``` irb</p>

<blockquote><blockquote><p>def foo(x)
  def bar(y)</p>

<pre><code>y + 2
</code></pre>

<p>  end
  bar x
end
nil
foo 10
12
```</p></blockquote></blockquote>

<p>Mais à la différence du comportement de Racket, la méthode Ruby <code>bar</code> est
<em>visible</em> à l'extérieur de <code>foo</code>:</p>

<p>``` irb</p>

<blockquote><blockquote><p>bar 10
12
```</p></blockquote></blockquote>

<p>Et c'est tout à fait normal. Il s'agit là d'une différence entre fonction
et méthode: une méthode est attachée à un objet.</p>

<h2>Retour à Racket</h2>

<p>La méthode <code>foo</code> peut être simplifiée. La revoici:</p>

<p>``` racket
(define (foo x)
  (define (bar y)</p>

<pre><code>(+ y 2))
</code></pre>

<p>  (bar x))
```</p>

<p>Pour la simplifier, il suffit de comprendre que l'argument <code>x</code> est <em>visible</em>
dans la fonction <code>bar</code>:</p>

<p>``` racket
(define (foo x)
  (define (bar)</p>

<pre><code>(+ x 2))
</code></pre>

<p>  (bar))
```</p>

<p>Évidemment, la vraie simplification serait celle-ci:</p>

<p><code>racket
(define (foo x)
  (+ x 2))
</code></p>

<p>Mais cet article parle de fonctions imbriquées…</p>

<p>La prochaine fois on réunira tout ce qu'on a appris jusqu'ici pour enfin
traduire en Racket la méthode Ruby suivante:</p>

<p><code>ruby
def divisors(n)
  (1..n).select {|i| n % i == 0}
end
</code></p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Racket pour les Rubyists 4: La fonction filter]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/11/09/racket-pour-les-rubyists-4-la-fonction-filter/"/>
    <updated>2013-11-09T18:39:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/11/09/racket-pour-les-rubyists-4-la-fonction-filter</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Aprés avoir vu comment faire un <a href="http://lkdjiin.github.io/blog/2013/11/08/racket-pour-les-rubyists-3-trouver-les-diviseurs/">test d'égalité</a>
en Racket, on s'intéresse aujourd'hui à la fonction <code>filter</code>, en la
comparant à la méthode Ruby <code>select</code>.</p>

<!-- more -->


<h2>select vs filter</h2>

<p>Pour obtenir les nombres impairs d'une liste, voici comment on pourrait
faire en Ruby:</p>

<p><code>ruby
[1, 2, 3, 4].select {|i| i.odd? } #=&gt; [1, 3]
</code></p>

<p>D'une manière générale, on a:</p>

<pre><code>liste.select bloc
</code></pre>

<p>Et voici la façon de faire en Racket:</p>

<p><code>racket
(filter odd? '(1 2 3 4)) ;=&gt; '(1 3)
</code></p>

<p>Qu'on généralise en:</p>

<pre><code>(filter fonction liste)
</code></pre>

<p>Comme Ruby, Racket place un point d'interrogation à la fin du nom d'une
fonction qui retourne vrai ou faux. <code>odd?</code> s'utilise ainsi:</p>

<p><code>racket
(odd? 1) ;=&gt; #t
(odd? 2) ;=&gt; #f
</code></p>

<p>On voit que dans <code>(filter odd? '(1 2 3 4))</code>, chaque élément de la liste est
fourni <em>implicitement</em> à la fonction <code>odd?</code>. De plus, on ne mets pas de
parenthèses autour de <code>odd?</code> car on ne veut pas l'évaluer mais seulement
fournir la référence. C'est quelque chose sur lequel je reviendrais souvent
et qu'il faudra expliquer plus en détail.</p>

<p>La prochaine fois on parlera des fonctions imbriquées en Racket.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Racket pour les Rubyists 3: Trouver les diviseurs]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/11/08/racket-pour-les-rubyists-3-trouver-les-diviseurs/"/>
    <updated>2013-11-08T19:17:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/11/08/racket-pour-les-rubyists-3-trouver-les-diviseurs</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Précédemment, on a vu comment produire une
<a href="http://lkdjiin.github.io/blog/2013/11/06/racket-pour-les-rubyists-2-produire-une-suite-de-nombre/">liste de nombre</a>
avec la fonction <code>range</code>. Aujourd'hui on va traduire les tests Ruby suivants
en Racket:</p>

<p><code>ruby
8 % 2 == 0 #=&gt; true
8 % 3 == 0 #=&gt; false
</code></p>

<!-- more -->


<h2>Reste d'une division</h2>

<p>Pour calculer le reste d'une division euclidienne, on utilise la fonction
<code>remainder</code>. Par exemple:</p>

<p><code>racket
(remainder 8 2) ;=&gt; 0
(remainder 8 3) ;=&gt; 2
</code></p>

<p>D'une manière plus générale, <code>(remainder a b)</code> calcule le reste de la
division de <code>a</code> par <code>b</code>. Vous remarquerez encore une fois la notation <em>prefix</em>
de Racket.</p>

<p>Au passage, vous notez que le signe pour débuter un commentaire est le
point-virgule (<code>;</code>).</p>

<h2>Les booléens</h2>

<p>En Ruby les deux valeurs booléennes sont <strong>true</strong> et <strong>false</strong>, en Racket
elles sont notées <strong>#t</strong> et <strong>#f</strong>:</p>

<h2>Tester l'égalité</h2>

<p>Quand Ruby utilise le signe <code>==</code>, comme beaucoup d'autres langages, Racket
utilise un seul signe <code>=</code>:</p>

<p><code>racket
(= 1 1) ;=&gt; #t
(= 1 2) ;=&gt; #f
</code></p>

<p>Attention, <code>=</code> ne fonctionne qu'avec les nombres comme vous pouvez le
constater dans la session suivante:</p>

<pre><code>-&gt; (= "xav" "xav")
; =: contract violation
;   expected: number?
;   given: "xav"
;   argument position: 1st
</code></pre>

<p>Donc, pour tester si le reste d'une division euclidienne est égal à zéro,
on pourra faire comme ça:</p>

<p><code>racket
(= 0 (remainder 8 2)) ;=&gt; #t
(= 0 (remainder 8 3)) ;=&gt; #f
</code></p>

<p>Et d'une manière générale, pour tester si <em>i</em> est un diviseur de <em>n</em>:</p>

<p><code>racket
(= 0 (remainder n i))
</code></p>

<p>La prochaine fois, on verra la fonction Racket <code>filter</code>, qui est le
pendant de la méthode <code>select</code> de Ruby.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
