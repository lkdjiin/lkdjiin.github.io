<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : tutoriel | Xavier Nayrac]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/tutoriel/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2015-02-17T11:10:07+01:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Introduction à Lambda Calculus]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/12/27/introduction-a-lambda-calculus/"/>
    <updated>2013-12-27T14:53:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/12/27/introduction-a-lambda-calculus</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Pour mieux comprendre la programmation fonctionnelle, j’ai décidé
de plonger aux racines de ce paradigme, à savoir le langage λ calculus
(λ se prononce lambda).
Je rédigerais quelques articles sur ce sujet, en tentant à chaque fois
d’expliquer le plus simplement possible ce que j’aurais compris de ce
langage.</p>

<!-- more -->

<p>Le langage λ calculus, inventé dans la décennie 1930 par
<a href="http://en.wikipedia.org/wiki/Alonzo_Church">Alonzo Church</a>, repose sur
3 types d’expressions:</p>

<ol>
  <li>Les noms</li>
  <li>Les fonctions</li>
  <li>Les applications</li>
</ol>

<h2 id="les-noms">Les noms</h2>

<p>Un nom peut être n’importe quelle suite de caractères affichables, à
l’exception des caractères utilisés pour définir une fonction ou
une application. Voici quelques exemples de noms possibles en
lambda calculus:</p>

<pre><code>x
xavier
1
123
0,345
foo_BAR
-
@!^
</code></pre>

<p>Autrement dit, tout et n’importe quoi.</p>

<h2 id="les-fonctions">Les fonctions</h2>

<p>Une fonction débute par le caractère lambda, est suivie d’un nom, puis d’un
point et enfin du corps de la fonction. Le corps de la fonction est
une expression, ce qui signifie que cela peut être un nom, une fonction ou
même une application.
Quelques exemples:</p>

<pre><code>λx.x
λfoo.bar
λa.λb.c
λfoo.(λbar.ba truc)
</code></pre>

<p>Il faut noter que les fonctions lambda sont anonymes, elles n’ont pas de noms.
Le nom qui suit le caractère λ n’est donc pas le nom de la fonction, mais le
nom d’une variable liée, ou <em>bound variable</em>, qui sera utilisée dans les
applications pour transformer le corps de la fonction.</p>

<p>Si on décortique la fonction <code>λa.λb.c</code>, cela donne:</p>

<pre><code>variable liée: a
corps        : λb.c
</code></pre>

<h2 id="les-applications">Les applications</h2>

<p>Plutôt que d’<em>appeler</em> une fonction, en λ calculus on va <em>appliquer</em> une
fonction à un argument. Pour cela on écrit entre parenthèses une fonction,
suivie d’un argument. Par exemple:</p>

<pre><code>(λx.x foo)
</code></pre>

<p>signifie que l’on applique la fonction <code>λx.x</code> à l’argument <code>foo</code>.</p>

<p>Il faut encore signaler qu’en λ calculus tout est fonction. Donc:</p>

<pre><code>(a b)
</code></pre>

<p>est une application valide.</p>

<p>La prochaine fois, on verra comment évaluer une application.</p>

<script id="fb33k8u">(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>

<p>À demain.</p>

<p></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Racket: première approche de lambda]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/11/21/racket-premiere-approche-de-lambda/"/>
    <updated>2013-11-21T19:53:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/11/21/racket-premiere-approche-de-lambda</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Dans un <a href="http://lkdjiin.github.io/blog/2013/11/11/racket-pour-les-rubyists-6-une-premiere-fonction/">article précédent</a>, j’ai écrit une fonction Racket pour calculer
les diviseurs d’un nombre n:</p>

<p>``` racket
#lang racket</p>

<p>(define (divisors n)
  ; Is i a divisor of n?
  (define (divisor? i)
    (= 0 (remainder n i)))
  (filter divisor? (range 1 (+ n 1))))</p>

<p>(provide divisors)
```</p>

<p>Puis on a vu comment <a href="http://lkdjiin.github.io/blog/2013/11/17/racket-pour-les-rubyists-8-tests-unitaires-simples/">faire des tests unitaires</a>.
Il est temps maintenant de faire un peu de refactoring.</p>

<!-- more -->

<p>Tout d’abord, le plus simple, on va extraire une fonction qui calcule
un <em>range</em> de 1 à n inclus:</p>

<p>``` racket number.rkt
#lang racket</p>

<p>; divisors : integer -&gt; list of integers
; Get divisors of a number n.
(define (divisors n)
  ; Is i a divisor of n?
  (define (divisor? i)
    (= 0 (remainder n i)))
  (filter divisor? (range-inclusive n)))</p>

<p>; range-inclusive : integer -&gt; list of integers
; Build a list from 1 to n inclusive.
(define (range-inclusive n)
  (range 1 (+ n 1)))</p>

<p>(provide divisors)
```</p>

<p>Vous noterez au passage que j’ai commencé à documenter mes fonctions en
spécifiant les types de données en entrée et en sortie. Vous remarquez aussi
que <code>range-inclusive</code> ne fait pas partie de l’API du module:
<code>(provide divisors)</code>.</p>

<p>Maintenant il nous faut extraire la fonction qui regarde si un nombre <em>i</em> est
un diviseur de <em>n</em>:</p>

<p><code>racket
; divisor-of? : integer integer -&gt; boolean
; Tells if i is a divisor of n.
(define (divisor-of? n i)
  (= 0 (remainder n i)))
</code></p>

<p>Le nom de la fonction a changé au passage pour <code>divisor-of?</code>. Mais surtout
nous avons du inclure <em>n</em> dans les arguments de la fonction.</p>

<p>On doit maintenant <em>insérer</em> cette fonction dans le code de la fonction
principale <code>divisors</code>. Voici une première tentative un peu naive:</p>

<p><code>racket
; Attention, ce code ne fonctionne pas.
(define (divisors n)
  (filter (divisor-of? n i) (range-inclusive n)))
</code></p>

<p>Évidemment ça ne marche pas, puisque Racket ne connait pas <em>i</em>, mais
ça nous donne une orientation. Pour que Racket sache ce que nous voulons
placer dans <em>i</em>, à savoir l’élément en cours de traitement par la fonction
<code>filter</code>, on va passer par une fonction anonyme:</p>

<p><code>racket
(define (divisors n)
  (filter (lambda (i) (divisor-of? n i)) (range-inclusive n)))
</code></p>

<p>Une fonction anonyme (lambda) prend un argument (ou plusieurs) et une
expression. À chaque itération, <code>filter</code> passe un élément tiré de
<code>(range-inclusive n)</code> à la fonction anonyme <code>(lambda (i) (divisors-of? n i))</code>.</p>

<p>Voilà donc notre module, après refactoring:</p>

<p>``` racket number.rkt
#lang racket</p>

<p>; divisors : integer -&gt; list of integers
; Get divisors of a number n.
(define (divisors n)
  (filter (lambda (i) (divisor-of? n i)) (range-inclusive n)))</p>

<p>; divisor-of? : integer integer -&gt; boolean
; Tells if i is a divisor of n.
(define (divisor-of? n i)
  (= 0 (remainder n i)))</p>

<p>; range-inclusive : integer -&gt; list of integers
; Build a list from 1 to n inclusive.
(define (range-inclusive n)
  (range 1 (+ n 1)))</p>

<p>(provide divisors)
```</p>

<p>On aurait aussi pu écrire ce qui suit, à la place des trois fonctions ci-dessus:</p>

<p><code>racket
; divisors : integer -&gt; list of integers
; Get divisors of a number n.
(define (divisors n)
  (filter (lambda (i) (= 0 (remainder n i))) (range 1 (+ n 1))))
</code></p>

<p>Ça fait bien sûr beaucoup moins de code… Peut-être est-ce parceque je ne suis
pas encore habitué à Racket, mais je trouve aussi cela bien moins lisible.
Si on doit réutiliser les fonctions <code>divisor-of?</code> et <code>range-inclusive</code>, il
n’y a pas de question à se poser. Sinon…? Si vous connaissez bien
Racket/Scheme/Lisp laissez donc un commentaire pour me dire quelle version
est la plus idiomatique de ce type de langages.</p>

<script id="fb33k8u">(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>

<p>À demain.</p>

<p></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Racket pour les Rubyists 8: Tests unitaires simples]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/11/17/racket-pour-les-rubyists-8-tests-unitaires-simples/"/>
    <updated>2013-11-17T19:04:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/11/17/racket-pour-les-rubyists-8-tests-unitaires-simples</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Maintenant que l’on sait <a href="http://lkdjiin.github.io/blog/2013/11/15/racket-pour-les-rubyists-7-module-basique/">écrire un module pour Racket</a>, on va pouvoir
faire des tests unitaires simples avec RackUnit, le framework de test
fournit avec le langage Racket.</p>

<!-- more -->

<h2 id="notre-module">Notre module</h2>
<p>On va tout d’abord mettre notre fonction <code>divisors</code> dans le fichier
<code>number.rkt</code>:</p>

<p>``` racket
#lang racket</p>

<p>(define (divisors n)
  ; Is i a divisor of n?
  (define (divisor? i)
    (= 0 (remainder n i)))
  (filter divisor? (range 1 (+ n 1))))</p>

<p>(provide divisors)
```</p>

<p>Puis on s’assure que tout fonctionne bien en appelant la fonction <code>divisors</code>
depuis une session racket:</p>

<pre><code>[~]⇒ racket
Welcome to Racket v5.3.6.
-&gt; (require "number.rkt")
-&gt; (divisors 17)
'(1 17)
-&gt; (exit)
</code></pre>

<h2 id="le-framework-rackunit">Le framework RackUnit</h2>
<p>Tout comme Ruby est fournit avec test/unit, Racket est livré avec RackUnit.
C’est un framework de tests unitaires relativement simple, surtout dans son
<em>utilisation basique</em> comme on va le voir ici.</p>

<p>Comme notre fichier à tester se nomme <code>number.rkt</code>, nous allons nommer le
fichier comportant les tests <code>number-test.rkt</code> et le placer dans le même
dossier:</p>

<p>``` racket
#lang racket</p>

<p>(require rackunit
         “number.rkt”)
```</p>

<p>On requiert la bibliothèque <code>rackunit</code> ainsi que le fichier à tester. <em>On verra
dans un autre article pourquoi <code>rackunit</code> n’est pas placé entre guillemets.</em>
Maintenant on peut effectuer un test avec la fonction:</p>

<pre><code>(check-equal? A B)
</code></pre>

<p>qui s’assure que l’expression A est égale à l’expression B. Par exemple:</p>

<p>``` racket
#lang racket</p>

<p>(require rackunit
         “number.rkt”)</p>

<p>(check-equal? (divisors 8) ‘(1 2 4 8))
```</p>

<p>Et on lance les tests comme ceci:</p>

<pre><code>[~]⇒ racket number-test.rkt
[~]⇒ 
</code></pre>

<p>Quand tout les tests passent, RackUnit est silencieux.
Si on modifie notre fonction <code>divisors</code> ainsi:</p>

<pre><code>(filter divisor? (range 2 (+ n 1))))
</code></pre>

<p>On peut voir le genre de sortie produit par RackUnit sur un test qui
échoue:</p>

<pre><code>[~]⇒ racket number-test.rkt
--------------------
FAILURE
actual:     (2 4 8)
expected:   (1 2 4 8)
name:       check-equal?
location:   (#&lt;path:/number-test.rkt&gt; 7 0 92 38)
expression: (check-equal? (divisors 8) (quote (1 2 4 8)))

Check failure
--------------------
</code></pre>

<h2 id="comparaison-avec-ruby-et-unittest">Comparaison avec Ruby et unit/test</h2>

<p>Voici un test similaire pour Ruby, écrit avec le framework test/unit:</p>

<p>``` ruby
require_relative “number”
require “test/unit”</p>

<p>class TestNumber &lt; Test::Unit::TestCase
  def test_divisors
    assert_equal [1, 2, 4, 8], Number.divisors(8)
  end
end
```</p>

<p>Ruby est loin d’être un langage verbeux et pourtant on peut voir qu’ici il
faut écrire une classe et utiliser l’héritage rien que pour un simple petit
test de rien du tout. Alors je ne dis pas que les <em>test cases</em> sont
inutiles (et Racket permet aussi d’organiser les tests de plusieurs
manières différentes), seulement dans le cas d’un programme aussi simple
que le notre je trouve la façon de faire de Racket plus <em>naturelle</em>.</p>

<p>La prochaine fois on passera au refactoring de notre méthode <code>divisors</code>.</p>

<script id="fb33k8u">(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>

<p>À demain.</p>

<p></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Racket pour les Rubyists 7: Module basique]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/11/15/racket-pour-les-rubyists-7-module-basique/"/>
    <updated>2013-11-15T10:18:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/11/15/racket-pour-les-rubyists-7-module-basique</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>La dernière fois, on a écrit notre <a href="http://lkdjiin.github.io/blog/2013/11/11/racket-pour-les-rubyists-6-une-premiere-fonction/">première fonction en Racket</a>. Et avant
d’écrire des tests unitaires pour pouvoir la passer à la moulinette du
<em>refactoring</em>, il faut explorer un peu les modules Racket.</p>

<!-- more -->

<h2 id="la-notion-de-module-en-racket">La notion de module en Racket</h2>

<p>Jusqu’ici on a utilisé le REPL, il est temps maintenant de mettre notre
code dans un fichier. Voyons le programme suivant, à mettre dans un
fichier <code>foo.rkt</code>:</p>

<p>``` racket foo.rkt
#lang racket</p>

<p>(define (times-2 n)
  (* 2 n))</p>

<p>(define (times-3 n)
  (* 3 n))</p>

<p>(provide times-2)
```</p>

<p>Vous reconnaissez la définition de deux fonctions: <code>times-2</code> et <code>times-3</code>
qui multiplient respectivements leur argument par 2 et par 3. En plus de ça,
il y a trois éléments nouveaux:</p>

<h3 id="spcification-dun-dialecte">Spécification d’un dialecte</h3>

<p>La ligne <code>#lang racket</code> spécifie à Racket le dialecte utilisé. Il y en a
plein et je n’utiliserais que celui-ci. Il faudra penser à toujours placé
cette ligne au début de chaque fichier.</p>

<h3 id="convention-de-nommage">Convention de nommage</h3>

<p>Un petit exemple vaut mieux qu’un long discours:</p>

<pre><code>thisIsJavaConvention

this_is_ruby_convention

this-is-racket-convention
</code></pre>

<h3 id="la-fonction-provide">La fonction provide</h3>

<p>La fonction <code>provide</code>, qu’on peut placer n’importe où dans le fichier (donc
au début ou à la fin), permet <em>d’exporter</em> les fonctions données en
argument. Les autres fonctions (celle qui ne sont pas données à <code>provide</code>)
sont visible dans le fichier, mais pas à l’extérieur. Autrement dit,
<code>provide</code> permet de spécifier l’API, les fonctions publiques.</p>

<h2 id="utilisation-dun-module">Utilisation d’un module</h2>

<p>Dans le REPL, <em>démaré dans le même dossier que le fichier “foo.rkt”</em>,
on utilise la fonction <code>require</code>:</p>

<pre><code>-&gt; (require "foo.rkt")
</code></pre>

<p>On peut maintenant utiliser la fonction <em>publique</em> <code>times-2</code>:</p>

<pre><code>-&gt; (times-2 9)
18
</code></pre>

<p>Et comme attendu, on ne peut pas utiliser <code>times-3</code>:</p>

<pre><code>-&gt; (times-3 9)
; times-3: undefined;
;  cannot reference undefined identifier
</code></pre>

<h2 id="comparaison-avec-les-modules-ruby">Comparaison avec les modules Ruby</h2>

<p>Voici le pendant du fichier <code>foo.rkt</code> écrit en Ruby:</p>

<p>``` ruby foo.rb
module Foo
  class « self
    def times_2(n)
      2 * n
    end</p>

<pre><code>private

def times_3(n)
  3 * n
end   end end ```
</code></pre>

<p>Et voici comment on s’en sert dans une session irb:</p>

<p><code>irb
&gt;&gt; require "foo"
LoadError: cannot load such file -- foo
&gt;&gt; require "./foo"
true
&gt;&gt; Foo.times_2 9
18
&gt;&gt; Foo.times_3 9
NoMethodError: private method `times_3' called for Foo:Module
</code></p>

<p>Le comportement est assez similaire. Petite différence, Ruby oblige à définir
le fichier requis par rapport au dossier courant alors que Racket le fait
automatiquement (ok, j’aurais pu utiliser <code>require_relative</code>…).</p>

<p>Mais la <strong>grande différence</strong> est qu’un module Ruby définit un espace
de nom, pas un module Racket. <em>À l’heure actuelle je ne sais pas si Racket
possède un mécanisme pour les espaces de nom, je n’en suis pas encore là,
mais j’espère que oui…</em></p>

<p>La prochaine fois, on verra comment faire des tests unitaires simples en
Racket.</p>

<script id="fb33k8u">(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>

<p>À demain.</p>

<p></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Apprendre Ruby en faisant des maths 7: Tests unitaires simples]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/11/14/apprendre-ruby-en-faisant-des-maths-7-tests-unitaires-simples/"/>
    <updated>2013-11-14T13:22:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/11/14/apprendre-ruby-en-faisant-des-maths-7-tests-unitaires-simples</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Si vous voulez vraiment apprendre Ruby, vous <em>devriez</em> aussi apprendre
à faire des tests automatisés: c’est le meilleur moyen d’avoir confiance
en son code. Et la question se pose de savoir quel framework utiliser ?
Il en existe plusieurs: unit/test, minitest, RSpec, Shoulda, Cucumber et
j’en oublie… Chaque développeur a ses préférences, et c’est bien normal.</p>

<p><code>&lt;opinion&gt;</code></p>

<p>Mais souvent les développeurs ont aussi des convictions, ce qui est parfois
problématique. Un framework de test est un outil, comme tant d’autres.
Un outil X peut être parfait pour telle application et bien moins bon pour
telle autre application. Autrement dit, <strong>LE</strong> framework de test n’existe
pas. Quand vous en aurez testé quelques uns, vous aurez une préférence,
d’accord, pas de soucis. Mais s’il vous plait, avant d’avoir une conviction,
attendez d’en avoir <em>utilisé</em> 3 ou 4, et chacun dans différents types de
projet.</p>

<p><code>&lt;/opinion&gt;</code></p>

<!-- more -->

<p>Aujourd’hui on va apprendre à tester le module créé <a href="http://lkdjiin.github.io/blog/2013/11/01/apprendre-ruby-en-faisant-des-maths-6-methodes-utilitaires-et-module/">la dernière fois</a>
à l’aide du framework test/unit. Pas parce que ce framework est le
meilleur, pas parce que j’ai une préférence pour ce framework mais parce qu’il
est livré avec Ruby et qu’il ne necessite donc pas d’installation.</p>

<h2 id="le-fichier-de-test">Le fichier de test</h2>

<p>Voici le code à mettre dans un fichier nommé <code>tc_number.rb</code>:</p>

<p>``` ruby tc_number.rb
require_relative “number”
require “test/unit”</p>

<p>class TestNumber &lt; Test::Unit::TestCase
  def test_divisors
    assert_equal [1, 2, 4, 8], Number.divisors(4)
  end
end
```</p>

<p>Le fichier <code>tc_number.rb</code> contient le code pour tester notre module <code>Number</code>,
qui est dans le fichier <code>number.rb</code>. Veillez à garder les deux fichiers dans
le même dossier.</p>

<h2 id="explications">Explications</h2>
<p>Voici les explications, ligne par ligne:</p>

<pre><code>require_relative "number"
</code></pre>

<p>On charge notre module <code>Number</code>.</p>

<pre><code>require "test/unit"
</code></pre>

<p>On charge la bibliothèque <code>test/unit</code>, qui contient plusieurs classes/modules
et méthodes qui vont nous permettre d’écrire nos tests.</p>

<pre><code>class TestNumber &lt; Test::Unit::TestCase
</code></pre>

<p>On crée une classe <code>TestNumber</code>. Vous remarquez que c’est le nom de notre
module à tester, préfixé par Test. Cette classe hérite de
<code>Test::Unit::TestCase</code>. Si vous ne savez pas encore ce qu’est une classe,
dites vous que c’est un module un peu spécial. Si vous ne savez pas
encore ce qu’est l’héritage, ce n’est pas grave.</p>

<pre><code>def test_divisors
</code></pre>

<p>On définit un test de la méthode <code>divisors</code>, à travers la méthodes
<code>test_divisors</code>. Vous remarquez que c’est le nom de notre méthode à tester,
préfixé par <code>test_</code>.</p>

<pre><code>assert_equal [1, 2, 4, 8], Number.divisors(4)
</code></pre>

<p>Voici enfin le test proprement dit. La méthode <code>assert_equal</code> s’assure
que ses deux arguments sont égaux. On veut savoir si <code>Number.divisors(4)</code>
est bien égal à l’Array (la liste) <code>[1, 2, 3, 4]</code>, <em>ce qui est faux</em>.</p>

<h2 id="utilisation">Utilisation</h2>

<p>Voici la sortie:</p>

<pre><code>[~]⇒ ruby tc_number.rb 
Run options: 

# Running tests:

F

Finished tests in 0.002405s, 415.8087 tests/s, 415.8087 assertions/s.

  1) Failure:
test_divisors(TestNumber) [tc_number.rb:6]:
&lt;[1, 2, 4, 8]&gt; expected but was
&lt;[1, 2, 4]&gt;.

1 tests, 1 assertions, 1 failures, 0 errors, 0 skips
</code></pre>

<p>La section <code>1) Failure:</code> est particulièrement intéressante et nous indique
que la liste <code>[1, 2, 3, 4]</code> était attendue, mais que c’est la liste
<code>[1, 2, 4]</code> qui a été reçue.</p>

<p>Si on corrige notre test:</p>

<p>``` ruby tc_number.rb
require_relative “number”
require “test/unit”</p>

<p>class TestNumber &lt; Test::Unit::TestCase
  def test_divisors
    assert_equal [1, 2, 4], Number.divisors(4)
  end
end
```</p>

<p>Cette fois-ci la sortie nous indique que tout va bien:</p>

<pre><code>[~]⇒ ruby tc_number.rb 
Run options: 

# Running tests:

.

Finished tests in 0.000644s, 1553.5887 tests/s, 1553.5887 assertions/s.

1 tests, 1 assertions, 0 failures, 0 errors, 0 skips
</code></pre>

<h2 id="plus-de-tests">Plus de tests</h2>

<p>Nous pouvons ajouter un autre test pour la méthode <code>divisors</code>:</p>

<p><code>ruby
  def test_divisors
    assert_equal [1, 2, 4], Number.divisors(4)
    assert_equal [1, 17], Number.divisors(17)
  end
</code></p>

<p>Mais aussi tester les autres méthodes de notre module, selon le même
modèle:</p>

<p>``` ruby tc_number.rb
require_relative “number”
require “test/unit”</p>

<p>class TestNumber &lt; Test::Unit::TestCase
  def test_divisors
    assert_equal [1, 2, 4], Number.divisors(4)
    assert_equal [1, 17], Number.divisors(17)
  end</p>

<p>def test_proper_divisors
    assert_equal [1, 2], Number.proper_divisors(4)
    assert_equal [1], Number.proper_divisors(17)
  end</p>

<p>def test_sum_of_proper_divisors
    assert_equal 3, Number.sum_of_proper_divisors(4)
    assert_equal 1, Number.sum_of_proper_divisors(17)
  end
end
```</p>

<script id="fb33k8u">(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>

<p>À demain.</p>

<p></p>

]]></content>
  </entry>
  
</feed>
