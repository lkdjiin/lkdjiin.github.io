<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : tutoriel | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/tutoriel/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2013-10-27T07:43:23+01:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Apprendre Ruby en faisant des maths 3]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/10/25/apprendre-ruby-en-faisant-des-maths-3/"/>
    <updated>2013-10-25T10:02:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/10/25/apprendre-ruby-en-faisant-des-maths-3</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>La <a href="http://lkdjiin.github.io/blog/2013/10/23/apprendre-ruby-en-faisant-des-maths-2/">dernière fois</a>, on a vu comment calculer la liste des diviseurs
d'un nombre avec <code>(1..8).select {|int| 8 % int == 0 }</code>. On va aujourd'hui
faire en sorte que ça fonctionne avec n'importe quel nombre, en écrivant
notre propre méthode.</p>

<!-- more -->


<p>Résumons : pour trouver les diviseurs de 8, j'écris:</p>

<p><code>ruby
(1..8).select {|int| 8 % int == 0 }
</code></p>

<p>et pour trouver les diviseurs de 4, j'écris:</p>

<p><code>ruby
(1..4).select {|int| 4 % int == 0 }
</code></p>

<p>Ce que je veux, c'est une façon de faire plus <em>générale</em>: je veux trouver
les diviseurs pour tout entier <em>n</em>. Essayons donc de remplacer le
nombre recherché par n:</p>

<p>``` irb</p>

<blockquote><blockquote><p>(1..n).select {|int| n % int == 0 }
NoMethodError: undefined method `n' on an instance of Object.
```</p></blockquote></blockquote>

<p>Ruby n'est pas content et nous signale qu'il ne connait pas n. Ok, essayons
alors de définir n d'abord:</p>

<p>``` irb</p>

<blockquote><blockquote><p>n = 8
=> 8
(1..n).select {|int| n % int == 0 }
=> [1, 2, 4, 8]
```</p></blockquote></blockquote>

<p>Cette fois c'est bon. Maintenant vous êtes prêt à définir une méthode:</p>

<p><code>ruby
def divisors(n)
  (1..n).select {|int| n % int == 0 }
end
</code></p>

<p><strong>Pour information, divisors est le mot anglais pour diviseurs.</strong></p>

<p>Une définition de méthode commence par le mot-clé <code>def</code> et se termine par
le mot-clé <code>end</code>. La méthode ci-dessus s'appelle <code>divisors</code> et elle prend
un argument qui est nommé <code>n</code>.</p>

<p>On lance/appelle/exécute une méthode simplement par son nom, sans oublier
son (ses) argument(s). Par exemple <code>divisors 8</code> va calculer et renvoyer la
liste des diviseurs de 8. Voici un exemple d'utilisation lors d'une session
irb:</p>

<p>``` irb</p>

<blockquote><blockquote><p>def divisors(n)
  (1..n).select {|int| n % int == 0 }
end
divisors 8
=> [1, 2, 4, 8]
divisors 4
=> [1, 2, 4]
divisors 417
=> [1, 3, 139, 417]
```</p></blockquote></blockquote>

<p>La prochaine fois nous verrons comment se servir de la méthode <code>divisors</code>
comme d'une base pour construire une autre méthode.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Une tonne de livres sur la programmation]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/10/24/une-tonne-de-livres-sur-la-programmation/"/>
    <updated>2013-10-24T10:22:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/10/24/une-tonne-de-livres-sur-la-programmation</id>
    <content type="html"><![CDATA[<p>Une super initiative de <a href="https://github.com/vhf">vhf</a> sur Github: une
longue, longue, très longue liste de livres sur le développement,
certains libres, tous gratuits.</p>

<!-- more -->


<p>Ils y a plusieurs listes de livres, selon les langues.
Vous trouverez la liste en anglais ici: <a href="https://github.com/vhf/free-programming-books/blob/master/free-programming-books.md">free-programming-books</a>.
Et la liste en français ici: <a href="https://github.com/vhf/free-programming-books/blob/master/free-programming-books-fr.md">free-programming-books-fr</a>.</p>

<p>Comme les listes sont sur Github, vous pouvez très facilement ajouter un
nouveau livre, rectifier un lien, etc.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Apprendre Ruby en faisant des maths 2]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/10/23/apprendre-ruby-en-faisant-des-maths-2/"/>
    <updated>2013-10-23T09:54:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/10/23/apprendre-ruby-en-faisant-des-maths-2</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>On a vu, <a href="http://lkdjiin.github.io/blog/2013/10/21/apprendre-ruby-en-faisant-des-maths/">précédemment</a>,
comment savoir si un nombre d est un diviseur de n avec <code>8 % 2</code> et
comment obtenir une liste de nombre avec <code>1..8</code>. Maintenant on peut
apprendre à sélectionner les nombres qui nous intéressent dans cette liste.</p>

<!-- more -->


<p>Pour cela, nous allons utiliser la méthode <code>select</code>:</p>

<p>``` irb</p>

<blockquote><blockquote><p>(1..8).select {|int| 8 % int == 0 }
=> [1, 2, 4, 8]
```</p></blockquote></blockquote>

<p>Et voilà, nous avons nos diviseurs de 8. La méthode <code>select</code> utilise un
bloc d'instructions (ce qui se trouve entre les <code>{}</code>). Cette (ou ces)
instruction va être exécutée sur chaque éléments de <code>1..8</code>, c'est à dire
sur 1, 2, 3, 4, 5 ,6, 7 puis enfin 8. Ici, l'instruction exécutée sur les
éléments est <code>8 % int == 0</code>. En clair on teste si le reste de la division
de 8 par <code>int</code> égal zéro. Qu'est-ce que c'est que ce <code>int</code> ? Et bien c'est
l'élément en cours de traitement, c'est à dire 1, puis 2, et ensuite 3, etc
jusqu'à 8. <code>int</code> est simplement un nom qu'on a donné pour pouvoir se
référer à l'élément en cours, ce nom est indiqué entre deux caractères <code>|</code>,
comme dans <code>|int|</code>. On peut lui donner le nom qu'on veut, par exemple:</p>

<p>``` irb</p>

<blockquote><blockquote><p>(1..8).select {|xavier| 8 % xavier == 0 }
=> [1, 2, 4, 8]
```</p></blockquote></blockquote>

<p>Pour information, <em>int</em> est le diminutif de integer, qui signifie
nombre entier en anglais.</p>

<p>Comment Ruby sait qu'il doit sélectionner 2 et pas 3 ? Regardons cela de
plus près:</p>

<p>``` irb</p>

<blockquote><blockquote><p>8 % 2 == 0
=> true
8 % 3 == 0
=> false
```</p></blockquote></blockquote>

<p>Le résultat d'un test, ici l'égalité avec <code>==</code> est soit vrai (true), soit
faux (false). Lorsque l'instruction dans le bloc (<code>{}</code>) renvoie true, l'élément
est sélectionné, lorsqu'elle renvoie false, l'élément est éliminé.</p>

<p>Vous devriez vérifier maintenant que ça fonctionne bien avec n'importe
quel nombre entier positif:</p>

<p>``` irb</p>

<blockquote><blockquote><p>(1..1).select {|int| 1 % int == 0 }
=> [1]
(1..41).select {|int| 41 % int == 0 }
=> [1, 41]
(1..417).select {|int| 417 % int == 0 }
=> [1, 3, 139, 417]
(1..4179).select {|int| 4179 % int == 0 }
=> [1, 3, 7, 21, 199, 597, 1393, 4179]
```</p></blockquote></blockquote>

<p>La prochaine fois, on verra comment créer nos propres méthodes.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Apprendre Ruby en faisant des maths]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/10/21/apprendre-ruby-en-faisant-des-maths/"/>
    <updated>2013-10-21T21:09:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/10/21/apprendre-ruby-en-faisant-des-maths</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>J'ai eu récemment à aider quelqu'un en mathématique (niveau 3ème), et ce
quelqu'un connaissait un peu Ruby. On a joué avec le langage pour faire
des maths. C'était drôle et intéressant. Ça m'a donné l'idée de
continuer cette affaire sur mon blog. Cette nouvelle série d'articles
s'adresse à celles et ceux qui débutent Ruby et qui ont un niveau de math de
3ème.</p>

<!-- more -->


<p>Le premier problème auquel on va essayer de répondre en utilisant Ruby est
le suivant:</p>

<p><blockquote><p>Afficher toutes les paires de nombres amiables jusqu'à 10.000.</p></blockquote></p>

<p>Si vous avez besoin de vous rafraichir la mémoire sur les nombres
amiables, voici <a href="http://fr.wikipedia.org/wiki/Nombre_amical">l'article de wikipédia</a>.
Et en voici une définition rapide:</p>

<p>si <em>f</em>(n) est une fonction qui calcule la
somme des diviseurs stricts de n, alors n et m sont amiables si
<em>f</em>(n) = m et <em>f</em>(m) = n.</p>

<h2>Obtenir les diviseurs d'un nombre</h2>

<p>La première chose à faire est de calculer les diviseurs d'un nombre n.
Pour mémoire, les diviseurs de 8, par exemple, sont 1 ; 2 ; 4 et 8.
Pour les trouver, une méthode consiste à diviser 8 par chaque nombre de 1 à 8
et à regarder le reste de la division. Si il reste 0, c'est un diviseur, sinon
ce n'est pas un diviseur. En Ruby, calculer le reste d'une division se fait
avec l'opérateur <code>%</code> (le modulo):</p>

<p>``` irb
[~]⇒ irb</p>

<blockquote><blockquote><p>8 % 1
0
8 % 2
0
8 % 3
2
8 % 4
0
8 % 5
3
8 % 6
2
8 % 7
1
8 % 8
0
```</p></blockquote></blockquote>

<p>On voit bien que les diviseurs de 8, soit 1, 2, 4 et 8 renvoient bien 0.
Évidemment, il n'est pas question de se taper tout ces chiffres <em>à la main</em>,
imaginez un peu que vous vouliez connaitre les diviseurs de 123456789 !
Il nous faut quelque chose pour produire automatiquement les nombres de 1 à
n. En Ruby, on appelle ça un <code>Range</code>:</p>

<p>``` irb</p>

<blockquote><blockquote><p>1..8
1..8
```</p></blockquote></blockquote>

<p>Pour y voir plus clair, on va appeler la méthode <code>to_a</code> sur ce <code>Range</code>, qui
va nous le transformer en un tableau (<code>Array</code>). Vous pouvez pensez à un
tableau comme à une simple liste:</p>

<p>``` irb</p>

<blockquote><blockquote><p>(1..8).to_a
[1, 2, 3, 4, 5, 6, 7, 8]
```</p></blockquote></blockquote>

<p>On a bien une liste des nombres de 1 à 8. Notez que les parenthèses sont ici
nécessaires, sinon la méthode <code>to_a</code> serait appelée sur le chiffre 8, et
c'est pas bon:</p>

<p>``` irb</p>

<blockquote><blockquote><p>1..8.to_a
NoMethodError: undefined method `to_a' for 8:Fixnum
```</p></blockquote></blockquote>

<p>La prochaine fois on verra comment sélectionner dans cette liste seulement
les nombres qui nous intéressent, c'est à dire les diviseurs.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Le problème des 100 portes en Elixir]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/07/25/le-probleme-des-100-portes-en-elixir/"/>
    <updated>2013-07-25T07:35:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/07/25/le-probleme-des-100-portes-en-elixir</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Je continue mon périple parmi le <a href="http://rosettacode.org/wiki/">rosetta code</a>
en m'attaquant au problème des «100 doors».</p>

<p><blockquote><p>Problem: You have 100 doors in a row that are all initially closed. You make 100 passes by the doors. The first time through, you visit every door and toggle the door (if the door is closed, you open it; if it is open, you close it). The second time you only visit every 2nd door (door #2, #4, #6, &hellip;). The third time, every 3rd door (door #3, #6, #9, &hellip;), etc, until you only visit the 100th door.</p></p><p><p>Question: What state are the doors in after the last pass? Which are open, which are closed?</p><footer><strong>Rosetta Code <a href="http://rosettacode.org/wiki/100_doors">http://rosettacode.org/wiki/100_doors</a> 100 doors</strong></footer></blockquote></p>

<!-- more -->


<p>Je me dis que je vais d'abord le faire dans un langage que je connais bien
pour voir de quoi il retourne, et si il n'y a pas de pièges cachés. En
quelques lignes de Ruby, le tour est joué:</p>

<p>``` ruby 100 doors en Ruby
doors = Array.new(100)</p>

<p>(1..100).each do |interval|
  doors.map!.with_index do |elem, idx|</p>

<pre><code>(idx+1) % interval == 0 ? !elem : elem
</code></pre>

<p>  end
end</p>

<h1>Écrire le numéro des portes ouvertes.</h1>

<p>doors.each_with_index {|e, i| puts i+1 if e }
```</p>

<p>Voyant cela j'ai pensé que ça allait être assez simple à implémenter en
Elixir. Pas du tout. J'ai galéré longtemps avant de trouver la solution qui
va suivre. Mon plus gros problème avec Elixir est que les variables sont
non-mutables. Une fois définie, une variable ne change pas. Il faut donc
faire appel constament à la récursivité. Je ne nie pas les avantages d'un
tel système (pas d'effets de bords) mais ce n'est pas évident de s'y faire quand
on vient comme moi du monde procédural ou objet. Trêve de baratin, voici
ma solution avec Elixir:</p>

<p>``` elixir 100 doors en Elixir
defmodule Doors do</p>

<p>  def soluce do</p>

<pre><code>doors = Enum.map 1..100, fn _ -&gt; false end
run(doors, 1)
</code></pre>

<p>  end</p>

<p>  defp run(doors, interval) when interval > 100 do</p>

<pre><code>doors
</code></pre>

<p>  end</p>

<p>  defp run doors, interval do</p>

<pre><code>run(switch_doors(doors,interval), interval + 1)
</code></pre>

<p>  end</p>

<p>  defp switch_doors(doors, interval) do</p>

<pre><code>stream = Stream.with_index(doors)
list = Enum.to_list(stream)
Enum.map list, fn e -&gt;
  door = elem e, 0
  index = elem(e, 1) + 1
  switch_door rem(index, interval), door
end
</code></pre>

<p>  end</p>

<p>  defp switch_door(0, door), do: not door
  defp switch_door(_, door), do: door
end</p>

<p>soluce = Doors.soluce
Enum.each Enum.to_list(Stream.with_index(soluce)), fn e &ndash;>
  if elem(e, 0) == true, do: IO.puts elem(e, 1) + 1
end
```</p>

<p>Plutôt long comparé à la version Ruby, hein ? Quoiqu'il en soit, j'en suis
fier, j'ai mis du temps à la pondre, cette version. Je pense que quelqu'un
connaissant bien Elixir doit pouvoir nettement améliorer mon code. Je
vais le poster sur la mailing-list et demander ce qu'il en
pense. Si j'ai des retours (ce dont je ne doute pas) je mettrais la
version améliorée dans un prochain article. En attendant je vais
commenter un peu mon code pour l'expliquer.</p>

<p><code>elixir
def soluce do
  doors = Enum.map 1..100, fn _ -&gt; false end
  run(doors, 1)
end
</code></p>

<p><code>soluce</code> est la seule fonction publique du module. Elle initialise une liste
de 100 éléments avec la valeur <code>false</code>. Puis elle commence le travail avec
<code>run(doors, 1)</code>, <code>1</code> étant le premier intervalle de la série, c'est à dire
qu'on passe par toutes les portes. Une fois la solution découverte, elle est
renvoyée explicitement. Si vous connaissez Ruby, vous savez à quoi je fais
référence, sinon, sachez qu'en Elixir toutes les fonctions renvoie une valeur,
et qu'on a pas besoin de l'indiquer. C'est implicite, la dernière évaluation
est renvoyée. Notez aussi l'usage de <code>_</code> qui indique qu'on se fiche du contenu
de la variable.</p>

<p>``` elixir
defp run(doors, interval) when interval > 100 do
  doors
end</p>

<p>defp run doors, interval do
  run(switch_doors(doors,interval), interval + 1)
end
```</p>

<p>La première version de <code>run</code> comporte un <em>guard</em>. Elle n'est utilisée que
lorsque <code>interval</code> est supérieur à 100. C'est notre clause de sortie de la
fonction récursive.</p>

<p>La seconde version de <code>run</code> est utilisée dans tout les autres cas. Elle se
contente de s'appeller elle-même (récursivité) avec une liste des portes
mise à jour et un intervalle incrémenté.</p>

<p>``` elixir
defp switch_doors(doors, interval) do
  stream = Stream.with_index(doors)
  list = Enum.to_list(stream)
  Enum.map list, fn e &ndash;></p>

<pre><code>door = elem e, 0
index = elem(e, 1) + 1
switch_door rem(index, interval), door
</code></pre>

<p>  end
end
```</p>

<p><code>switch_doors</code> est responsable de fabriquer une nouvelle liste de portes.
C'est la fonction qui m'a tenu en échec pendant des heures, jusqu'à ce que
je découvre le module <code>Stream</code>. Voyons <code>switch_doors</code> en détails:</p>

<p><code>elixir
stream = Stream.with_index(doors)
list = Enum.to_list(stream)
</code></p>

<p>Je crée une nouvelle liste qui va embarquer les valeurs de <code>doors</code>
en les associant aux indexs. <code>list</code> va ressembler à ça:</p>

<pre><code>[{false, 0}, {false, 1}, {false, 2}, ... {false, 99}]
</code></pre>

<p>Qui en Elixir peut aussi être représenté ainsi:</p>

<pre><code>[false: 0, false: 1 ...
</code></pre>

<p><code>elixir
Enum.map list, fn e -&gt;
  door = elem e, 0
  index = elem(e, 1) + 1
  switch_door rem(index, interval), door
end
</code></p>

<p><code>Enum.map</code> fabrique et renvoie une nouvelle version de la liste des portes.
Chaque élément de <code>list</code> (chaque <code>{false, 0}</code>) passe à travers une fonction
anonyme qui renvoie false ou true, selon le résultat de index modulo interval.</p>

<p><code>elixir
defp switch_door(0, door), do: not door
defp switch_door(_, door), do: door
</code></p>

<p>Si le modulo égal zéro, on inverse l'état de la porte. Sinon la porte doit
rester dans le même état.</p>

<p><code>elixir
Enum.each Enum.to_list(Stream.with_index(soluce)), fn e -&gt;
  if elem(e, 0) == true, do: IO.puts elem(e, 1) + 1
end
</code></p>

<p>J'écris les numéros des portes ouvertes. Avec mes explications qui précèdent,
j'espère que vous pourrez comprendre comment ça marche.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
