<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : avancé | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/avance/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2014-02-03T20:44:24+01:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[L'auto-complétion programmable en Bash - partie 7]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/02/02/lauto-completion-programmable-en-bash-partie-7/"/>
    <updated>2014-02-02T18:35:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/02/02/lauto-completion-programmable-en-bash-partie-7</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-3'>Niveau : <span>avancé</span></div></p>

<p>Cet article est la suite de:
<a href="/blog/2014/01/29/lauto-completion-programmable-en-bash-partie-6/">L'auto complétion programmable en bash: partie 6</a>.</p>

<h2>Un motif général et basique, la suite</h2>

<p>Après avoir regardé la variable <code>COMPREPLY</code> dans le dernier article,
on étudie aujourd'hui les variables <code>COMP_WORDS</code> et <code>COMP_CWORD</code>.</p>

<!-- more -->


<p>On va encore modifier notre script, cette fois pour examiner le
contenu de la variable <code>COMP_WORDS</code>:</p>

<p>``` bash /etc/bash_completion.d/mytool
_mytool()
{</p>

<pre><code>COMPREPLY=${COMP_WORDS[@]}
</code></pre>

<p>}
complete -F _mytool mytool
```</p>

<p>N'oubliez pas de sourcer:</p>

<pre><code>$ source /etc/bash_completion.d/mytool
</code></pre>

<p>Testons:</p>

<pre><code>$ mytool foo bar[TAB]
</code></pre>

<p>est remplacé par:</p>

<pre><code>$ mytool foo mytool foo bar
</code></pre>

<p>On voit que <code>COMP_WORDS</code> est un tableau qui contient chaque éléments
de notre ligne de commande, au moment où celle ci est envoyée à
l'auto-complétion.</p>

<p>Voyons maintenant <code>COMP_CWORD</code>:</p>

<p>``` bash /etc/bash_completion.d/mytool
_mytool()
{</p>

<pre><code>COMPREPLY=( $COMP_CWORD )
</code></pre>

<p>}
complete -F _mytool mytool
```</p>

<p>Si je tapes:</p>

<pre><code>$ mytool foo bar[TAB]
</code></pre>

<p>Cela va être remplacé par:</p>

<pre><code>$ mytool foo 2
</code></pre>

<p>Donc, <code>COMP_CWORD</code> contient l'index de l'élément de la ligne de
commande dans lequel se trouve le curseur.</p>

<p>On a maintenant tous les éléments en main pour comprendre le script
présenté la dernière fois comme le motif de base pour
l'auto-complétion:</p>

<p>``` bash /etc/bash_completion.d/mytool
_mytool()
{</p>

<pre><code>local current=${COMP_WORDS[COMP_CWORD]}
COMPREPLY=( $(compgen -W "new compile test" -- $current) )
</code></pre>

<p>}
complete -F _mytool mytool
```</p>

<p>Il reste juste à expliquer la dernière ligne:</p>

<p><code>bash
complete -F _mytool mytool
</code></p>

<p>La fonction <code>complete</code>, interne à Bash, s'occupe bien sûr de l'auto-complétion
du programme <code>mytool</code>. Le nombre d'options possibles est important, vous pouvez
jeter un oeil au manuel si vous avez le temps. On se contentera ici de l'option
<code>-F</code>. Cette option est très intéressante, elle prend en argument le nom d'une
fonction (ici <code>_mytool</code>) qui va calculer la complétion. Cette fameuse option
<code>-F</code> permet aussi à <code>complete</code> de savoir qu'elle doit chercher des résultats
dans la variable <code>COMPREPLY</code>. Notez la convention utilisée: la fonction
<code>_mytool</code> calcule la complétion du programme <code>mytool</code>.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[L'auto-complétion programmable en Bash - partie 6]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/01/29/lauto-completion-programmable-en-bash-partie-6/"/>
    <updated>2014-01-29T20:47:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/01/29/lauto-completion-programmable-en-bash-partie-6</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-3'>Niveau : <span>avancé</span></div></p>

<p>Cet article est la suite de:
<a href="/blog/2014/01/15/lauto-completion-en-bash-partie-5/">L'auto complétion programmable en bash: partie 5</a>.</p>

<h2>Un motif général et basique</h2>

<p>Nous avons écrit un petit <a href="/blog/2014/01/14/lauto-completion-programmable-en-bash-partie-4/">programme pour tester</a>,
puis nous avons écrit <a href="/blog/2014/01/15/lauto-completion-en-bash-partie-5/">un script d'auto-complétion très simple</a>.
Reprenons notre jeu de rôle: nous avons un programme <code>mytool</code> qui
attend une des trois commandes suivantes: <code>new</code>, <code>compile</code> ou
<code>test</code>. On va ajouter ceci: la commande <code>new</code> peut prendre
l'option <code>--without-test</code> et la commande <code>compile</code> peut prendre
l'option <code>--verbose</code>. Ça reste encore très simple, mais on ne peut
déjà plus se servir uniquement de la fonction <code>complete</code>, vue
la dernière fois.</p>

<p>Voyons donc le motif général utilisé par beaucoup de scripts
d'auto-complétion:</p>

<!-- more -->


<p>``` bash /etc/bash_completion.d/mytool
_mytool()
{</p>

<pre><code>local current=${COMP_WORDS[COMP_CWORD]}
COMPREPLY=( $(compgen -W "new compile test" -- $current) )
</code></pre>

<p>}
complete -F _mytool mytool
```</p>

<p>Le script ci-dessus fait exactement la même chose que notre simple
script de la dernière fois, qui était le suivant:</p>

<p><code>bash /etc/bash_completion.d/mytool
complete -W "new compile test" mytool
</code></p>

<p>Mais il le fait d'une manière plus compliquée. En effet,
pourquoi faire simple… Les explications viendront plus tard.</p>

<p>En fait, pour aller plus loin, il est important de comprendre le rôle
des variables <code>COMP_WORDS</code>, <code>COMP_CWORD</code> et <code>COMPREPLY</code>. Pour ça, on
va modifier notre script, et chercher à comprendre ce que
représente <code>COMPREPLY</code>:</p>

<p>``` bash /etc/bash_completion.d/mytool
_mytool()
{</p>

<pre><code>COMPREPLY=( this is some replacement )
</code></pre>

<p>}
complete -F _mytool mytool
```</p>

<p>Pour qu'il soit pris en compte tout de suite, il faut le sourcer:</p>

<pre><code>$ source /etc/bash_completion.d/mytool
</code></pre>

<p>Alors, que fait-il ? Si je tapes <code>mytool foo bar[TAB]</code>, voici ce que
le script sort:</p>

<pre><code>$ mytool foo bar[TAB]
is           replacement  some         this   
</code></pre>

<p>COMPREPLY accepte un tableau de chaînes, qui sont les suggestions que
nous renvoit l'auto-complétion. On note au passage que ces suggestions
sont triées alphabétiquement.</p>

<p>Modifions à nouveau notre script:</p>

<p>``` bash /etc/bash_completion.d/mytool
_mytool()
{</p>

<pre><code>COMPREPLY=( replacement )
</code></pre>

<p>}
complete -F _mytool mytool
```</p>

<p>Cette fois, COMPREPLY représente un tableau d'un seul élément.
N'oubliez pas de sourcer le script avant de le tester:</p>

<pre><code>$ mytool foo bar[TAB]
</code></pre>

<p>devient:</p>

<pre><code>$ mytool foo replacement
</code></pre>

<p>Vous devriez maintenant avoir bien compris à quoi sert la variable
<code>COMPREPLY</code>.</p>

<p>La prochaine fois, on regardera en détail les variables <code>COMP_WORDS</code>
et <code>COMP_CWORD</code>.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Utiliser Vim comme un tableur sur Linux (enfin presque)]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/11/24/utiliser-vim-comme-un-tableur-sur-linux-enfin-presque/"/>
    <updated>2013-11-24T20:55:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/11/24/utiliser-vim-comme-un-tableur-sur-linux-enfin-presque</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-3'>Niveau : <span>avancé</span></div></p>

<p><a href="http://lkdjiin.github.io/blog/2013/11/23/pourcentage-des-issues-par-langages-sur-github/">Hier</a> j'ai donné une liste des rapports issues/nombre de dépots
par langages sur Github. Aujourd'hui je montre comment j'ai utilisé
Vim (sur linux) pour calculer ce rapport et formater la liste.</p>

<!-- more -->


<p>Voici la liste de départ, à récupérer <a href="http://hubreports.yougeezer.co.uk/languages">ici</a>, il s'agit juste d'un
copier/coller de la page web et je n'ai pris ici que les 5 premiers,
c'est suffisant pour la démonstration:</p>

<pre><code>1   JavaScript .js  560,116 891,531 319,537 4,951   1,147   343,483
2   Ruby .rb    466,411 469,913 175,577 2,726   607 147,339
3   Java .java  388,610 376,683 231,186 4,185   825 161,136
4   Python .py  281,835 323,858 130,034 2,538   685 184,908
5   PHP .php    275,411 289,899 155,941 2,331   454 150,024
</code></pre>

<p>Alors on n'y comprend rien puisque les colonnes sont invisibles. On va
former de belles colonnes à l'aide de l'utilitaire unix <strong>column</strong>:</p>

<p><code>vim
:%! column -t
</code></p>

<p>Et voici le résultat:</p>

<pre><code>1  JavaScript  .js    560,116  891,531  319,537  4,951  1,147  343,483
2  Ruby        .rb    466,411  469,913  175,577  2,726  607    147,339
3  Java        .java  388,610  376,683  231,186  4,185  825    161,136
4  Python      .py    281,835  323,858  130,034  2,538  685    184,908
5  PHP         .php   275,411  289,899  155,941  2,331  454    150,024
</code></pre>

<p>Les colonnes qui m'intéresse sont la 1 (rang), la 2 (langage), la 4
(nombre de dépots) et la dernière (nombre d'issues actives).
Je vais donc sélectionner la 3ème colonne à l'aide de <code>Ctrl-v</code> et la
supprimer (avec <code>d</code>). Voici ce que donne la sélection d'une colonne en
image si vous n'êtes pas familier de Vim:</p>

<p><img src="/images/vim-column.png"></p>

<p>Je répète ensuite la sélection/suppression pour les autres colonnes et
j'obtiens:</p>

<pre><code>1  JavaScript  560,116  343,483
2  Ruby        466,411  147,339
3  Java        388,610  161,136
4  Python      281,835  184,908
5  PHP         275,411  150,024
</code></pre>

<p>Il faut maintenant ajouter une colonne de chiffre qui contiendras le rapport
d'issues par dépots en pourcentage. C'est à dire la 4ème colonne divisée par
la 3ème colonne, le tout multiplié par 100. C'est classiquement un boulot
qu'on confierai au langage Awk, mais j'ai décidé il y a quelques temps de
faire le plus possible de choses avec Ruby, voici donc ce que j'ai écrit
dans Vim:</p>

<p><code>vim
:%! ruby -aple '$_ += " \#{(($F[3].to_f/$F[2].to_f)*100).to_i}"'
</code></p>

<p>Un peu cryptique ? Je l'avoue bien volontiers, mais les one-shots sont
rarement fait pour (peuvent rarement) être lisible… Je ferais certainement
un article sur les switchs a, p, l et e de <code>ruby</code>. Quoiqu'il en soit, voici
le résultat:</p>

<pre><code>1  JavaScript  560,116  343,483 61
2  Ruby        466,411  147,339 31
3  Java        388,610  161,136 41
4  Python      281,835  184,908 65
5  PHP         275,411  150,024 54
</code></pre>

<p>Il reste à trier cette liste sur la 5ème et dernière colonne, un jeu d'enfant
avec l'utilitaire unix <code>sort</code>:</p>

<p><code>vim
:%! sort -k5nr
</code></p>

<pre><code>4  Python      281,835  184,908 65
1  JavaScript  560,116  343,483 61
5  PHP         275,411  150,024 54
3  Java        388,610  161,136 41
2  Ruby        466,411  147,339 31
</code></pre>

<p>Voilà, ça prend un certain temps à décrire mais c'est rapide à faire quand
vous avez sous le coude une paire d'utilitaires qui déchirent !</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
