<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : avancé | Xavier Nayrac]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/avance/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2015-08-20T17:00:56+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Un exemple de polymorphisme en situation réelle]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/05/14/un-exemple-de-polymorphisme-en-situation-reelle/"/>
    <updated>2015-05-14T19:16:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/05/14/un-exemple-de-polymorphisme-en-situation-reelle</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-3'>Niveau : <span>avancé</span></div></p>

<p>J’écris en ce moment un <a href="http://fr.wikipedia.org/wiki/%C3%89mulation">émulateur</a>
pour <a href="http://fr.wikipedia.org/wiki/CHIP-8">Chip-8</a>, en Ruby. Dans les outils que
j’écris à coté il y a un <a href="http://fr.wikipedia.org/wiki/D%C3%A9sassembleur">désassembleur</a> de code Chip-8. Dans ce
désassembleur il y a un bel exemple de polymorphisme.</p>

<!-- more -->

<h2 id="un-peu-de-contexte">Un peu de contexte</h2>

<p>La classe Opcode permet de faire la correspondance entre un <a href="http://fr.wikipedia.org/wiki/Langage_machine#Opcode">opcode</a> Chip-8
et une ligne de code assembleur. Un opcode Chip-8 est toujours représenté par
un nombre <a href="http://fr.wikipedia.org/wiki/Syst%C3%A8me_hexad%C3%A9cimal">hexadécimal</a> de 4 chiffres.</p>

<p>Voici quelques exemples d’opcodes et leur correspondance en assembleur :</p>

<pre><code>Opcode | Assembleur  | Remarque
-------|-------------|---------
2a00   | CALL a00    |
7012   | ADD V0, 12  | V0 est un registre
a22e   | LOAD I, 22e | I est un registre
</code></pre>

<p>On pourra remarquer (même si ça n’est pas ultra visible avec seulement trois
exemples) que c’est le premier chiffre (ici <code>2</code>, <code>7</code> et <code>a</code>) qui décide du
type d’instruction.</p>

<p>De <code>0</code> à <code>f</code>, on a donc 16 types possibles, ce qui donne ce genre de code :</p>

<p>``` ruby opcode.rb
class Opcode</p>

<p>def initialize(opcode)
    @opcode = opcode
    @assembly = compute_assembly
    …
  end</p>

<p>…</p>

<p>private</p>

<p>def compute_assembly
    case @opcode[0]
    when ‘0’ then “Return this code”
    when ‘1’ then “Return that code”
    when ‘2’ then # …
    …
    when ‘d’ then # …
    when ‘e’ then # …
    when ‘f’ then # …
    end
  end</p>

<p>end
```</p>

<p>De plus, certains type d’instruction sont partagés en sous type, selon le
quatrième chiffre, ou bien selon les troisième et quatrième, ça dépend. Comme
toujours, on se retrouve à devoir gérer des cas particuliers, et le code
ressemble rapidement à la monstruosité qui suit :</p>

<p><code>ruby
def compute_assembly
  case @opcode[0]
  when '0'
    if @opcode == '00e0'
      # do that
    elsif @opcode == '00ee'
      # do that
    else
      # do that
    end
  when '1' then # do that
  when '2' then # do that
  when '3' then # do that
  when '4' then # do that
  when '5' then # do that
  when '6' then # do that
  when '7' then # do that
  when '8'
    case @opcode[3]
    when '0' then # do that
    when '1' then # do that
    when '2' then # do that
    when '3' then # do that
    when '4' then # do that
    when '5' then # do that
    when '6' then # do that
    when '7' then # do that
    when 'e' then # do that
    else
      # do that
    end
  when '9' then ...
  when 'a' then ...
  when 'b' then ...
  when 'c' then ...
  when 'd' then ...
  when 'e'
    # Ici, encore 2 sous-groupes
  when 'f'
    # Ici, encore 10 autres sous-groupes
  end
end
</code></p>

<p>C’est pas bon, hein ? Pour arranger ça, rien de tel qu’un peu de polymorphisme.
La classe Opcode va donc se contenter de ceci :</p>

<p>``` ruby Opcode
class Opcode</p>

<pre><code>def initialize(opcode)
  asm = Assembly.new(opcode)
  @assembly = asm.to_s
end
</code></pre>

<p>end
```</p>

<p>Vous devinez que c’est maintenant dans une nouvelle classe <code>Assembly</code> que sont géré les différentes
instructions et sous instructions :</p>

<p>``` ruby Assembly
class Assembly</p>

<p>def initialize(opcode)
    @opcode = opcode
    @assembly = build_assembly.to_s || ‘’
  end</p>

<p>def to_s
    @assembly
  end</p>

<p>private</p>

<p>def build_assembly
    klass = Kernel.const_get(‘Asm’ + @opcode[0])
    klass.new(@opcode)
  end</p>

<p>end
```</p>

<p>Et bien non, elles sont gérées chacune dans sa classe respective, à savoir
<code>Asm0</code>, <code>Asm1</code>, <code>Asm2</code>, et cetera jusqu’à <code>Asmf</code>. Voici un exemple :</p>

<p>``` ruby asm2.rb
class Asm2 &lt; AsmBase</p>

<p>def to_s
    “CALL #{nnn}”
  end</p>

<p>end
```</p>

<p>Chacune des classes <code>Asm0</code> à <code>Asmf</code> hérite de <code>AsmBase</code> qui définit le
comportement commun (nnn, kk, x et y sont simplement des conventions de nommage en
assembleur Chip-8) :</p>

<p>``` ruby asm_base.rb
class AsmBase</p>

<p>def initialize(opcode)
    @opcode = opcode
  end</p>

<p>def nnn
    @opcode[1, 3]
  end</p>

<p>def kk
    @opcode[2, 2]
  end</p>

<p>def x
    @opcode[1]
  end</p>

<p>def y
    @opcode[2]
  end</p>

<p>end
```</p>

<p>C’est un cas classique d’utilisation du polymorphisme. On troque
un long switch/case (virtuellement infini) pour plusieurs petites classes simples.
Le système est toujours aussi complexe dans son ensemble, mais sa maintenance
est maintenant plus facile.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[L'auto-complétion programmable en Bash - partie 11]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/02/21/lauto-completion-programmable-en-bash-partie-11/"/>
    <updated>2014-02-21T20:53:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/02/21/lauto-completion-programmable-en-bash-partie-11</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-3'>Niveau : <span>avancé</span></div></p>

<p>Cet article est la suite de:
<a href="/blog/2014/02/10/lauto-completion-programmable-en-bash-partie-10/">L’auto complétion programmable en bash: partie 10</a>.</p>

<h2 id="compltion-des-options-longues---suite">Complétion des options longues - suite</h2>

<p>Aujourd’hui on voit que <code>_get_comp_words_by_ref</code> peut être appellée
avec une option bien utile qui modifie <code>COMP_WORDBREAKS</code>.</p>

<!-- more -->

<p>La variable <code>COMP_WORDBREAKS</code> contient les caractères qui permettent
de splitter les mots pour la complétion. Voici son contenu:</p>

<pre><code>$  echo $COMP_WORDBREAKS 
"'&gt;&lt;=;|&amp;(:
</code></pre>

<p>On voit que <code>=</code> en fait partie, et c’est ce qui rendait un peu compliqué
le <a href="/blog/2014/02/10/lauto-completion-programmable-en-bash-partie-10/">code de la dernière fois</a>.
Grâce à l’option <code>-n</code> de la fonction <code>_get_comp_words_by_ref</code>, on va pouvoir
simplifier ça:</p>

<p>``` bash
_mytool_long_options()
{
    case $1 in
        –format)
            options=’dot documentation’
            ;;
    esac
    COMPREPLY=( $( compgen -W “$options” – “$2” ) )
}</p>

<p>_mytool()
{
    local cur prev command options
    COMPREPLY=( )
    _get_comp_words_by_ref -n = cur prev
    commands=’new compile test’</p>

<pre><code>if [[ $COMP_CWORD -eq 1 ]]; then
    COMPREPLY=( $( compgen -W "$commands" -- "$cur" ) )
elif [[ "$cur" == --*=* ]]; then
    _split_longopt
    _mytool_long_options "$prev" "$cur" 
elif [[ "$cur" == -* ]]; then
    command=${COMP_WORDS[1]}
    case $command in
        new)
            options='--without-test'
            ;;
        compile)
            options='--verbose'
            ;;
        test)
            options='--format='
            compopt -o nospace
            ;;
    esac
    COMPREPLY=( $( compgen -W "$options" -- "$cur" ) )
fi } complete -F _mytool mytool ```
</code></pre>

<p>Ce code fait la même chose que celui du <a href="/blog/2014/02/10/lauto-completion-programmable-en-bash-partie-10/">dernier article</a>,
mais est bien plus simple et lisible.</p>

<script id="fb33k8u">(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>

<p>À demain.</p>

<p></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[L'auto-complétion programmable en Bash - partie 10]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/02/10/lauto-completion-programmable-en-bash-partie-10/"/>
    <updated>2014-02-10T20:45:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/02/10/lauto-completion-programmable-en-bash-partie-10</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-3'>Niveau : <span>avancé</span></div></p>

<p>Cet article est la suite de:
<a href="/blog/2014/02/09/lauto-completion-programmable-en-bash-partie-9/">L’auto complétion programmable en bash: partie 9</a>.</p>

<h2 id="compltion-des-options-longues">Complétion des options longues</h2>

<p>Aujourd’hui j’ai envie de voir comment on pourrait utiliser
l’auto-complétion pour les options longues, du genre
<code>--format=documentation</code>.</p>

<!-- more -->

<p>L’option <code>--format=</code> peut prendre deux valeurs: <code>dot</code> ou <code>documentation</code>.
Je veux donc obtenir ceci:</p>

<pre><code>$ mytool test -[TAB]
$ mytool test --format=[TAB]
documentation  dot            
$ mytool test --format=do

$ mytool test --format=doc[TAB]
$ mytool test --format=documentation 
</code></pre>

<p>Voici une manière d’obtenir ça:</p>

<p>``` bash
_mytool_long_options()
{
    case $1 in
        –format)
            options=’dot documentation’
            ;;
    esac
    COMPREPLY=( $( compgen -W “$options” – “$2” ) )
}</p>

<p>_mytool()
{
    local cur prev command options
    COMPREPLY=( )
    _get_comp_words_by_ref cur prev
    commands=’new compile test’</p>

<pre><code>if [[ $COMP_CWORD -eq 1 ]]; then
    COMPREPLY=( $( compgen -W "$commands" -- "$cur" ) )
elif [[ "$prev" == = ]]; then
    _mytool_long_options "${COMP_WORDS[COMP_CWORD-2]}" "$cur"
elif [[ "$cur" == = ]]; then
    _mytool_long_options "$prev"
elif [[ "$cur" == -* ]]; then
    command=${COMP_WORDS[1]}
    case $command in
        new)
            options='--without-test'
            ;;
        compile)
            options='--verbose'
            ;;
        test)
            options='--format='
            compopt -o nospace
            ;;
    esac
    COMPREPLY=( $( compgen -W "$options" -- "$cur" ) )
fi } complete -F _mytool mytool
</code></pre>

<h1 id="vim-ftsh-ts4-sw4">vim: ft=sh ts=4 sw=4</h1>
<p>```</p>

<p>La fonction <code>_mytool_long_options</code> prend un paramètre obligatoire et
un second optionnel. Le premier est le mot <em>avant</em> le signe <code>=</code> et le
second est l’éventuel mot <em>après</em> le signe <code>=</code>:</p>

<p><code>bash
_mytool_long_options()
{
    case $1 in
        --format)
            options='dot documentation'
            ;;
    esac
    COMPREPLY=( $( compgen -W "$options" -- "$2" ) )
}
</code></p>

<p>J’ai ajouté deux <code>elif</code>, qui regarde si le mot sous le curseur (<code>$cur</code>)
ou le mot précédent (<code>$pre</code>) est le caractère <code>=</code>. Dans ce cas,
on appelle la fonction <code>_mytool_long_options</code> qui s’occupe de gérer
la complétion des options du style <code>--foo=bar</code>:</p>

<p><code>bash
    elif [[ "$prev" == = ]]; then
        _mytool_long_options "${COMP_WORDS[COMP_CWORD-2]}" "$cur"
    elif [[ "$cur" == = ]]; then
        _mytool_long_options "$prev"
</code></p>

<p>Même si cela fonctionne, je pense pouvoir trouver plus simple, et c’est
ce que j’espère faire dans un prochain article.</p>

<script id="fb33k8u">(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[L'auto-complétion programmable en Bash - partie 9]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/02/09/lauto-completion-programmable-en-bash-partie-9/"/>
    <updated>2014-02-09T18:55:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/02/09/lauto-completion-programmable-en-bash-partie-9</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-3'>Niveau : <span>avancé</span></div></p>

<p>Cet article est la suite de:
<a href="/blog/2014/02/08/lauto-completion-programmable-en-bash-partie-8/">L’auto complétion programmable en bash: partie 8</a>.</p>

<h2 id="une-compltion-amliore">Une complétion améliorée</h2>

<p>On voit aujourd’hui deux fonctions bien utiles lors de l’écriture
de votre script d’auto-complétion: <code>_get_comp_words_by_ref</code> et
<code>compopt</code>.</p>

<!-- more -->

<p>On va ajouter une option <code>--format=</code> à notre commande <code>test</code>. Ce que
je veux, c’est pouvoir écrire quelque chose comme ça:</p>

<pre><code>$ mytool test --format=documentation
</code></pre>

<p>Il faut donc que:</p>

<pre><code>$ mytool test -[TAB]
</code></pre>

<p>nous donne ceci:</p>

<pre><code>$ mytool test --format=
</code></pre>

<p>Mais contrairement à ce qu’il se passe jusqu’ici, je ne veux pas
que l’auto-complétion ajoute un espace après <code>--format=</code>.</p>

<p>Voici tout d’abord le script qui fait ça :</p>

<p>``` bash
_mytool()
{
    local cur prev command options
    COMPREPLY=( )
    _get_comp_words_by_ref cur prev
    commands=’new compile test’</p>

<pre><code>if [[ $COMP_CWORD -eq 1 ]]; then
    COMPREPLY=( $( compgen -W "$commands" -- "$cur" ) )
elif [[ "$cur" == -* ]]; then
    command=${COMP_WORDS[1]}
    case $command in
        new)
            options='--without-test'
            ;;
        compile)
            options='--verbose'
            ;;
        test)
            options='--format='
            compopt -o nospace
            ;;
    esac
    COMPREPLY=( $( compgen -W "$options" -- "$cur" ) )
fi } complete -F _mytool mytool ```
</code></pre>

<p>Et maintenant, je vais détailler les nouveautés. D’abord, vous avez
peut-être remarqué que la ligne:</p>

<p><code>bash
    _get_comp_words_by_ref cur prev
</code></p>

<p>a remplacé les deux lignes suivantes
(<a href="">voir article précédent</a>):</p>

<p><code>bash
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"
</code></p>

<p>C’est plus simple, plus lisible, plus propre. Cette fonction,
<code>_get_comp_words_by_ref</code>, se trouve dans le script <code>/etc/bash_completion</code>,
que je vous invite à étudier. Ce fichier défini plusieurs fonctions
utiles pour la complétion.</p>

<p>Voyons maintenant l’ajout de la nouvelle option:</p>

<p><code>bash
            test)
                options='--format='
                compopt -o nospace
                ;;
</code></p>

<p>La nouveauté est ici <code>compopt -o nospace</code>. La fonction <code>compopt</code> permet
d’allumer/éteindre certaines options pour la complétion en cours. Ici on
demande de ne pas ajouter d’espace à la fin de la chaîne renvoyée par
la complétion.</p>

<script id="fb33k8u">(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>

<p>À demain.</p>

<p></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[L'auto-complétion programmable en Bash - partie 8]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/02/08/lauto-completion-programmable-en-bash-partie-8/"/>
    <updated>2014-02-08T14:10:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/02/08/lauto-completion-programmable-en-bash-partie-8</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-3'>Niveau : <span>avancé</span></div></p>

<p>Cet article est la suite de:
<a href="/blog/2014/02/02/lauto-completion-programmable-en-bash-partie-7/">L’auto complétion programmable en bash: partie 7</a>.</p>

<h2 id="une-compltion-plus-toffe">Une complétion plus étoffée</h2>

<p>Après avoir étudié les variables <code>COMPREPLY</code>, <code>COMP_WORDS</code>, <code>COMP_CWORD</code>,
et le motif minimal, voici maintenant un programme plus utile.</p>

<!-- more -->

<p>Je veux que <code>mytool new</code> réponde à la seule option <code>--without-test</code>.
Donc:</p>

<pre><code>$ mytool new -[TAB]
</code></pre>

<p>doit donner:</p>

<pre><code>$ mytool new --without-test
</code></pre>

<p>Je veux aussi que <code>mytool commpile</code> réponde seulement à <code>--verbose</code>, donc:</p>

<pre><code>$ mytool compile -[TAB]
</code></pre>

<p>doit donner:</p>

<pre><code>$ mytool compile --verbose
</code></pre>

<p>Quant à <code>mytool test</code>, il ne prend aucune option.</p>

<p>Voici sans plus tarder un programme qui fait ça:</p>

<p>``` bash
_mytool()
{
    local cur prev command options
    COMPREPLY=( )
    cur=”${COMP_WORDS[COMP_CWORD]}”
    prev=”${COMP_WORDS[COMP_CWORD-1]}”
    commands=’new compile test’</p>

<pre><code>if [[ $COMP_CWORD -eq 1 ]] ; then
    COMPREPLY=( $( compgen -W "$commands" -- "$cur" ) )
else
    command=${COMP_WORDS[1]}
    if [[ "$cur" == -* ]]; then
        case $command in
            new)
                options='--without-test'
                ;;
            compile)
                options='--verbose'
                ;;
        esac
        COMPREPLY=( $( compgen -W "$options" -- "$cur" ) )
    fi
fi } complete -F _mytool mytool ```
</code></pre>

<p>Ok, Bash n’est pas le plus lisible des langages, mais si vous avez suivi
tous les articles précédent, vous êtes en mesure de suivre la logique
de ce programme. Voilà ce que donne l’algorithme:</p>

<pre><code>Si le curseur est en position 1
  Compléter avec les commandes
Sinon
  Trouver la commande courante
  Si le mot sous le curseur commence par '-'
    Compléter les options suivant la commande courante
</code></pre>

<p>Quelques points précis maintenant : on calcule le mot sous le curseur
dans <code>cur</code> et le mot précédent dans <code>prev</code>:</p>

<p><code>bash
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"
</code></p>

<p>On place toutes les commandes dans une variable <code>commands</code>,</p>

<p><code>bash
    commands='new compile test'
</code></p>

<p>ce qui permet de calculer les complétions possibles de la manière
suivante (plus lisible et flexible quand on a beaucoup de commandes):</p>

<p><code>bash
        COMPREPLY=( $( compgen -W "$commands" -- "$cur" ) )
</code></p>

<script id="fb33k8u">(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>

<p>À demain.</p>

<p></p>

]]></content>
  </entry>
  
</feed>
