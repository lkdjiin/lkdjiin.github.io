<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : awk | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/awk/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2013-12-06T21:30:47+01:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Remplacer Sed et Awk par Ruby 5: Accéder aux champs/colonnes]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/12/05/remplacer-sed-et-awk-par-ruby-5-acceder-aux-champs-slash-colonnes/"/>
    <updated>2013-12-05T19:12:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/12/05/remplacer-sed-et-awk-par-ruby-5-acceder-aux-champs-slash-colonnes</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Toujours dans l'optique de remplacer Sed et Awk par Ruby,
et après avoir vu <a href="http://lkdjiin.github.io/blog/2013/12/04/remplacer-sed-et-awk-par-ruby-4-les-options-p-et-l/">les options -p et -l</a>, on voit
comment accéder facilement aux différentes colonnes
d'un fichier.</p>

<!-- more -->


<p>Voici le fichier de données tout simple qui va nous servir aujourd'hui:</p>

<p><code>raw data.txt
1 a
2 a
3 b
4 a
5 a
6 b
7 b
8 b
9 b
</code></p>

<p>L'objectif est de calculer la somme des valeurs de la 1ère colonne,
uniquement quand la 2e colonne affiche <code>a</code>. On pourrait bien sûr splitter
la ligne (<code>$_</code>) pour obtenir nos champs, mais il y a plus rapide.
En activant l'option <code>-a</code> de la ligne de commande, Ruby va automatiquement
splitter chaque lignes du fichier de données dans la variable prédéfinie
<code>$F</code> (pour <em>Fields</em>). On n'a donc rien à faire ;) et on peut se concentrer
sur les calculs:</p>

<p>``` ruby test.rb
BEGIN { total = 0 }</p>

<p>total += $F[0].to_i if $F[1] == &ldquo;a&rdquo;</p>

<p>END { puts &ldquo;Total: #{total}&rdquo; }
```</p>

<pre><code>[~]⇒ ruby -an test.rb &lt; data.txt 
Total: 12
</code></pre>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Remplacer Sed et Awk par Ruby 4: Les options -p et -l]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/12/04/remplacer-sed-et-awk-par-ruby-4-les-options-p-et-l/"/>
    <updated>2013-12-04T21:21:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/12/04/remplacer-sed-et-awk-par-ruby-4-les-options-p-et-l</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Les options -p et -l de la ligne de commande de Ruby permettent de se
rapprocher encore un peu plus du comportement de Sed et Awk.  On reprend notre
fichier tout simple:</p>

<p><code>raw data.txt
1
2
3
4
5
6
7
8
9
</code></p>

<p>Aujourd'hui l'objectif est d'ajouter une nouvelle colonne, qui nous dit si
le nombre est pair (p) ou impair (i). C'est un exemple trivial, mais
suffisant pour ce que je veux montrer.</p>

<!-- more -->


<h2>Un premier script déjà concis</h2>

<p>Voici un premier code possible, avec ce que nous connaissons déjà, c'est
à dire l'option -n:</p>

<p><code>ruby test1.rb
$_ = $_.chomp + ($_.to_i.even? ? " p" : " i")
puts $_
</code></p>

<pre><code>[~]⇒ ruby -n test1.rb &lt; data.txt 
1 i
2 p
3 i
4 p
5 i
6 p
7 i
8 p
9 i
</code></pre>

<p>On peut noter que:</p>

<ul>
<li>contrairement à l'exemple précédent, on n'utilise pas les blocs BEGIN et
END (voir <a href="http://lkdjiin.github.io/blog/2013/11/30/remplacer-sed-et-awk-par-ruby-2-premiers-pas/">Premiers pas</a>
et <a href="http://lkdjiin.github.io/blog/2013/12/01/remplacer-sed-et-awk-par-ruby-3-begin-et-end/">BEGIN et END</a>).</li>
<li>la variable prédéfinie <code>$_</code> est <strong>accessible en écriture</strong>.</li>
<li>la variable prédéfinie <code>$_</code> contient le caractère de fin de ligne, il a
fallu le supprimer avec <code>chomp</code>. C'est agaçant.</li>
<li>on écrit chaque nouvelle ligne avec <code>puts</code>. C'est un pattern classique,
il doit bien y avoir un truc pour nous éviter cela.</li>
</ul>


<h2>La même chose en plus court</h2>

<p>Voici maintenant une réécriture du script ci-dessus, qui tire parti
des options -p et -l:</p>

<p><code>ruby test2.rb
$_ += $_.to_i.even? ? " p" : " i"
</code></p>

<pre><code>[~]⇒ ruby -pl test2.rb &lt; data.txt 
1 i
2 p
3 i
4 p
5 i
6 p
7 i
8 p
9 i
</code></pre>

<h2>Les explications de -p et -l</h2>

<p>L'option -p fonctionne comme l'option -n, mais en plus, affiche automatiquement
le contenu de la variable <code>$_</code> à la fin de la boucle de traitement.</p>

<p>L'option -l, quant à elle, s'occupe automatiquement du caractère de fin
de ligne en le supprimant.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Remplacer Sed et Awk par Ruby 3: BEGIN et END]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/12/01/remplacer-sed-et-awk-par-ruby-3-begin-et-end/"/>
    <updated>2013-12-01T21:23:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/12/01/remplacer-sed-et-awk-par-ruby-3-begin-et-end</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Les blocs BEGIN et END du langage Ruby paraissent étranges pour beaucoup
de personnes. Ils sont inutiles (et certainement néfastes) pour des
programmes dit <em>classiques</em>. Ils peuvent être utiles pour un script.
Il sont indispensables pour remplacer Sed et Awk et on va donc les
regarder plus en détail.</p>

<!-- more -->


<p>Un exemple simple vaut mieux qu'un long discours:</p>

<p><code>ruby test1.rb
BEGIN { puts "avant" }
END { puts "après" }
puts "au milieu"
</code></p>

<pre><code>[~]⇒ ruby test1.rb 
avant
au milieu
après
</code></pre>

<p><code>BEGIN</code> est donc l'endroit où on initialisera les variables et <code>END</code>
permettra de faire les calculs et l'affichage en fin de traitement.</p>

<p>Il faut savoir qu'on peut avoir plusieurs blocs
<code>BEGIN</code> et <code>END</code>. Les blocs <code>BEGIN</code> seront interprétés dans l'ordre
d'apparition, tandis que les blocs <code>END</code> seront interprétés dans l'ordre
inverse d'apparition:</p>

<p><code>ruby test2.rb
END { puts "end 1" }
END { puts "end 2" }
END { puts "end 3" }
BEGIN { puts "begin 1" }
BEGIN { puts "begin 2" }
BEGIN { puts "begin 3" }
</code></p>

<pre><code>[~]⇒ ruby test2.rb
begin 1
begin 2
begin 3
end 3
end 2
end 1
</code></pre>

<p>Enfin, pour être exhaustif, on ne peut pas remplacer les <code>{}</code> par <code>do</code>
et <code>end</code>, comme on pourrait s'y attendre:</p>

<p><code>ruby test3.rb
BEGIN do
  puts "avant"
end
</code></p>

<pre><code>[~]⇒ ruby test3.rb
test3.rb:1: syntax error, unexpected keyword_do, expecting '{'
test3.rb:3: syntax error, unexpected keyword_end, expecting end-of-input
</code></pre>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Remplacer Sed et Awk par Ruby 2: Premiers pas]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/11/30/remplacer-sed-et-awk-par-ruby-2-premiers-pas/"/>
    <updated>2013-11-30T16:29:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/11/30/remplacer-sed-et-awk-par-ruby-2-premiers-pas</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Vous avez décidé de <a href="http://lkdjiin.github.io/blog/2013/11/29/remplacer-sed-et-awk-par-ruby/">remplacer Sed et Awk par Ruby</a> ? C'est parti.
L'objectif de cet article sera de calculer et d'afficher la somme des
valeurs contenues dans un fichier.</p>

<p>Prenons le simple fichier de données (data.txt) suivant:</p>

<p><code>raw data.txt
1
2
3
4
5
6
7
8
9
</code></p>

<!-- more -->


<h2>Hello world!</h2>

<p>Le premier pas sera d'afficher chaque ligne du fichier de données. Voici le
script Ruby qui va faire ça:</p>

<p><code>ruby test1.rb
puts $_
</code></p>

<p>La variable <code>$_</code> est une variable prédéfinie qui contient la ligne en cours
de traitement. Dans <a href="http://lkdjiin.github.io/blog/2013/11/29/remplacer-sed-et-awk-par-ruby/">l'article précédent</a>, j'évoquai la boucle de traitement
implicite. Pour dire à Ruby d'utiliser cette boucle implicite, on doit
utiliser l'option <code>-n</code> sur la ligne de commande:</p>

<p><code>bash
[~]⇒ ruby -n test1.rb &lt; data.txt
1
2
3
4
5
6
7
8
9
</code></p>

<h2>BEGIN et END</h2>

<p>Pour calculer la somme des valeurs du fichier, il va falloir initialiser
une variable <em>avant</em> la boucle de traitement et l'afficher <em>après</em> la
boucle de traitement. Pour ça, Ruby reprend ce que fait Awk avec les
blocs <code>BEGIN {}</code> et <code>END {}</code>:</p>

<p>``` ruby one_shot.rb
BEGIN { total = 0 }</p>

<p>total += $_.to_i</p>

<p>END { puts total }
```</p>

<p>Le code placé dans un bloc <code>BEGIN</code> est executé avant tout autre code du
fichier. Celui placé dans un bloc <code>END</code> est executé après tout autre code
du fichier. Objectif atteint:</p>

<p><code>bash
[~]⇒ ruby -n one_shot.rb &lt; data.txt
45
</code></p>

<p>Il faut noter qu'on a réussi notre objectif sans avoir explicitement à ouvrir
le fichier et à lire chaque ligne.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Remplacer Sed et Awk par Ruby]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/11/29/remplacer-sed-et-awk-par-ruby/"/>
    <updated>2013-11-29T18:31:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/11/29/remplacer-sed-et-awk-par-ruby</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Sed et Awk sont deux petits langages spécialisés dans l'édition, le
traitement, l'analyse, le filtrage, etc, des fichiers texte.
Ce que peuvent faire ces deux langages, Ruby peut le faire.</p>

<!-- more -->


<p>Dans mon <a href="http://lkdjiin.github.io/blog/2013/11/28/vim-plier-folder-les-commentaires-de-style-unix/">article précédant</a>
j'ai écrit:</p>

<p><blockquote><p>le fichier <a href="https://github.com/ruby/ruby/blob/trunk/lib/csv.rb">https://github.com/ruby/ruby/blob/trunk/lib/csv.rb</a> de<br/>Ruby contient à ce jour 46% de lignes qui sont des commentaires.</p></blockquote></p>

<p>Je n'ai bien sûr pas compté chaque commentaire du fichier. J'ai écrit pour
cela un petit script Ruby.</p>

<p>Un algorithme standard pour ce type de tâche serait:</p>

<pre><code>ouvrir le fichier
initialiser des variables

pour chaque ligne du fichier
    mettre à jour des variables
fin

fermer le fichier
calculer le résultat
afficher le résultat
</code></pre>

<p>En fait, quand on traite/édite/analyse/filtre un fichier texte, un pattern
basique apparait:</p>

<pre><code>ouvrir le fichier
pour chaque ligne du fichier
    # faire un truc
fin
fermer le fichier
</code></pre>

<p>Avec Sed et Awk, l'ouverture du fichier, sa fermeture et la boucle de
traitement sont <em>implicites</em>. Autrement dit, on n'écrit jamais ce code.
On écrit seulement le code du traitement.</p>

<p>Ruby peut faire cela.</p>

<p>Une question se pose alors :
si Sed et Awk sont faits pour ça, pourquoi utiliser Ruby à la place ?
Il y a plusieurs raisons possibles:</p>

<ul>
<li>Vous ne connaissez ni Sed, ni Awk mais vous connaissez déjà Ruby,
même un peu. Pourquoi apprendre un nouveau langage ?</li>
<li>Vous pratiquez Sed et Awk et vous trouvez la syntaxe … comment dire …
ésotérique (surtout celle de Sed).</li>
<li>Utiliser Ruby permet d'avoir accès à toutes ses bibliothèques.</li>
</ul>


<p>Convaincu ? Dans ce cas surveillez ce blog, je vais rapidement écrire
quelques articles sur ce sujet.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
