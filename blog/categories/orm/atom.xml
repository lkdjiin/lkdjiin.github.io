<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : orm | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/orm/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2014-04-24T21:16:17+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ruby - Et si on écrivait un ORM ? - partie 7]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/04/24/ruby-et-si-on-ecrivait-un-orm-partie-7/"/>
    <updated>2014-04-24T21:01:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/04/24/ruby-et-si-on-ecrivait-un-orm-partie-7</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Seconde partie du refactoring de SORM, mon <em>toy ORM</em> qui me sert de
prétexte pour quelques articles ;)</p>

<!-- more -->


<p>Parce que j'espère que vous avez compris que je n'était pas sérieusement
en train d'écrire un nouvel ORM pour Ruby, hein ? C'est juste pour étudier
un peu ensemble comment ça fonctionne…</p>

<p>Bref, il est temps je pense d'utiliser quelques namespace. <code>SORM::Database</code>
pour gérer la connexion et <code>SORM::Base</code> comme modèle de base. Voici donc les
tests remaniés:</p>

<p>``` ruby sorm_spec.rb
require &lsquo;./sorm&rsquo;</p>

<p>describe SORM::Database do
  describe &lsquo;connection&rsquo; do</p>

<pre><code>it 'is not connected' do
  expect(SORM::Database.connected?).to be false
end

describe 'after connection' do
  it 'is connected' do
    SORM::Database.connect('test.db')
    expect(SORM::Database.connected?).to be true
  end
end
</code></pre>

<p>  end
end</p>

<p>describe SORM::Base do
  class Article &lt; SORM::Base ; end</p>

<p>  describe &lsquo;.sql&rsquo; do</p>

<pre><code>before do
  Article.sql("INSERT INTO article VALUES(1, 'Foo');")
  Article.sql("INSERT INTO article VALUES(2, 'Bar');")
end

after do
  Article.sql("DELETE FROM article;")
end

it 'returns the correct number of rows' do
  rows = Article.sql("SELECT * FROM article;")
  expect(rows.size).to eq 2
end

it 'returns correct values' do
  rows = Article.sql("SELECT * FROM article;")
  expect(rows[0][0]).to eq 1
  expect(rows[0][1]).to eq 'Foo'
  expect(rows[1][0]).to eq 2
  expect(rows[1][1]).to eq 'Bar'
end
</code></pre>

<p>  end</p>

<p>  describe &lsquo;object creation&rsquo; do</p>

<pre><code>after { Article.sql("DELETE FROM article;") }

it 'creates a record' do
  Article.save(id: 1, name: 'bépo')
  rows = Article.sql("SELECT * FROM article WHERE id = 1;")
  expect(rows[0][0]).to eq 1
  expect(rows[0][1]).to eq 'bépo'
end

it 'returns an object with correct class' do
  article = Article.save(id: 1, name: 'bépo')
  expect(article.class).to eq Article
end

it 'returns an object with correct attributes' do
  article = Article.save(id: 1, name: 'bépo')
  expect(article.id).to eq 1
  expect(article.name).to eq 'bépo'
end
</code></pre>

<p>  end
end
```</p>

<p>Et bien sûr la nouvelle implémentation qui va avec:</p>

<p>``` ruby sorm.rb
require &lsquo;sqlite3&rsquo;</p>

<p>module SORM</p>

<p>  class Database</p>

<pre><code>@@db = false

def self.connect(database_filename)
  @@db = SQLite3::Database.open(database_filename)
end

def self.connected?
  @@db ? true : false
end

def self.connection
  @@db
end
</code></pre>

<p>  end</p>

<p>  class Base</p>

<pre><code>def self.sql(raw_query)
  Database.connection.execute(raw_query)
end

def self.save(parameters)
  Recorder.new(Database.connection, self.to_s.downcase, parameters).save
  self.new(parameters)
end

def initialize(attributes)
  attributes.each do |name, value|
    instance_variable_set("@#{name}", value)
    singleton_class.class_eval{attr_reader name.to_sym}
  end
end
</code></pre>

<p>  end</p>

<p>  class Recorder</p>

<pre><code>def initialize(connection, table, parameters)
  @connection = connection
  @table = table
  @parameters = parameters
end

def save
  @connection.execute(query)
end

def query
  "INSERT INTO #@table (#{columns}) VALUES(#{values});"
end

def columns
  @parameters.keys.join(',')
end

def values
  @parameters.values.map do |item|
    item.class == String ? "'#{item}'" : item
  end.join(',')
end
</code></pre>

<p>  end
end
```</p>

<p>Voilà, ça fait pas mal de code sans explication :( mais j'ai peu de temps
aujourd'hui. La prochaine on fera… je sais pas… on verra bien ;)</p>

<p><em>To be continued</em></p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby - Et si on écrivait un ORM ? - partie 6]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/04/20/ruby-et-si-on-ecrivait-un-orm-partie-6/"/>
    <updated>2014-04-20T12:53:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/04/20/ruby-et-si-on-ecrivait-un-orm-partie-6</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Hier je m'étais arrêté sur cette implémentation de <code>SORM.save</code>:</p>

<p>``` ruby
  def self.save(parameters)</p>

<pre><code>table = self.to_s.downcase
columns = parameters.keys.join(',')
values = parameters.values.map do |item|
  item.class == String ? "'#{item}'" : item
end.join(',')
query = "INSERT INTO #{table} (#{columns}) VALUES(#{values});"
@@db.execute(query)
</code></pre>

<p>  end
```</p>

<p>Cette méthode est déja bien trop longue selon mes critères, et si on ne fait
pas quelque chose tout de suite on va vite se retrouver avec un tas de
méthodes de classe impossibles à remanier.</p>

<!-- more -->


<p>Une première partie du refactoring va consister à extraire une classe que
je vais nommer <code>Recorder</code>:</p>

<p>``` ruby
  def self.save(parameters)</p>

<pre><code>recorder = Recorder.new(@@db, self.to_s.downcase, parameters)
recorder.save
</code></pre>

<p>  end</p>

<p>  class Recorder</p>

<pre><code>def initialize(connection, table, parameters)
  @connection = connection
  @table = table
  @parameters = parameters
end

def save
  @connection.execute(query)
end

def query
  "INSERT INTO #@table (#{columns}) VALUES(#{values});"
end

def columns
  @parameters.keys.join(',')
end

def values
  @parameters.values.map do |item|
    item.class == String ? "'#{item}'" : item
  end.join(',')
end
</code></pre>

<p>  end
```</p>

<p>Ça permet d'avoir des méthodes simples, faciles à comprendre.</p>

<p>Une seconde partie du refactoring consistera à <em>namespacer</em> correctement
les différentes parties de SORM. Pour ça il faudra aussi modifier les tests.</p>

<p><em>To be continued</em></p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby - Et si on écrivait un ORM ? - partie 5]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/04/19/ruby-et-si-on-ecrivait-un-orm-partie-5/"/>
    <updated>2014-04-19T21:14:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/04/19/ruby-et-si-on-ecrivait-un-orm-partie-5</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Au menu d'aujourd'hui: réparation du test défecteux et début de la
création/insertion d'un objet.</p>

<!-- more -->


<p>Tout d'abord on répare le test d'hier. Je sors les appels à <code>INSERT</code> dans
un bloc <code>before</code> et j'ajoute ce qui manquait cruellement, un appel à
<code>DELETE</code> dans un bloc <code>after</code>:</p>

<p>``` ruby
  describe &lsquo;.sql&rsquo; do</p>

<pre><code>before do
  Article.sql("INSERT INTO article VALUES(1, 'Foo');")
  Article.sql("INSERT INTO article VALUES(2, 'Bar');")
end

after do
  Article.sql("DELETE FROM article;")
end

it 'returns the correct number of rows' do
  rows = Article.sql("SELECT * FROM article;")
  expect(rows.size).to eq 2
end

it 'returns correct values' do
  rows = Article.sql("SELECT * FROM article;")
  expect(rows[0][0]).to eq 1
  expect(rows[0][1]).to eq 'Foo'
  expect(rows[1][0]).to eq 2
  expect(rows[1][1]).to eq 'Bar'
end
</code></pre>

<p>  end
```</p>

<p>Voilà, maintenant on peut passer à la partie création. J'ai envie que SORM
ait une méthode <code>save</code>, qui enregistrera les données en base et
renverra un objet. On commence avec un test pour l'enregistrement:</p>

<p>``` ruby sorm_spec.rb
require &lsquo;./sorm&rsquo;</p>

<p>describe SORM do
  describe &lsquo;connection&rsquo; do</p>

<pre><code># ...
</code></pre>

<p>  end</p>

<p>  class Article &lt; SORM
  end</p>

<p>  describe &lsquo;.sql&rsquo; do</p>

<pre><code># ...
</code></pre>

<p>  end</p>

<p>  describe &lsquo;object creation&rsquo; do</p>

<pre><code>after { Article.sql("DELETE FROM article;") }

it 'creates a record' do
  Article.save(id: 1, name: 'bépo')
  rows = Article.sql("SELECT * FROM article WHERE id = 1;")
  expect(rows[0][0]).to eq 1
  expect(rows[0][1]).to eq 'bépo'
end
</code></pre>

<p>  end
end
```</p>

<p>J'écris un premier jet de la méthode <code>save</code>, pour faire passer le test:</p>

<p>``` ruby sorm.rb
require &lsquo;sqlite3&rsquo;</p>

<p>class SORM</p>

<p>  @@db = false</p>

<p>  def self.connect(database_filename)</p>

<pre><code>@@db = SQLite3::Database.open(database_filename)
</code></pre>

<p>  end</p>

<p>  def self.connected?</p>

<pre><code>@@db ? true : false
</code></pre>

<p>  end</p>

<p>  def self.sql(raw_query)</p>

<pre><code>@@db.execute(raw_query)
</code></pre>

<p>  end</p>

<p>  def self.save(parameters)</p>

<pre><code>table = self.to_s.downcase
columns = parameters.keys.join(',')
values = parameters.values.map do |item|
  item.class == String ? "'#{item}'" : item
end.join(',')
query = "INSERT INTO #{table} (#{columns}) VALUES(#{values});"
@@db.execute(query)
</code></pre>

<p>  end
end
```</p>

<p>Ça fonctionne, mais la méthode est moche. Ce sera l'occasion de faire du
refactoring dans un prochain article.</p>

<p><em>To be continued</em></p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby - Et si on écrivait un ORM ? - partie 4]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/04/18/ruby-et-si-on-ecrivait-un-orm-partie-4/"/>
    <updated>2014-04-18T21:01:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/04/18/ruby-et-si-on-ecrivait-un-orm-partie-4</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Maintenant qu'on peut se connecter à une base sqlite, je pense qu'il faut
qu'on puisse écrire des requêtes en pur SQL à partir d'un objet qui
hérite de SORM.</p>

<!-- more -->


<p>Voilà donc mon nouveau test:</p>

<p>``` ruby sorm_spec.rb
require &lsquo;./sorm&rsquo;</p>

<p>describe SORM do
  describe &lsquo;connection&rsquo; do</p>

<pre><code># ...

describe 'after connection' do
  # ...
end
</code></pre>

<p>  end</p>

<p>  class Article &lt; SORM
  end</p>

<p>  describe &lsquo;.sql&rsquo; do</p>

<pre><code>it 'executes raw sql query on a table' do
  Article.sql("INSERT INTO article VALUES(1, 'Foo');")
  Article.sql("INSERT INTO article VALUES(2, 'Bar');")
  rows = Article.sql("SELECT * FROM article;")
  expect(rows.size).to eq 2
end
</code></pre>

<p>  end
end
```</p>

<p>Je veux enregistrer deux lignes en base et les récupérer. Si on lance les
tests, Rspec se plaint que la méthode <code>sql</code> n'existe pas. Jusqu'ici tout
va bien:</p>

<pre><code>$ rspec sorm_spec.rb 
..F

Failures:

  1) SORM.sql executes raw sql query on a table
     Failure/Error: Article.sql("INSERT INTO article VALUES(1, 'Foo');")
     NoMethodError:
       undefined method `sql' for Article:Class
</code></pre>

<p>Pour faire passer ce test, le code est simple, on ajoute la méthode <code>sql</code>:</p>

<p>``` ruby sorm.rb
require &lsquo;sqlite3&rsquo;</p>

<p>class SORM</p>

<p>  @@db = false</p>

<p>  def self.connect(database_filename)</p>

<pre><code>@@db = SQLite3::Database.open(database_filename)
</code></pre>

<p>  end</p>

<p>  def self.connected?</p>

<pre><code>@@db ? true : false
</code></pre>

<p>  end</p>

<p>  def self.sql(raw_query)</p>

<pre><code>@@db.execute(raw_query)
</code></pre>

<p>  end
end
```</p>

<p>Et hop:</p>

<pre><code>$ rspec sorm_spec.rb 
...

Finished in 0.01381 seconds
3 examples, 0 failures
</code></pre>

<p>Comme je suis curieux, j'ai envie de voir à quoi ressemble le contenu de
<code>rows</code> dans le test:</p>

<p>``` ruby
  describe &lsquo;.sql&rsquo; do</p>

<pre><code>it 'executes raw sql query on a table' do
  Article.sql("INSERT INTO article VALUES(1, 'Foo');")
  Article.sql("INSERT INTO article VALUES(2, 'Bar');")
  rows = Article.sql("SELECT * FROM article;")
  p rows
  expect(rows.size).to eq 2
end
</code></pre>

<p>  end
```</p>

<p>Et là, une petite surprise m'attend au tournant:</p>

<pre><code>$ rspec sorm_spec.rb 
..[[1, "Foo"], [2, "Bar"], [1, "Foo"], [2, "Bar"]]
F

Failures:

  1) SORM.sql executes raw sql query on a table
     Failure/Error: expect(rows.size).to eq 2

       expected: 2
            got: 4

       (compared using ==)
     # ./sorm_spec.rb:26:in `block (3 levels) in &lt;top (required)&gt;'
</code></pre>

<p>Tout d'abord, j'ai oublié de vider la table après le test qui fait des
insertions. Et ensuite j'ai négligé de spécifier <code>id</code> comme clé primaire !
Bref, j'ai encore du boulot pour que SORM fonctionne ;)</p>

<p><em>To be continued</em></p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby - Et si on écrivait un ORM ? - partie 3]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/04/16/ruby-et-si-on-ecrivait-un-orm-partie-3/"/>
    <updated>2014-04-16T21:23:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/04/16/ruby-et-si-on-ecrivait-un-orm-partie-3</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Cette fois je me dis qu'il faudrait quand même se connecter à la base de
données avant d'aller plus loin…</p>

<!-- more -->


<p>Alors au départ, la connexion est inexistante:</p>

<p>``` ruby sorm_spec.rb
require &lsquo;./sorm&rsquo;</p>

<p>describe SORM do
  describe &lsquo;connection&rsquo; do</p>

<pre><code>it 'is not connected' do
  expect(SORM.connected?).to be false
end
</code></pre>

<p>  end
end
```</p>

<p>On fait passer ce test très facilement:</p>

<p>``` ruby sorm.rb
require &lsquo;sqlite3&rsquo;</p>

<p>class SORM
  def self.connected?</p>

<pre><code>false
</code></pre>

<p>  end
end
```</p>

<p>Maintenant on cherche à se connecter à une base de données existante
(n'oubliez pas de la créer):</p>

<p>``` ruby sorm_spec.rb
require &lsquo;./sorm&rsquo;</p>

<p>describe SORM do
  describe &lsquo;connection&rsquo; do</p>

<pre><code>it 'is not connected' do
  expect(SORM.connected?).to be false
end

describe 'after connection' do
  it 'is connected' do
    SORM.connect('test.db')
    expect(SORM.connected?).to be true
  end
end
</code></pre>

<p>  end
end
```</p>

<p>Pour implémenter cette fonctionnalité, ce à quoi je pense de plus rapide
et de plus simple est une variable de classe. Même si on a parfois des
scrupules à utiliser les variables de classe parce qu'elles sont partagées
aussi par les sous-classes, je me dis que c'est bien le comportement que
je voudrais obtenir. Donc voici le code qui fait passer notre test:</p>

<p>``` ruby sorm.rb
require &lsquo;sqlite3&rsquo;</p>

<p>class SORM</p>

<p>  @@db = false</p>

<p>  def self.connect(database_filename)</p>

<pre><code>@@db = SQLite3::Database.open(database_filename)
</code></pre>

<p>  end</p>

<p>  def self.connected?</p>

<pre><code>@@db ? true : false
</code></pre>

<p>  end
end
```</p>

<p><em>To be continued</em></p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
