<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : orm | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/orm/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2014-04-16T21:45:36+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ruby - Et si on écrivait un ORM ? - partie 3]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/04/16/ruby-et-si-on-ecrivait-un-orm-partie-3/"/>
    <updated>2014-04-16T21:23:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/04/16/ruby-et-si-on-ecrivait-un-orm-partie-3</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Cette fois je me dis qu'il faudrait quand même se connecter à la base de
données avant d'aller plus loin…</p>

<!-- more -->


<p>Alors au départ, la connexion est inexistante:</p>

<p>``` ruby sorm_spec.rb
require &lsquo;./sorm&rsquo;</p>

<p>describe SORM do
  describe &lsquo;connection&rsquo; do</p>

<pre><code>it 'is not connected' do
  expect(SORM.connected?).to be false
end
</code></pre>

<p>  end
end
```</p>

<p>On fait passer ce test très facilement:</p>

<p>``` ruby sorm.rb
require &lsquo;sqlite3&rsquo;</p>

<p>class SORM
  def self.connected?</p>

<pre><code>false
</code></pre>

<p>  end
end
```</p>

<p>Maintenant on cherche à se connecter à une base de données existante
(n'oubliez pas de la créer):</p>

<p>``` ruby sorm_spec.rb
require &lsquo;./sorm&rsquo;</p>

<p>describe SORM do
  describe &lsquo;connection&rsquo; do</p>

<pre><code>it 'is not connected' do
  expect(SORM.connected?).to be false
end

describe 'after connection' do
  it 'is connected' do
    SORM.connect('test.db')
    expect(SORM.connected?).to be true
  end
end
</code></pre>

<p>  end
end
```</p>

<p>Pour implémenter cette fonctionnalité, ce à quoi je pense de plus rapide
et de plus simple est une variable de classe. Même si on a parfois des
scrupules à utiliser les variables de classe parce qu'elles sont partagées
aussi par les sous-classes, je me dis que c'est bien le comportement que
je voudrais obtenir. Donc voici le code qui fait passer notre test:</p>

<p>``` ruby sorm.rb
require &lsquo;sqlite3&rsquo;</p>

<p>class SORM</p>

<p>  @@db = false</p>

<p>  def self.connect(database_filename)</p>

<pre><code>@@db = SQLite3::Database.open(database_filename)
</code></pre>

<p>  end</p>

<p>  def self.connected?</p>

<pre><code>@@db ? true : false
</code></pre>

<p>  end
end
```</p>

<p><em>To be continued</em></p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby - Et si on écrivait un ORM ? - partie 2]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/04/14/ruby-et-si-on-ecrivait-un-orm-partie-2/"/>
    <updated>2014-04-14T21:08:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/04/14/ruby-et-si-on-ecrivait-un-orm-partie-2</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Après avoir installé sqlite et la gem sqlite3-ruby, on installe maintenant
rspec et on fait passer un premier test pour notre futur <em>Simple ORM</em>.</p>

<!-- more -->


<p>Pour écrire SORM, on va faire du <em>Test Driven Development</em>, parce que j'ai
envie d'encourager les bonnes pratiques ;) Pour les tests j'utiliserai
Rspec, puisque c'est le framework que je connais le mieux:</p>

<pre><code>gem install rspec
</code></pre>

<p>On écrit un premier test:</p>

<p>``` ruby sorm_spec.rb
require &lsquo;./sorm&rsquo;</p>

<p>describe SORM do</p>

<p>  class Article &lt; SORM
  end</p>

<p>  describe &lsquo;.find_by_*&rsquo; do</p>

<pre><code>it 'returns an array' do
  article = Article.find_by_whatever('foobar')
  expect(article.class).to eq Array
end
</code></pre>

<p>  end
end
```</p>

<p>Alors c'est un test un peu <em>foireux</em>, ok. J'avoue que je n'ai pas réfléchi
une seconde au design de SORM. Je me dis qu'on s'adaptera au fur et à mesure.
Ici je teste qu'une méthode <code>.find_by_whatever</code> renvoie un tableau, c'est
tout. C'est histoire de se mettre en marche. Lancement du test:</p>

<pre><code>$ rspec sorm_spec.rb 
sorm_spec.rb:3:in `&lt;top (required)&gt;': uninitialized constant SORM (NameError)
</code></pre>

<p>Et c'est partie pour l'écriture de notre classe <code>SORM</code>:</p>

<p>``` ruby sorm.rb
class SORM</p>

<p>end
```</p>

<p>Je relance le test:</p>

<pre><code>$ rspec sorm_spec.rb 
F

Failures:

  1) SORM.find_by_* returns an array
     Failure/Error: article = Article.find_by_whatever('foobar')
     NoMethodError:
       undefined method `find_by_whatever' for Article:Class
     # ./sorm_spec.rb:10:in `block (3 levels) in &lt;top (required)&gt;'

Finished in 0.0009 seconds
1 example, 1 failure

Failed examples:

rspec ./sorm_spec.rb:9 # SORM.find_by_* returns an array
</code></pre>

<p>La méthode <code>find_by_whatever</code> est bien sûr inconnue. Comme je veux gérer
les méthodes <code>find_by_*</code> avec <code>method_missing</code> j'écris:</p>

<p>``` ruby sorm.rb
class SORM</p>

<p>  def self.method_missing(method, *args)</p>

<pre><code>[]
</code></pre>

<p>  end</p>

<p>end
```</p>

<p>Et maintenant on est sur la voie:</p>

<pre><code>$ rspec sorm_spec.rb 
.

Finished in 0.01664 seconds
1 example, 0 failures
</code></pre>

<p>On a pas avancé beaucoup, mais on a quand même mis en place le TDD et notre
classe <code>SORM</code>.</p>

<p><em>To be continued</em></p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby - Et si on écrivait un ORM ? - partie 1]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/04/13/ruby-et-si-on-ecrivait-un-orm-partie-1/"/>
    <updated>2014-04-13T21:29:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/04/13/ruby-et-si-on-ecrivait-un-orm-partie-1</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Les derniers articles sur la méta programmation m'ont donnés envie d'écrire
un <a href="http://fr.wikipedia.org/wiki/Mapping_objet-relationnel">ORM</a>.
Un truc simple, basé sur la base de données <a href="https://www.sqlite.org/sqlite.html">Sqlite</a>.
D'ailleurs on va l'appeller SORM, pour <em>Simple Object Relational Mapping</em> ;)</p>

<!-- more -->


<p>Dans ce premier article, on va prendre contact avec Sqlite. Une fois ce dernier
installé sur votre machine, le client console est <code>sqlite3</code>.
Pour créer une nouvelle base de données, <code>test1.db</code>, il suffit de:</p>

<pre><code>$ sqlite3 test1.db
Enter SQL statements terminated with a ";"
</code></pre>

<p>Pour créer une table article:</p>

<pre><code>sqlite&gt; create table article(id int, name varchar(100));
</code></pre>

<p>Pour enregistrer quelques articles:</p>

<pre><code>sqlite&gt; insert into article values(1, 'foo');
sqlite&gt; insert into article values(2, 'bar');
sqlite&gt; insert into article values(3, 'baz');
</code></pre>

<p>Pour faire une requête:</p>

<pre><code>sqlite&gt; select * from article;
1|foo
2|bar
3|baz
</code></pre>

<p>Enfin pour sortir du programme, tapez Control+D.</p>

<p>Passons maintenant à la partie Ruby. J'avais pensé dans un premier temps à
écrire le driver pour communiquer avec Sqlite, mais ça nous entrainerait trop
loin. On va donc utiliser la gem <a href="https://github.com/sparklemotion/sqlite3-ruby">sqlite3-ruby</a>:</p>

<pre><code>gem install sqlite3
</code></pre>

<p>L'utilisation est fort simple:</p>

<p>``` irb
$ irb</p>

<blockquote><blockquote><p>require &lsquo;sqlite3&rsquo;
db = SQLite3::Database.open &ldquo;test1.db&rdquo;
db.execute &lsquo;select * from article;&rsquo;
[[1, &ldquo;foo&rdquo;], [2, &ldquo;bar&rdquo;], [3, &ldquo;baz&rdquo;]]
```</p></blockquote></blockquote>

<p><em>To be continued</em></p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
