<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : ncurses | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/ncurses/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2014-03-03T21:18:02+01:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Écrire un éditeur pour le terminal - partie 6]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/03/03/ecrire-un-editeur-pour-le-terminal-partie-6/"/>
    <updated>2014-03-03T21:10:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/03/03/ecrire-un-editeur-pour-le-terminal-partie-6</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Après avoir vu
<a href="/blog/2014/03/01/ecrire-un-editeur-pour-le-terminal-partie-4/">comment centrer du texte</a>
et
<a href="/blog/2014/03/02/ecrire-un-editeur-pour-le-terminal-partie-5/">comment faire du fenêtrage</a>,
on peut réunir les deux pour afficher un fichier, et le nom de ce fichier
centré sur la première ligne du terminal.</p>

<!-- more -->


<p>``` ruby test.rb</p>

<h1>!/usr/bin/env ruby</h1>

<p>require &lsquo;curses&rsquo;
include Curses</p>

<p>def display_filename
  setpos(0, (cols &ndash; ARGV[0].size) / 2)
  addstr(ARGV[0])
end</p>

<p>def display_file
  setpos(2, 0)
  File.open(ARGV[0]).each {|line| addstr(line) }
end</p>

<p>begin
  init_screen
  display_filename
  display_file
  refresh
  getch
ensure
  close_screen
end
```</p>

<p>Et voilà.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Écrire un éditeur pour le terminal - partie 5]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/03/02/ecrire-un-editeur-pour-le-terminal-partie-5/"/>
    <updated>2014-03-02T20:54:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/03/02/ecrire-un-editeur-pour-le-terminal-partie-5</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>La bibliothèque <em>curses</em> sait gérer le fenêtrage. Voici un programme qui
montre comment faire.</p>

<!-- more -->


<p>C'est une traduction en ruby d'un programme C issu d'un tutoriel
sur <em>ncurses</em> (dont je ne retrouve plus la référence dans l'immédiat).</p>

<p>``` ruby
require &lsquo;curses&rsquo;
include Curses</p>

<p>def create_newwin(height, width, top, left)
  local_win = Window.new(height, width, top, left)
  local_win.box(?|, ?&ndash;)
  local_win.refresh
  local_win
end</p>

<p>def destroy_win(w)
  w.clear
  w.refresh
  w.close
end</p>

<p>begin
  init_screen
  cbreak
  stdscr.keypad(true)
  height = 3
  width = 10
  top = (lines &ndash; height) / 2
  left = (cols &ndash; width) / 2
  addstr(&ldquo;Press F1 to exit&rdquo;)
  refresh
  my_win = create_newwin(height, width, top, left)</p>

<p>  while (ch = getch) != KEY_F1</p>

<pre><code>case ch
when KEY_LEFT then left -= 1
when KEY_RIGHT then left += 1
when KEY_UP then top -= 1
when KEY_DOWN then top += 1
end
destroy_win(my_win)
my_win = create_newwin(height, width, top, left)
</code></pre>

<p>  end
ensure
  close_screen
end
```</p>

<p>En étudiant ce programme avec en parallèle la documentation ruby
de <a href="http://ruby-doc.org/stdlib-2.1.0/libdoc/curses/rdoc/Curses.html">curses</a>,
vous devriez comprendre sans problèmes la gestion des fenêtres.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Écrire un éditeur pour le terminal - partie 4]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/03/01/ecrire-un-editeur-pour-le-terminal-partie-4/"/>
    <updated>2014-03-01T17:47:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/03/01/ecrire-un-editeur-pour-le-terminal-partie-4</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Aujourd'hui on voit comment écrire un message centré horizontalement et
verticalement, comment lire une chaîne de caractères, et comment être
tranquille avec les caractères non ASCII.</p>

<!-- more -->


<p>Voici un programme qui montre tout ça:</p>

<p>``` ruby
require &lsquo;curses&rsquo;
include Curses</p>

<p>message = &ldquo;Enter a string: &rdquo;</p>

<p>begin
  init_screen
  setpos(lines / 2, (cols &ndash; message.size) / 2)
  addstr(message)
  str = getstr
  setpos(lines &ndash; 2, 0)
  addstr(sprintf(&ldquo;You entered: %s&rdquo;, str))
  getch
ensure
  close_screen
end
```</p>

<p>Quelques brèves explications maintenant:</p>

<p>Tout d'abord, on affiche un message centré ainsi:</p>

<p><code>ruby
  setpos(lines / 2, (cols - message.size) / 2)
  addstr(message)
</code></p>

<p>Pour lire une chaîne de caractères, on utilise <code>getstr</code>:</p>

<p><code>ruby
  str = getstr
</code></p>

<p>Puis on affiche ce qu'on vient de lire sur l'avant-dernière ligne du
terminal:</p>

<p><code>ruby
  setpos(lines - 2, 0)
  addstr(sprintf("You entered: %s", str))
</code></p>

<p>Le <a href="http://www.ruby-doc.org/core-2.1.1/Kernel.html#method-i-sprintf">sprintf</a>,
qui vous rappelera des choses si vous avez fait du C, est ce que j'ai
trouvé de mieux pour ne pas avoir de soucis avec les caractères
non ASCII.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Écrire un éditeur pour le terminal - partie 3]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/02/24/ecrire-un-editeur-pour-le-terminal-partie-3/"/>
    <updated>2014-02-24T20:59:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/02/24/ecrire-un-editeur-pour-le-terminal-partie-3</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Comment connaitre le nombre de lignes et de colonnes du terminal ?
Voici la réponse…</p>

<!-- more -->


<p>Le programme suivant utilise les méthodes <code>cols</code> et <code>lines</code> de la
bibliothèque <code>Curses</code> pour avoir ces informations:</p>

<p>``` ruby
require &lsquo;curses&rsquo;
include Curses</p>

<p>begin
  init_screen
  addstr(&ldquo;#{cols} x #{lines}&rdquo;)
  getch
ensure
  close_screen
end
```</p>

<p>Redimensionnez votre terminal et relancez le programme pour être sûr
que ça fonctionne ;)</p>

<p>Ces informations nous seront bien utiles pour l'écriture d'un éditeur…</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Écrire un éditeur pour le terminal - partie 2]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/02/23/ecrire-un-editeur-pour-le-terminal-partie-2/"/>
    <updated>2014-02-23T16:33:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/02/23/ecrire-un-editeur-pour-le-terminal-partie-2</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Comme j'ai eu un peu trop de problêmes à faire tourner <em>ncurses</em> sur
plusieurs machines, j'ai décidé de repasser à <em>curses</em>.</p>

<!-- more -->


<p>Voici donc le programme de <a href="/blog/2014/02/22/ecrire-un-editeur-pour-le-terminal-partie-1/">la dernière fois</a>, réécrit pour <em>curses</em>:</p>

<p>``` ruby redvim.rb</p>

<h1>!/usr/bin/env ruby</h1>

<p>require &lsquo;curses&rsquo;
include Curses</p>

<p>file = File.open ARGV[0]</p>

<p>begin
  init_screen
  file.each {|line| addstr(line) }
  refresh
  getch
ensure
  close_screen
end
```</p>

<h2>Un problème avec Unicode ?</h2>

<p>Il se peut que vous ayez des problèmes pour afficher correctement les
caractères unicode. À tous les coups, c'est parce que la gem <em>curses</em>
à été compilée sans les headers indispensables.
Installez donc ces headers: libncurses5.dev et libncurses5w.dev, ensuite
vous avez deux solutions:</p>

<ol>
<li>Si vous utilisez Ruby 2.1, désinstallez <em>curses</em> et réinstallez la:
<code>gem uninstall curses &amp;&amp; gem install curses</code>.</li>
<li>Si vous utilisez Ruby 2.0 ou inférieur, <em>curses</em> fait partie de la
bibliothèque standard, c'est donc Ruby qu'il faudra recompiler.</li>
</ol>


<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
