<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : ncurses | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/ncurses/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2014-03-01T18:00:04+01:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Écrire un éditeur pour le terminal - partie 4]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/03/01/ecrire-un-editeur-pour-le-terminal-partie-4/"/>
    <updated>2014-03-01T17:47:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/03/01/ecrire-un-editeur-pour-le-terminal-partie-4</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Aujourd'hui on voit comment écrire un message centré horizontalement et
verticalement, comment lire une chaîne de caractères, et comment être
tranquille avec les caractères non ASCII.</p>

<!-- more -->


<p>Voici un programme qui montre tout ça:</p>

<p>``` ruby
require &lsquo;curses&rsquo;
include Curses</p>

<p>message = &ldquo;Enter a string: &rdquo;</p>

<p>begin
  init_screen
  setpos(lines / 2, (cols &ndash; message.size) / 2)
  addstr(message)
  str = getstr
  setpos(lines &ndash; 2, 0)
  addstr(sprintf(&ldquo;You entered: %s&rdquo;, str))
  getch
ensure
  close_screen
end
```</p>

<p>Quelques brèves explications maintenant:</p>

<p>Tout d'abord, on affiche un message centré ainsi:</p>

<p><code>ruby
  setpos(lines / 2, (cols - message.size) / 2)
  addstr(message)
</code></p>

<p>Pour lire une chaîne de caractères, on utilise <code>getstr</code>:</p>

<p><code>ruby
  str = getstr
</code></p>

<p>Puis on affiche ce qu'on vient de lire sur l'avant-dernière ligne du
terminal:</p>

<p><code>ruby
  setpos(lines - 2, 0)
  addstr(sprintf("You entered: %s", str))
</code></p>

<p>Le <a href="http://www.ruby-doc.org/core-2.1.1/Kernel.html#method-i-sprintf">sprintf</a>,
qui vous rappelera des choses si vous avez fait du C, est ce que j'ai
trouvé de mieux pour ne pas avoir de soucis avec les caractères
non ASCII.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Écrire un éditeur pour le terminal - partie 3]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/02/24/ecrire-un-editeur-pour-le-terminal-partie-3/"/>
    <updated>2014-02-24T20:59:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/02/24/ecrire-un-editeur-pour-le-terminal-partie-3</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Comment connaitre le nombre de lignes et de colonnes du terminal ?
Voici la réponse…</p>

<!-- more -->


<p>Le programme suivant utilise les méthodes <code>cols</code> et <code>lines</code> de la
bibliothèque <code>Curses</code> pour avoir ces informations:</p>

<p>``` ruby
require &lsquo;curses&rsquo;
include Curses</p>

<p>begin
  init_screen
  addstr(&ldquo;#{cols} x #{lines}&rdquo;)
  getch
ensure
  close_screen
end
```</p>

<p>Redimensionnez votre terminal et relancez le programme pour être sûr
que ça fonctionne ;)</p>

<p>Ces informations nous seront bien utiles pour l'écriture d'un éditeur…</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Écrire un éditeur pour le terminal - partie 2]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/02/23/ecrire-un-editeur-pour-le-terminal-partie-2/"/>
    <updated>2014-02-23T16:33:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/02/23/ecrire-un-editeur-pour-le-terminal-partie-2</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Comme j'ai eu un peu trop de problêmes à faire tourner <em>ncurses</em> sur
plusieurs machines, j'ai décidé de repasser à <em>curses</em>.</p>

<!-- more -->


<p>Voici donc le programme de <a href="/blog/2014/02/22/ecrire-un-editeur-pour-le-terminal-partie-1/">la dernière fois</a>, réécrit pour <em>curses</em>:</p>

<p>``` ruby redvim.rb</p>

<h1>!/usr/bin/env ruby</h1>

<p>require &lsquo;curses&rsquo;
include Curses</p>

<p>file = File.open ARGV[0]</p>

<p>begin
  init_screen
  file.each {|line| addstr(line) }
  refresh
  getch
ensure
  close_screen
end
```</p>

<h2>Un problème avec Unicode ?</h2>

<p>Il se peut que vous ayez des problèmes pour afficher correctement les
caractères unicode. À tous les coups, c'est parce que la gem <em>curses</em>
à été compilée sans les headers indispensables.
Installez donc ces headers: libncurses5.dev et libncurses5w.dev, ensuite
vous avez deux solutions:</p>

<ol>
<li>Si vous utilisez Ruby 2.1, désinstallez <em>curses</em> et réinstallez la:
<code>gem uninstall curses &amp;&amp; gem install curses</code>.</li>
<li>Si vous utilisez Ruby 2.0 ou inférieur, <em>curses</em> fait partie de la
bibliothèque standard, c'est donc Ruby qu'il faudra recompiler.</li>
</ol>


<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Écrire un éditeur pour le terminal - partie 1]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/02/22/ecrire-un-editeur-pour-le-terminal-partie-1/"/>
    <updated>2014-02-22T15:14:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/02/22/ecrire-un-editeur-pour-le-terminal-partie-1</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Après avoir parler quelque peu de ncurses, on passe à la première étape
de l'écriture d'un éditeur qui ressemblerait à Vim: afficher le contenu
d'un fichier.</p>

<!-- more -->


<p>Le progamme est très proche de ce qu'on avait obtenu
<a href="/blog/2014/02/16/curses-et-ncurses-en-ruby/">la dernière fois</a>,
et pour cause, la seule différence étant l'ouverture/affichage du
fichier passé en argument:</p>

<p>``` ruby redvim.rb</p>

<h1>!/usr/bin/env ruby</h1>

<p>require &lsquo;ffi-ncurses&rsquo;
include FFI::NCurses</p>

<p>file = File.open ARGV[0]</p>

<p>begin
  initscr
  file.each {|line| printw line }
  refresh
  getch
ensure
  endwin
end
```</p>

<p>N'oubliez pas de donner les droits d'exécution à ce programme:</p>

<pre><code>chmod +x redvim.rb
</code></pre>

<p>Et lancez-le ainsi pour qu'il s'affiche lui-même:</p>

<pre><code>./redvim.rb redvim.rb
</code></pre>

<p>Si vous essayez de lui faire afficher un fichier trop long pour tenir
dans le terminal, il va se passer des choses bizarres. On corrigera
ça plus tard. Pour l'instant notre programme affiche un fichier, c'est
déjà le début de la gloire ;)</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Curses et ncurses en Ruby]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/02/16/curses-et-ncurses-en-ruby/"/>
    <updated>2014-02-16T14:29:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/02/16/curses-et-ncurses-en-ruby</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Tiens, j'ai envie d'écrire en Ruby un embryon d'éditeur pour le terminal, qui
serait fortement inspiré de Vim. Juste histoire de voir comment ça marche.
La première étape sera d'utiliser la bibliothèque curses (ou ncurses) à
partir de Ruby.</p>

<!-- more -->


<h2>Curses</h2>

<p>La bibliothèque <em>curses</em> permet de gérer toutes les interactions
clavier et souris avec un terminal. Jusqu'à la version 2.1 de Ruby, elle
faisait partie de la bibliothèque standard. Donc, si vous utilisez
Ruby 2.1, n'oubliez pas de faire:</p>

<pre><code>gem install curses
</code></pre>

<p>Si vous utilisez Ruby 2.0 où inférieur, vous possédez déjà la bibliothèque
<em>curses</em>.</p>

<p>Voici donc un <em>hello world</em>:</p>

<p>``` ruby
require &lsquo;curses&rsquo;</p>

<p>include Curses</p>

<p>begin
  init_screen
  setpos(0, 0)
  addstr(&lsquo;Hello, world!&rsquo;)
  refresh
  getch
ensure
  close_screen
end
```</p>

<p>On remarque tout d'abord la paire:</p>

<pre><code>init_screen
close_screen
</code></pre>

<p>Il faut toujours appeler <code>close_screen</code> à la fin de votre programme, pour
remettre le terminal dans l'état où il se trouvait avant le lancement de
votre programme.</p>

<p>Pour positionner le curseur, on utilise:</p>

<pre><code>setpos(0, 0)
</code></pre>

<p>Attention, le premier nombre est le numéro de la ligne, et le second est le
numéro de la colonne. Et lignes et colonnes se comptent à partir de 0…</p>

<p>Pour écrire une chaîne de caractère à la position du curseur:</p>

<pre><code>addstr('Hello, world!')
refresh
</code></pre>

<p>Curses n'écrit directement dans le terminal, mais dans un buffer en mémoire,
c'est pourquoi il faut appeler <code>refresh</code> pour voir les changements.</p>

<p>Ensuite, on attends l'appui sur une touche du clavier avec:</p>

<pre><code>getch
</code></pre>

<h2>Ncurses</h2>

<p>Il existe aussi la bibliothèque <em>ncurses</em>, un peu plus puissante. Il existe
plusieurs wrappers pour Ruby. J'utilise personnelement <a href="https://github.com/seanohalpin/ffi-ncurses">ffi-ncurses</a>.</p>

<p>Le même programme que le précédent, mais pour ncurses:</p>

<p>``` ruby
require &lsquo;ffi-ncurses&rsquo;</p>

<p>include FFI::NCurses</p>

<p>begin
  initscr
  printw &ldquo;Hello World !!!&rdquo;
  refresh
  getch
ensure
  endwin
end
```</p>

<p>Les deux programmes se ressemblent beaucoup. Et pour cause, <em>ncurses</em> fait
la même chose que <em>curses</em>, avec des extensions en plus.</p>

<h2>Choisir entre curses et ncurses</h2>

<p>L'une et l'autre ont leurs avantages et leurs inconvénients. <em>curses</em> à
l'avantage d'avoir été distribuée en standard avec Ruby jusqu'à la version
2.0 incluse, et est donc très bien intégrée. Je pense qu'on doit pouvoir
l'utiliser facilement, même sur Windows. <em>ncurses</em> est plus puissante mais
requiert plus de dépendances, et il n'est pas toujours évident de trouver
un wrapper qui fonctionne avec une version récente de Ruby, même sur Linux.</p>

<p>Si je devais écrire un programme grand public, j'utiliserais <em>curses</em>, mais
comme il s'agit juste d'un programme exemple pour ce blog, je vais me faire
plaisir et utiliser <em>ncurses</em>…</p>

<p>La prochaine fois on commencera à écrire l'éditeur.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
