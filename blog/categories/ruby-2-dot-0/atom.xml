<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : ruby 2.0 | Xavier Nayrac]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/ruby-2-dot-0/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2015-10-06T16:04:53+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ruby 2.0: Tableaux littéraux pour les symboles]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/10/17/ruby-2-dot-0-tableaux-litteraux-pour-les-symboles/"/>
    <updated>2013-10-17T10:48:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/10/17/ruby-2-dot-0-tableaux-litteraux-pour-les-symboles</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>La version 2.0 de Ruby gagne une nouvelle syntaxe pour la définition
de tableaux de symboles : <code>%i</code>.</p>

<p>On a maintenant le choix pour définir un tableau de symboles entre les deux
syntaxes suivantes:</p>

<p>``` ruby
[:voici, :plusieurs, :symboles]</p>

<p>%i( voici plusieurs symboles )
```</p>

<!-- more -->

<p>On y gagne en clarté mais aussi, le langage y gagne en cohérence. On est
habitué à utiliser <code>%w</code> pour les tableaux de chaînes de caractères, il n’y
avait pas de raison pour qu’on ne puisse pas le faire avec des symboles.
J’aime beaucoup cette nouvelle possibilité, même si je ne vois pas
le rapport entre la lettre <code>i</code> et les symboles…</p>

<p>Il existe aussi une version qui permet l’interpolation, c’est <code>%I</code> (avec
un i majuscule). Vous pouvez voir la différence entre <code>%i</code> et <code>%I</code> dans la
session suivante:</p>

<p><code>irb
&gt;&gt; %i( #{"bé" + "po"} azerty )
[
    [0] :"\#{\"bé\"",
    [1] :+,
    [2] :"\"po\"}",
    [3] :azerty
]
&gt;&gt; %I( #{"bé" + "po"} azerty )
[
    [0] :bépo,
    [1] :azerty
]
</code></p>

<script id="fb33k8u">(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>

<p>À demain.</p>

<p></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby 2.0: Les arguments nommés]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/10/14/ruby-2-dot-0-les-arguments-nommes/"/>
    <updated>2013-10-14T19:04:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/10/14/ruby-2-dot-0-les-arguments-nommes</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Les arguments nommés étaient absents de Ruby jusqu’à sa version 2.0, curieux
pour un langage qui fait tellement penser à Smalltalk.</p>

<!-- more -->

<p>Il était bien sûr possible de les <em>simuler</em> en utilisant un hash, un peu
comme ce qu’on fait en Javascript:</p>

<p><code>ruby
def person(opts = {})
  defaults = {name: "toto", age: 99}
  opts = defaults.merge opts
  puts opts[:name]
  puts opts[:age]
end
</code></p>

<p>Mais bof. Ça ressemble à tout sauf à du Ruby. C’est un <em>hack</em>, un truc, une
astuce, tout ce qu’on veut mais ça ne s’intègre pas au langage.
Voici la même méthode, avec cette fois-ci des arguments nommés:</p>

<p><code>ruby
def person(name: "toto", age: 99)
  puts name
  puts age
end
</code></p>

<p>Et voici comment différentes manières d’appeler cette méthode:</p>

<p><code>ruby
person
person name: "oscar"
person age: 18
person name: "oscar", age: 18
person age: 18, name: "oscar"
</code></p>

<p>Cool, ça fonctionne dans tous les sens. Par contre, pas question d’oublier
le nom de l’argument:</p>

<p><code>irb
person "oscar", 18
ArgumentError: wrong number of arguments (2 for 0)
</code></p>

<p>On peut aussi mélanger arguments normaux et nommés, à condition que les
arguments nommés viennent après. Le code suivant est valide:</p>

<p>``` ruby
def person(name, age: 99)
  puts name
  puts age
end</p>

<p>person “oscar”
```</p>

<p>Mais pas celui-ci:</p>

<p><code>irb
&gt;&gt; def person(age: 99, name)
&gt;&gt; end
SyntaxError: (irb):1: syntax error, unexpected tIDENTIFIER
def person(age: 99, name)
                        ^
</code></p>

<script id="fb33k8u">(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>

<p>À demain.</p>

<p></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby 2.0: Raffinement de méthode]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/10/10/ruby-2-dot-0-raffinement-de-methode/"/>
    <updated>2013-10-10T18:18:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/10/10/ruby-2-dot-0-raffinement-de-methode</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Ruby possède un truc cool : les classes ouvertes. Lorsque j’écris :</p>

<p><code>ruby
class String
  def foo
    "foo"
  end
end
</code></p>

<p>Je ne suis pas en train de <em>définir</em> une nouvelle classe <code>String</code>, je suis
simplement en train <em>d’ouvrir</em> la classe <code>String</code> existante pour lui ajouter
une nouvelle méthode.</p>

<!-- more -->

<p>C’est très utile et très cohérent avec l’esprit orienté objet de Ruby.
Mettons que j’ai besoin de cacher les voyelles d’une phrase pour un
hypothétique jeu de lettre, je peux écrire un module avec une collection
de méthodes utilitaires, par exemple:</p>

<p>``` ruby
module Util
  def self.hide_vowels(string)
    string.tr(‘aeiouy’, ‘*’)
  end
end</p>

<p>puts Util.hide_vowels(“bonjour xavier”)
```</p>

<p>Ce qui donne:</p>

<pre><code>b*nj**r x*v**r
</code></pre>

<p>Mais on peut aussi tirer parti des classes ouvertes de cette manière:</p>

<p>``` ruby
class String
  def hide_vowels
    tr(‘aeiouy’, ‘*’)
  end
end</p>

<p>puts “bonjour xavier”.hide_vowels
```</p>

<p>C’est plus élégant, à la fois dans la définition et dans l’utilisation.
Seulement ce genre de code peut poser problème quand il est utilisé dans
des bibliothèques, puisque une fois chargée, la nouvelle méthode est visible
dans tout le code client. Parfois c’est ce qu’on veut, parfois ce ne devrait
être qu’une méthode utilitaire du code tiers.</p>

<p>Ruby 2.0 propose le raffinement de méthode (<em>method refinement</em>) pour
pallier à ce problème. L’idée est de limiter la portée des méthodes ajoutées
ou modifiées avec le mécanisme des classes ouvertes. Voici un petit exemple:</p>

<p>```
module CoolString
  refine String do
    def hide_vowels
      tr(‘aeiouy’, ‘*’)
    end
  end
end</p>

<h1 id="puts-abchidevowels">puts “abc”.hide_vowels</h1>

<p>using CoolString
puts “abc”.hide_vowels
```</p>

<p>La ligne en commentaire provoquerait une erreur (NoMethodError). Pour pouvoir
utiliser la méthode <code>hide_vowels</code> il faut explicitement écrire
<code>using CoolString</code>. La portée de <code>hide_vowels</code> s’étend du moment où on utilise
la méthode <code>using</code> jusqu’à la fin du fichier.</p>

<p>Le raffinement de méthode est expérimental dans Ruby 2.0 et devrait être
définitivement adopté dans Ruby 2.1. Pour aller plus loin, on peut se
reporter à la <a href="http://www.ruby-doc.org/core-2.0.0/doc/syntax/refinements_rdoc.html">documentation</a>.</p>

<script id="fb33k8u">(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>

<p>À demain.</p>

<p></p>

]]></content>
  </entry>
  
</feed>
