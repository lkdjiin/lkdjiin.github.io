<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : Ruby | Xavier Nayrac]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2017-01-20T14:57:34+01:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Racket pour les Rubyists 4: La fonction filter]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/11/09/racket-pour-les-rubyists-4-la-fonction-filter/"/>
    <updated>2013-11-09T18:39:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/11/09/racket-pour-les-rubyists-4-la-fonction-filter</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Aprés avoir vu comment faire un <a href="http://lkdjiin.github.io/blog/2013/11/08/racket-pour-les-rubyists-3-trouver-les-diviseurs/">test d’égalité</a>
en Racket, on s’intéresse aujourd’hui à la fonction <code>filter</code>, en la
comparant à la méthode Ruby <code>select</code>.</p>

<!-- more -->

<h2 id="select-vs-filter">select vs filter</h2>
<p>Pour obtenir les nombres impairs d’une liste, voici comment on pourrait
faire en Ruby:</p>

<p><code>ruby
[1, 2, 3, 4].select {|i| i.odd? } #=&gt; [1, 3]
</code></p>

<p>D’une manière générale, on a:</p>

<pre><code>liste.select bloc
</code></pre>

<p>Et voici la façon de faire en Racket:</p>

<p><code>racket
(filter odd? '(1 2 3 4)) ;=&gt; '(1 3)
</code></p>

<p>Qu’on généralise en:</p>

<pre><code>(filter fonction liste)
</code></pre>

<p>Comme Ruby, Racket place un point d’interrogation à la fin du nom d’une
fonction qui retourne vrai ou faux. <code>odd?</code> s’utilise ainsi:</p>

<p><code>racket
(odd? 1) ;=&gt; #t
(odd? 2) ;=&gt; #f
</code></p>

<p>On voit que dans <code>(filter odd? '(1 2 3 4))</code>, chaque élément de la liste est
fourni <em>implicitement</em> à la fonction <code>odd?</code>. De plus, on ne mets pas de
parenthèses autour de <code>odd?</code> car on ne veut pas l’évaluer mais seulement
fournir la référence. C’est quelque chose sur lequel je reviendrais souvent
et qu’il faudra expliquer plus en détail.</p>

<p>La prochaine fois on parlera des fonctions imbriquées en Racket.</p>

<script id="fb33k8u">(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>

<p>À demain.</p>

<p></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Racket pour les Rubyists 3: Trouver les diviseurs]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/11/08/racket-pour-les-rubyists-3-trouver-les-diviseurs/"/>
    <updated>2013-11-08T19:17:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/11/08/racket-pour-les-rubyists-3-trouver-les-diviseurs</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Précédemment, on a vu comment produire une
<a href="http://lkdjiin.github.io/blog/2013/11/06/racket-pour-les-rubyists-2-produire-une-suite-de-nombre/">liste de nombre</a>
avec la fonction <code>range</code>. Aujourd’hui on va traduire les tests Ruby suivants
en Racket:</p>

<p><code>ruby
8 % 2 == 0 #=&gt; true
8 % 3 == 0 #=&gt; false
</code></p>

<!-- more -->

<h2 id="reste-dune-division">Reste d’une division</h2>

<p>Pour calculer le reste d’une division euclidienne, on utilise la fonction
<code>remainder</code>. Par exemple:</p>

<p><code>racket
(remainder 8 2) ;=&gt; 0
(remainder 8 3) ;=&gt; 2
</code></p>

<p>D’une manière plus générale, <code>(remainder a b)</code> calcule le reste de la
division de <code>a</code> par <code>b</code>. Vous remarquerez encore une fois la notation <em>prefix</em>
de Racket.</p>

<p>Au passage, vous notez que le signe pour débuter un commentaire est le
point-virgule (<code>;</code>).</p>

<h2 id="les-boolens">Les booléens</h2>

<p>En Ruby les deux valeurs booléennes sont <strong>true</strong> et <strong>false</strong>, en Racket
elles sont notées <strong>#t</strong> et <strong>#f</strong>:</p>

<h2 id="tester-lgalit">Tester l’égalité</h2>

<p>Quand Ruby utilise le signe <code>==</code>, comme beaucoup d’autres langages, Racket
utilise un seul signe <code>=</code>:</p>

<p><code>racket
(= 1 1) ;=&gt; #t
(= 1 2) ;=&gt; #f
</code></p>

<p>Attention, <code>=</code> ne fonctionne qu’avec les nombres comme vous pouvez le
constater dans la session suivante:</p>

<pre><code>-&gt; (= "xav" "xav")
; =: contract violation
;   expected: number?
;   given: "xav"
;   argument position: 1st
</code></pre>

<p>Donc, pour tester si le reste d’une division euclidienne est égal à zéro,
on pourra faire comme ça:</p>

<p><code>racket
(= 0 (remainder 8 2)) ;=&gt; #t
(= 0 (remainder 8 3)) ;=&gt; #f
</code></p>

<p>Et d’une manière générale, pour tester si <em>i</em> est un diviseur de <em>n</em>:</p>

<p><code>racket
(= 0 (remainder n i))
</code></p>

<p>La prochaine fois, on verra la fonction Racket <code>filter</code>, qui est le
pendant de la méthode <code>select</code> de Ruby.</p>

<script id="fb33k8u">(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>

<p>À demain.</p>

<p></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Racket pour les rubyists 2: Produire une suite de nombre]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/11/06/racket-pour-les-rubyists-2-produire-une-suite-de-nombre/"/>
    <updated>2013-11-06T19:10:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/11/06/racket-pour-les-rubyists-2-produire-une-suite-de-nombre</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>La <a href="http://lkdjiin.github.io/blog/2013/11/03/racket-pour-les-rubyists-definir-une-fonction/">dernière fois</a>
on a vu comment définir une fonction en Racket. Aujourd’hui on va essayer
de traduire la méthode Ruby suivante:</p>

<p><code>ruby
def divisors(n)
  (1..n).select {|i| n % i == 0}
end
</code></p>

<!-- more -->

<p>Tout d’abord, j’ai envie découper cette méthode en trois parties plus petites:</p>

<ol>
  <li><code>1..n</code>, pour produire une suite de nombre.</li>
  <li><code>select</code>, qui est la méthode utilisée pour conserver/supprimer certains
éléments.</li>
  <li><code>n % i == 0</code>, qui est un test pour savoir si i est un diviseur de n.</li>
</ol>

<h2 id="produire-une-suite-de-nombre">Produire une suite de nombre</h2>
<p>On s’intéresse d’abord à la 1ère partie. Racket possède la fonction <code>range</code>,
qui produit une liste de nombre. En fournissant un seul argument, n, <code>range</code>
produit une liste de 0 à n <em>non-inclus</em>:</p>

<pre><code>-&gt; (range 4)
'(0 1 2 3)
</code></pre>

<p>En fournissant deux arguments, m et n, <code>range</code> produit une liste de m à n
<em>non-inclus</em>:</p>

<pre><code>-&gt; (range 1 4)
'(1 2 3)
</code></pre>

<p>Pour être exhaustif, il existe une dernière possibilité, avec 3 arguments
m, n et p, pour produire une liste
de m à n <em>non-inclus</em> par pas de p:</p>

<pre><code>-&gt; (range 10 20 3)
'(10 13 16 19)
</code></pre>

<p>Pour produire une liste de m à n <em>inclus</em>, il faut falloir augmenter n de 1:</p>

<pre><code>-&gt; (define n 4)
-&gt; (range 1 (+ n 1))
'(1 2 3 4)
</code></pre>

<p>Vous notez au passage la manière de définir une variable, identique à la
définition d’une méthode, ainsi que la façon dont Racket écrit une liste:</p>

<ul>
  <li>entre parenthèses</li>
  <li>précédée par un apostrophe</li>
  <li>pas de virgule pour séparer les éléments</li>
</ul>

<p>Le prochain article abordera le test d’égalité en Racket.</p>

<script id="fb33k8u">(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>

<p>À demain.</p>

<p></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Racket pour les Rubyists: Définir une fonction]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/11/03/racket-pour-les-rubyists-definir-une-fonction/"/>
    <updated>2013-11-03T15:06:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/11/03/racket-pour-les-rubyists-definir-une-fonction</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Racket est un langage dérivé de Scheme que je suis en train d’apprendre.
Je vais m’inspirer de ma série d’articles
<a href="http://lkdjiin.github.io/blog/2013/10/21/apprendre-ruby-en-faisant-des-maths/">Apprendre Ruby en faisant des maths</a>
pour expliquer les bases de Racket en le comparant à Ruby. Si vous
connaissez un peu Ruby, j’espère que vous n’aurez aucun mal à suivre
ces articles. On commence aujourd’hui avec la définition d’une fonction.</p>

<!-- more -->

<p>J’utiliserais la version 5.3.6 de Racket et la version 2.0 de Ruby.
Au début, on va utiliser le REPL, pour Ruby on a <code>irb</code>, pour Racket on
a <code>racket</code>.</p>

<h2 id="dfinir-une-fonction">Définir une fonction</h2>
<p>Racket a des fonctions et Ruby a des méthodes, mais ça ne fait aucune
différence pour l’instant. Voyons comment définir une fonction <code>addition</code>,
qui va calculer et renvoyer la somme de deux arguments, <code>a</code> et <code>b</code>:</p>

<pre><code>[~]⇒ racket
-&gt; (define (addition a b)
     (+ a b))
-&gt; (addition 12 34)
46
</code></pre>

<p>Comparons immédiatement avec la version Ruby:</p>

<pre><code>[~]⇒ irb
&gt;&gt; def addition(a, b)
&gt;&gt;   a + b
&gt;&gt; end
nil
&gt;&gt; addition 12, 34
46
</code></pre>

<p>Première remarque: avec Racket les parenthèses sont <strong>très importantes</strong>.
On est obligé de les utilisées, et de les utilisées correctement.</p>

<p>Deuxième remarque: Ruby utilise la notation <em>infix</em> (<code>a + b</code>) alors que
Racket utilise la notation <em>prefix</em> (<code>+ a b</code>). Étrange au début si vous
n’avez jamais utilisé ce genre de truc, on s’y fait très vite.</p>

<p>Troisième remarque: avec Racket les arguments ne sont pas séparés par des
virgules.</p>

<p>Enfin, Ruby utilise des mots clés (<code>def</code> et <code>end</code>) pour délimiter un
bloc/ensemble d’instructions alors que Racket utilise simplement les
parenthèses.</p>

<p><strong>Exercice</strong>: Sur le même modèle que la fonction <code>addition</code>, définissez et
utilsez les fonctions <code>soustraction</code> et <code>multiplication</code>. Voici les solutions:</p>

<p>``` racket
(define (soustraction a b)
  (- a b))</p>

<p>(soustraction 17 7)</p>

<p>(define (multiplication a b)
  (* a b))</p>

<p>(multiplication 2 3)
```</p>

<script id="fb33k8u">(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>

<p>À demain.</p>

<p></p>

]]></content>
  </entry>
  
</feed>
