<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : ruby | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2013-10-27T07:43:23+01:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Couverture de code pour Ruby avec coco]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/10/26/couverture-de-code-pour-ruby-avec-coco/"/>
    <updated>2013-10-26T18:07:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/10/26/couverture-de-code-pour-ruby-avec-coco</id>
    <content type="html"><![CDATA[<p>Il y a 3 ans, j'ai écrit une gem Ruby pour faire de la couverture de
code (<em>code coverage</em>). <a href="https://github.com/colszowka/simplecov">SimpleCov</a>,
la gem la plus utilisée pour cette tâche venait tout juste de voir le
jour et ne me convenait pas entièrement. À l'époque je trouvais SimpleCov
trop ennuyeuse à configurer et à faire fonctionner.</p>

<!-- more -->


<p>Qu'on ne me fasse pas dire ce que je n'ai pas écrit : SimpleCov remplie
<em>parfaitement</em> sa tâche. C'est juste que je voulais un truc plus simple.
Je voulais quelque chose qui fonctionne en une ligne, avec configuration
optionnelle et surtout, avec un rapport de couverture
super simple et dépouillé. C'est comme ça qu'est née la gem
<a href="https://github.com/lkdjiin/coco">coco</a>. Bon ok, il m'est arrivé de me
demander si je ne l'avais pas écrit juste pour le jeu de mot…</p>

<p>Pour utiliser coco, il suffit de charger la gem au tout début des tests
comme ceci:</p>

<p><code>ruby
require 'coco'
</code></p>

<p>Et… c'est tout ! Chaque fois que vous lancerez les tests, coco produira un
rapport si (et seulement si) au moins un fichier n'est pas couvert à 100%.</p>

<p>La configuration, au besoin, se fait dans un fichier caché au format yaml,
à la racine du projet. Par exemple si vous trouvez qu'un taux de couverture
de 90% est acceptable, vous pouvez le changer comme ça:</p>

<pre><code>:threshold: 90
</code></pre>

<p>Si vous voulez exclure un fichier et un dossier complet du rapport vous
pouvez écrire:</p>

<pre><code>:excludes:
- lib/project/file1.rb
- config/initializers
</code></pre>

<p>Il y a plusieurs autres exemples de configuration sur le
<a href="https://github.com/lkdjiin/coco/wiki">wiki du projet</a>. Enfin, pour une
présentation rapide de coco, en anglais, il y a le
<a href="http://lkdjiin.github.io/coco/">site web</a>.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Apprendre Ruby en faisant des maths 3]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/10/25/apprendre-ruby-en-faisant-des-maths-3/"/>
    <updated>2013-10-25T10:02:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/10/25/apprendre-ruby-en-faisant-des-maths-3</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>La <a href="http://lkdjiin.github.io/blog/2013/10/23/apprendre-ruby-en-faisant-des-maths-2/">dernière fois</a>, on a vu comment calculer la liste des diviseurs
d'un nombre avec <code>(1..8).select {|int| 8 % int == 0 }</code>. On va aujourd'hui
faire en sorte que ça fonctionne avec n'importe quel nombre, en écrivant
notre propre méthode.</p>

<!-- more -->


<p>Résumons : pour trouver les diviseurs de 8, j'écris:</p>

<p><code>ruby
(1..8).select {|int| 8 % int == 0 }
</code></p>

<p>et pour trouver les diviseurs de 4, j'écris:</p>

<p><code>ruby
(1..4).select {|int| 4 % int == 0 }
</code></p>

<p>Ce que je veux, c'est une façon de faire plus <em>générale</em>: je veux trouver
les diviseurs pour tout entier <em>n</em>. Essayons donc de remplacer le
nombre recherché par n:</p>

<p>``` irb</p>

<blockquote><blockquote><p>(1..n).select {|int| n % int == 0 }
NoMethodError: undefined method `n' on an instance of Object.
```</p></blockquote></blockquote>

<p>Ruby n'est pas content et nous signale qu'il ne connait pas n. Ok, essayons
alors de définir n d'abord:</p>

<p>``` irb</p>

<blockquote><blockquote><p>n = 8
=> 8
(1..n).select {|int| n % int == 0 }
=> [1, 2, 4, 8]
```</p></blockquote></blockquote>

<p>Cette fois c'est bon. Maintenant vous êtes prêt à définir une méthode:</p>

<p><code>ruby
def divisors(n)
  (1..n).select {|int| n % int == 0 }
end
</code></p>

<p><strong>Pour information, divisors est le mot anglais pour diviseurs.</strong></p>

<p>Une définition de méthode commence par le mot-clé <code>def</code> et se termine par
le mot-clé <code>end</code>. La méthode ci-dessus s'appelle <code>divisors</code> et elle prend
un argument qui est nommé <code>n</code>.</p>

<p>On lance/appelle/exécute une méthode simplement par son nom, sans oublier
son (ses) argument(s). Par exemple <code>divisors 8</code> va calculer et renvoyer la
liste des diviseurs de 8. Voici un exemple d'utilisation lors d'une session
irb:</p>

<p>``` irb</p>

<blockquote><blockquote><p>def divisors(n)
  (1..n).select {|int| n % int == 0 }
end
divisors 8
=> [1, 2, 4, 8]
divisors 4
=> [1, 2, 4]
divisors 417
=> [1, 3, 139, 417]
```</p></blockquote></blockquote>

<p>La prochaine fois nous verrons comment se servir de la méthode <code>divisors</code>
comme d'une base pour construire une autre méthode.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Apprendre Ruby en faisant des maths 2]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/10/23/apprendre-ruby-en-faisant-des-maths-2/"/>
    <updated>2013-10-23T09:54:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/10/23/apprendre-ruby-en-faisant-des-maths-2</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>On a vu, <a href="http://lkdjiin.github.io/blog/2013/10/21/apprendre-ruby-en-faisant-des-maths/">précédemment</a>,
comment savoir si un nombre d est un diviseur de n avec <code>8 % 2</code> et
comment obtenir une liste de nombre avec <code>1..8</code>. Maintenant on peut
apprendre à sélectionner les nombres qui nous intéressent dans cette liste.</p>

<!-- more -->


<p>Pour cela, nous allons utiliser la méthode <code>select</code>:</p>

<p>``` irb</p>

<blockquote><blockquote><p>(1..8).select {|int| 8 % int == 0 }
=> [1, 2, 4, 8]
```</p></blockquote></blockquote>

<p>Et voilà, nous avons nos diviseurs de 8. La méthode <code>select</code> utilise un
bloc d'instructions (ce qui se trouve entre les <code>{}</code>). Cette (ou ces)
instruction va être exécutée sur chaque éléments de <code>1..8</code>, c'est à dire
sur 1, 2, 3, 4, 5 ,6, 7 puis enfin 8. Ici, l'instruction exécutée sur les
éléments est <code>8 % int == 0</code>. En clair on teste si le reste de la division
de 8 par <code>int</code> égal zéro. Qu'est-ce que c'est que ce <code>int</code> ? Et bien c'est
l'élément en cours de traitement, c'est à dire 1, puis 2, et ensuite 3, etc
jusqu'à 8. <code>int</code> est simplement un nom qu'on a donné pour pouvoir se
référer à l'élément en cours, ce nom est indiqué entre deux caractères <code>|</code>,
comme dans <code>|int|</code>. On peut lui donner le nom qu'on veut, par exemple:</p>

<p>``` irb</p>

<blockquote><blockquote><p>(1..8).select {|xavier| 8 % xavier == 0 }
=> [1, 2, 4, 8]
```</p></blockquote></blockquote>

<p>Pour information, <em>int</em> est le diminutif de integer, qui signifie
nombre entier en anglais.</p>

<p>Comment Ruby sait qu'il doit sélectionner 2 et pas 3 ? Regardons cela de
plus près:</p>

<p>``` irb</p>

<blockquote><blockquote><p>8 % 2 == 0
=> true
8 % 3 == 0
=> false
```</p></blockquote></blockquote>

<p>Le résultat d'un test, ici l'égalité avec <code>==</code> est soit vrai (true), soit
faux (false). Lorsque l'instruction dans le bloc (<code>{}</code>) renvoie true, l'élément
est sélectionné, lorsqu'elle renvoie false, l'élément est éliminé.</p>

<p>Vous devriez vérifier maintenant que ça fonctionne bien avec n'importe
quel nombre entier positif:</p>

<p>``` irb</p>

<blockquote><blockquote><p>(1..1).select {|int| 1 % int == 0 }
=> [1]
(1..41).select {|int| 41 % int == 0 }
=> [1, 41]
(1..417).select {|int| 417 % int == 0 }
=> [1, 3, 139, 417]
(1..4179).select {|int| 4179 % int == 0 }
=> [1, 3, 7, 21, 199, 597, 1393, 4179]
```</p></blockquote></blockquote>

<p>La prochaine fois, on verra comment créer nos propres méthodes.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Apprendre Ruby en faisant des maths]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/10/21/apprendre-ruby-en-faisant-des-maths/"/>
    <updated>2013-10-21T21:09:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/10/21/apprendre-ruby-en-faisant-des-maths</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>J'ai eu récemment à aider quelqu'un en mathématique (niveau 3ème), et ce
quelqu'un connaissait un peu Ruby. On a joué avec le langage pour faire
des maths. C'était drôle et intéressant. Ça m'a donné l'idée de
continuer cette affaire sur mon blog. Cette nouvelle série d'articles
s'adresse à celles et ceux qui débutent Ruby et qui ont un niveau de math de
3ème.</p>

<!-- more -->


<p>Le premier problème auquel on va essayer de répondre en utilisant Ruby est
le suivant:</p>

<p><blockquote><p>Afficher toutes les paires de nombres amiables jusqu'à 10.000.</p></blockquote></p>

<p>Si vous avez besoin de vous rafraichir la mémoire sur les nombres
amiables, voici <a href="http://fr.wikipedia.org/wiki/Nombre_amical">l'article de wikipédia</a>.
Et en voici une définition rapide:</p>

<p>si <em>f</em>(n) est une fonction qui calcule la
somme des diviseurs stricts de n, alors n et m sont amiables si
<em>f</em>(n) = m et <em>f</em>(m) = n.</p>

<h2>Obtenir les diviseurs d'un nombre</h2>

<p>La première chose à faire est de calculer les diviseurs d'un nombre n.
Pour mémoire, les diviseurs de 8, par exemple, sont 1 ; 2 ; 4 et 8.
Pour les trouver, une méthode consiste à diviser 8 par chaque nombre de 1 à 8
et à regarder le reste de la division. Si il reste 0, c'est un diviseur, sinon
ce n'est pas un diviseur. En Ruby, calculer le reste d'une division se fait
avec l'opérateur <code>%</code> (le modulo):</p>

<p>``` irb
[~]⇒ irb</p>

<blockquote><blockquote><p>8 % 1
0
8 % 2
0
8 % 3
2
8 % 4
0
8 % 5
3
8 % 6
2
8 % 7
1
8 % 8
0
```</p></blockquote></blockquote>

<p>On voit bien que les diviseurs de 8, soit 1, 2, 4 et 8 renvoient bien 0.
Évidemment, il n'est pas question de se taper tout ces chiffres <em>à la main</em>,
imaginez un peu que vous vouliez connaitre les diviseurs de 123456789 !
Il nous faut quelque chose pour produire automatiquement les nombres de 1 à
n. En Ruby, on appelle ça un <code>Range</code>:</p>

<p>``` irb</p>

<blockquote><blockquote><p>1..8
1..8
```</p></blockquote></blockquote>

<p>Pour y voir plus clair, on va appeler la méthode <code>to_a</code> sur ce <code>Range</code>, qui
va nous le transformer en un tableau (<code>Array</code>). Vous pouvez pensez à un
tableau comme à une simple liste:</p>

<p>``` irb</p>

<blockquote><blockquote><p>(1..8).to_a
[1, 2, 3, 4, 5, 6, 7, 8]
```</p></blockquote></blockquote>

<p>On a bien une liste des nombres de 1 à 8. Notez que les parenthèses sont ici
nécessaires, sinon la méthode <code>to_a</code> serait appelée sur le chiffre 8, et
c'est pas bon:</p>

<p>``` irb</p>

<blockquote><blockquote><p>1..8.to_a
NoMethodError: undefined method `to_a' for 8:Fixnum
```</p></blockquote></blockquote>

<p>La prochaine fois on verra comment sélectionner dans cette liste seulement
les nombres qui nous intéressent, c'est à dire les diviseurs.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Programmation fonctionnelle pour les développeurs Ruby]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/10/19/programmation-fonctionnelle-pour-les-developpeurs-ruby/"/>
    <updated>2013-10-19T16:43:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/10/19/programmation-fonctionnelle-pour-les-developpeurs-ruby</id>
    <content type="html"><![CDATA[<p>Si vous êtes comme moi, la programmation fonctionnelle vous intéresse,
mais vous n'y comprenez pas grand chose…
Je vous encourage à regarder cette conférence de Jessica Kerr:
<a href="http://vimeo.com/75181845">Functional Principles for Ruby Developers</a>.</p>

<!-- more -->


<p>Elle y développe une analogie que j'ai beaucoup aimé: C'est Watson qui
demande
à Sherlock Holmes «Vous saviez qu'on a découvert une nouvelle planète dans
le système solaire ?». Et Holmes de répondre un truc du genre «Non. Pourtant
vous venez de me le dire, mais je l'ai déjà oublié.»</p>

<p>Dans cette histoire, Holmes ne veut pas remplir son cerveau avec ce genre
d'information qui lui est inutile pour résoudre ses enquêtes. Il se contente
de savoir ce dont il a besoin.</p>

<p>Jessica Kerr nous explique que c'est cela la programmation fonctionnelle:
se contenter de faire seulement ce qu'on a à faire, sans toucher au monde
extérieur. Et elle nous explique comment le faire en Ruby.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
