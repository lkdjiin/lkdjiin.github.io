<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : maker | Xavier Nayrac]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/maker/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2016-02-12T10:09:50+01:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Fabriquer un sablier à thé électronique 3]]></title>
    <link href="http://lkdjiin.github.io/blog/2016/02/02/fabriquer-un-sablier-a-the-electronique-3/"/>
    <updated>2016-02-02T15:05:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2016/02/02/fabriquer-un-sablier-a-the-electronique-3</id>
    <content type="html"><![CDATA[<p>Comme promis, voici le code de mon <em>sablier à thé électronique</em>. C’est le
premier <em>objet</em> que j’ai pensé et fabriqué de A à Z, en me servant d’un
arduino pour réaliser d’abord un prototype. Ce qui fait que, même si le
résultat est moche, j’en suis fier ;)</p>

<p><img class="center" src="/images/tea_timer.jpg"></p>

<!-- more -->

<p>Tout d’abord le code C qui doit être envoyé dans un micro contrôleur Attiny13,
à l’aide d’un <a href="/blog/2015/10/29/fabriquer-un-sablier-a-the-electronique/">programmateur</a>.</p>

<p>```c main.c
#include &lt;avr/io.h&gt;
#include &lt;util/delay.h&gt;</p>

<h1 id="define-led-pb0">define LED PB0</h1>
<p>#define BUZZER PB2
#define BUTTON3 PB3 // For 3 minutes
#define BUTTON5 PB4 // For 5 minutes</p>

<h1 id="define-threeminutesinseconds-180">define THREE_MINUTES_IN_SECONDS 180</h1>
<p>#define FIVE_MINUTES_IN_SECONDS  300</p>

<p>int main(void)
{
  DDRB |= 1 « LED | 1 « BUZZER; // Outputs declarations.
  PORTB |= 1 « LED;              // Switch on the LED.
  PORTB &amp;= ~(1 « BUZZER);        // Switch off the buzzer.</p>

<table>
  <tbody>
    <tr>
      <td>DDRB &amp;= ~(1 « BUTTON3</td>
      <td>1 « BUTTON5); // Inputs declarations.</td>
      <td> </td>
    </tr>
    <tr>
      <td>PORTB</td>
      <td>= (1 « BUTTON3</td>
      <td>1 « BUTTON5); // Pull up for inputs.</td>
    </tr>
  </tbody>
</table>

<p>// Number of seconds for the timer to buzz.
  int g_timer = 0;</p>

<p>// Give enough time to enable pull ups.
  _delay_ms(100);</p>

<p>while(1) {</p>

<pre><code>// Button for 3 minutes pressed?
if(!(PINB &amp; (1 &lt;&lt; BUTTON3))) {
  _delay_ms(10);
  g_timer = THREE_MINUTES_IN_SECONDS;
  break;
}

// Button for 5 minutes pressed?
if(!(PINB &amp; (1 &lt;&lt; BUTTON5))) {
  _delay_ms(10);
  g_timer = FIVE_MINUTES_IN_SECONDS;
  break;
}   }
</code></pre>

<p>// Each cycle is approximately 1 second, but this is not really
  // accurate.
  while(g_timer &gt; 0) {
    PORTB ^= 1 « LED; // LED off cause it was set up to on.
    _delay_ms(500);
    PORTB ^= 1 « LED; // LED on.
    _delay_ms(500);
    g_timer–;
  }</p>

<p>// Now it’s time to bip and blink forever.
  while(1) {</p>

<pre><code>int i;

for(i = 0; i &lt; 3; i++) {
  PORTB |= 1 &lt;&lt; BUZZER;
  _delay_ms(100);
  PORTB &amp;= ~(1 &lt;&lt; BUZZER);
  _delay_ms(100);
}

for(i = 0; i &lt; 3; i++) {
  PORTB |= 1 &lt;&lt; LED;
  _delay_ms(100);
  PORTB &amp;= ~(1 &lt;&lt; LED);
  _delay_ms(100);
}   } } ```
</code></pre>

<p>Et voici le contenu du Makefile, qui simplifie les phases de compilation et
d’installation.</p>

<pre><code>DEVICE = attiny13
CLOCK  = 1000000
PROGRAMMER = -P /dev/ttyUSB0 -c arduino
BAUDRATE   = -b 19200

help:
  @echo 'check =&gt; check connection with ATtiny13'
  @echo 'hex   =&gt; compile hex file'
  @echo 'flash =&gt; install hex file'
  @echo 'clean =&gt; delete unnecessary files'

check:
  avrdude -p $(DEVICE) $(PROGRAMMER) $(BAUDRATE)

hex:
  avr-gcc -Wall -Os -DF_CPU=$(CLOCK) -mmcu=$(DEVICE) -c main.c
  avr-gcc -mmcu=$(DEVICE) -o main.elf main.o
  avr-objcopy -O ihex main.elf main.hex

flash:
  avrdude -p $(DEVICE) $(PROGRAMMER) -U flash:w:main.hex $(BAUDRATE)

clean:
  rm main.o
  rm main.elf
</code></pre>

<p>Vous pouvez retrouver ce code sur <a href="https://github.com/lkdjiin/tea-timer">gitub</a>, ainsi que le schéma avec les
composants électroniques.</p>

<p>J’espère me faire bientôt une deuxième version plus jolie et plus sophistiquée.</p>

<p><a href="/blog/2015/10/29/fabriquer-un-sablier-a-the-electronique/">Lire la partie 1</a></p>

<p><a href="/blog/2015/12/12/fabriquer-un-sablier-a-the-electronique-2/">Lire la partie 2</a></p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Fabriquer un sablier à thé électronique 2]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/12/12/fabriquer-un-sablier-a-the-electronique-2/"/>
    <updated>2015-12-12T16:51:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/12/12/fabriquer-un-sablier-a-the-electronique-2</id>
    <content type="html"><![CDATA[<p>Après avoir appris à programmer un ATtiny45 avec l’IDE Arduino, il fallait
maintenant s’en passer. Pour cela je suis passé du langage Arduino au
langage C, avec le cross compilateur <code>avr-gcc</code> et l’outil <code>avrdude</code>.</p>

<p>Je vais profiter de vous montrer cela pour comparer la taille d’un même
programme, écrit une fois en langage Arduino et l’autre en C.</p>

<!-- more -->

<p><a href="/blog/2015/10/29/fabriquer-un-sablier-a-the-electronique/">Lire la partie 1</a></p>

<p><a href="/blog/2015/12/12/fabriquer-un-sablier-a-the-electronique-2/">Lire la partie 2</a></p>

<p>Le programme, c’est deux boutons/deux LEDs. Le bouton A s’occupe de la LED A.
Le bouton B s’occupe de la LED B. Quand un bouton est pressé puis relâché, sa
LED respective change d’état. Si elle était éteinte elle s’allume, et vice-versa.
C’était un peu mon <em>hello world!</em></p>

<p>Voilà le programme en langage Arduino:</p>

<p>```c sketch/sketch.ino
void setup() {
  pinMode(3, OUTPUT);
  pinMode(4, OUTPUT);
  digitalWrite(3, HIGH);
  digitalWrite(4, HIGH);
  pinMode(0, INPUT_PULLUP);
  pinMode(1, INPUT_PULLUP);
}</p>

<p>void loop() {
  if(digitalRead(0) == LOW) {
    delay(10);
    while(digitalRead(0) != HIGH) ;
    delay(10);
    digitalWrite(3, bitRead(PORTB, 3) ^ HIGH);
  }
  if(digitalRead(1) == LOW) {
    delay(10);
    while(digitalRead(1) != HIGH) ;
    delay(10);
    digitalWrite(4, bitRead(PORTB, 4) ^ HIGH);
  }
}
```</p>

<p>Le dossier contient juste deux sous dossiers:</p>

<pre><code>$ dirtree
.
├── build
└── sketch
</code></pre>

<p>Je compile avec l’IDE (en ligne de commande mais avec l’IDE quand même):</p>

<pre><code>$ ~/local/bin/arduino-1.6.5/arduino --verify sketch/sketch.ino
--pref build.path=build
Picked up JAVA_TOOL_OPTIONS: 
Loading configuration...
Initializing packages...
Preparing boards...
Verifying...

Le croquis utilise 972 octets (23%) de l'espace de stockage de programmes.
Le maximum est de 4 096 octets.
Les variables globales utilisent 9 octets de mémoire dynamique.
</code></pre>

<p>La taille du programme a déjà était annoncée, mais on peut la vérifier avec
<code>avr-size</code>, 972 octets:</p>

<pre><code>$ avr-size -d build/sketch.cpp.hex 
   text	   data	    bss	    dec	    hex	filename
      0	    972	      0	    972	    3cc	build/sketch.cpp.hex
</code></pre>

<p>Maintenant voici le même programme, cette fois directement en C. Donc sans
toutes les aides et fioritures de l’Arduino:</p>

<p>```c main.c
#include &lt;avr/io.h&gt;
#define F_CPU 1000000UL
#include &lt;util/delay.h&gt;</p>

<p>int main(void)
{
  DDRB |= 1 « 4 | 1 « 3;
  PORTB |= 1 « 4 | 1 « 3;
  DDRB &amp;= ~(1 « 0 | 1 « 1);
  PORTB |= (1 « 0 | 1 « 1);</p>

<p>while(1) {
    if(!(PINB &amp; (1 « 0))) {
      _delay_ms(10);
      while(!(PINB &amp; (1 « 0))) ;
      _delay_ms(10);
      PORTB ^= (1 « 3);
    }
    if(!(PINB &amp; (1 « 1))) {
      _delay_ms(10);
      while(!(PINB &amp; (1 « 1))) ;
      _delay_ms(10);
      PORTB ^= (1 « 4);
    }
  }
}
```</p>

<p>La chaîne de compilation est cette fois un peu plus longue:</p>

<pre><code>$ avr-gcc -O -mmcu=attiny45 -c main.c
$ avr-gcc -mmcu=attiny45 -o main.elf main.o
$ avr-objcopy -O ihex main.elf main.hex
</code></pre>

<p>Même avec une option d’optimisation au minimum, la différence de taille est… sidérale:</p>

<pre><code>$ avr-size -d main.hex 
   text	   data	    bss	    dec	    hex	filename
      0	    158	      0	    158	     9e	main.hex
</code></pre>

<p>Pour transférer le code vers le micro processeur il n’y a plus besoin de l’IDE
Arduino. Je place l’ATtiny45 sur le <a href="/blog/2015/10/29/fabriquer-un-sablier-a-the-electronique/">shield programmateur</a> et j’utilise le
programme avrdude :</p>

<p><code>
avrdude -p attiny45 -P /dev/ttyUSB0 -c arduino -U flash:w:main.hex -b 19200
</code></p>

<p>Rendez vous une prochaine fois pour le code du sablier électronique avec son
Makefile et tout et tout.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Fabriquer un sablier à thé électronique]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/10/29/fabriquer-un-sablier-a-the-electronique/"/>
    <updated>2015-10-29T14:59:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/10/29/fabriquer-un-sablier-a-the-electronique</id>
    <content type="html"><![CDATA[<p>Voici un projet que j’avais en route depuis quelques semaines.  L’objectif était de
fabriquer mon premier «objet» grâce à l’arduino, en l’occurrence un <em>sablier à
thé électronique</em>.</p>

<p><img class="center" src="/images/hourglass.jpg"></p>

<p>Un quoi ? En fait il s’agit tout simplement d’un minuteur. Mais je trouve le
nom <em>sablier à thé électronique</em> bien plus évocateur ;) Quand je me fais du thé
je laisse passer 9 fois sur 10 le temps d’infusion et je me retrouve avec un
breuvage imbuvable. J’avais donc envie d’un minuteur simple avec deux boutons,
un buzzer et une LED. Un des boutons lance un décompte de 3 minutes pour le thé
vert, l’autre c’est 5 minutes pour le thé noir. À la fin ça bip bip et ça
clignote jusqu’à ce qu’on l’arrête. Du vraiment simple, quoi. Sauf que je ne
voulais pas mettre un arduino entier dans ce projet alors qu’un petit micro
contrôleur à 60 centimes pourrait faire l’affaire.</p>

<!-- more -->

<p>J’allais donc devoir apprendre à programmer les micro contrôleurs ATtiny de
chez Atmel. Pourquoi ceux-là ? Parce qu’ils sont proches du micro contrôleur
utilisé par l’arduino (le ATmega 328). Bref je gardais quand même un pied en
terrain connu.</p>

<p>J’ai d’abord créé un prototype de ce <em>sablier sonore</em> avec l’arduino, pour être
sûr que je savais comment faire. Niveau schéma ça pourrait donner quelque chose
comme ça:</p>

<p><img class="center" src="/images/attiny45-step4.png"></p>

<p>Au final je n’utilise qu’une seule LED, mais dans le prototype original il y en
avait deux. Et c’est en utilisant ce premier prototype que je me suis aperçu
qu’une seule LED était suffisante.</p>

<p>L’étape suivante fut de réaliser ce montage, et le code, pour un ATtiny45.
Pourquoi ce micro contrôleur précisément ? Parce que 1) j’en avais un dans un
tiroir, et 2) on trouve une pléthore de tutoriels pour programmer un ATtiny45
en se servant d’un arduino. Si vous n’êtes pas familier du terme,
<strong>programmer</strong> un micro contrôleur c’est, en gros, lui transférer son programme
depuis un ordinateur. Pour que les deux cotés communiquent, on utilise un
<strong>programmateur</strong>. Il y a plusieurs façons de faire ça, je voulais utiliser un
arduino comme base de programmateur pour ne rien avoir à acheter de nouveau.
Vous pouvez trouver un bon tutoriel ici:
<a href="http://www.instructables.com/id/Program-an-ATtiny44458485-with-Arduino/">Program an ATtiny44/45/84/85 with Arduino</a>.</p>

<p>Finalement, on peut se créer le programmateur assez facilement pour l’ATtiny45:</p>

<p><img class="center" src="/images/hello_world_bb.png"></p>

<p>Comme j’allais programmer un certain nombre de micro contrôleurs, j’ai préféré
fabriquer un shield. D’abord un temporaire:</p>

<p><img class="center" src="/images/arduino-temp-shield.jpg"></p>

<p>Puis finalement un définitif:</p>

<p><img class="center" src="/images/arduino-shield-attiny45.jpg"></p>

<p>Trop pressé de le réaliser, je me suis trompé de sens pour le socket, ce qui
explique les câbles qui passent d’un coté à l’autre, puisque je n’ai pas
voulu le dessouder. C’est pas grave et il fonctionne très bien ;)</p>

<p>J’étais donc capable de programmer un ATtiny45 (4K de ROM) en utilisant
l’arduino <strong>ET</strong> l’IDE Arduino. C’était un bon début, mais ça n’était pas
suffisant. D’abord je ne voulais pas utiliser l’IDE Arduino, mais plutôt des
outils en ligne de commande, pour des raisons de reproductibilité et d’automatisation, et ensuite
je soupçonnais que le code de mon <em>sablier sonore</em> pouvait tenir sur un
ATtiny13 qui ne posséde que 1K de ROM et est pratiquement deux fois moins cher
que l’ATtiny45.</p>

<p><a href="/blog/2015/12/12/fabriquer-un-sablier-a-the-electronique-2/">Lire la partie 2</a></p>

<p><a href="/blog/2016/02/02/fabriquer-un-sablier-a-the-electronique-3/">Lire la partie 3</a></p>

<p>À suivre…</p>

<p></p>
]]></content>
  </entry>
  
</feed>
