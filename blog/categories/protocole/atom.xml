<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : protocole | Xavier Nayrac]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/protocole/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2019-12-04T16:21:02+01:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Gopher : Récupérer le menu principal]]></title>
    <link href="http://lkdjiin.github.io/blog/2018/07/27/gopher-recuperer-le-menu-principal/"/>
    <updated>2018-07-27T10:27:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2018/07/27/gopher-recuperer-le-menu-principal</id>
    <content type="html"><![CDATA[<p>Pour aller plus loin dans la compréhension du protocole Gopher nous pouvons écrire un
petit client texte, sans prétention.</p>

<p>Mais avant toutes choses, il faut pouvoir se connecter à un serveur, lui envoyer un
sélecteur, et récupérer les informations que va envoyer le serveur.
Il nous faut un langage qui
permet de créer et d’utiliser des sockets facilement. Beaucoup de langages
répondront à cette contrainte, donc en gros, choisissez celui avec lequel vous êtes le
plus à l’aise.</p>

<!-- more -->

<p>Voir l’article précédent : <a href="/blog/2018/07/21/presentation-de-gopher/">Présentation de Gopher</a></p>

<h2 id="ruby">Ruby</h2>

<p>Voyons comment faire en Ruby.</p>

<p>D’abord on crée la connexion (1). Rappelez-vous,
le protocole Gopher prévoit que le serveur n’envoie rien du tout après une
connexion réussie.</p>

<p>Ensuite (2) nous envoyons un sélecteur vide au serveur.
Ce qui correspond en quelque sorte à demander le menu principal. Le
protocole Gopher explique qu’un sélecteur doit être terminé avec les caractères
de retour à la ligne CR suivi de LF. Ce qu’on écrira <code>"\r\n"</code> dans beaucoup de
langages.</p>

<p>Puis (3) nous consommons et affichons chaque ligne de la réponse du
serveur. Le protocole Gopher nous dit que le serveur termine lui aussi ses
lignes par CR + LF. Ruby gère cette situation, avec <code>gets</code>, en supprimant les
fin de ligne, c’est pourquoi nous devons utiliser <code>puts</code> ensuite pour afficher
<code>line</code> avec un retour à la ligne.</p>

<p>```ruby
# Fichier gopher.rb
require ‘socket’</p>

<h1 id="section">1</h1>
<p>socket = TCPSocket.new ‘gopher.quux.org’, 70</p>

<h1 id="section-1">2</h1>
<p>socket.write “\r\n”</p>

<h1 id="section-2">3</h1>
<p>while line = socket.gets
  puts line
end</p>

<p>socket.close
```</p>

<p>Lancez le programme avec <code>ruby gopher.rb</code>.</p>

<h2 id="d">D</h2>

<p>On pourra préférer un langage qui produira un binaire pour distribuer le programme plus
facilement. <em>(Ici les performances ne rentrent pas en ligne de compte.)</em> J’ai un
faible pour le langage D en ce moment, alors voici le même programme en D.
Vous le compilerez avec <code>dmd gopher.d</code> et le lancerez avec <code>./gopher</code>.</p>

<p>Ce programme D suit exactement le même principe que le programme Ruby. On
crée une connexion (1) ; on envoie un sélecteur vide (2) ; et on affiche la
réponse (3).</p>

<p>Pour ce qui est de la lecture, D est plus <em>low-level</em> que Ruby, et
on doit lire par tranche de X caractères, et non pas par lignes. Ici on lit
la réponse par tranches de 1024 caractères et les retours à la ligne ne sont
pas supprimés comme en Ruby, d’où l’utilisation de <code>write</code> et non pas <code>writeln</code>.</p>

<p>```d
// Fichier gopher.d
import std.stdio;
import std.socket;</p>

<p>void main()
{
    // 1
    auto socket = new TcpSocket(new InternetAddress(“gopher.quux.org”, 70));</p>

<pre><code>// 2
socket.send("\r\n");

char[1024] buffer;
ptrdiff_t amountRead;

// 3
while((amountRead = socket.receive(buffer)) != 0) {
    write(buffer[0 .. amountRead]);
}

socket.close; } ```
</code></pre>

<h2 id="un-point-sur-le-point">Un point sur le point</h2>

<p>Comme beaucoup de protocoles de la même époque et avant lui, Gopher indique
qu’une réponse du serveur doit se terminer par un point (le caractère <code>.</code>)
isolé sur une ligne. Dans les faits, très peu de serveurs se complique la
vie avec ça.</p>

<p>N’hésitez pas à poster dans un commentaire ce petit programme traduit dans votre
langage favori. À bientôt.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Présentation de Gopher]]></title>
    <link href="http://lkdjiin.github.io/blog/2018/07/21/presentation-de-gopher/"/>
    <updated>2018-07-21T09:06:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2018/07/21/presentation-de-gopher</id>
    <content type="html"><![CDATA[<p>En 1997, ma maigre connexion internet était facturée chèrement à la seconde.
J’utilisai encore beaucoup Gopher qui était plus rapide que le web pour
chercher des documents purement textuels. À cette époque je ne m’intéressais
pas au fonctionnement de Gopher, je voulais seulement que ça aille vite.  21
ans après, alors que je redécouvre cette partie d’internet que j’avais oublié,
je vais prendre le temps de voir comment Gopher fonctionne.</p>

<!-- more -->

<ul>
  <li>Présentation de Gopher</li>
  <li><a href="/blog/2018/07/27/gopher-recuperer-le-menu-principal/">Gopher : Récupérer le menu principal</a></li>
</ul>

<p>Le protocole Gopher est très simple <em>“by design”</em>. D’abord un client contacte
un serveur, qui ne répond rien. Puis le client envoie l’identifiant d’une
ressource au serveur (un <em>selecteur</em> dans le jargon Gopher), qui envoie en
réponse le document ou le menu correspondant et ferme la connexion.
Et c’est presque tout. Un document est un fichier quelconque et un menu est un
fichier texte avec une structure minimale, voir même minimaliste.</p>

<p>Pour explorer Gopher, nous pourrions utiliser un client texte (<code>apt-get install
gopher</code>), ou un plugin pour notre navigateur. Mais pour voir un peu ce qu’il se
passe sous le capot, utilisons plutôt l’utilitaire <code>netcat</code> pour simuler un
client. Gopher écoute le port 70 par défaut :</p>

<pre><code>$ netcat gopher.quux.org 70
</code></pre>

<p>À ce moment la connexion est établie et le serveur attend que vous lui envoyiez
un sélecteur. Appuyez directement sur la touche Entrée pour envoyer un
sélecteur vide, ce qui a pour effet de selectionner le dossier courant sur le
serveur distant. Le serveur répond immédiatement avec quelques lignes
représentant un menu. En voici une sélection (j’ai remplacé les tabulations par
des <code>|</code>) :</p>

<pre><code>0About This Server|/About This Server.txt|gopher.quux.org|70
1Archives|/Archives|gopher.quux.org|70
</code></pre>

<p>Chaque ligne contient 5 zones séparées par une tabulation, à l’exception des
deux premières zones qui sont accollées :</p>

<ol>
  <li>Le type de document. Un 0 pour un document texte, un 1 pour un dossier. Il existe plusieurs autres types.</li>
  <li>La description du document. C’est une sorte de titre. Par exemple <code>About This Server</code>.</li>
  <li>Le sélecteur, qui identifie une ressource sur un serveur. Par exemple <code>/About This Server.txt</code>.</li>
  <li>L’adresse du serveur où se trouve la ressource.</li>
  <li>Le port utilisé par Gopher sur le serveur de la ressource.</li>
</ol>

<p>On voit à cette description que Gopher est une espèce de système de fichier distribué.</p>

<p>Pour suivre un lien du menu, on ouvre une nouvelle connexion :</p>

<pre><code>$ netcat gopher.quux.org 70
</code></pre>

<p>Et cette fois on envoie un sélecteur :</p>

<pre><code>/About This Server.txt
</code></pre>

<p>Le serveur envoie le document correspondant au sélecteur avant de fermer la connexion :</p>

<pre><code>Welcome to the gopher server at quux.org!

This is one of the world's few maintained, modern gopher servers.  On it,
you will find a huge collection of information, files, software, archives,
[...]
</code></pre>

<p>Les menus sont donc tout simplement des hyper-liens, comme dans le web. La
grande différence, c’est que dans le web les hyper-liens sont internes aux
documents, ce qui nécessite un langage (le HTML) pour écrire ces documents.
Alors qu’avec Gopher les liens sont externes aux documents, dans des menus ;
ils peuvent donc être dans n’importe quel format et écrit par n’importe qui, en
théorie.</p>

<p>Connaissiez vous Gopher ? L’avez vous déjà utilisé ? L’utiliser vous encore ?</p>

<p>À bientôt.</p>
]]></content>
  </entry>
  
</feed>
