<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : sed | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/sed/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2014-04-13T21:52:43+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Filtrer ses logs en direct]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/02/28/filtrer-ses-logs-en-direct/"/>
    <updated>2014-02-28T20:50:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/02/28/filtrer-ses-logs-en-direct</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Aujourd'hui on voit comment filtrer nos fichiers de log en direct à l'aide
des commandes UNIX <code>tail</code> et <code>sed</code>.</p>

<!-- more -->


<p>Pour afficher un fichier en direct live sur le terminal, autrement dit pour
visualiser au fur et à mesure les ajouts dans ce fichier, on utilise
<code>tail -f</code>:</p>

<p><code>bash
tail -f un/fichier/de/log
</code></p>

<p>Pour afficher <strong>uniquement</strong> les lignes d'un fichier qui contiennent la
chaîne de caractères <code>ERROR</code>, on va utiliser <code>sed</code>:</p>

<p><code>bash
sed -n '/ERROR/p' un/fichier/de/log
</code></p>

<p>Ou bien pour afficher toutes les lignes d'un fichier <strong>sauf</strong> celles qui
contiennent la chaîne de caractères <code>bruit</code>, on utilisera:</p>

<p><code>bash
sed '/bruit/d' un/fichier/de/log
</code></p>

<p>Et en combinant les deux, on aura un log en direct et filtré:</p>

<p><code>bash
tail -f un/fichier/de/log | sed -n '/ERROR/p'
</code></p>

<p>Et vous, vous utilisez quelle(s) commande(s) ?</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sed - Remplacer la n-ième occurence]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/02/25/sed-remplacer-la-n-ieme-occurence/"/>
    <updated>2014-02-25T21:10:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/02/25/sed-remplacer-la-n-ieme-occurence</id>
    <content type="html"><![CDATA[<p>J'adore Sed. Je l'utilise depuis de longues années. Et pourtant je n'avais
jamais remarqué qu'on pouvait remplacer la n-ième occurence d'un pattern
dans une ligne.</p>

<!-- more -->


<p>Soit le fichier <code>test</code> suivant:</p>

<pre><code>Bonjour le monde !
</code></pre>

<p>Pour remplacer le premier <code>o</code> par un <code>-</code>:</p>

<p><code>bash
sed 's/o/-/' test
</code></p>

<p>Pour remplacer tous les <code>o</code> par des <code>-</code>:</p>

<p><code>bash
sed 's/o/-/g' test
</code></p>

<p>Pour remplacer le deuxième <code>o</code> par un <code>-</code>:</p>

<p><code>bash
sed 's/o/-/2' test
</code></p>

<p>Sed, c'est magique !</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Remplacer Sed et Awk par Ruby: Récapitulatif]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/12/24/remplacer-sed-et-awk-par-ruby-recapitulatif/"/>
    <updated>2013-12-24T15:16:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/12/24/remplacer-sed-et-awk-par-ruby-recapitulatif</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>C'est la fin de cette série. Durant une quinzaine d'articles, on a vu
qu'il était possible de remplacer Sed ou Awk par Ruby, pour faire de
l'édition, de l'analyse ou du filtrage de fichier texte.
Cet article récapitule tout ce qu'on a vu.</p>

<!-- more -->


<p>Dans <a href="http://lkdjiin.github.io/blog/2013/11/29/remplacer-sed-et-awk-par-ruby/">Remplacer Sed et Awk par Ruby</a>
j'explique l'utilité des langages Sed et Awk, et pourquoi il peut-être
intéressant de les remplacer par Ruby.</p>

<p>Dans <a href="http://lkdjiin.github.io/blog/2013/11/30/remplacer-sed-et-awk-par-ruby-2-premiers-pas/">Premier pas</a>
on a appris à parcourir les lignes d'un fichier, à utiliser la variable
prédéfinie <code>$_</code> et on a approché les blocs BEGIN et END.</p>

<p>Dans <a href="http://lkdjiin.github.io/blog/2013/12/01/remplacer-sed-et-awk-par-ruby-3-begin-et-end/">BEGIN et END</a>
je parle en détail des blocs BEGIN et END.</p>

<p>Dans <a href="http://lkdjiin.github.io/blog/2013/12/04/remplacer-sed-et-awk-par-ruby-4-les-options-p-et-l/">Les options -p et -l</a>
on voit comment Ruby peut s'occuper automatiquement de l'affichage des lignes
et des caractères de fin de ligne.</p>

<p>Dans <a href="http://lkdjiin.github.io/blog/2013/12/05/remplacer-sed-et-awk-par-ruby-5-acceder-aux-champs-slash-colonnes/">Accéder aux champs/colonnes</a>
on voit que Ruby peut <em>splitter</em> automatiquement les différents champs d'une
ligne.</p>

<p>Dans <a href="http://lkdjiin.github.io/blog/2013/12/07/remplacer-sed-et-awk-par-ruby-6-separateur-de-champ/">Séparateur de champs</a>
je montre comment spécifier les séparateurs de champs.</p>

<p>Dans <a href="http://lkdjiin.github.io/blog/2013/12/08/remplacer-sed-et-awk-par-ruby-7-modifier-slash-sauvegarder-les-donnees/">Modifier/sauvegarder les données</a>
on apprend à modifier un fichier <em>en place</em> et à faire automatiquement une
copie de sauvegarde.</p>

<p>Dans <a href="http://lkdjiin.github.io/blog/2013/12/09/remplacer-sed-et-awk-par-ruby-8-script-sur-la-ligne-de-commande/">Scripts sur la ligne de commande</a>
je montre comment écrire un <em>one liner</em>.</p>

<p>Dans <a href="http://lkdjiin.github.io/blog/2013/12/10/remplacer-sed-et-awk-par-ruby-9-utiliser-la-bibliotheque-standard/">Utiliser la bibliothèque standard</a>
on voit comment charger une gem sur la ligne de commande.</p>

<p>Dans <a href="http://lkdjiin.github.io/blog/2013/12/14/remplacer-sed-et-awk-par-ruby-11-la-gem-english/">La gem English</a>
on apprend à utiliser des noms qui ont du sens à la place des variables
prédéfinies.</p>

<p>Dans <a href="http://lkdjiin.github.io/blog/2013/12/17/remplacer-sed-et-awk-par-ruby-12-numero-de-ligne/">Numéro de ligne</a>
on apprend que Ruby tient automatiquement le compte des numéros de ligne.</p>

<p>Dans <a href="http://lkdjiin.github.io/blog/2013/12/18/remplacer-sed-et-awk-par-ruby-13-separateurs-en-sortie/">Séparateurs en sortie</a>
on voit comment modifier les valeurs du séparateur de champs et du séparateur
d'enregistrements/lignes.</p>

<p>Dans <a href="http://lkdjiin.github.io/blog/2013/12/21/remplacer-sed-et-awk-par-ruby-flip-flop/">Flip flop</a>
je montre une technique très utilisée dans Sed ou Awk pour traiter des
groupes de lignes.</p>

<p>Enfin, dans
<a href="http://lkdjiin.github.io/blog/2013/12/12/remplacer-sed-et-awk-par-ruby-10-un-exemple-dutilisation/">Un exemple d'utilisation</a>
et <a href="http://lkdjiin.github.io/blog/2013/12/22/remplacer-sed-et-awk-par-ruby-un-dernier-exemple/">Un dernier exemple</a>
je montre deux exemples réels.</p>

<p>Voilà, avec cette série je pense que vous avez tout ce qu'il faut pour
traiter vos logs, fichiers csv et autres joyeusetées en Ruby. Joyeux Noël !</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Remplacer Sed et Awk par Ruby: Un dernier exemple]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/12/22/remplacer-sed-et-awk-par-ruby-un-dernier-exemple/"/>
    <updated>2013-12-22T20:58:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/12/22/remplacer-sed-et-awk-par-ruby-un-dernier-exemple</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Avant de mettre un terme à cette série d'articles, j'aimerais donner
un dernier exemple concret de l'utilisation de Ruby en <em>mode</em> Sed/Awk.
Il y a quelques jours, j'ai ajouté un bouton «flattr» à la fin des
quelques 160 articles de ce blog. Voici comment j'ai fait…</p>

<!-- more -->


<p>Tout d'abord le script Ruby:</p>

<p>``` ruby script.rb
BEGIN{code= &ldquo;code à insérer&rdquo;}</p>

<p>if $<em>.start_with?(&ldquo;À demain.&rdquo;)
  $</em> = &ldquo;\n\n#{code}\n\n#{$_}&rdquo;
end
```</p>

<p>Je cherche à insérer le code avant la chaîne &ldquo;À demain.&rdquo;, qui termine
chacun de mes articles. Si vous avez suivi cette série d'articles depuis
le début, j'espère que ce script parle de lui-même…
Notez quand même que ce script demande une version de Ruby supérieure
ou égale à 2.0, ou alors il faudra ajouter un commentaire <em>magique</em> pour
spécifier l'encodage utf-8.</p>

<p>Maintenant, comment appliquer ce script à chacun des articles. J'ai choisi
d'utiliser une boucle en Bash:</p>

<p><code>bash
[~]⇒ for i in *.markdown; do ruby -p -i script.rb $i; done
</code></p>

<p>Si vous avez besoin d'explications sur cette ligne de commande, je vous
renvoie à ces articles:</p>

<ul>
<li><a href="http://lkdjiin.github.io/blog/2013/12/04/remplacer-sed-et-awk-par-ruby-4-les-options-p-et-l/">ruby -p</a></li>
<li><a href="http://lkdjiin.github.io/blog/2013/12/08/remplacer-sed-et-awk-par-ruby-7-modifier-slash-sauvegarder-les-donnees/">ruby -i</a></li>
<li><a href="http://lkdjiin.github.io/blog/2013/08/23/bash-ajouter-une-ligne-a-la-fin-de-plusieurs-fichiers/">Les boucles en Bash</a></li>
</ul>


<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Remplacer Sed et Awk par Ruby: Flip flop]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/12/21/remplacer-sed-et-awk-par-ruby-flip-flop/"/>
    <updated>2013-12-21T18:44:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/12/21/remplacer-sed-et-awk-par-ruby-flip-flop</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Comment faire pour travailler sur un groupe de lignes, quand ce groupe
de lignes commence avec un marqueur et fini avec un autre ?
Par exemple, avec le fichier de données suivant, on cherche à afficher
les lignes depuis «start» jusqu'à «end»:</p>

<p><code>raw data.txt
1
2
3
start
4
5
6
end
7
8
9
</code></p>

<!-- more -->


<p>C'est ce qu'on appelle un <em>flip flop</em> : On commence le traitement sur une
condition de départ, puis on traite toutes les lignes jusqu'à une
condition d'arrêt. C'est un principe très utilisé avec Sed ou Awk.
Pour faire la même chose en Ruby, on va se servir d'un <em>range</em>:</p>

<p><code>ruby flip_flop.rb
puts $_ if $_.start_with?("start")..$_.start_with?("end")
</code></p>

<p><code>bash
[~]⇒ ruby -n flip_flop.rb data.txt
start
4
5
6
end
</code></p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
