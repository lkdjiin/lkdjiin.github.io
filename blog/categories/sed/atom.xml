<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : sed | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/sed/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2013-12-10T18:48:49+01:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Remplacer Sed et Awk par Ruby: 9 Utiliser la bibliothèque standard]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/12/10/remplacer-sed-et-awk-par-ruby-9-utiliser-la-bibliotheque-standard/"/>
    <updated>2013-12-10T18:40:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/12/10/remplacer-sed-et-awk-par-ruby-9-utiliser-la-bibliotheque-standard</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Se servir de Ruby pour remplacer Sed et Awk permet, entre autre, d'avoir accès
à la bibliothèque standard de Ruby (et même à n'importe quelle gem).  Pour un
script on peut charger les bibliothèques néccessaires dans un bloc BEGIN (avec
<code>require</code>), mais pour un <em>one liner</em>, ce serait beaucoup moins drôle. Ruby
permet de charger une gem sur la ligne de commande avec <code>-r</code>, une syntaxe plus
courte que <code>require</code>.</p>

<!-- more -->


<p>Tout au long de <a href="http://lkdjiin.github.io/blog/2013/11/29/remplacer-sed-et-awk-par-ruby/">cette série</a>, les exemples ont été triviaux et ça sera
encore le cas aujourd'hui. Prenons le fichier de données suivant:</p>

<p><code>raw data.txt
1
2
3
2
3
4
</code></p>

<p>L'objectif est d'afficher les différentes valeurs, <strong>sans doublons</strong>.
Pour le fichier ci-dessus, on veut donc obtenir: 1, 2, 3 et 4. Il y a plusieurs
solutions pour réaliser ça, l'une d'elles est d'utiliser <a href="http://ruby-doc.org/stdlib-2.0.0/libdoc/set/rdoc/Set.html">les sets</a>
fournis par la bibliothèque standard de Ruby.</p>

<p>Voici une ligne de commande qui réalise l'objectif:</p>

<p>``` bash
[~]⇒ ruby -nl -rset -e &lsquo;BEGIN{s=Set.new};s.add($_);END{p s}&rsquo; data.txt</p>

<h1>&lt;Set: {&ldquo;1&rdquo;, &ldquo;2&rdquo;, &ldquo;3&rdquo;, &ldquo;4&rdquo;}></h1>

<p>```</p>

<p>Le switch <code>-n</code> passe Ruby en <em>mode sed/awk</em>. Le switch <code>-l</code> s'occupe des
caractères de fin de ligne.</p>

<p>Le switch <code>-r</code> va charger la gem passée en argument. Donc <code>-rset</code> va charger
la gem «set».</p>

<p>Pour ce qui est du script, on commence par initialiser une variable <code>s</code> en
tant qu'objet Set:</p>

<pre><code>BEGIN { s = Set.new }
</code></pre>

<p>Puis on ajoute le contenu de chaque ligne dans ce set (comme il s'agit
justement d'un type Set, les doublons ne seront pas pris en compte):</p>

<pre><code>s.add($_)
</code></pre>

<p>Enfin, on affiche le résultat, <code>p s</code> étant un raccourci pour
<code>puts s.inspect</code>. Les raccourcis sont les bienvenus pour les <em>one liners</em>:</p>

<pre><code>END { p s }
</code></pre>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Remplacer Sed et Awk par Ruby 8: Script sur la ligne de commande]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/12/09/remplacer-sed-et-awk-par-ruby-8-script-sur-la-ligne-de-commande/"/>
    <updated>2013-12-09T20:36:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/12/09/remplacer-sed-et-awk-par-ruby-8-script-sur-la-ligne-de-commande</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Il est temps de se passer d'un fichier pour notre script… Lorsque celui-ci
est suffisament court, on peut l'écrire directement sur la ligne de
commande.</p>

<!-- more -->


<p>Si on reprend l'exemple tout simple du <a href="http://lkdjiin.github.io/blog/2013/12/08/remplacer-sed-et-awk-par-ruby-7-modifier-slash-sauvegarder-les-donnees/">dernier article</a>,
nous avions le fichier de données suivant à transformer <em>en place</em> en
majuscule:</p>

<p><code>raw data.txt
alice
bob
</code></p>

<p>Ce qu'on a fait à l'aide du script suivant:</p>

<p><code>ruby test.rb
$_.upcase!
</code></p>

<p>Autrement une seule ligne ! Est-ce que ça vaut vraiment la peine d'écrire
un fichier pour ça ? Bien sûr que non. On va donc se passer du fichier
script en donnant le code sur la ligne de commande grâce à l'option <code>-e</code>:</p>

<p><code>bash
ruby -p -i.2 -e '$_.upcase!' data.txt
</code></p>

<p>Et voilà, vous êtes maintenant prêts à écrire des <em>one liners</em>. Notez
quand même qu'il vaut mieux utiliser les guillemets simples (<code>'</code>) autour
du code plutôt que les doubles (<code>"</code>), pour empêcher Bash d'interpréter
certains caractères (comme ici le <code>!</code>).</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Remplacer Sed et Awk par Ruby 7: Modifier/sauvegarder les données]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/12/08/remplacer-sed-et-awk-par-ruby-7-modifier-slash-sauvegarder-les-donnees/"/>
    <updated>2013-12-08T19:30:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/12/08/remplacer-sed-et-awk-par-ruby-7-modifier-slash-sauvegarder-les-donnees</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Parfois on veut analyser un fichier, et parfois on veut le modifier.
Si on suit la logique de <a href="http://lkdjiin.github.io/blog/2013/11/29/remplacer-sed-et-awk-par-ruby/">cette série d'articles</a>, Ruby devrait offrir
un switch permettant de modifier un fichier sans avoir à l'enregistrer
explicitement. Et je ne vais pas vous surprendre
en vous apprenant qu'un tel switch existe, il s'agit de l'option
<code>-i</code>, qui permet aussi de sauvegarder l'ancien fichier.</p>

<!-- more -->


<p>L'exemple d'aujourd'hui est encore plus trivial que d'habitude ;) Voici
le fichier de données:</p>

<p><code>raw data.txt
alice
bob
</code></p>

<p>Ce que je voudrais, c'est simplement tout mettre en majuscule. Ce que
permet le script suivant:</p>

<p><code>ruby test.rb
$_.upcase!
</code></p>

<p>Si on lance le script comme on sait le faire maintenant
(voir par exemple <a href="http://lkdjiin.github.io/blog/2013/12/07/remplacer-sed-et-awk-par-ruby-6-separateur-de-champ/">l'article précédant</a>), on obtient un bel
affichage:</p>

<pre><code>[~/test]⇒ ruby -p test.rb data.txt 
ALICE
BOB
</code></pre>

<p>Mais le fichier lui-même n'a pas changé:</p>

<pre><code>[~/test]⇒ cat data.txt
alice
bob
</code></pre>

<p>Si on veut modifier le fichier, on doit se servir de l'option <code>-i</code> en
spécifiant l'extension qui sera ajouter au fichier original sauvegardé,
ici <code>.2</code>:</p>

<pre><code>[~/test]⇒ ruby -p -i.2 test.rb data.txt 
</code></pre>

<p>Et voilà, on a bien les deux fichiers attendus:</p>

<pre><code>[~/test]⇒ ls data*
data.txt  data.txt.2
</code></pre>

<p>Notre fichier est bien modifié:</p>

<pre><code>[~/test]⇒ cat data.txt
ALICE
BOB
</code></pre>

<p>Et il est bien sauvegardé:</p>

<pre><code>[~/test]⇒ cat data.txt.2
alice
bob
</code></pre>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Remplacer Sed et Awk par Ruby 6: Séparateur de champ]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/12/07/remplacer-sed-et-awk-par-ruby-6-separateur-de-champ/"/>
    <updated>2013-12-07T20:54:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/12/07/remplacer-sed-et-awk-par-ruby-6-separateur-de-champ</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Aujourd'hui on voit comment changer le séparateur de champ à l'aide de
l'option <code>-F</code>.</p>

<!-- more -->


<p>Reprenons le fichier de données du <a href="http://lkdjiin.github.io/blog/2013/12/05/remplacer-sed-et-awk-par-ruby-5-acceder-aux-champs-slash-colonnes/">dernier article</a>,
ajoutons un séparateur de champ, par exemple la virgule (<code>,</code>) et
<em>salissons-le</em> quelque peu:</p>

<p><code>raw data.txt
1, a
2, a
3, b
4 , a
5 ,a
6 ,b
7,b
8,b
9,b
</code></p>

<p>Le script du dernier article ne fonctionnera plus, puisque jusqu'ici nous
supposions que les champs étaient séparés par des espaces, ce qui n'est plus
le cas.</p>

<p>En admettant que les champs seront séparés par des virgules, il faut effectuer
un petit changement dans notre script, pour nettoyer le second champ:</p>

<p>``` ruby test.rb
BEGIN { total = 0 }</p>

<p>total += $F[0].to_i if $F[1].strip == &ldquo;a&rdquo;</p>

<p>END { puts &ldquo;Total: #{total}&rdquo; }
```</p>

<p>Et pour que Ruby sépare bien les champs en tenant compte des virgules, il faut
lui passer l'option <code>-F</code>, suivie d'une <em>regex</em> (sans les <code>//</code>) décrivant
le séparateur:</p>

<pre><code>[~]⇒ ruby -an -F, test.rb &lt; data.txt 
Total: 12
</code></pre>

<p>Et voilà.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Remplacer Sed et Awk par Ruby 5: Accéder aux champs/colonnes]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/12/05/remplacer-sed-et-awk-par-ruby-5-acceder-aux-champs-slash-colonnes/"/>
    <updated>2013-12-05T19:12:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/12/05/remplacer-sed-et-awk-par-ruby-5-acceder-aux-champs-slash-colonnes</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Toujours dans l'optique de remplacer Sed et Awk par Ruby,
et après avoir vu <a href="http://lkdjiin.github.io/blog/2013/12/04/remplacer-sed-et-awk-par-ruby-4-les-options-p-et-l/">les options -p et -l</a>, on voit
comment accéder facilement aux différentes colonnes
d'un fichier.</p>

<!-- more -->


<p>Voici le fichier de données tout simple qui va nous servir aujourd'hui:</p>

<p><code>raw data.txt
1 a
2 a
3 b
4 a
5 a
6 b
7 b
8 b
9 b
</code></p>

<p>L'objectif est de calculer la somme des valeurs de la 1ère colonne,
uniquement quand la 2e colonne affiche <code>a</code>. On pourrait bien sûr splitter
la ligne (<code>$_</code>) pour obtenir nos champs, mais il y a plus rapide.
En activant l'option <code>-a</code> de la ligne de commande, Ruby va automatiquement
splitter chaque lignes du fichier de données dans la variable prédéfinie
<code>$F</code> (pour <em>Fields</em>). On n'a donc rien à faire ;) et on peut se concentrer
sur les calculs:</p>

<p>``` ruby test.rb
BEGIN { total = 0 }</p>

<p>total += $F[0].to_i if $F[1] == &ldquo;a&rdquo;</p>

<p>END { puts &ldquo;Total: #{total}&rdquo; }
```</p>

<pre><code>[~]⇒ ruby -an test.rb &lt; data.txt 
Total: 12
</code></pre>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
