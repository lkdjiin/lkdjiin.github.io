<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : sed | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/sed/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2013-12-07T20:59:22+01:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Remplacer Sed et Awk par Ruby 6: Séparateur de champ]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/12/07/remplacer-sed-et-awk-par-ruby-6-separateur-de-champ/"/>
    <updated>2013-12-07T20:54:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/12/07/remplacer-sed-et-awk-par-ruby-6-separateur-de-champ</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Aujourd'hui on voit comment changer le séparateur de champ à l'aide de
l'option <code>-F</code>.</p>

<!-- more -->


<p>Reprenons le fichier de données du <a href="http://lkdjiin.github.io/blog/2013/12/05/remplacer-sed-et-awk-par-ruby-5-acceder-aux-champs-slash-colonnes/">dernier article</a>,
ajoutons un séparateur de champ, par exemple la virgule (<code>,</code>) et
<em>salissons-le</em> quelque peu:</p>

<p><code>raw data.txt
1, a
2, a
3, b
4 , a
5 ,a
6 ,b
7,b
8,b
9,b
</code></p>

<p>Le script du dernier article ne fonctionnera plus, puisque jusqu'ici nous
supposions que les champs étaient séparés par des espaces, ce qui n'est plus
le cas.</p>

<p>En admettant que les champs seront séparés par des virgules, il faut effectuer
un petit changement dans notre script, pour nettoyer le second champ:</p>

<p>``` ruby test.rb
BEGIN { total = 0 }</p>

<p>total += $F[0].to_i if $F[1].strip == &ldquo;a&rdquo;</p>

<p>END { puts &ldquo;Total: #{total}&rdquo; }
```</p>

<p>Et pour que Ruby sépare bien les champs en tenant compte des virgules, il faut
lui passer l'option <code>-F</code>, suivie d'une <em>regex</em> (sans les <code>//</code>) décrivant
le séparateur:</p>

<pre><code>[~]⇒ ruby -an -F, test.rb &lt; data.txt 
Total: 12
</code></pre>

<p>Et voilà.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Remplacer Sed et Awk par Ruby 5: Accéder aux champs/colonnes]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/12/05/remplacer-sed-et-awk-par-ruby-5-acceder-aux-champs-slash-colonnes/"/>
    <updated>2013-12-05T19:12:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/12/05/remplacer-sed-et-awk-par-ruby-5-acceder-aux-champs-slash-colonnes</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Toujours dans l'optique de remplacer Sed et Awk par Ruby,
et après avoir vu <a href="http://lkdjiin.github.io/blog/2013/12/04/remplacer-sed-et-awk-par-ruby-4-les-options-p-et-l/">les options -p et -l</a>, on voit
comment accéder facilement aux différentes colonnes
d'un fichier.</p>

<!-- more -->


<p>Voici le fichier de données tout simple qui va nous servir aujourd'hui:</p>

<p><code>raw data.txt
1 a
2 a
3 b
4 a
5 a
6 b
7 b
8 b
9 b
</code></p>

<p>L'objectif est de calculer la somme des valeurs de la 1ère colonne,
uniquement quand la 2e colonne affiche <code>a</code>. On pourrait bien sûr splitter
la ligne (<code>$_</code>) pour obtenir nos champs, mais il y a plus rapide.
En activant l'option <code>-a</code> de la ligne de commande, Ruby va automatiquement
splitter chaque lignes du fichier de données dans la variable prédéfinie
<code>$F</code> (pour <em>Fields</em>). On n'a donc rien à faire ;) et on peut se concentrer
sur les calculs:</p>

<p>``` ruby test.rb
BEGIN { total = 0 }</p>

<p>total += $F[0].to_i if $F[1] == &ldquo;a&rdquo;</p>

<p>END { puts &ldquo;Total: #{total}&rdquo; }
```</p>

<pre><code>[~]⇒ ruby -an test.rb &lt; data.txt 
Total: 12
</code></pre>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Remplacer Sed et Awk par Ruby 4: Les options -p et -l]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/12/04/remplacer-sed-et-awk-par-ruby-4-les-options-p-et-l/"/>
    <updated>2013-12-04T21:21:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/12/04/remplacer-sed-et-awk-par-ruby-4-les-options-p-et-l</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Les options -p et -l de la ligne de commande de Ruby permettent de se
rapprocher encore un peu plus du comportement de Sed et Awk.  On reprend notre
fichier tout simple:</p>

<p><code>raw data.txt
1
2
3
4
5
6
7
8
9
</code></p>

<p>Aujourd'hui l'objectif est d'ajouter une nouvelle colonne, qui nous dit si
le nombre est pair (p) ou impair (i). C'est un exemple trivial, mais
suffisant pour ce que je veux montrer.</p>

<!-- more -->


<h2>Un premier script déjà concis</h2>

<p>Voici un premier code possible, avec ce que nous connaissons déjà, c'est
à dire l'option -n:</p>

<p><code>ruby test1.rb
$_ = $_.chomp + ($_.to_i.even? ? " p" : " i")
puts $_
</code></p>

<pre><code>[~]⇒ ruby -n test1.rb &lt; data.txt 
1 i
2 p
3 i
4 p
5 i
6 p
7 i
8 p
9 i
</code></pre>

<p>On peut noter que:</p>

<ul>
<li>contrairement à l'exemple précédent, on n'utilise pas les blocs BEGIN et
END (voir <a href="http://lkdjiin.github.io/blog/2013/11/30/remplacer-sed-et-awk-par-ruby-2-premiers-pas/">Premiers pas</a>
et <a href="http://lkdjiin.github.io/blog/2013/12/01/remplacer-sed-et-awk-par-ruby-3-begin-et-end/">BEGIN et END</a>).</li>
<li>la variable prédéfinie <code>$_</code> est <strong>accessible en écriture</strong>.</li>
<li>la variable prédéfinie <code>$_</code> contient le caractère de fin de ligne, il a
fallu le supprimer avec <code>chomp</code>. C'est agaçant.</li>
<li>on écrit chaque nouvelle ligne avec <code>puts</code>. C'est un pattern classique,
il doit bien y avoir un truc pour nous éviter cela.</li>
</ul>


<h2>La même chose en plus court</h2>

<p>Voici maintenant une réécriture du script ci-dessus, qui tire parti
des options -p et -l:</p>

<p><code>ruby test2.rb
$_ += $_.to_i.even? ? " p" : " i"
</code></p>

<pre><code>[~]⇒ ruby -pl test2.rb &lt; data.txt 
1 i
2 p
3 i
4 p
5 i
6 p
7 i
8 p
9 i
</code></pre>

<h2>Les explications de -p et -l</h2>

<p>L'option -p fonctionne comme l'option -n, mais en plus, affiche automatiquement
le contenu de la variable <code>$_</code> à la fin de la boucle de traitement.</p>

<p>L'option -l, quant à elle, s'occupe automatiquement du caractère de fin
de ligne en le supprimant.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Remplacer Sed et Awk par Ruby 3: BEGIN et END]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/12/01/remplacer-sed-et-awk-par-ruby-3-begin-et-end/"/>
    <updated>2013-12-01T21:23:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/12/01/remplacer-sed-et-awk-par-ruby-3-begin-et-end</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Les blocs BEGIN et END du langage Ruby paraissent étranges pour beaucoup
de personnes. Ils sont inutiles (et certainement néfastes) pour des
programmes dit <em>classiques</em>. Ils peuvent être utiles pour un script.
Il sont indispensables pour remplacer Sed et Awk et on va donc les
regarder plus en détail.</p>

<!-- more -->


<p>Un exemple simple vaut mieux qu'un long discours:</p>

<p><code>ruby test1.rb
BEGIN { puts "avant" }
END { puts "après" }
puts "au milieu"
</code></p>

<pre><code>[~]⇒ ruby test1.rb 
avant
au milieu
après
</code></pre>

<p><code>BEGIN</code> est donc l'endroit où on initialisera les variables et <code>END</code>
permettra de faire les calculs et l'affichage en fin de traitement.</p>

<p>Il faut savoir qu'on peut avoir plusieurs blocs
<code>BEGIN</code> et <code>END</code>. Les blocs <code>BEGIN</code> seront interprétés dans l'ordre
d'apparition, tandis que les blocs <code>END</code> seront interprétés dans l'ordre
inverse d'apparition:</p>

<p><code>ruby test2.rb
END { puts "end 1" }
END { puts "end 2" }
END { puts "end 3" }
BEGIN { puts "begin 1" }
BEGIN { puts "begin 2" }
BEGIN { puts "begin 3" }
</code></p>

<pre><code>[~]⇒ ruby test2.rb
begin 1
begin 2
begin 3
end 3
end 2
end 1
</code></pre>

<p>Enfin, pour être exhaustif, on ne peut pas remplacer les <code>{}</code> par <code>do</code>
et <code>end</code>, comme on pourrait s'y attendre:</p>

<p><code>ruby test3.rb
BEGIN do
  puts "avant"
end
</code></p>

<pre><code>[~]⇒ ruby test3.rb
test3.rb:1: syntax error, unexpected keyword_do, expecting '{'
test3.rb:3: syntax error, unexpected keyword_end, expecting end-of-input
</code></pre>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Remplacer Sed et Awk par Ruby 2: Premiers pas]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/11/30/remplacer-sed-et-awk-par-ruby-2-premiers-pas/"/>
    <updated>2013-11-30T16:29:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/11/30/remplacer-sed-et-awk-par-ruby-2-premiers-pas</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Vous avez décidé de <a href="http://lkdjiin.github.io/blog/2013/11/29/remplacer-sed-et-awk-par-ruby/">remplacer Sed et Awk par Ruby</a> ? C'est parti.
L'objectif de cet article sera de calculer et d'afficher la somme des
valeurs contenues dans un fichier.</p>

<p>Prenons le simple fichier de données (data.txt) suivant:</p>

<p><code>raw data.txt
1
2
3
4
5
6
7
8
9
</code></p>

<!-- more -->


<h2>Hello world!</h2>

<p>Le premier pas sera d'afficher chaque ligne du fichier de données. Voici le
script Ruby qui va faire ça:</p>

<p><code>ruby test1.rb
puts $_
</code></p>

<p>La variable <code>$_</code> est une variable prédéfinie qui contient la ligne en cours
de traitement. Dans <a href="http://lkdjiin.github.io/blog/2013/11/29/remplacer-sed-et-awk-par-ruby/">l'article précédent</a>, j'évoquai la boucle de traitement
implicite. Pour dire à Ruby d'utiliser cette boucle implicite, on doit
utiliser l'option <code>-n</code> sur la ligne de commande:</p>

<p><code>bash
[~]⇒ ruby -n test1.rb &lt; data.txt
1
2
3
4
5
6
7
8
9
</code></p>

<h2>BEGIN et END</h2>

<p>Pour calculer la somme des valeurs du fichier, il va falloir initialiser
une variable <em>avant</em> la boucle de traitement et l'afficher <em>après</em> la
boucle de traitement. Pour ça, Ruby reprend ce que fait Awk avec les
blocs <code>BEGIN {}</code> et <code>END {}</code>:</p>

<p>``` ruby one_shot.rb
BEGIN { total = 0 }</p>

<p>total += $_.to_i</p>

<p>END { puts total }
```</p>

<p>Le code placé dans un bloc <code>BEGIN</code> est executé avant tout autre code du
fichier. Celui placé dans un bloc <code>END</code> est executé après tout autre code
du fichier. Objectif atteint:</p>

<p><code>bash
[~]⇒ ruby -n one_shot.rb &lt; data.txt
45
</code></p>

<p>Il faut noter qu'on a réussi notre objectif sans avoir explicitement à ouvrir
le fichier et à lire chaque ligne.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
