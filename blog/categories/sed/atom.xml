<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : sed | Xavier Nayrac]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/sed/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2017-01-20T14:26:30+01:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Utiliser Bash pour supprimer les encodages magiques de Ruby 1.9]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/08/06/utiliser-bash-pour-supprimer-les-encodages-magiques-de-ruby-1-dot-9/"/>
    <updated>2015-08-06T17:27:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/08/06/utiliser-bash-pour-supprimer-les-encodages-magiques-de-ruby-1-dot-9</id>
    <content type="html"><![CDATA[<p>Si vous avez travaillé sur des projets écrit avec Ruby 1.9, vous avez peut-être
utilisé les encodages magiques (souvent appelés <em>magic comment</em>). Il s’agit
d’un commentaire en début de fichier qui définit l’encodage :</p>

<p><code>ruby
# -*- encoding: UTF-8 -*-
</code></p>

<p>Récemment j’ai passé plusieurs projets de Ruby 1.9.x à Ruby 2.x et j’ai
naturellement voulu supprimer ces <em>directives d’encodage</em> qui ne sont plus
nécessaires.</p>

<p>J’imagine qu’un IDE ou un autre doit être capable de faire ça (<code>&lt;mode troll&gt;</code>
sinon quel intérêt à utiliser un IDE ? <code>&lt;/mode troll&gt;</code>). Toujours est-il que
quelques commandes dans Bash et hop, terminé ;)</p>

<p>Voici comment faire, sans trop entrer dans les détails. J’espère juste vous
donner envie d’utiliser Bash, ou un autre shell (si ça n’est pas déjà le cas).</p>

<!-- more -->

<p>De quoi a-t-on besoin ?  <code>find</code>, <code>sed</code> et <code>xargs</code> :</p>

<p><code>bash
$ find . -type f -name '*.rb' | xargs sed -i '1{/encoding/d}'
$ find . -type f -name '*.rb' | xargs sed -i -n '/./,$p'
</code></p>

<p>La première commande efface la première ligne des fichiers ruby si cette
ligne contient <code>encoding</code>. La seconde commande enlève la première ligne si
cette ligne est vide.</p>

<h2 id="find">find</h2>

<pre><code>find . -type f -name '*.rb'
</code></pre>

<p>Cherche tout les fichiers dont le nom se termine par <code>.rb</code> et les affichent
les uns après les autres.  Ça donne quelque chose comme ça :</p>

<pre><code>./fichier1.rb
./fichier2.rb
./dossier1/fichier1.rb
./dossier1/fichier2.rb
./dossier2/fichier1.rb
[...]
</code></pre>

<h2 id="xargs">xargs</h2>

<p>Pour donner les noms de fichier à manger à sed, il faut qu’ils soient sur une
seule ligne. C’est à dire les uns à coté des autres comme on écrirait des
paramètres, et pas les uns en dessous des autres comme ce qui sort de <code>find</code>.</p>

<p>Voilà donc <code>xargs</code> :</p>

<p><code>bash
$ echo -e "a\nb\nc"
a
b
c
$ echo -e "a\nb\nc" | xargs
a b c
</code></p>

<p>– <em>Le switch <code>-e</code> de echo interprète la séquence \n comme un saut de ligne.</em> —</p>

<h2 id="sed">sed</h2>

<p>Le switch <code>-i</code> c’est pour <em>in place</em>. On modifie vraiment les fichiers.</p>

<pre><code>sed -i '1{/encoding/d}'
</code></pre>

<p>Supprime (<code>d</code>) la ligne qui contient <code>encoding</code>. Ne s’applique qu’à la 1ère
ligne <code>1{}</code>.</p>

<pre><code>sed -i -n '/./,$p'
</code></pre>

<p>Supprime la 1ère ligne si elle est vide. Je trouve que cette ligne mérite bien
un article à elle toute seule. Alors son explication sera pour une prochaine
fois ;)</p>

<p>Et vous, comment auriez vous fait ? Avec un shell ? Un IDE ?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ce que je n'ai pas fait cette 14ème semaine de 2015]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/04/05/ce-que-je-nai-pas-fait-cette-14eme-semaine-de-2015/"/>
    <updated>2015-04-05T20:15:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/04/05/ce-que-je-nai-pas-fait-cette-14eme-semaine-de-2015</id>
    <content type="html"><![CDATA[<p>Je n’ai pas commencé à bloguer en anglais, mais ça ne saurait tarder. Il me
reste à choisir quelle techno utiliser. J’hésite entre :</p>

<ol>
  <li>Jekyll (que je connais bien)</li>
  <li><a href="http://www.metalsmith.io">metalsmith</a> (pour sortir de ma zone de comfort)</li>
  <li>rake, cat, <a href="http://en.wikipedia.org/wiki/M4_%28computer_language%29">m4</a>, sed, etc (sans rire ! pour un retour aux sources)</li>
</ol>

<p>Vous me conseillez quoi ?</p>

<!-- more -->

<p>Sinon, je n’ai pas encore lu <a href="http://en.wikipedia.org/wiki/Super-Cannes">Super-Cannes</a> de J.G. Ballard, que je me suis offert
il y a 2 semaines. J’ai plus envie de lire de la fiction en ce moment, j’espère
que ça va revenir vite.</p>

<p>Et vous ? Que n’avez-vous pas fait cette semaine ?</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Filtrer ses logs en direct]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/02/28/filtrer-ses-logs-en-direct/"/>
    <updated>2014-02-28T20:50:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/02/28/filtrer-ses-logs-en-direct</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Aujourd’hui on voit comment filtrer nos fichiers de log en direct à l’aide
des commandes UNIX <code>tail</code> et <code>sed</code>.</p>

<!-- more -->

<p>Pour afficher un fichier en direct live sur le terminal, autrement dit pour
visualiser au fur et à mesure les ajouts dans ce fichier, on utilise
<code>tail -f</code>:</p>

<p><code>bash
tail -f un/fichier/de/log
</code></p>

<p>Pour afficher <strong>uniquement</strong> les lignes d’un fichier qui contiennent la
chaîne de caractères <code>ERROR</code>, on va utiliser <code>sed</code>:</p>

<p><code>bash
sed -n '/ERROR/p' un/fichier/de/log
</code></p>

<p>Ou bien pour afficher toutes les lignes d’un fichier <strong>sauf</strong> celles qui
contiennent la chaîne de caractères <code>bruit</code>, on utilisera:</p>

<p><code>bash
sed '/bruit/d' un/fichier/de/log
</code></p>

<p>Et en combinant les deux, on aura un log en direct et filtré:</p>

<p><code>bash
tail -f un/fichier/de/log | sed -n '/ERROR/p'
</code></p>

<p>Et vous, vous utilisez quelle(s) commande(s) ?</p>

<script id="fb33k8u">(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>

<p>À demain.</p>

<p></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sed - Remplacer la n-ième occurence]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/02/25/sed-remplacer-la-n-ieme-occurence/"/>
    <updated>2014-02-25T21:10:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/02/25/sed-remplacer-la-n-ieme-occurence</id>
    <content type="html"><![CDATA[<p>J’adore Sed. Je l’utilise depuis de longues années. Et pourtant je n’avais
jamais remarqué qu’on pouvait remplacer la n-ième occurence d’un pattern
dans une ligne.</p>

<!-- more -->

<p>Soit le fichier <code>test</code> suivant:</p>

<pre><code>Bonjour le monde !
</code></pre>

<p>Pour remplacer le premier <code>o</code> par un <code>-</code>:</p>

<p><code>bash
sed 's/o/-/' test
</code></p>

<p>Pour remplacer tous les <code>o</code> par des <code>-</code>:</p>

<p><code>bash
sed 's/o/-/g' test
</code></p>

<p>Pour remplacer le deuxième <code>o</code> par un <code>-</code>:</p>

<p><code>bash
sed 's/o/-/2' test
</code></p>

<p>Sed, c’est magique !</p>

<script id="fb33k8u">(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>

<p>À demain.</p>

<p></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Remplacer Sed et Awk par Ruby: Récapitulatif]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/12/24/remplacer-sed-et-awk-par-ruby-recapitulatif/"/>
    <updated>2013-12-24T15:16:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/12/24/remplacer-sed-et-awk-par-ruby-recapitulatif</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>C’est la fin de cette série. Durant une quinzaine d’articles, on a vu
qu’il était possible de remplacer Sed ou Awk par Ruby, pour faire de
l’édition, de l’analyse ou du filtrage de fichier texte.
Cet article récapitule tout ce qu’on a vu.</p>

<!-- more -->

<p>Dans <a href="http://lkdjiin.github.io/blog/2013/11/29/remplacer-sed-et-awk-par-ruby/">Remplacer Sed et Awk par Ruby</a>
j’explique l’utilité des langages Sed et Awk, et pourquoi il peut-être
intéressant de les remplacer par Ruby.</p>

<p>Dans <a href="http://lkdjiin.github.io/blog/2013/11/30/remplacer-sed-et-awk-par-ruby-2-premiers-pas/">Premier pas</a>
on a appris à parcourir les lignes d’un fichier, à utiliser la variable
prédéfinie <code>$_</code> et on a approché les blocs BEGIN et END.</p>

<p>Dans <a href="http://lkdjiin.github.io/blog/2013/12/01/remplacer-sed-et-awk-par-ruby-3-begin-et-end/">BEGIN et END</a>
je parle en détail des blocs BEGIN et END.</p>

<p>Dans <a href="http://lkdjiin.github.io/blog/2013/12/04/remplacer-sed-et-awk-par-ruby-4-les-options-p-et-l/">Les options -p et -l</a>
on voit comment Ruby peut s’occuper automatiquement de l’affichage des lignes
et des caractères de fin de ligne.</p>

<p>Dans <a href="http://lkdjiin.github.io/blog/2013/12/05/remplacer-sed-et-awk-par-ruby-5-acceder-aux-champs-slash-colonnes/">Accéder aux champs/colonnes</a>
on voit que Ruby peut <em>splitter</em> automatiquement les différents champs d’une
ligne.</p>

<p>Dans <a href="http://lkdjiin.github.io/blog/2013/12/07/remplacer-sed-et-awk-par-ruby-6-separateur-de-champ/">Séparateur de champs</a>
je montre comment spécifier les séparateurs de champs.</p>

<p>Dans <a href="http://lkdjiin.github.io/blog/2013/12/08/remplacer-sed-et-awk-par-ruby-7-modifier-slash-sauvegarder-les-donnees/">Modifier/sauvegarder les données</a>
on apprend à modifier un fichier <em>en place</em> et à faire automatiquement une
copie de sauvegarde.</p>

<p>Dans <a href="http://lkdjiin.github.io/blog/2013/12/09/remplacer-sed-et-awk-par-ruby-8-script-sur-la-ligne-de-commande/">Scripts sur la ligne de commande</a>
je montre comment écrire un <em>one liner</em>.</p>

<p>Dans <a href="http://lkdjiin.github.io/blog/2013/12/10/remplacer-sed-et-awk-par-ruby-9-utiliser-la-bibliotheque-standard/">Utiliser la bibliothèque standard</a>
on voit comment charger une gem sur la ligne de commande.</p>

<p>Dans <a href="http://lkdjiin.github.io/blog/2013/12/14/remplacer-sed-et-awk-par-ruby-11-la-gem-english/">La gem English</a>
on apprend à utiliser des noms qui ont du sens à la place des variables
prédéfinies.</p>

<p>Dans <a href="http://lkdjiin.github.io/blog/2013/12/17/remplacer-sed-et-awk-par-ruby-12-numero-de-ligne/">Numéro de ligne</a>
on apprend que Ruby tient automatiquement le compte des numéros de ligne.</p>

<p>Dans <a href="http://lkdjiin.github.io/blog/2013/12/18/remplacer-sed-et-awk-par-ruby-13-separateurs-en-sortie/">Séparateurs en sortie</a>
on voit comment modifier les valeurs du séparateur de champs et du séparateur
d’enregistrements/lignes.</p>

<p>Dans <a href="http://lkdjiin.github.io/blog/2013/12/21/remplacer-sed-et-awk-par-ruby-flip-flop/">Flip flop</a>
je montre une technique très utilisée dans Sed ou Awk pour traiter des
groupes de lignes.</p>

<p>Enfin, dans
<a href="http://lkdjiin.github.io/blog/2013/12/12/remplacer-sed-et-awk-par-ruby-10-un-exemple-dutilisation/">Un exemple d’utilisation</a>
et <a href="http://lkdjiin.github.io/blog/2013/12/22/remplacer-sed-et-awk-par-ruby-un-dernier-exemple/">Un dernier exemple</a>
je montre deux exemples réels.</p>

<p>Voilà, avec cette série je pense que vous avez tout ce qu’il faut pour
traiter vos logs, fichiers csv et autres joyeusetées en Ruby. Joyeux Noël !</p>

<script id="fb33k8u">(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>

<p>À demain.</p>

<p></p>

]]></content>
  </entry>
  
</feed>
