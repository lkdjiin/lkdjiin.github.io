<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : sed | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/sed/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2013-12-09T21:07:53+01:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Remplacer Sed et Awk par Ruby 8: Script sur la ligne de commande]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/12/09/remplacer-sed-et-awk-par-ruby-8-script-sur-la-ligne-de-commande/"/>
    <updated>2013-12-09T20:36:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/12/09/remplacer-sed-et-awk-par-ruby-8-script-sur-la-ligne-de-commande</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Il est temps de se passer d'un fichier pour notre script… Lorsque celui-ci
est suffisament court, on peut l'écrire directement sur la ligne de
commande.</p>

<!-- more -->


<p>Si on reprend l'exemple tout simple du <a href="http://lkdjiin.github.io/blog/2013/12/08/remplacer-sed-et-awk-par-ruby-7-modifier-slash-sauvegarder-les-donnees/">dernier article</a>,
nous avions le fichier de données suivant à transformer <em>en place</em> en
majuscule:</p>

<p><code>raw data.txt
alice
bob
</code></p>

<p>Ce qu'on a fait à l'aide du script suivant:</p>

<p><code>ruby test.rb
$_.upcase!
</code></p>

<p>Autrement une seule ligne ! Est-ce que ça vaut vraiment la peine d'écrire
un fichier pour ça ? Bien sûr que non. On va donc se passer du fichier
script en donnant le code sur la ligne de commande grâce à l'option <code>-e</code>:</p>

<p><code>bash
ruby -p -i.2 -e '$_.upcase!' data.txt
</code></p>

<p>Et voilà, vous êtes maintenant prêts à écrire des <em>one liners</em>. Notez
quand même qu'il vaut mieux utiliser les guillemets simples (<code>'</code>) autour
du code plutôt que les doubles (<code>"</code>), pour empêcher Bash d'interpréter
certains caractères (comme ici le <code>!</code>).</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Remplacer Sed et Awk par Ruby 7: Modifier/sauvegarder les données]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/12/08/remplacer-sed-et-awk-par-ruby-7-modifier-slash-sauvegarder-les-donnees/"/>
    <updated>2013-12-08T19:30:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/12/08/remplacer-sed-et-awk-par-ruby-7-modifier-slash-sauvegarder-les-donnees</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Parfois on veut analyser un fichier, et parfois on veut le modifier.
Si on suit la logique de <a href="http://lkdjiin.github.io/blog/2013/11/29/remplacer-sed-et-awk-par-ruby/">cette série d'articles</a>, Ruby devrait offrir
un switch permettant de modifier un fichier sans avoir à l'enregistrer
explicitement. Et je ne vais pas vous surprendre
en vous apprenant qu'un tel switch existe, il s'agit de l'option
<code>-i</code>, qui permet aussi de sauvegarder l'ancien fichier.</p>

<!-- more -->


<p>L'exemple d'aujourd'hui est encore plus trivial que d'habitude ;) Voici
le fichier de données:</p>

<p><code>raw data.txt
alice
bob
</code></p>

<p>Ce que je voudrais, c'est simplement tout mettre en majuscule. Ce que
permet le script suivant:</p>

<p><code>ruby test.rb
$_.upcase!
</code></p>

<p>Si on lance le script comme on sait le faire maintenant
(voir par exemple <a href="http://lkdjiin.github.io/blog/2013/12/07/remplacer-sed-et-awk-par-ruby-6-separateur-de-champ/">l'article précédant</a>), on obtient un bel
affichage:</p>

<pre><code>[~/test]⇒ ruby -p test.rb data.txt 
ALICE
BOB
</code></pre>

<p>Mais le fichier lui-même n'a pas changé:</p>

<pre><code>[~/test]⇒ cat data.txt
alice
bob
</code></pre>

<p>Si on veut modifier le fichier, on doit se servir de l'option <code>-i</code> en
spécifiant l'extension qui sera ajouter au fichier original sauvegardé,
ici <code>.2</code>:</p>

<pre><code>[~/test]⇒ ruby -p -i.2 test.rb data.txt 
</code></pre>

<p>Et voilà, on a bien les deux fichiers attendus:</p>

<pre><code>[~/test]⇒ ls data*
data.txt  data.txt.2
</code></pre>

<p>Notre fichier est bien modifié:</p>

<pre><code>[~/test]⇒ cat data.txt
ALICE
BOB
</code></pre>

<p>Et il est bien sauvegardé:</p>

<pre><code>[~/test]⇒ cat data.txt.2
alice
bob
</code></pre>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Remplacer Sed et Awk par Ruby 6: Séparateur de champ]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/12/07/remplacer-sed-et-awk-par-ruby-6-separateur-de-champ/"/>
    <updated>2013-12-07T20:54:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/12/07/remplacer-sed-et-awk-par-ruby-6-separateur-de-champ</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Aujourd'hui on voit comment changer le séparateur de champ à l'aide de
l'option <code>-F</code>.</p>

<!-- more -->


<p>Reprenons le fichier de données du <a href="http://lkdjiin.github.io/blog/2013/12/05/remplacer-sed-et-awk-par-ruby-5-acceder-aux-champs-slash-colonnes/">dernier article</a>,
ajoutons un séparateur de champ, par exemple la virgule (<code>,</code>) et
<em>salissons-le</em> quelque peu:</p>

<p><code>raw data.txt
1, a
2, a
3, b
4 , a
5 ,a
6 ,b
7,b
8,b
9,b
</code></p>

<p>Le script du dernier article ne fonctionnera plus, puisque jusqu'ici nous
supposions que les champs étaient séparés par des espaces, ce qui n'est plus
le cas.</p>

<p>En admettant que les champs seront séparés par des virgules, il faut effectuer
un petit changement dans notre script, pour nettoyer le second champ:</p>

<p>``` ruby test.rb
BEGIN { total = 0 }</p>

<p>total += $F[0].to_i if $F[1].strip == &ldquo;a&rdquo;</p>

<p>END { puts &ldquo;Total: #{total}&rdquo; }
```</p>

<p>Et pour que Ruby sépare bien les champs en tenant compte des virgules, il faut
lui passer l'option <code>-F</code>, suivie d'une <em>regex</em> (sans les <code>//</code>) décrivant
le séparateur:</p>

<pre><code>[~]⇒ ruby -an -F, test.rb &lt; data.txt 
Total: 12
</code></pre>

<p>Et voilà.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Remplacer Sed et Awk par Ruby 5: Accéder aux champs/colonnes]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/12/05/remplacer-sed-et-awk-par-ruby-5-acceder-aux-champs-slash-colonnes/"/>
    <updated>2013-12-05T19:12:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/12/05/remplacer-sed-et-awk-par-ruby-5-acceder-aux-champs-slash-colonnes</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Toujours dans l'optique de remplacer Sed et Awk par Ruby,
et après avoir vu <a href="http://lkdjiin.github.io/blog/2013/12/04/remplacer-sed-et-awk-par-ruby-4-les-options-p-et-l/">les options -p et -l</a>, on voit
comment accéder facilement aux différentes colonnes
d'un fichier.</p>

<!-- more -->


<p>Voici le fichier de données tout simple qui va nous servir aujourd'hui:</p>

<p><code>raw data.txt
1 a
2 a
3 b
4 a
5 a
6 b
7 b
8 b
9 b
</code></p>

<p>L'objectif est de calculer la somme des valeurs de la 1ère colonne,
uniquement quand la 2e colonne affiche <code>a</code>. On pourrait bien sûr splitter
la ligne (<code>$_</code>) pour obtenir nos champs, mais il y a plus rapide.
En activant l'option <code>-a</code> de la ligne de commande, Ruby va automatiquement
splitter chaque lignes du fichier de données dans la variable prédéfinie
<code>$F</code> (pour <em>Fields</em>). On n'a donc rien à faire ;) et on peut se concentrer
sur les calculs:</p>

<p>``` ruby test.rb
BEGIN { total = 0 }</p>

<p>total += $F[0].to_i if $F[1] == &ldquo;a&rdquo;</p>

<p>END { puts &ldquo;Total: #{total}&rdquo; }
```</p>

<pre><code>[~]⇒ ruby -an test.rb &lt; data.txt 
Total: 12
</code></pre>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Remplacer Sed et Awk par Ruby 4: Les options -p et -l]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/12/04/remplacer-sed-et-awk-par-ruby-4-les-options-p-et-l/"/>
    <updated>2013-12-04T21:21:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/12/04/remplacer-sed-et-awk-par-ruby-4-les-options-p-et-l</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Les options -p et -l de la ligne de commande de Ruby permettent de se
rapprocher encore un peu plus du comportement de Sed et Awk.  On reprend notre
fichier tout simple:</p>

<p><code>raw data.txt
1
2
3
4
5
6
7
8
9
</code></p>

<p>Aujourd'hui l'objectif est d'ajouter une nouvelle colonne, qui nous dit si
le nombre est pair (p) ou impair (i). C'est un exemple trivial, mais
suffisant pour ce que je veux montrer.</p>

<!-- more -->


<h2>Un premier script déjà concis</h2>

<p>Voici un premier code possible, avec ce que nous connaissons déjà, c'est
à dire l'option -n:</p>

<p><code>ruby test1.rb
$_ = $_.chomp + ($_.to_i.even? ? " p" : " i")
puts $_
</code></p>

<pre><code>[~]⇒ ruby -n test1.rb &lt; data.txt 
1 i
2 p
3 i
4 p
5 i
6 p
7 i
8 p
9 i
</code></pre>

<p>On peut noter que:</p>

<ul>
<li>contrairement à l'exemple précédent, on n'utilise pas les blocs BEGIN et
END (voir <a href="http://lkdjiin.github.io/blog/2013/11/30/remplacer-sed-et-awk-par-ruby-2-premiers-pas/">Premiers pas</a>
et <a href="http://lkdjiin.github.io/blog/2013/12/01/remplacer-sed-et-awk-par-ruby-3-begin-et-end/">BEGIN et END</a>).</li>
<li>la variable prédéfinie <code>$_</code> est <strong>accessible en écriture</strong>.</li>
<li>la variable prédéfinie <code>$_</code> contient le caractère de fin de ligne, il a
fallu le supprimer avec <code>chomp</code>. C'est agaçant.</li>
<li>on écrit chaque nouvelle ligne avec <code>puts</code>. C'est un pattern classique,
il doit bien y avoir un truc pour nous éviter cela.</li>
</ul>


<h2>La même chose en plus court</h2>

<p>Voici maintenant une réécriture du script ci-dessus, qui tire parti
des options -p et -l:</p>

<p><code>ruby test2.rb
$_ += $_.to_i.even? ? " p" : " i"
</code></p>

<pre><code>[~]⇒ ruby -pl test2.rb &lt; data.txt 
1 i
2 p
3 i
4 p
5 i
6 p
7 i
8 p
9 i
</code></pre>

<h2>Les explications de -p et -l</h2>

<p>L'option -p fonctionne comme l'option -n, mais en plus, affiche automatiquement
le contenu de la variable <code>$_</code> à la fin de la boucle de traitement.</p>

<p>L'option -l, quant à elle, s'occupe automatiquement du caractère de fin
de ligne en le supprimant.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
