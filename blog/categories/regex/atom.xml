<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : regex | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/regex/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2014-01-16T20:53:44+01:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Une regex pour savoir si un nombre est premier]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/11/05/une-regex-pour-savoir-si-un-nombre-est-premier/"/>
    <updated>2013-11-05T16:55:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/11/05/une-regex-pour-savoir-si-un-nombre-est-premier</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Aujourd'hui je traduis (approximativement) un article de 2007 qui m'a fasciné:
<a href="http://www.noulakaz.net/weblog/2007/03/18/a-regular-expression-to-check-for-prime-numbers/">A regular expression to check for prime numbers</a>.</p>

<!-- more -->


<p>Les regexs sont très puissantes. C'est un truc que je lis une ou deux fois par
jour sur le web.</p>

<p>Pendant que j'étais sur le net aujourd'hui, je suis tombé sur
<a href="http://montreal.pm.org/tech/neil_kandalgaonkar.shtml">cette page</a>
qui décrit minutieusement la regex <code>/^1?$|^(11+?)\1+$/</code> en Perl pour voir
si un nombre est premier ou non !</p>

<p>Pour être franc, j'étais sceptique. La regex semble être magique ! Et je
voulais la comprendre mieux. Je l'ai réécrite en Ruby, pour la tester:</p>

<p>``` irb
[~]⇒ irb</p>

<blockquote><blockquote><p>def prime?(n)
  (&ldquo;1&rdquo; * n) !~ /^1?$|^(11+?)\1+$/
end
=>
prime? 10
=> false
prime? 11
=> true
prime? 12
=> false
prime? 13
=> true
prime? 99
=> false
prime? 100
=> false
prime? 101
=> true
```</p></blockquote></blockquote>

<p>Cool ! Ça marche aussi en Ruby ! Ce qui veut dire qu'il n'y a aucune magie
due à Perl. La regex fonctionne vraiment. Mais comment ? Essayons de la
décortiquer.</p>

<h2>Est-ce-que 7 est un nombre premier ?</h2>

<p>Pour le savoir, la méthode génère &ldquo;1111111&rdquo; et regarde si cette chaîne
<strong>ne correspond pas</strong> avec <code>/^1?$|^(11+?)\1+$/</code>. Si il n'y a pas
correspondance, alors le nombre est premier.</p>

<p>Notez que la regex a deux parties (séparées par une barre verticale <code>|</code>).</p>

<p>La première partie <code>/^1?$/</code> est triviale, et cherche une correspondance
avec un début de ligne (<code>^</code>), un 1 optionel (<code>1?</code>) et une fin de ligne
(<code>$</code>), ce qui implique une chaîne vide ou &ldquo;1&rdquo;. Donc l'appel de cette
méthode quand n vaut 0 ou 1 renverra false, le bon résultat.</p>

<p>La seconde partie est plus… magique…</p>

<p><code>/^(11+?)\1+$/</code> cherche une correspondance avec un début de ligne (<code>^</code>)
puis <code>11+?</code> puis <code>\1+</code> et finalement une fin de ligne (<code>$</code>).
Je suppose que vous savez que <code>\1</code> est une variable attachée à ce qui a été
mis en correspondance précédement (dans notre cas avec <code>11+?</code>).</p>

<p>Allons y lentement…</p>

<p><code>(11+?)</code> fait deux choses:</p>

<ol>
<li>Il cherche une correspondance avec un &ldquo;1&rdquo; suivi par un ou plusieurs autres
&ldquo;1&rdquo; <strong>de façon minimale</strong>. Ce qui signifie qu'on aura une correspondance
avec &ldquo;11&rdquo; la première fois (notez que si il n'y avait pas de <code>?</code> dans
<code>(11+?)</code> c'est la chaîne entière qui serait mise en correspondance).</li>
<li>La chaîne obtenue (&ldquo;11&rdquo; la première fois) est attachée à la variable <code>\1</code>.</li>
</ol>


<p><code>\1+</code> cherche alors une correspondance avec ce qu'on a obtenu avant (&ldquo;11&rdquo;
la première fois) <strong>de manière répétitive, une ou plusieurs fois</strong>.
Si une correspondance est trouvée, alors le nombre n'est pas premier.</p>

<p>Si vous suivez jusqu'ici, vous avez peut-être réalisé que cela éliminait tout
les nombres pairs, excepté 2 (par exemple, 8 est &ldquo;11111111&rdquo; and donc <code>(11+?)</code>
va correspondre avec &ldquo;11&rdquo; et <code>\1+</code> va correspondre avec &ldquo;111111&rdquo;).</p>

<p>Pour les nombres impairs (7 dans notre cas), le <code>(11+?)</code> correspond à &ldquo;11&rdquo;
la première fois mais <code>\1+$</code> ne peut pas être vrai (notez le <code>$</code>) puisqu'il
reste cinq &ldquo;1&rdquo;. Le moteur de regexp va <strong>revenir en arrière</strong> et <code>(11+?)</code>
va alors correspondre avec &ldquo;111&rdquo; et là aussi, <code>\1+$</code> sera faux puisqu'il
reste quatre &ldquo;1&rdquo; (et à ce moment là, <code>\1+$</code> ne peut correspondre qu'avec un
nombre de &ldquo;1&rdquo; qui est multiple de 3, suivi par une fin de ligne), etc…
D'où le fait que &ldquo;1111111&rdquo; ne correspondra jamais avec la regex, ce qui
implique que 7 est un nombre premier.</p>

<p>[&hellip;] Voyons ce qu'il se passe avec 9, qui n'est pas un nombre premier:
&ldquo;1&rdquo; * 9 devrait correspondre avec la regex.</p>

<p>&ldquo;1&rdquo; * 9 = &ldquo;111111111&rdquo;. <code>(11+?)</code> correspond initialement à &ldquo;11&rdquo;. <code>\1+$</code> ne
peut être mis en correspondance puisqu'il reste 7 &ldquo;1&rdquo;. Quand le moteur de
regex repart en arrière, <code>(11+?)</code> correspond alors avec &ldquo;111&rdquo;. Et cette
fois <code>\1+$</code> correspond aux 6 &ldquo;1&rdquo; restants ! D'où 9 n'est pas premier.</p>

<p>Simple et beau en même temps.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
