<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : one liner | Xavier Nayrac]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/one-liner/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2016-01-18T09:34:57+01:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Comment convertir un nombre décimal en binaire en Bash ?]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/05/02/comment-convertir-un-nombre-decimal-en-binaire-en-bash/"/>
    <updated>2015-05-02T12:20:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/05/02/comment-convertir-un-nombre-decimal-en-binaire-en-bash</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Pour convertir un nombre décimal en binaire, en Bash, suivez ce tweet :
<a href="https://twitter.com/climagic/status/593842202314420224">https://twitter.com/climagic/status/593842202314420224</a>.</p>

<p>Et voici la conversion du décimal 27 en son équivalent binaire :</p>

<p><code>bash
$ Dec2Bin=({0..1}{0..1}{0..1}{0..1}{0..1}{0..1}{0..1}{0..1});echo ${Dec2Bin[27]} 
00011011
</code></p>

<p>Alors, comment ça marche ?</p>

<p><img class="center" src="/images/binary.jpg"></p>

<!-- more -->

<p>Pour commencer, voici comment faire un tableau en bash, qui va contenir les 3
chaînes <code>foo</code>, <code>bar</code>, et <code>baz</code>. Ne soyez pas surpris par le manque de guillemets
autour des chaînes, Bash est fait pour traiter du texte.</p>

<p><code>bash
$ myarray=(foo bar baz)
</code></p>

<p>Et voici comment afficher le contenu de ce tableau.</p>

<p><code>bash
$ echo ${myarray[@]}
foo bar baz
</code></p>

<p>On peut bien sûr accéder aux éléments du tableau séparément :</p>

<p><code>bash
$ echo ${myarray[0]}
foo
$ echo ${myarray[1]}
bar
$ echo ${myarray[2]}
baz
</code></p>

<p>Pour connaître la taille d’un tableau, voici la syntaxe :</p>

<p><code>bash
$ echo ${#myarray[@]}
3
</code></p>

<p>Appliquons ce nouveau savoir au tableau <code>Dec2Bin</code>, qui contient…</p>

<p>…</p>

<p>…des trucs :</p>

<p><code>bash
$ Dec2Bin=({0..1}{0..1}{0..1}{0..1}{0..1}{0..1}{0..1}{0..1})
</code></p>

<p>Combien a-t-il d’éléments ?</p>

<p><code>bash
$ echo ${#Dec2Bin[@]}
256
</code></p>

<p>256 ? Et ça ressemble à quoi ?</p>

<p><code>bash
$ echo ${Dec2Bin[@]}
00000000 00000001 00000010 00000011 00000100 00000101 00000110 00000111 00001000 
00001001 00001010 00001011 00001100 00001101 00001110 00001111 00010000 00010001
...
11101010 11101011 11101100 11101101 11101110 11101111 11110000 11110001 11110010 
11110011 11110100 11110101 11110110 11110111 11111000 11111001 11111010 11111011 
11111100 11111101 11111110 11111111
</code></p>

<p>Tranquille, <code>Dec2Bin</code> est un tableau qui contient 256 chaînes représentant les
nombres binaires de 0 à 255.</p>

<p>Les crochets <code>{}</code> créent un <em>range</em> :</p>

<p><code>bash
$ echo {0..1}
0 1
$ echo {a..f}
a b c d e f
</code></p>

<p>Plusieurs crochets <code>{}</code> les uns à la suite des autres produisent toutes les
permutations possibles :</p>

<p><code>bash
$ echo {0..1}{0..1}
00 01 10 11
</code></p>

<p>Et on peut mettre tout ça dans un tableau :</p>

<p><code>bash
$ a=({0..1})
$ echo ${a[@]}
0 1
$ a=({0..1}{0..1})
$ echo ${a[@]}
00 01 10 11
$ a=({0..1}{0..1}{0..1})
$ echo ${a[@]}
000 001 010 011 100 101 110 111
</code></p>

<p>Et voilà, il faut encore savoir qu’ici, le point-virgule sert à joindre 2 lignes de
code en une seule :</p>

<p><code>bash
$ Dec2Bin=({0..1}{0..1}{0..1}{0..1}{0..1}{0..1}{0..1}{0..1})
$ echo ${Dec2Bin[27]}
00011011
</code></p>

<h2 id="bonus-1---le-mme-en-hexadcimal">Bonus 1 - Le même en hexadécimal</h2>

<p>Et si on voulait convertir un nombre décimal en hexadécimal plutôt qu’en
binaire ? Il faudrait générer toutes les permutations entre deux suites
<code>0 1 2 3 4 5 6 7 8 9 A B C D E F</code> :</p>

<p>
<code>bash
$ echo {{0..9},{A..F}}{{0..9},{A..F}}
00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F 10 11 12 13 14 15 16 17 18 19 1A 
1B 1C 1D 1E 1F 20 21 22 23 24 25 26 27 28 29 2A 2B 2C 2D 2E 2F 30 31 32 33 34 35 
36 37 38 39 3A 3B 3C 3D 3E 3F 40 41 42 43 44 45 46 47 48 49 4A 4B 4C 4D 4E 4F 50 
51 52 53 54 55 56 57 58 59 5A 5B 5C 5D 5E 5F 60 61 62 63 64 65 66 67 68 69 6A 6B 
6C 6D 6E 6F 70 71 72 73 74 75 76 77 78 79 7A 7B 7C 7D 7E 7F 80 81 82 83 84 85 86 
87 88 89 8A 8B 8C 8D 8E 8F 90 91 92 93 94 95 96 97 98 99 9A 9B 9C 9D 9E 9F A0 A1 
A2 A3 A4 A5 A6 A7 A8 A9 AA AB AC AD AE AF B0 B1 B2 B3 B4 B5 B6 B7 B8 B9 BA BB BC 
BD BE BF C0 C1 C2 C3 C4 C5 C6 C7 C8 C9 CA CB CC CD CE CF D0 D1 D2 D3 D4 D5 D6 D7 
D8 D9 DA DB DC DD DE DF E0 E1 E2 E3 E4 E5 E6 E7 E8 E9 EA EB EC ED EE EF F0 F1 F2 
F3 F4 F5 F6 F7 F8 F9 FA FB FC FD FE FF
</code>
</p>

<p>
<code>bash
$ Dec2Hex=({{0..9},{A..F}}{{0..9},{A..F}});echo ${Dec2Hex[27]}
1B
</code>
</p>

<h2 id="bonus-2---le-mme-en-ruby">Bonus 2 - Le même en Ruby</h2>

<p>On peut faire la même chose en Ruby en utilisant <code>repeated_permutation</code> :</p>

<p><code>irb
&gt;&gt; [0,1].repeated_permutation(8).to_a.each{|e| puts e.join}
00000000
00000001
00000010
00000011
00000100
00000101
...
11111010
11111011
11111100
11111101
11111110
11111111
</code></p>

<p>Il peut-être intéressant de comparer les deux versions :</p>

<p><code>bash
$ ruby -e "puts [0,1].repeated_permutation(8).to_a[27].join"
00011011
</code></p>

<p><code>bash
$ Dec2Bin=({0..1}{0..1}{0..1}{0..1}{0..1}{0..1}{0..1}{0..1});echo ${Dec2Bin[27]} 
00011011
</code></p>

<h2 id="bonus-3---encore-plus-court">Bonus 3 - Encore plus court</h2>

<p>Pour finir, on peut faire plus court avec Bash en utilisant <code>{0,1}</code> au lieu de
<code>{0..1}</code> puisqu’il y a seulement deux éléments :</p>

<p><code>bash
$ Dec2Bin=({0,1}{0,1}{0,1}{0,1}{0,1}{0,1}{0,1}{0,1});echo ${Dec2Bin[27]} 
00011011
</code></p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Le hack FizzBuzz en Ruby]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/04/30/le-hack-fizzbuzz-en-ruby/"/>
    <updated>2015-04-30T17:07:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/04/30/le-hack-fizzbuzz-en-ruby</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Voici ce qui trainait sur le net aujourd’hui, un jeu de
<a href="http://en.wikipedia.org/wiki/Fizz_buzz">FizzBuzz</a> en une ligne de Ruby:</p>

<p><code>ruby
1.upto(100){|n|puts'FizzBuzz '[o=n**4%-15,o+13]||n}
</code></p>

<p>Ce qui donne:</p>

<p><code>bash
ruby -e "1.upto(100){|n|puts'FizzBuzz '[o=n**4%-15,o+13]||n}"
1
2
Fizz
4
Buzz 
Fizz
7
8
Fizz
Buzz 
11
.
.
.
94
Buzz 
Fizz
97
98
Fizz
Buzz 
</code></p>

<p>Pour celles et ceux qui ne pigent pas cette ligne de code Ruby, on va la
déconstruire petit à petit.</p>

<!-- more -->

<p>Nous avons affaire à une boucle (j’ai remplacé les <code>{}</code> par <code>do end</code>):</p>

<p><code>ruby
1.upto(100) do |n|
  puts'FizzBuzz '[o=n**4%-15,o+13]||n
end
</code></p>

<p><code>a.upto(b)</code> itère de <code>a</code> jusqu’à <code>b</code>:</p>

<p><code>irb
$ irb
&gt;&gt; 10.upto(12) do |iteration|
?&gt;   puts iteration
&gt;&gt; end
10
11
12
</code></p>

<p>Regardons de plus près l’intérieur de la boucle, là où c’est intéressant.
Ruby permet d’appeler les
méthodes sans utiliser de parenthèses. Ici je les ai simplement rajouter pour
tenter de clarifier le code:</p>

<p><code>ruby
1.upto(100) do |n|
  puts( 'FizzBuzz '[o=n**4%-15,o+13]||n )
end
</code></p>

<p>Maintenant qu’on est bien sûr qu’il s’agit de la méthode <code>puts</code> avec un
argument bizarre dedans, je sépare les différents éléments de la <em>grammaire de
Ruby</em> par des espaces. Toujours pour essayer d’y voir plus clair:</p>

<p><code>ruby
1.upto(100) do |n|
  puts( 'FizzBuzz '[o = n ** 4 % -15, o + 13] || n )
end
</code></p>

<p>Arrêtons nous un peu sur les sous-ensembles de chaîne <code>[a, b]</code>.
Le premier chiffre est la position de départ, le second est le nombre de
caractères:</p>

<p><code>irb
$ irb
&gt;&gt; "abcdef"[0, 2]
"ab"
&gt;&gt; "abcdef"[3, 2]
"de"
</code></p>

<p>Ruby permet de donner une position de départ pas rapport à la fin:</p>

<p><code>irb
&gt;&gt; "abcdef"[-4, 2]
"cd"
</code></p>

<p>Pour la suite, notez bien que si on va chercher des caractères <strong>avant</strong> le début ou <strong>après</strong> la fin de la chaîne, on se retrouve avec <code>nil</code>. Ça n’est pas une erreur, c’est le comportement attendu:</p>

<p><code>irb
&gt;&gt; "abcdef"[-123, 2]
nil
&gt;&gt; "abcdef"[999, 2]
nil
</code></p>

<p>Maintenant essayons de décrypter la formule mathématique.
Utilisons une variable temporaire pour l’isoler:</p>

<p><code>ruby
1.upto(100) do |n|
  o = n ** 4 % -15
  puts( 'FizzBuzz '[o, o + 13] || n )
end
</code></p>

<p>En Ruby, <code>**</code> est l’opérateur de puissance:</p>

<p><code>irb
$ irb
&gt;&gt; 10 ** 2
100
&gt;&gt; 10 ** 3
1000
&gt;&gt; 10 ** 4
10000
</code></p>

<p>Quant à <code>%</code>, c’est l’opérateur de la division modulaire, souvent appelé
<em>modulo</em>. Si vous avez plein de temps devant vous il y a la page wikipédia sur
<a href="http://fr.wikipedia.org/wiki/Arithm%C3%A9tique_modulaire">l’arithmétique modulaire</a>.
Sinon voici une explication rapide du modulo: <strong>c’est le reste de la division
entière</strong>. Donc <code>9 % 4 == 1</code>.</p>

<p>Sauf qu’ici on utilise le modulo avec un nombre négatif. Et là les maths se
compliquent un peu, et surtout différents langages de programmation auront différents
comportements.</p>

<p>Essayons plutôt de <em>sentir</em> la formule en l’appliquant aux nombres de 1 à 16:</p>

<p><code>irb
$ irb
&gt;&gt; (1..16).each do |n|
?&gt;   o = n ** 4 % -15
&gt;&gt;   puts "#{n} =&gt; #{o}"
&gt;&gt; end
1 =&gt; -14
2 =&gt; -14
3 =&gt; -9
4 =&gt; -14
5 =&gt; -5
6 =&gt; -9
7 =&gt; -14
8 =&gt; -14
9 =&gt; -9
10 =&gt; -5
11 =&gt; -14
12 =&gt; -9
13 =&gt; -14
14 =&gt; -14
15 =&gt; 0
16 =&gt; -14
</code></p>

<p>J’imagine qu’à ce moment précis, vous êtes plusieurs à crier <strong>«Ha ha !»</strong>.</p>

<p>Cette formule, en Ruby, a donc 4 solutions possibles:</p>

<ul>
  <li>Quand <em>n</em> est un multiple de 3, la solution est <strong>-9</strong>.</li>
  <li>Quand <em>n</em> est un multiple de 5, la solution est <strong>-5</strong>.</li>
  <li>Quand <em>n</em> est un multiple de 15 (c’est à dire à la fois multiple de 3 et de
9), la solution est <strong>0</strong>.</li>
  <li>Dans les autres cas, la solution est <strong>-14</strong>.</li>
</ul>

<p>Voyons ce qu’il se passe avec <code>'FizzBuzz '</code> quand <code>o</code> vaut respectivement -9, -5, 0 puis -14:</p>

<p><code>irb
$ irb
&gt;&gt; 'FizzBuzz '[-9, -9 + 13]
"Fizz"
&gt;&gt; 'FizzBuzz '[-5, -5 + 13]
"Buzz "
&gt;&gt; 'FizzBuzz '[0, 13]
"FizzBuzz "
&gt;&gt; 'FizzBuzz '[-14, -14 + 13]
nil
</code></p>

<p>Peut-être vous demandez vous pourquoi il y a un espace après FizzBuzz ?
En pratique, voici la raison:</p>

<p><code>irb
&gt;&gt; 'FizzBuzz'[-9, -9 + 13]
nil
&gt;&gt; 'FizzBuzz'[-5, -5 + 13]
"zBuzz"
</code></p>

<p>En théorie, je vous laisse faire les calculs ;)</p>

<p>Pour finir, il reste à expliquer le <code>||</code>, un exemple vaut mieux qu’un long
discours:</p>

<p><code>irb
&gt;&gt; "foo" || 13
"foo"
&gt;&gt; nil || 13
13
</code></p>

<p>Voilà, si vous voulez ajouter d’autres explications, les commentaires sont fait
pour ça ;)</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Remplacer Sed et Awk par Ruby 8: Script sur la ligne de commande]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/12/09/remplacer-sed-et-awk-par-ruby-8-script-sur-la-ligne-de-commande/"/>
    <updated>2013-12-09T20:36:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/12/09/remplacer-sed-et-awk-par-ruby-8-script-sur-la-ligne-de-commande</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Il est temps de se passer d’un fichier pour notre script… Lorsque celui-ci
est suffisament court, on peut l’écrire directement sur la ligne de
commande.</p>

<!-- more -->

<p>Si on reprend l’exemple tout simple du <a href="http://lkdjiin.github.io/blog/2013/12/08/remplacer-sed-et-awk-par-ruby-7-modifier-slash-sauvegarder-les-donnees/">dernier article</a>,
nous avions le fichier de données suivant à transformer <em>en place</em> en
majuscule:</p>

<p><code>raw data.txt
alice
bob
</code></p>

<p>Ce qu’on a fait à l’aide du script suivant:</p>

<p><code>ruby test.rb
$_.upcase!
</code></p>

<p>Autrement une seule ligne ! Est-ce que ça vaut vraiment la peine d’écrire
un fichier pour ça ? Bien sûr que non. On va donc se passer du fichier
script en donnant le code sur la ligne de commande grâce à l’option <code>-e</code>:</p>

<p><code>bash
ruby -p -i.2 -e '$_.upcase!' data.txt
</code></p>

<p>Et voilà, vous êtes maintenant prêts à écrire des <em>one liners</em>. Notez
quand même qu’il vaut mieux utiliser les guillemets simples (<code>'</code>) autour
du code plutôt que les doubles (<code>"</code>), pour empêcher Bash d’interpréter
certains caractères (comme ici le <code>!</code>).</p>

<script id="fb33k8u">(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
