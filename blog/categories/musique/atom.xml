<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : musique | Xavier Nayrac]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/musique/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2019-11-20T17:38:33+01:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Quelques oscillateurs très simples]]></title>
    <link href="http://lkdjiin.github.io/blog/2019/11/20/quelques-oscillateurs-tres-simples/"/>
    <updated>2019-11-20T17:05:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2019/11/20/quelques-oscillateurs-tres-simples</id>
    <content type="html"><![CDATA[<p>J’ai l’intention de fabriquer mon synthétiseur modulaire. Et comme il faut bien
commencer quelque part, un oscillateur semble un bon point de départ. Je
pourrais utiliser un Arduino, ou une plate-forme similaire, écrire quelques
lignes de code, et voilà. Mais ça aurait beaucoup moins de charme que de faire
un peu d’électronique en mode vintage. Je vais donc commencer par ce que
j’imagine être le plus simple : un oscillateur avec un seul composant principal
et quelques résistances et condensateurs.  Ça n’ira pas bien loin, ça fera
sûrement mal aux oreilles, mais au risque de me répéter «Il faut bien commencer
quelque part.»</p>

<!-- more -->

<h2 id="quest-ce-quun-oscillateur">Qu’est ce qu’un oscillateur</h2>

<p>Un oscillateur est un dispositif électronique qui produit un signal électrique
ayant la forme d’une onde.  Une onde électrique, c’est un motif, une forme, que
produit la sortie du dispositif en Volt, qui oscille entre un minimum et un
maximum, et qui se répète, encore et encore.  On rencontre couramment les types d’ondes
carrée, triangle, en dent de scie, et enfin, sinusoïdale.</p>

<p><a title="Omegatron translated by Roland Brierre [CC BY 3.0 (https://creativecommons.org/licenses/by/3.0)], via Wikimedia Commons" href="https://commons.wikimedia.org/wiki/File:Formes_d%27onde.png"><img width="512" alt="Formes d&#039;onde" src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/21/Formes_d%27onde.png/512px-Formes_d%27onde.png" /></a></p>

<p>Chaque forme d’onde particulière produit une sonorité particulière quand on la
passe dans un haut-parleur. Une répétition - on dit aussi un cycle - par
seconde donne par définition une fréquence de 1 Hertz. C’est la hauteur
(musicale) de la note produite. Dix cycles par seconde correspondent à 10 Hertz.
Deux cent trente quatre cycles par seconde correspondent à 234 Hertz, etc. Un
Hertz est une fréquence beaucoup trop basse pour être entendue par les humains.
Des oreilles jeunes, en bonne santé, pas trop fatiguées, peuvent entendre les
fréquences comprises entre 40 et 20 000 Hertz, en gros.</p>

<h2 id="onde-carre">Onde carrée</h2>

<h3 id="cd40106">CD40106</h3>

<p>Le premier oscillateur que j’ai testé à pour composant de base un CD40106, et produit une onde carrée.</p>

<p><img class="center" src="/images/osc-40106.png"></p>

<p>Si vous l’essayez, raccordez aussi les pins 3, 5, 9, 11 et 13 au ground. Et si
possible ajoutez lui un volume, la sortie pouvant être assez élevée. <em>(Dans
tous les cas, vous devriez toujours ajouter un contrôle de volume et mettre
votre ampli à zéro pour commencer ; ça vous évitera des mauvaises surprises.)</em></p>

<p>On obtient une belle onde carrée :</p>

<p><img class="center" src="/images/square-wave.jpg"></p>

<h3 id="hc14">74HC14</h3>

<p>Le 74HC14, c’est la même chose qu’un CD40106 mais en 5 Volt, voire même moins.
Il est donc idéal si votre circuit doit fonctionner en 5 Volt ou moins.  Le
schéma est exactement le même que le précédent, pin pour pin. Pensez seulement
à bien utiliser du 5 Volt, sinon vous le grillerez.</p>

<h3 id="section">555</h3>

<p><img class="center" src="/images/osc-555.png"></p>

<p>Le 555 est un grand classique. Un des composants électroniques les plus utilisés au monde.</p>

<p><img class="center" src="/images/bread-555.jpg"></p>

<h2 id="dents-de-scie">Dents de scie</h2>

<p><img class="center" src="/images/osc-transistor.png"></p>

<p>Je voulais aussi voir ce que je pouvais faire avec un transistor. Le résultat est
intéressant mais l’amplitude est un peu faible.</p>

<p><img class="center" src="/images/sawtooth-wave.jpg"></p>

<p>J’ai pu le faire fonctionner à 9 Volt avec un 2N2222A en
métal. Tout les autres types de transistors que j’ai essayé n’ont pas réussi à osciller. Je pense
que la plupart fonctionnerait avec 12 Volt. Il faudra que j’essaye plus tard
car je n’avais pas de 12 Volt sous la main.</p>

<h2 id="les-contrles">Les contrôles</h2>

<p>De manière générale, augmenter la résistance diminue la fréquence. C’est à dire
que ça produit une note plus basse.  De même, augmenter la valeur du condensateur diminue
aussi la fréquence. Il ne faut pas hésiter à tester les différentes valeurs
qu’on a sous la main.</p>

<h2 id="ce-qui-manque">Ce qui manque</h2>

<p>Laissez moi le répéter une fois encore : il faut commencer quelque part. Et là,
ça n’est clairement que le début. Tel quel, ces oscillateurs sont inutilisables
dans un synthé. Voyons rapidement ce qui manque :</p>

<ul>
  <li><strong>Plusieurs formes d’ondes</strong>. Il me manque encore triangle et sinus. Et l’idéal serait qu’un seul oscillateur puissent produire plusieurs formes d’ondes.</li>
  <li><strong>Un contrôle fin de la fréquence</strong>. Généralement les oscillateurs possèdent 2 contrôles de fréquence. Un grossier (<em>coarse</em>) qui balaye toute l’étendue du registre, et un plus fin de l’ordre d’un ou deux tons, qui permet de s’accorder précisément.</li>
  <li><strong>1V/oct</strong>. C’est LA fonctionnalité que j’attends avec le plus d’impatience. Je pense que ce sera aussi la plus complexe à mettre en place. En gros, c’est ce qui permettra à mes oscillateurs de jouer des notes précises, à partir d’un clavier ou d’un séquenceur, par exemple.</li>
  <li><strong>Pulse modulation</strong>. Un carré est aussi un rectangle. Pensez donc à une onde carrée comme à une onde rectangle, avec par exemples des «bosses» plus longues et des «creux» plus courts. Ça permet d’obtenir des nouvelles sonorités.</li>
  <li><strong>La synchro</strong>. Mais c’est un peu normal car pour cela il faut un deuxième oscillateur. En gros c’est quand on utilise deux oscillateurs en même temps. L’un s’occupant de la fréquence et l’autre de la forme d’onde.</li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Le format Eurorack]]></title>
    <link href="http://lkdjiin.github.io/blog/2019/11/10/le-format-eurorack/"/>
    <updated>2019-11-10T10:52:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2019/11/10/le-format-eurorack</id>
    <content type="html"><![CDATA[<p>Eurorack est actuellement le format le plus populaire pour les synthétiseurs
modulaires.  C’est un standard de facto parmi la jungle des formats existants.
Du moins, c’est le standard «pas trop cher» car le format Moog Unit, plus
luxueux, est aussi assez populaire. Vous remarquerez que j’utilise des
guillemets autour de «pas trop cher» parce qu’un synthé modulaire, c’est de
toute manière onéreux.</p>

<p><a title="Nina Richards (who can be contacted via ZoeB). [CC BY 3.0 (https://creativecommons.org/licenses/by/3.0)], via Wikimedia Commons" href="https://commons.wikimedia.org/wiki/File:Doepfer_A-100.jpg"><img width="256" alt="Doepfer A-100" src="https://upload.wikimedia.org/wikipedia/commons/thumb/6/66/Doepfer_A-100.jpg/256px-Doepfer_A-100.jpg" /></a></p>

<!-- more -->

<h2 id="synthtiseur-modulaire">Synthétiseur modulaire</h2>

<p>Un synthétiseur modulaire est un synthétiseur dont vous agencez vous même les
différents modules. Vous choisissez des oscillateurs, des filtres, des
générateurs d’enveloppes, des effets, des amplis, des mixeurs, des séquenceurs,
des portes logiques, des horloges, etc, et vous les relier dans l’ordre que
vous voulez avec des câbles pour produire des sonorités, voir des musiques
complètes.  Les seules limites sont votre imagination et votre porte-monnaie
(parce que à première vue, c’est quand même honteusement cher).</p>

<p>J’ai envie d’un synthé modulaire depuis que j’ai vu un documentaire sur les Who
dans lequel Pete Townshend recréait les sonorités de «Won’t get fooled again»
dans son home studio. En écrivant cet article j’ai recherché ce documentaire,
mais je n’ai pas réussi à le retrouver. Et ça n’était peut-être même pas
vraiment un synthé modulaire. Mais c’est toujours resté dans un coin de ma
tête.</p>

<h2 id="les-spcifications-du-format-eurorack">Les spécifications du format Eurorack</h2>

<p>Eurorack est un ensemble de spécifications plutôt laxistes, initiées par
l’entreprise Doepfer en 1996, pour définir la taille des modules, les
mécanismes de montage et les détails de l’alimentation électrique, des différents types de
connecteurs et du transport de l’information (audio, gate, trigger).</p>

<p>Ce que tout le monde peut voir facilement, c’est la taille des modules. On
donne généralement la hauteur des modules d’un synthé modulaire, comme de tout
matériel qui se monte en rack, en unité <strong>U</strong> (pour Rack Unit). On parle donc
d’une hauteur de 1U, de 2U, de 3U, 4U, 5U, etc. Le Rack Unit mesure 44,45 mm.
Donc 3U devrait faire 133,35 mm. Mais pas pour Eurorack. Pour EuroRack, 3U
mesure 128,5 mm. Pourquoi ? J’avoue que je n’ai pas tout compris.</p>

<p>Pour la largeur d’un module on parle de HP (pour Horizontal Pitch). Un HP
corresponds à 5,08 mm et les modules sont censés avoir une largeur qui est un
multiple de 1HP.</p>

<p>Pour l’anecdote, Doepfer défini aussi des spécifications pour la longueur et la
largeur des vis de montage.</p>

<p>Du côté de l’alimentation, un module utilise du +12 volt, du -12 volt et
nécessite un <em>ground</em> à 0 volt. Certains modules peuvent aussi avoir besoin de
+5 volt, une tension classique pour les Arduino &amp; Cie. Les modules sont
connectés à l’alimentation par une prise ruban à 16 broches (mais parfois seulement
10 broches, standard, vous avez dit standard).</p>

<p><a title="Heron 21:16, 22 Nov 2004 (UTC) [CC BY-SA 3.0 (http://creativecommons.org/licenses/by-sa/3.0/)], via Wikimedia Commons" href="https://commons.wikimedia.org/wiki/File:Flachbandkabel.jpg"><img width="128" alt="Flachbandkabel" src="https://upload.wikimedia.org/wikipedia/commons/6/65/Flachbandkabel.jpg" /></a></p>

<p>Les tensions de travail en interne (audio, CV, trigger, clock) sont définies de
manière assez laxistes. Un signal audio est censé se cantonner entre -5 volt et
+5 volt.  Un CV (control voltage) est normalement de 5 volt entre deux pics et
peut-être uni polaire ou bipolaire. En clair il peut se balader quelque part
entre -2,5 volt et +2,5 volt, jusqu’à entre 0 volt et +5 volt.
Trigger, gate et clock sont censés être des signaux numériques, 0 volt ou 5 volt.</p>

<p>Enfin, les connexions entre modules sont réalisées avec des petits jacks (3,5 mm).</p>

<h2 id="dautres-formats">D’autres formats</h2>

<p>Il existe d’autres formats (ou form factors) de synthé modulaires. Le format
Moog Unit est surement le plus populaire après Eurorack. Et le format FrackRack
est celui qui se rapproche le plus de Eurorack. Voici ces trois formats en résumé :</p>

<p><strong>Eurorack</strong>  <br />
Hauteur : 3U (moins de 13 cm)  <br />
Tensions : +/-12v +5v  <br />
Jack : petit    </p>

<p><strong>Moog Unit (MU)</strong>  <br />
Hauteur : 5U (environ 22 cm)  <br />
Tensions : +/-15v +5v  <br />
Jack : gros    </p>

<p><strong>FrackRack</strong>  <br />
Hauteur : 3U  <br />
Tensions : +/-15v  <br />
Jack : petit</p>

<p>Parmi tout les formats que j’ai exploré, la hauteur peut aller tout de même
jusqu’à 40cm (Technosaurus Selector).  Quant à l’alimentation, on trouve de
tout entre -18 volt et +24 volt.</p>

<h2 id="sources">Sources</h2>

<p>https://en.wikipedia.org/wiki/Eurorack</p>

<p>http://www.doepfer.de/a100_man/a100m_e.htm</p>

<p>http://www.doepfer.de/a100_man/a100t_e.htm</p>

<p>https://sdiy.info/wiki/Eurorack</p>

<p>https://sdiy.info/wiki/Eurorack_DIY_parts</p>

<p>https://www.synthesizers.com/formfactors.html</p>

<p>https://en.wikipedia.org/wiki/Rack_unit</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[100 jours de synthé modulaire]]></title>
    <link href="http://lkdjiin.github.io/blog/2019/11/03/100-jours-de-synthe-modulaire/"/>
    <updated>2019-11-03T13:54:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2019/11/03/100-jours-de-synthe-modulaire</id>
    <content type="html"><![CDATA[<p>Pendant 100 jours je vais étudier les synthés modulaires selon les règles
suivantes, adaptées du site <a href="https://www.100daysofx.com/">100DaysOfX</a> :</p>

<h2 id="rgles">Règles</h2>

<ul>
  <li>1 heure par jour pendant les 100 prochains jours. (<em>Mais j’ai une famille,
des obligations, plusieurs autres passions et loisirs. Donc il est probable
que je ne puisse pas souvent trouver une heure entière. Pas grave, ce qui
compte c’est le coté journalier.)</em></li>
  <li>1 tweet quotidien sur mes progrès du jour (#100DaysOfMusic #ModularSynth).</li>
  <li>1 blog post par semaine minimum, pour aider d’autres personnes avec ce que
j’aurai appris.</li>
</ul>

<!-- more -->

<h2 id="objectifs">Objectif(s)</h2>

<p>L’objectif général est simplement de <em>faire quelque chose</em> avec un synthé
modulaire.  Cela devrait se concrétiser à travers les quatre directions
suivantes :</p>

<h3 id="fabriquer-un-synth-modulaire-hardware">Fabriquer un synthé modulaire hardware</h3>

<p>Un synthé modulaire revient vite très cher. Mais en le fabriquant moi-même, et
avec peu de modules, je devrais m’en sortir pour pas grand chose. Je pense
fabriquer des modules analogiques aussi bien que des numériques.</p>

<h3 id="crire-des-modules-software">Écrire des modules software</h3>

<p>Y a pas que le hardware dans la vie. J’ai découvert récemment le programme
<a href="https://vcvrack.com/">VCV Rack</a>, un synthé modulaire software, et j’ai
plusieurs modules en tête.</p>

<h3 id="produire-de-la-musique">Produire de la musique</h3>

<p>Parce que c’est quand le but d’un instrument de musique, quel qu’il soit !  Je
vais donc faire de la musique avec des synthés modulaires hardware et software.
Et je la diffuserai, parce qu’au final, la musique c’est quand même mieux quand
on l’écoute.</p>

<h3 id="comprendre-la-thorie-derrire-les-modules-des-synths-modulaires">Comprendre la théorie derrière les modules des synthés modulaires</h3>

<p>J’ai certaines lacunes que j’aimerai combler. Par exemple, comment faire de la
musique avec des <em>shift registers</em>, avec des portes logiques (or, xor, and),
comment peut bien fonctionner un séquenceur analogique, quelles sont les
différences entre un bruit blanc, un bruit rose, un bruit bleu, etc.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Arduino : Un métronome tap tempo]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/04/03/arduino-un-metronome-tap-tempo/"/>
    <updated>2015-04-03T18:35:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/04/03/arduino-un-metronome-tap-tempo</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>J’aimerais fabriquer un métronome <em>tap tempo</em> avec l’arduino. C’est un projet à
moyen terme, et
comme souvent, il pourrait être bénéfique de diviser le projet en plusieurs
petites parties. Donc, avant de tenter la programmation du tap tempo, je vais
faire un métronome tout simple avec juste une LED.</p>

<h2 id="les-composants">Les composants</h2>

<p>Coté composants, on a seulement besoin d’une LED et d’une résistance (220 Ohms
ça ira).</p>

<p><img class="center" src="/images/metronome1_bb.png"></p>

<!-- more -->

<h2 id="un-premier-code-naif">Un premier code naif</h2>

<p>Le premier jet est tout simple :</p>

<p>``` cpp
const byte LED_PIN = 2;</p>

<p>void setup() {
  pinMode(LED_PIN, OUTPUT);
}</p>

<p>void loop() {
  digitalWrite(LED_PIN, HIGH);
  delay(100);
  digitalWrite(LED_PIN, LOW);
  delay(600);
}
```</p>

<p>Une fois compilé et envoyé dans l’arduino, la LED clignote toutes les 0,7
secondes. Nous avons un métronome visuel !</p>

<p>C’est simple, non ? Mouais. Trop simple, bien sûr. Ce code est problèmatique
pour la fabrication d’un métronome. Alors afin de comprendre pourquoi, parlons
un peu du tempo.</p>

<h2 id="le-tempo">Le tempo</h2>

<p>Pour le musicien, le tempo est une suite de clics (ou tic, ou tac, ou poum, ou
tchak, ou clac). Ces clics, qui ont la particularité de se succéder à
intervalles réguliers, marquent la <strong>vitesse</strong> de la musique.</p>

<p>Le tempo (donc la vitesse de la musique) est indiqué à l’aide d’un nombre qui
représente le nombre de clics par minute.
Par exemple un tempo de 60 nous indique qu’il doit y avoir 60 clics dans une minute,
ou plus simplement 1 clic par seconde. Autre exemple, un tempo de 120 indique
120 clics par minute, soit 2 clics par seconde, ou encore 1 clic toutes les
0,5 secondes.</p>

<p>Voyons maintenant quelques formules. Pour trouver la fréquence F, en secondes,
il faut diviser 60 par le tempo (noté T) :</p>

<p>$$
\begin{align}

F = 60 / T
\end{align}
$$</p>

<p>Pour obtenir cette fréquence en millisecondes, il faut multiplier le résultat
précédent par 1000 ;</p>

<p>$$
\begin{align}

F = 60 / T \times 1000
\end{align}
$$</p>

<p>Le code arduino ci-dessus envoit un clic toutes les 0,7 secondes, à quel
tempo cela correspond-t-il ? Pour calculer le tempo, on divise 60 par la
fréquence en secondes :</p>

<p>$$
\begin{align}

T = 60 / F
\end{align}
$$</p>

<p>Donc, une fréquence de 0,7 seconde, comme celle de notre code arduino,
correspond à un tempo de \(60 / 0,7\). Soit à peu près 86.</p>

<h2 id="le-problme-de-la-boucle-de-code">Le problème de la boucle de code</h2>

<p>Maintenant on peut regarder le souci de ce code :</p>

<p><code>cpp
void loop() {
  digitalWrite(LED_PIN, HIGH);
  delay(100);
  digitalWrite(LED_PIN, LOW);
  delay(600);
}
</code></p>

<p>Partons de l’hypothèse qu’en plus des deux <code>digitalWrite</code>, mon code doit
aussi :</p>

<ul>
  <li>calculer l’intensité de la LED suivant le beat.</li>
  <li>jouer du son et ausssi calculer son intensité suivant le beat.</li>
  <li>s’occuper de plusieurs LEDs, peut-être avec des motifs.</li>
  <li>écrire le tempo et d’autres informations sur un écran LCD.</li>
  <li>tout ce que vous pourrez imaginer d’autre ;)</li>
</ul>

<p>Imaginons maintenant que l’ensemble de ces actions prennent 30 millisecondes
(0,03 secondes). Dans ce cas le tempo sera de \(60 / 0,73\). Soit à peu près 82.
Donc plus du tout la valeur de 86 qu’on avait trouvé tout à l’heure. <strong>Notre
métronome n’est pas fiable !</strong> Il ne vaut rien, arg.</p>

<p><img class="center" src="/images/facepalm.jpg"></p>

<h2 id="faire-et-ne-pas-attendre">Faire et ne pas attendre</h2>

<p>Pour remédier à ce problème nous demandons à l’arduino d’allumer la LED toutes
les 700 millisecondes et non pas <strong>d’attendre</strong> pendant 700 millisecondes.
Pour cela nous gardons une trace du dernier moment où la LED a été allumée
(dans <code>oldTime</code>) et nous comparons cette trace avec le moment présent
(<code>currentTime</code>) à chaque passage dans la boucle :</p>

<p>``` cpp
const byte LED_PIN = 2;
// In millisecondes.
const long FREQUENCY = 700;</p>

<p>long currentTime;
long oldTime;</p>

<p>void setup() {
  pinMode(LED_PIN, OUTPUT);
  currentTime = 0;
  oldTime = 0;
}</p>

<p>void loop() {
  currentTime = millis();</p>

<p>if(currentTime &gt;= oldTime + FREQUENCY) {
    digitalWrite(LED_PIN, HIGH);
    delay(100);
    digitalWrite(LED_PIN, LOW);
    oldTime = currentTime;
  }
}
```</p>

<p>Ça fonctionne pour notre métronome, bien qu’il reste encore 100 millisecondes
gachées (avec <code>delay(100);</code>). La prochaine fois on verra un moyen de se
débarasser de cette attente inutile.</p>

<p></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Le métier de copiste musical]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/10/06/le-metier-de-copiste-musical/"/>
    <updated>2013-10-06T20:58:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/10/06/le-metier-de-copiste-musical</id>
    <content type="html"><![CDATA[<p>Pour changer un peu de l’informatique et comme on est dimanche, je vous
présente aujourd’hui le métier de copiste musical.</p>

<!-- more -->

<p>En quelques mots, un copiste musical se charge de mettre votre musique sur
partition. Doté d’une très bonne oreille, il travaille généralement à partir
d’un enregistrement audio et transcrit votre musique pour vous. Le
produit fini est souvent dans un format imposé par la SACEM.
Il peut aussi travailler avec un imprimeur et/ou un graphiste pour
produire, par exemple un songbook de vos chansons.</p>

<p>Un copiste musical vous sera utile si vous avez besoin de mettre votre
musique sur partition mais que vous ne connaissez pas le solfège, ou encore
si vous n’en avez pas le temps, si vous voulez que ça aie l’air vraiment
pro, etc.
J’ai une amie dont c’est le métier, vous pouvez voir son site ici:
<a href="http://www.la-copiste-musicale.com/">la-copiste-musicale.com</a>.</p>

<script id="fb33k8u">(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>

<p>À demain.</p>

]]></content>
  </entry>
  
</feed>
