<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : base de données | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/base-de-donnees/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2014-04-15T21:32:03+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ruby - Et si on écrivait un ORM ? - partie 2]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/04/14/ruby-et-si-on-ecrivait-un-orm-partie-2/"/>
    <updated>2014-04-14T21:08:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/04/14/ruby-et-si-on-ecrivait-un-orm-partie-2</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Après avoir installé sqlite et la gem sqlite3-ruby, on installe maintenant
rspec et on fait passer un premier test pour notre futur <em>Simple ORM</em>.</p>

<!-- more -->


<p>Pour écrire SORM, on va faire du <em>Test Driven Development</em>, parce que j'ai
envie d'encourager les bonnes pratiques ;) Pour les tests j'utiliserai
Rspec, puisque c'est le framework que je connais le mieux:</p>

<pre><code>gem install rspec
</code></pre>

<p>On écrit un premier test:</p>

<p>``` ruby sorm_spec.rb
require &lsquo;./sorm&rsquo;</p>

<p>describe SORM do</p>

<p>  class Article &lt; SORM
  end</p>

<p>  describe &lsquo;.find_by_*&rsquo; do</p>

<pre><code>it 'returns an array' do
  article = Article.find_by_whatever('foobar')
  expect(article.class).to eq Array
end
</code></pre>

<p>  end
end
```</p>

<p>Alors c'est un test un peu <em>foireux</em>, ok. J'avoue que je n'ai pas réfléchi
une seconde au design de SORM. Je me dis qu'on s'adaptera au fur et à mesure.
Ici je teste qu'une méthode <code>.find_by_whatever</code> renvoie un tableau, c'est
tout. C'est histoire de se mettre en marche. Lancement du test:</p>

<pre><code>$ rspec sorm_spec.rb 
sorm_spec.rb:3:in `&lt;top (required)&gt;': uninitialized constant SORM (NameError)
</code></pre>

<p>Et c'est partie pour l'écriture de notre classe <code>SORM</code>:</p>

<p>``` ruby sorm.rb
class SORM</p>

<p>end
```</p>

<p>Je relance le test:</p>

<pre><code>$ rspec sorm_spec.rb 
F

Failures:

  1) SORM.find_by_* returns an array
     Failure/Error: article = Article.find_by_whatever('foobar')
     NoMethodError:
       undefined method `find_by_whatever' for Article:Class
     # ./sorm_spec.rb:10:in `block (3 levels) in &lt;top (required)&gt;'

Finished in 0.0009 seconds
1 example, 1 failure

Failed examples:

rspec ./sorm_spec.rb:9 # SORM.find_by_* returns an array
</code></pre>

<p>La méthode <code>find_by_whatever</code> est bien sûr inconnue. Comme je veux gérer
les méthodes <code>find_by_*</code> avec <code>method_missing</code> j'écris:</p>

<p>``` ruby sorm.rb
class SORM</p>

<p>  def self.method_missing(method, *args)</p>

<pre><code>[]
</code></pre>

<p>  end</p>

<p>end
```</p>

<p>Et maintenant on est sur la voie:</p>

<pre><code>$ rspec sorm_spec.rb 
.

Finished in 0.01664 seconds
1 example, 0 failures
</code></pre>

<p>On a pas avancé beaucoup, mais on a quand même mis en place le TDD et notre
classe <code>SORM</code>.</p>

<p><em>To be continued</em></p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby - Et si on écrivait un ORM ? - partie 1]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/04/13/ruby-et-si-on-ecrivait-un-orm-partie-1/"/>
    <updated>2014-04-13T21:29:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/04/13/ruby-et-si-on-ecrivait-un-orm-partie-1</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Les derniers articles sur la méta programmation m'ont donnés envie d'écrire
un <a href="http://fr.wikipedia.org/wiki/Mapping_objet-relationnel">ORM</a>.
Un truc simple, basé sur la base de données <a href="https://www.sqlite.org/sqlite.html">Sqlite</a>.
D'ailleurs on va l'appeller SORM, pour <em>Simple Object Relational Mapping</em> ;)</p>

<!-- more -->


<p>Dans ce premier article, on va prendre contact avec Sqlite. Une fois ce dernier
installé sur votre machine, le client console est <code>sqlite3</code>.
Pour créer une nouvelle base de données, <code>test1.db</code>, il suffit de:</p>

<pre><code>$ sqlite3 test1.db
Enter SQL statements terminated with a ";"
</code></pre>

<p>Pour créer une table article:</p>

<pre><code>sqlite&gt; create table article(id int, name varchar(100));
</code></pre>

<p>Pour enregistrer quelques articles:</p>

<pre><code>sqlite&gt; insert into article values(1, 'foo');
sqlite&gt; insert into article values(2, 'bar');
sqlite&gt; insert into article values(3, 'baz');
</code></pre>

<p>Pour faire une requête:</p>

<pre><code>sqlite&gt; select * from article;
1|foo
2|bar
3|baz
</code></pre>

<p>Enfin pour sortir du programme, tapez Control+D.</p>

<p>Passons maintenant à la partie Ruby. J'avais pensé dans un premier temps à
écrire le driver pour communiquer avec Sqlite, mais ça nous entrainerait trop
loin. On va donc utiliser la gem <a href="https://github.com/sparklemotion/sqlite3-ruby">sqlite3-ruby</a>:</p>

<pre><code>gem install sqlite3
</code></pre>

<p>L'utilisation est fort simple:</p>

<p>``` irb
$ irb</p>

<blockquote><blockquote><p>require &lsquo;sqlite3&rsquo;
db = SQLite3::Database.open &ldquo;test1.db&rdquo;
db.execute &lsquo;select * from article;&rsquo;
[[1, &ldquo;foo&rdquo;], [2, &ldquo;bar&rdquo;], [3, &ldquo;baz&rdquo;]]
```</p></blockquote></blockquote>

<p><em>To be continued</em></p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Redis - Comment supprimer un ensemble de clés]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/03/21/redis-comment-supprimer-un-ensemble-de-cles/"/>
    <updated>2014-03-21T21:44:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/03/21/redis-comment-supprimer-un-ensemble-de-cles</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Tiens, mon premier article sur Redis ! Normal, c'est une technologie que
j'ai découvert il y a peu…</p>

<!-- more -->


<p>Pour supprimer une clé dans Redis, on se connecte et on utilise la commande
<code>del</code>:</p>

<pre><code>$ redis-cli
&gt; del "nom:de:la:clef"
</code></pre>

<p>Mais quand on a des dizaines/centaines de clés, bof… Bien souvent (toujours
même ça vaut mieux) le nom des clés suit un motif. Par exemple:</p>

<pre><code>"motif:foo"
"motif:bar"
"motif:baz"
etc...
</code></pre>

<p>Dans ce cas on peut utiliser Bash pour s'en sortir rapidement:</p>

<p><code>bash
redis-cli keys "*motif*" | xargs redis-cli del
</code></p>

<p>Et voilà, au revoir toutes les clés.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
