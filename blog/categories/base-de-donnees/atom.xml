<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : base de données | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/base-de-donnees/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2014-04-19T21:38:56+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ruby - Et si on écrivait un ORM ? - partie 5]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/04/19/ruby-et-si-on-ecrivait-un-orm-partie-5/"/>
    <updated>2014-04-19T21:14:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/04/19/ruby-et-si-on-ecrivait-un-orm-partie-5</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Au menu d'aujourd'hui: réparation du test défecteux et début de la
création/insertion d'un objet.</p>

<!-- more -->


<p>Tout d'abord on répare le test d'hier. Je sors les appels à <code>INSERT</code> dans
un bloc <code>before</code> et j'ajoute ce qui manquait cruellement, un appel à
<code>DELETE</code> dans un bloc <code>after</code>:</p>

<p>``` ruby
  describe &lsquo;.sql&rsquo; do</p>

<pre><code>before do
  Article.sql("INSERT INTO article VALUES(1, 'Foo');")
  Article.sql("INSERT INTO article VALUES(2, 'Bar');")
end

after do
  Article.sql("DELETE FROM article;")
end

it 'returns the correct number of rows' do
  rows = Article.sql("SELECT * FROM article;")
  expect(rows.size).to eq 2
end

it 'returns correct values' do
  rows = Article.sql("SELECT * FROM article;")
  expect(rows[0][0]).to eq 1
  expect(rows[0][1]).to eq 'Foo'
  expect(rows[1][0]).to eq 2
  expect(rows[1][1]).to eq 'Bar'
end
</code></pre>

<p>  end
```</p>

<p>Voilà, maintenant on peut passer à la partie création. J'ai envie que SORM
ait une méthode <code>save</code>, qui enregistrera les données en base et
renverra un objet. On commence avec un test pour l'enregistrement:</p>

<p>``` ruby sorm_spec.rb
require &lsquo;./sorm&rsquo;</p>

<p>describe SORM do
  describe &lsquo;connection&rsquo; do</p>

<pre><code># ...
</code></pre>

<p>  end</p>

<p>  class Article &lt; SORM
  end</p>

<p>  describe &lsquo;.sql&rsquo; do</p>

<pre><code># ...
</code></pre>

<p>  end</p>

<p>  describe &lsquo;object creation&rsquo; do</p>

<pre><code>after { Article.sql("DELETE FROM article;") }

it 'creates a record' do
  Article.save(id: 1, name: 'bépo')
  rows = Article.sql("SELECT * FROM article WHERE id = 1;")
  expect(rows[0][0]).to eq 1
  expect(rows[0][1]).to eq 'bépo'
end
</code></pre>

<p>  end
end
```</p>

<p>J'écris un premier jet de la méthode <code>save</code>, pour faire passer le test:</p>

<p>``` ruby sorm.rb
require &lsquo;sqlite3&rsquo;</p>

<p>class SORM</p>

<p>  @@db = false</p>

<p>  def self.connect(database_filename)</p>

<pre><code>@@db = SQLite3::Database.open(database_filename)
</code></pre>

<p>  end</p>

<p>  def self.connected?</p>

<pre><code>@@db ? true : false
</code></pre>

<p>  end</p>

<p>  def self.sql(raw_query)</p>

<pre><code>@@db.execute(raw_query)
</code></pre>

<p>  end</p>

<p>  def self.save(parameters)</p>

<pre><code>table = self.to_s.downcase
columns = parameters.keys.join(',')
values = parameters.values.map do |item|
  item.class == String ? "'#{item}'" : item
end.join(',')
query = "INSERT INTO #{table} (#{columns}) VALUES(#{values});"
@@db.execute(query)
</code></pre>

<p>  end
end
```</p>

<p>Ça fonctionne, mais la méthode est moche. Ce sera l'occasion de faire du
refactoring dans un prochain article.</p>

<p><em>To be continued</em></p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby - Et si on écrivait un ORM ? - partie 4]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/04/18/ruby-et-si-on-ecrivait-un-orm-partie-4/"/>
    <updated>2014-04-18T21:01:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/04/18/ruby-et-si-on-ecrivait-un-orm-partie-4</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Maintenant qu'on peut se connecter à une base sqlite, je pense qu'il faut
qu'on puisse écrire des requêtes en pur SQL à partir d'un objet qui
hérite de SORM.</p>

<!-- more -->


<p>Voilà donc mon nouveau test:</p>

<p>``` ruby sorm_spec.rb
require &lsquo;./sorm&rsquo;</p>

<p>describe SORM do
  describe &lsquo;connection&rsquo; do</p>

<pre><code># ...

describe 'after connection' do
  # ...
end
</code></pre>

<p>  end</p>

<p>  class Article &lt; SORM
  end</p>

<p>  describe &lsquo;.sql&rsquo; do</p>

<pre><code>it 'executes raw sql query on a table' do
  Article.sql("INSERT INTO article VALUES(1, 'Foo');")
  Article.sql("INSERT INTO article VALUES(2, 'Bar');")
  rows = Article.sql("SELECT * FROM article;")
  expect(rows.size).to eq 2
end
</code></pre>

<p>  end
end
```</p>

<p>Je veux enregistrer deux lignes en base et les récupérer. Si on lance les
tests, Rspec se plaint que la méthode <code>sql</code> n'existe pas. Jusqu'ici tout
va bien:</p>

<pre><code>$ rspec sorm_spec.rb 
..F

Failures:

  1) SORM.sql executes raw sql query on a table
     Failure/Error: Article.sql("INSERT INTO article VALUES(1, 'Foo');")
     NoMethodError:
       undefined method `sql' for Article:Class
</code></pre>

<p>Pour faire passer ce test, le code est simple, on ajoute la méthode <code>sql</code>:</p>

<p>``` ruby sorm.rb
require &lsquo;sqlite3&rsquo;</p>

<p>class SORM</p>

<p>  @@db = false</p>

<p>  def self.connect(database_filename)</p>

<pre><code>@@db = SQLite3::Database.open(database_filename)
</code></pre>

<p>  end</p>

<p>  def self.connected?</p>

<pre><code>@@db ? true : false
</code></pre>

<p>  end</p>

<p>  def self.sql(raw_query)</p>

<pre><code>@@db.execute(raw_query)
</code></pre>

<p>  end
end
```</p>

<p>Et hop:</p>

<pre><code>$ rspec sorm_spec.rb 
...

Finished in 0.01381 seconds
3 examples, 0 failures
</code></pre>

<p>Comme je suis curieux, j'ai envie de voir à quoi ressemble le contenu de
<code>rows</code> dans le test:</p>

<p>``` ruby
  describe &lsquo;.sql&rsquo; do</p>

<pre><code>it 'executes raw sql query on a table' do
  Article.sql("INSERT INTO article VALUES(1, 'Foo');")
  Article.sql("INSERT INTO article VALUES(2, 'Bar');")
  rows = Article.sql("SELECT * FROM article;")
  p rows
  expect(rows.size).to eq 2
end
</code></pre>

<p>  end
```</p>

<p>Et là, une petite surprise m'attend au tournant:</p>

<pre><code>$ rspec sorm_spec.rb 
..[[1, "Foo"], [2, "Bar"], [1, "Foo"], [2, "Bar"]]
F

Failures:

  1) SORM.sql executes raw sql query on a table
     Failure/Error: expect(rows.size).to eq 2

       expected: 2
            got: 4

       (compared using ==)
     # ./sorm_spec.rb:26:in `block (3 levels) in &lt;top (required)&gt;'
</code></pre>

<p>Tout d'abord, j'ai oublié de vider la table après le test qui fait des
insertions. Et ensuite j'ai négligé de spécifier <code>id</code> comme clé primaire !
Bref, j'ai encore du boulot pour que SORM fonctionne ;)</p>

<p><em>To be continued</em></p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby - Et si on écrivait un ORM ? - partie 3]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/04/16/ruby-et-si-on-ecrivait-un-orm-partie-3/"/>
    <updated>2014-04-16T21:23:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/04/16/ruby-et-si-on-ecrivait-un-orm-partie-3</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Cette fois je me dis qu'il faudrait quand même se connecter à la base de
données avant d'aller plus loin…</p>

<!-- more -->


<p>Alors au départ, la connexion est inexistante:</p>

<p>``` ruby sorm_spec.rb
require &lsquo;./sorm&rsquo;</p>

<p>describe SORM do
  describe &lsquo;connection&rsquo; do</p>

<pre><code>it 'is not connected' do
  expect(SORM.connected?).to be false
end
</code></pre>

<p>  end
end
```</p>

<p>On fait passer ce test très facilement:</p>

<p>``` ruby sorm.rb
require &lsquo;sqlite3&rsquo;</p>

<p>class SORM
  def self.connected?</p>

<pre><code>false
</code></pre>

<p>  end
end
```</p>

<p>Maintenant on cherche à se connecter à une base de données existante
(n'oubliez pas de la créer):</p>

<p>``` ruby sorm_spec.rb
require &lsquo;./sorm&rsquo;</p>

<p>describe SORM do
  describe &lsquo;connection&rsquo; do</p>

<pre><code>it 'is not connected' do
  expect(SORM.connected?).to be false
end

describe 'after connection' do
  it 'is connected' do
    SORM.connect('test.db')
    expect(SORM.connected?).to be true
  end
end
</code></pre>

<p>  end
end
```</p>

<p>Pour implémenter cette fonctionnalité, ce à quoi je pense de plus rapide
et de plus simple est une variable de classe. Même si on a parfois des
scrupules à utiliser les variables de classe parce qu'elles sont partagées
aussi par les sous-classes, je me dis que c'est bien le comportement que
je voudrais obtenir. Donc voici le code qui fait passer notre test:</p>

<p>``` ruby sorm.rb
require &lsquo;sqlite3&rsquo;</p>

<p>class SORM</p>

<p>  @@db = false</p>

<p>  def self.connect(database_filename)</p>

<pre><code>@@db = SQLite3::Database.open(database_filename)
</code></pre>

<p>  end</p>

<p>  def self.connected?</p>

<pre><code>@@db ? true : false
</code></pre>

<p>  end
end
```</p>

<p><em>To be continued</em></p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby - Et si on écrivait un ORM ? - partie 2]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/04/14/ruby-et-si-on-ecrivait-un-orm-partie-2/"/>
    <updated>2014-04-14T21:08:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/04/14/ruby-et-si-on-ecrivait-un-orm-partie-2</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Après avoir installé sqlite et la gem sqlite3-ruby, on installe maintenant
rspec et on fait passer un premier test pour notre futur <em>Simple ORM</em>.</p>

<!-- more -->


<p>Pour écrire SORM, on va faire du <em>Test Driven Development</em>, parce que j'ai
envie d'encourager les bonnes pratiques ;) Pour les tests j'utiliserai
Rspec, puisque c'est le framework que je connais le mieux:</p>

<pre><code>gem install rspec
</code></pre>

<p>On écrit un premier test:</p>

<p>``` ruby sorm_spec.rb
require &lsquo;./sorm&rsquo;</p>

<p>describe SORM do</p>

<p>  class Article &lt; SORM
  end</p>

<p>  describe &lsquo;.find_by_*&rsquo; do</p>

<pre><code>it 'returns an array' do
  article = Article.find_by_whatever('foobar')
  expect(article.class).to eq Array
end
</code></pre>

<p>  end
end
```</p>

<p>Alors c'est un test un peu <em>foireux</em>, ok. J'avoue que je n'ai pas réfléchi
une seconde au design de SORM. Je me dis qu'on s'adaptera au fur et à mesure.
Ici je teste qu'une méthode <code>.find_by_whatever</code> renvoie un tableau, c'est
tout. C'est histoire de se mettre en marche. Lancement du test:</p>

<pre><code>$ rspec sorm_spec.rb 
sorm_spec.rb:3:in `&lt;top (required)&gt;': uninitialized constant SORM (NameError)
</code></pre>

<p>Et c'est partie pour l'écriture de notre classe <code>SORM</code>:</p>

<p>``` ruby sorm.rb
class SORM</p>

<p>end
```</p>

<p>Je relance le test:</p>

<pre><code>$ rspec sorm_spec.rb 
F

Failures:

  1) SORM.find_by_* returns an array
     Failure/Error: article = Article.find_by_whatever('foobar')
     NoMethodError:
       undefined method `find_by_whatever' for Article:Class
     # ./sorm_spec.rb:10:in `block (3 levels) in &lt;top (required)&gt;'

Finished in 0.0009 seconds
1 example, 1 failure

Failed examples:

rspec ./sorm_spec.rb:9 # SORM.find_by_* returns an array
</code></pre>

<p>La méthode <code>find_by_whatever</code> est bien sûr inconnue. Comme je veux gérer
les méthodes <code>find_by_*</code> avec <code>method_missing</code> j'écris:</p>

<p>``` ruby sorm.rb
class SORM</p>

<p>  def self.method_missing(method, *args)</p>

<pre><code>[]
</code></pre>

<p>  end</p>

<p>end
```</p>

<p>Et maintenant on est sur la voie:</p>

<pre><code>$ rspec sorm_spec.rb 
.

Finished in 0.01664 seconds
1 example, 0 failures
</code></pre>

<p>On a pas avancé beaucoup, mais on a quand même mis en place le TDD et notre
classe <code>SORM</code>.</p>

<p><em>To be continued</em></p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby - Et si on écrivait un ORM ? - partie 1]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/04/13/ruby-et-si-on-ecrivait-un-orm-partie-1/"/>
    <updated>2014-04-13T21:29:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/04/13/ruby-et-si-on-ecrivait-un-orm-partie-1</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Les derniers articles sur la méta programmation m'ont donnés envie d'écrire
un <a href="http://fr.wikipedia.org/wiki/Mapping_objet-relationnel">ORM</a>.
Un truc simple, basé sur la base de données <a href="https://www.sqlite.org/sqlite.html">Sqlite</a>.
D'ailleurs on va l'appeller SORM, pour <em>Simple Object Relational Mapping</em> ;)</p>

<!-- more -->


<p>Dans ce premier article, on va prendre contact avec Sqlite. Une fois ce dernier
installé sur votre machine, le client console est <code>sqlite3</code>.
Pour créer une nouvelle base de données, <code>test1.db</code>, il suffit de:</p>

<pre><code>$ sqlite3 test1.db
Enter SQL statements terminated with a ";"
</code></pre>

<p>Pour créer une table article:</p>

<pre><code>sqlite&gt; create table article(id int, name varchar(100));
</code></pre>

<p>Pour enregistrer quelques articles:</p>

<pre><code>sqlite&gt; insert into article values(1, 'foo');
sqlite&gt; insert into article values(2, 'bar');
sqlite&gt; insert into article values(3, 'baz');
</code></pre>

<p>Pour faire une requête:</p>

<pre><code>sqlite&gt; select * from article;
1|foo
2|bar
3|baz
</code></pre>

<p>Enfin pour sortir du programme, tapez Control+D.</p>

<p>Passons maintenant à la partie Ruby. J'avais pensé dans un premier temps à
écrire le driver pour communiquer avec Sqlite, mais ça nous entrainerait trop
loin. On va donc utiliser la gem <a href="https://github.com/sparklemotion/sqlite3-ruby">sqlite3-ruby</a>:</p>

<pre><code>gem install sqlite3
</code></pre>

<p>L'utilisation est fort simple:</p>

<p>``` irb
$ irb</p>

<blockquote><blockquote><p>require &lsquo;sqlite3&rsquo;
db = SQLite3::Database.open &ldquo;test1.db&rdquo;
db.execute &lsquo;select * from article;&rsquo;
[[1, &ldquo;foo&rdquo;], [2, &ldquo;bar&rdquo;], [3, &ldquo;baz&rdquo;]]
```</p></blockquote></blockquote>

<p><em>To be continued</em></p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
