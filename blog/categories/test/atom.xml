<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : test | Xavier Nayrac]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/test/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2015-10-10T18:22:47+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Coco version 0.13.0]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/07/29/coco-version-0-dot-13-dot-0/"/>
    <updated>2015-07-29T10:50:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/07/29/coco-version-0-dot-13-dot-0</id>
    <content type="html"><![CDATA[<p>Je me rend compte que j’ai sorti la version 0.13.0 de
<a href="https://github.com/lkdjiin/coco">coco</a>
il y a près d’un mois et que je n’ai pas encore écrit une seule ligne sur le
sujet !</p>

<p>Coco est un outil de <strong>co</strong>uverture de <strong>co</strong>de pour Ruby — <strong>co</strong>de
<strong>co</strong>verage en anglais —. En gros, coco vous dit quels sont les fichiers d’un
projet qui ne sont pas suffisamment testés :</p>

<p><img class="center" src="/images/coco-shot-1.png"></p>

<!-- more -->

<p>Puis, pour les fichiers qui ne sont pas couverts à 100% par les tests, vous
pouvez visualiser les parties du code qui ne sont pas couvertes (ici en rouge) :</p>

<p><img class="center" src="/images/coco-shot-2.png"></p>

<p>Qu’y a-t-il de nouveau dans cette version 0.13.0 ? J’ai essentiellement
travaillé sur l’aspect du rapport HTML, afin qu’il soit un peu plus agréable
à regarder (je ne suis toujours ni graphiste ni designer, mais je crois que
cette fois ça n’est pas trop mal). On peut retenir aussi que les versions de
Ruby inférieures à 2 ne sont plus supportées.</p>

<p>Il ne reste plus grand chose à faire avant la <a href="https://github.com/lkdjiin/coco/issues">version 1.0</a>. Ça sera peut-être pour la fin de cette année, 5 ans après la première release, qui sait ?</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Comportement inattendu de Rspec]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/06/30/comportement-inattendu-de-rspec/"/>
    <updated>2015-06-30T15:37:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/06/30/comportement-inattendu-de-rspec</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Je suis tombé aujourd’hui sur un comportement inattendu de Rspec.
Je ne dis pas que le comportement est mauvais, seulement je m’attendais à
autre chose qui me semble plus logique. Quoiqu’il en soit, je partage mes
réflexions avec vous.</p>

<!-- more -->

<p>J’utilise beaucoup Rspec que j’aime bien. Pourtant je connais assez mal sa
mécanique interne. Un pattern dont je me sers de temps
en temps est de définir des méthodes helper dans le fichier de test :</p>

<p>``` ruby spec/thing1_spec.rb
require ‘spec_helper’</p>

<p>describe Thing1 do</p>

<p>it “returns ‘foo’” do
    expect(Thing1.new.get).to eq result
  end</p>

<p>end</p>

<p>def result
  ‘foo’
end
```</p>

<p>Avec <code>Thing1</code> défini ainsi :</p>

<p><code>ruby thing1.rb
class Thing1
  def get
    'foo'
  end
end
</code></p>

<p>Ça marche très bien :</p>

<pre><code>$ rspec -I. spec/thing1_spec.rb 
.

Finished in 0.00184 seconds (files took 0.23569 seconds to load)
1 example, 0 failures
</code></pre>

<p>Là où ça devient problématique, c’est si j’utilise le même nom de méthode helper
dans un autre fichier de test :</p>

<p>``` ruby spec/thing2_spec.rb
require ‘spec_helper’</p>

<p>describe Thing2 do</p>

<p>it “returns ‘bar’” do
    expect(Thing2.new.get).to eq result
  end</p>

<p>end</p>

<p>def result
  ‘bar’
end
```</p>

<p>Avec <code>Thing2</code> comme ceci :</p>

<p><code>ruby thing2.rb
class Thing2
  def get
    'bar'
  end
end
</code></p>

<p>Dans ce cas un test échoue :</p>

<pre><code>$ rspec -I.
F.

Failures:

  1) Thing1 returns 'foo'
     Failure/Error: expect(Thing1.new.get).to eq result
       
       expected: "bar"
            got: "foo"
       
       (compared using ==)
     # ./spec/thing1_spec.rb:6:in `block (2 levels) in &lt;top (required)&gt;'

Finished in 0.00232 seconds (files took 0.21784 seconds to load)
2 examples, 1 failure

Failed examples:

rspec ./spec/thing1_spec.rb:5 # Thing1 returns 'foo'
</code></pre>

<p>J’ai tenté de les jouer de différentes manières : seulement l’un, puis
seulement l’autre, Thing1 puis Thing2, Thing2 puis Thing1, pour voir…</p>

<p>J’en arrive à la conclusion que Rspec charge tous les fichiers de test avant de
démarrer un test. Comme Ruby est dynamique, c’est la dernière méthode <code>result</code> chargée qui, en quelque sorte, à raison.</p>

<p>La solution est donc simple, il faut <em>rentrer</em> les méthodes helper dans le
bloc <code>describe</code> :</p>

<p>``` ruby
require ‘spec_helper’</p>

<p>describe Thing1 do</p>

<p>it “returns ‘foo’” do
    expect(Thing1.new.get).to eq result
  end</p>

<p>def result
    ‘foo’
  end</p>

<p>end
```</p>

<p>Maintenant les deux tests fonctionnent comme attendu :</p>

<pre><code>$ rspec -I.
..

Finished in 0.00283 seconds (files took 0.21533 seconds to load)
2 examples, 0 failures
</code></pre>

<p><strong>Je m’attendais à ce que les différents fichiers de test soient joués en
isolation totale</strong>, sans connexion si mince soit elle avec d’autres fichiers.
Manifestement c’est pas le cas.</p>

<p>Pour être exhaustif voici le contenu du <em>spec helper</em> :</p>

<p><code>ruby spec/spec_helper.rb
require 'thing1'
require 'thing2'
</code></p>

<p>Et voici les fichiers :</p>

<pre><code>$ \tree
.
|-- spec
|   |-- spec_helper.rb
|   |-- thing1_spec.rb
|   `-- thing2_spec.rb
|-- thing1.rb
`-- thing2.rb
</code></pre>

<p>Si vous avez un avis sur la question il m’intéresse beaucoup, n’hésitez donc pas à laisser un
commentaire.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby CSV tests et quelques questions]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/07/03/ruby-csv-tests-et-quelques-questions/"/>
    <updated>2014-07-03T21:31:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/07/03/ruby-csv-tests-et-quelques-questions</id>
    <content type="html"><![CDATA[<p>Ça fait une semaine que je travaille sur des exports de statisques au format
CSV en Ruby. Ce n’est pas la première fois que je bosse sur ce genre de
fonctionnalité, que ce soit en Ruby ou dans un autre langage, et j’ai
toujours et encore le même problême: les tests.</p>

<!-- more -->

<p>Je m’explique. J’aime avoir des tests d’intégration qui s’assurent que les
bons fichiers soient produits. Par exemple:</p>

<pre><code>A, B, C, D ...
1, 2, 3, 4 ...
.
.
.
</code></pre>

<p>J’aime pouvoir contrôler la production de plusieurs fichiers, un pour chaque
scénario. Le gros soucis avec ce genre de test, c’est leur fragilité,
quand, par exemple, les utilisateurs s’aperçoivent que l’ordre des champs serait mieux
ainsi:</p>

<pre><code>A, C, D, B ...
1, 3, 4, 2 ...
.
.
.
</code></pre>

<p>Et là, il faut réécrire tous les fichiers de contrôle. Certains pouvant
contenir des dizaines de champs…</p>

<p>J’ai donc une question pour vous: comment faites vous pour faciliter ce
genre de tests ?</p>

<script id="fb33k8u">(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby Timecop - Comment ça marche ?]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/04/02/ruby-timecop-comment-ca-marche/"/>
    <updated>2014-04-02T21:07:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/04/02/ruby-timecop-comment-ca-marche</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Hier je vous parlais de Timecop, une gem Ruby qui <em>arrête le
temps</em>, très utile pour tester les dates. J’y ai repensé un
peu aujourd’hui sur le mode : «j’aurais pu y penser avant !».</p>

<p>Alors justement, si j’avais eu cette idée, comment j’aurais
fait ? C’est l’occasion de parler de méta-programmation.
Allez j’essaye d’écrire ma propre méthode
<code>Time.freeze</code>, on verra bien…</p>

<!-- more -->

<p>Voilà les étapes qui me semble nécessaires:</p>

<ol>
  <li>Geler le temps et le retenir.</li>
  <li>Faire un backup de Time.now.</li>
  <li>Définir une nouvelle méthode Time.now qui renvoie toujours
le même temps.</li>
  <li>Appeler le block passé à la méthode.</li>
  <li>Restaurer la méthode Time.now originale.</li>
</ol>

<p>Avant de coder, j’écris un test:</p>

<p>``` ruby
puts “Time before #{Time.now}”
sleep 3</p>

<p>Time.freeze do
  puts Time.now.to_s
  sleep 3
  puts Time.now.to_s
end</p>

<p>sleep 3
puts “Time after #{Time.now}”
```</p>

<p>Je veux donc obtenir un affichage du genre:</p>

<pre><code>Time before hh:mm:00
hh:mm:03
hh:mm:03
Time after hh:mm:09
</code></pre>

<p>Ok ? C’est parti.</p>

<h2 id="ouvrir-la-classe-time">Ouvrir la classe Time</h2>

<p><code>ruby
class Time
  def self.freeze
  end
end
</code></p>

<p>Premier truc à savoir, une classe Ruby est toujours ouverte
à la modification. Même si il s’agit d’une classe du coeur
du langage, comme Object ou Kernel. <em>Si vous êtes perdus,
faites une recherche sur «ruby open class».</em></p>

<h2 id="arrter-le-temps">Arrêter le temps</h2>

<p><code>ruby
class Time
  def self.freeze
    freezed = Time.now
  end
end
</code></p>

<p>Pas grand chose à dire. On pourra renvoyer l’objet <code>freezed</code>
chaque fois qu’on nous demandera <code>Time.now</code>.</p>

<h2 id="sauvegarder-timenow-original">Sauvegarder Time.now original</h2>

<p><code>ruby
class Time
  def self.freeze
    freezed = Time.now
    singleton_class.send(:alias_method, :old_now, :now)
  end
end
</code></p>

<p>Là il y a beaucoup à dire. On rentre dans la
méta-programmation et je n’ai pas la place (ni le temps) dans
cet article pour parler du modêle objet de Ruby.
N’hésitez pas à faire une recherche sur «ruby object model» ou
«ruby eigenclass».</p>

<p>On dit à la classe <code>Time</code> de créer un alias de la méthode de
classe <code>now</code> avec le nom <code>old_now</code>.</p>

<h2 id="un-nouveau-timenow">Un nouveau Time.now</h2>

<p><code>ruby
class Time
  def self.freeze
    freezed = Time.now
    singleton_class.send(:alias_method, :old_now, :now)
    define_singleton_method('now') { freezed }
  end
end
</code></p>

<p>Cette fois, je dis à la classe <code>Time</code> de créer une méthode de
classe qui s’appelle <code>now</code> et qui renvoie notre objet
<code>freezed</code>.</p>

<h2 id="appeler-le-block">Appeler le block</h2>

<p><code>ruby
class Time
  def self.freeze
    freezed = Time.now
    singleton_class.send(:alias_method, :old_now, :now)
    define_singleton_method('now') { freezed }
    yield
  end
end
</code></p>

<p>Bon, ça c’était facile ;)</p>

<h2 id="restaurer-timenow">Restaurer Time.now</h2>

<p><code>ruby
class Time
  def self.freeze
    freezed = Time.now
    singleton_class.send(:alias_method, :old_now, :now)
    define_singleton_method('now') { freezed }
    yield
    singleton_class.send(:alias_method, :now, :old_now)
  end
end
</code></p>

<p>Ça me semble tout bon. On teste ?</p>

<h2 id="le-test">Le test</h2>

<p>``` ruby freeze.rb
class Time
  def self.freeze
    freezed = Time.now
    singleton_class.send(:alias_method, :old_now, :now)
    define_singleton_method(‘now’) { freezed }
    yield
    singleton_class.send(:alias_method, :now, :old_now)
    # singleton_class.send(:remove_method, :old_now)
  end
end</p>

<p>puts “Time before #{Time.now}”
sleep 3</p>

<p>Time.freeze do
  puts Time.now.to_s
  sleep 3
  puts Time.now.to_s
end</p>

<p>sleep 3
puts “Time after #{Time.now}”
```</p>

<p><code>bash
$ ruby freeze.rb 
Time before 2014-04-02 21:40:57 +0200
2014-04-02 21:41:00 +0200
2014-04-02 21:41:00 +0200
Time after 2014-04-02 21:41:06 +0200
</code></p>

<p>Excellent !</p>

<p>Il reste un léger problème : la méthode <code>Time.old_now</code>
existe toujours, ce qui n’est pas très propre. On pourra
la supprimer ainsi:</p>

<pre><code>singleton_class.send(:remove_method, :old_now)
</code></pre>

<p>Voilà, j’aurais quand même pu y penser avant… J’espère
trouver du temps une prochaine fois pour jeter un coup
d’oeil au code de Timecop pour comparer avec le code
d’aujourd’hui.</p>

<script id="fb33k8u">(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tester facilement vos dates avec Timecop]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/04/01/tester-facilement-vos-dates-avec-timecop/"/>
    <updated>2014-04-01T21:06:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/04/01/tester-facilement-vos-dates-avec-timecop</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p><a href="https://github.com/travisjeffery/timecop">Timecop</a>
n’est pas une nouvelle gem. Mais je ne la découvre qu’aujourd’hui.
Ça fait pourtant 4 ans que je travaille quotidiennement avec Ruby
et/ou Rails… Et je ne me suis jamais sentis très à l’aise pour tester
les dates. Avec Timecop, ça devient un jeu d’enfant.</p>

<!-- more -->

<p>Pour voir un souci possible, prenons la classe suivante qui représente
un article:</p>

<p>``` ruby article.rb
class Article
  def initialize(name)
    @name = name
    @created_at = Time.now
  end</p>

<p>attr_reader :name, :created_at
end
```</p>

<p>Dans le monde réel, ce serait surement un ActiveRecord, mais pour
l’exemple on se contentera bien de cette classe ;)</p>

<p>Maintenant testons la création d’un article:</p>

<p>``` ruby tc_article.rb
require_relative “article”
require “test/unit”</p>

<p>class TestArticle &lt; Test::Unit::TestCase
  def test_creation
    article = Article.new(‘Foo’)
    assert_equal ‘Foo’, article.name
    assert_equal Time.now, article.created_at
  end
end
```</p>

<p>Et voilà le souci, à quelques nano-secondes près ça pète:</p>

<p>``` bash
$ ruby tc_article.rb 
Run options: </p>

<h1 id="running-tests">Running tests:</h1>

<p>[1/1] TestArticle#test_creation = 0.00 s
  1) Failure:
TestArticle#test_creation [tc_article.rb:8]:
&lt;2014-04-01 21:05:10 +0200&gt; (204201[ns]) expected but was
&lt;2014-04-01 21:05:10 +0200&gt; (176685[ns]).</p>

<p>Finished tests in 0.009979s, 100.2062 tests/s, 200.4125 assertions/s.
1 tests, 2 assertions, 1 failures, 0 errors, 0 skips
```</p>

<p>Timecop est la meilleure solution que j’ai vu jusqu’ici pour régler
ce type de problème. La gem propose tout simplement (entre autres)
<em>de geler le temps</em>:</p>

<p>``` ruby tc_article.rb
require_relative “article”
require “test/unit”
require “timecop”</p>

<p>class TestArticle &lt; Test::Unit::TestCase
  def test_creation
    Timecop.freeze do
      article = Article.new(‘Foo’)
      assert_equal ‘Foo’, article.name
      assert_equal Time.now, article.created_at
    end
  end
end
```</p>

<p>Et voilà le résultat:</p>

<p>``` bash
ruby tc_article.rb 
Run options: </p>

<h1 id="running-tests-1">Running tests:</h1>

<p>Finished tests in 0.010756s, 92.9747 tests/s, 185.9494 assertions/s.
1 tests, 2 assertions, 0 failures, 0 errors, 0 skips
```</p>

<p>J’aimerais bien savoir quelles solutions vous avez adoptés pour
régler ce genre de soucis…</p>

<script id="fb33k8u">(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
