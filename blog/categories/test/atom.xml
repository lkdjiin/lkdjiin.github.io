<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : test | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/test/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2014-04-01T21:31:10+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Tester facilement vos dates avec Timecop]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/04/01/tester-facilement-vos-dates-avec-timecop/"/>
    <updated>2014-04-01T21:06:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/04/01/tester-facilement-vos-dates-avec-timecop</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p><a href="https://github.com/travisjeffery/timecop">Timecop</a>
n'est pas une nouvelle gem. Mais je ne la découvre qu'aujourd'hui.
Ça fait pourtant 4 ans que je travaille quotidiennement avec Ruby
et/ou Rails… Et je ne me suis jamais sentis très à l'aise pour tester
les dates. Avec Timecop, ça devient un jeu d'enfant.</p>

<!-- more -->


<p>Pour voir un souci possible, prenons la classe suivante qui représente
un article:</p>

<p>``` ruby article.rb
class Article
  def initialize(name)</p>

<pre><code>@name = name
@created_at = Time.now
</code></pre>

<p>  end</p>

<p>  attr_reader :name, :created_at
end
```</p>

<p>Dans le monde réel, ce serait surement un ActiveRecord, mais pour
l'exemple on se contentera bien de cette classe ;)</p>

<p>Maintenant testons la création d'un article:</p>

<p>``` ruby tc_article.rb
require_relative &ldquo;article&rdquo;
require &ldquo;test/unit&rdquo;</p>

<p>class TestArticle &lt; Test::Unit::TestCase
  def test_creation</p>

<pre><code>article = Article.new('Foo')
assert_equal 'Foo', article.name
assert_equal Time.now, article.created_at
</code></pre>

<p>  end
end
```</p>

<p>Et voilà le souci, à quelques nano-secondes près ça pète:</p>

<p>``` bash
$ ruby tc_article.rb
Run options:</p>

<h1>Running tests:</h1>

<p>[1/1] TestArticle#test_creation = 0.00 s
  1) Failure:
TestArticle#test_creation [tc_article.rb:8]:
&lt;2014-04-01 21:05:10 +0200> (204201[ns]) expected but was
&lt;2014-04-01 21:05:10 +0200> (176685[ns]).</p>

<p>Finished tests in 0.009979s, 100.2062 tests/s, 200.4125 assertions/s.
1 tests, 2 assertions, 1 failures, 0 errors, 0 skips
```</p>

<p>Timecop est la meilleure solution que j'ai vu jusqu'ici pour régler
ce type de problème. La gem propose tout simplement (entre autres)
<em>de geler le temps</em>:</p>

<p>``` ruby tc_article.rb
require_relative &ldquo;article&rdquo;
require &ldquo;test/unit&rdquo;
require &ldquo;timecop&rdquo;</p>

<p>class TestArticle &lt; Test::Unit::TestCase
  def test_creation</p>

<pre><code>Timecop.freeze do
  article = Article.new('Foo')
  assert_equal 'Foo', article.name
  assert_equal Time.now, article.created_at
end
</code></pre>

<p>  end
end
```</p>

<p>Et voilà le résultat:</p>

<p>``` bash
ruby tc_article.rb
Run options:</p>

<h1>Running tests:</h1>

<p>Finished tests in 0.010756s, 92.9747 tests/s, 185.9494 assertions/s.
1 tests, 2 assertions, 0 failures, 0 errors, 0 skips
```</p>

<p>J'aimerais bien savoir quelles solutions vous avez adoptés pour
régler ce genre de soucis…</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Exemple de test pour Vim avec le framework Vader]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/03/29/exemple-de-test-pour-vim-avec-le-framework-vader/"/>
    <updated>2014-03-29T21:10:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/03/29/exemple-de-test-pour-vim-avec-le-framework-vader</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Pour mon plugin <a href="https://github.com/lkdjiin/quickmarkdown">QuickMarkdown</a>, je vais ajouter une petite fonction
qui insère la ligne <code>&lt;!-- more --&gt;</code> quand je tape la combinaison de
touche <code>&lt;Leader&gt;qm</code>. Ça devrait m'être utile vu que j'écris du markdown
pour Octopress tous les jours ;) Si on est pas obligé de passer par un
plugin pour ce genre de chose, ça va aussi me permettre de parler un peu
de Vader. Voici donc un exemple simple de TDD pour
Vim, avec le framework de test Vader.</p>

<!-- more -->


<p>Tout d'abord, j'écris le test:</p>

<p>``` raw test/more.vader
Given (some text):
  First line
  Last line</p>

<p>Do (insert more marker in normal mode):
  gg
  :QuickMarkdownMore&lt;Enter></p>

<p>Expect (marker inserted):
  First line
  <!-- more -->
  Last line
```</p>

<p>Voici comment il fonctionne. La directive <code>Given</code> produit un buffer (=~ fichier)
utilisé dans les directives suivante, qui contient 2 lignes, respectivement
<code>First line</code> et <code>Last line</code>:</p>

<p><code>raw
Given (some text):
  First line
  Last line
</code></p>

<p>Ensuite, la directive <code>Do</code> joue des commandes en mode normal. Tout d'abord
<code>gg</code>, pour s'assurer qu'on est sur la première ligne, puis la commande
<code>QuickMarkdownMore</code>, qui est celle qui est censée faire le travail:</p>

<p><code>raw
Do (insert more marker in normal mode):
  gg
  :QuickMarkdownMore\&lt;Enter&gt;
</code></p>

<p>Finalement, la directive <code>Expect</code> s'assure que le buffer de test a été
transformé comme je le voulais:</p>

<p><code>raw
Expect (marker inserted):
  First line
  &lt;!-- more --&gt;
  Last line
</code></p>

<p>Il reste à lancer le test (avec <code>:Vader</code>) pour s'assurer qu'il ne passe
pas, puis à écrire la fonction, et relancer le test en s'assurant qu'il
passe bien cette fois-ci.</p>

<p>Et voici pour finir le code d'implémentation:</p>

<p><code>vim plugin/markdown.vim
command! QuickMarkdownMore call quickmarkdown#more()
</code></p>

<p><code>vim autoload/markdown.vim
function! quickmarkdown#more()
  call append('.', "&lt;!-- more --&gt;")
endfunction
</code></p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Quelques trucs pour lancer Rspec]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/03/20/quelques-trucs-pour-lancer-rspec/"/>
    <updated>2014-03-20T21:06:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/03/20/quelques-trucs-pour-lancer-rspec</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p><a href="http://rspec.info/">Rspec</a> est un framework de test très utilisé dans le monde Ruby.
Il y a bien des manières différentes de le lancer et aujourd'hui on
voit quelques options basiques qu'on peut utiliser tous les jours.</p>

<!-- more -->


<p>Tout d'abord, on peut lancer Rspec avec ses options par défaut:</p>

<pre><code>$ rspec spec/
.................................................................
Finished in 0.25958 seconds
65 examples, 0 failures
</code></pre>

<p>À noter que le programme repose, comme souvent dans l'éco-système Ruby,
sur certaines conventions. Si le répertoire qui comporte vos tests est
nommé <code>spec</code>, vous pouvez vous contentez de:</p>

<pre><code>$ rspec
.................................................................
Finished in 0.25958 seconds
65 examples, 0 failures
</code></pre>

<p>Parfois, on a envie de voir le nom des tests, plutôt que des petits points:</p>

<pre><code>$ rspec --format=documentation spec/
Coco::Configuration
  should respond to #user_wants_to_run?
  with no config file
    should give a default threshold of 100%
    should give a default list of directories
    should give an empty default list of files to excludes
    should give false for 'single_line_report'
    #user_wants_to_run? returns true
    give false for 'show_link_in_terminal'
[...]
Finished in 0.08854 seconds
65 examples, 0 failures
</code></pre>

<p>Nos tests doivent fonctionner en isolation, le résultat doit être le même
quel que soit l'ordre:</p>

<pre><code>$ rspec --order=random spec/
.................................................................
Finished in 0.08785 seconds
65 examples, 0 failures
Randomized with seed 8689
</code></pre>

<p>Vous pouvez mettre ses options, et d'autres, dans un fichier <code>.rspec</code> à la
racine de votre projet pour qu'elles deviennent les options par défaut.
Par exemple, le fichier suivant vous donnera une sortie en couleur et des
tests joués aléatoirement à chaque lancement de <code>rspec</code>:</p>

<p><code>raw .rspec
--color
--order=random
</code></p>

<p>Pour lancer les tests d'un seul fichier:</p>

<pre><code>$ rspec spec/configuration_spec.rb 
.......................
Finished in 0.03708 seconds
23 examples, 0 failures
</code></pre>

<p>Pour lancer un seul test, ajouter le numéro de la ligne derrière le nom du
fichier:</p>

<pre><code>$ rspec spec/configuration_spec.rb:41
Run options: include {:locations=&gt;{"./spec/configuration_spec.rb"=&gt;[41]}}
Coco::Configuration
  with no config file
    #user_wants_to_run? returns true
Finished in 0.00333 seconds
1 example, 0 failures
</code></pre>

<p>Pour terminer ce <em>Rspec basics</em>, on peut désactiver un test en écrivant <code>xit</code>
à la place de <code>it</code>:</p>

<p>``` ruby</p>

<pre><code>xit "should give a default threshold of 100%" do
  @config[:threshold].should == 100
end
</code></pre>

<p>```</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vader, un framework de test pour Vim]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/03/16/vader-un-framework-de-test-pour-vim/"/>
    <updated>2014-03-16T20:52:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/03/16/vader-un-framework-de-test-pour-vim</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/junegunn/vader.vim">Vader</a> est un framework de test pour Vim, écrit en VimScript. Sa syntaxe très simple
fait penser un peu à un mélange de Cucumber et de Python. Il est vraiment sympa
à utiliser.</p>

<!-- more -->


<p>Voici à quoi ressemble un test simple avec Vader:</p>

<pre><code>Given (A line of text):
  Make a title of this

Execute (To level 1 title):
  QuickMarkdownTitle1

Expect (to be a level 1 title):
  Make a title of this
  ====================
</code></pre>

<p>Le bloc <code>Given</code> permet de remplir un buffer de test avec des données.</p>

<p>Le bloc <code>Execute</code> lance des fonctions Vim.</p>

<p>Le bloc <code>Expect</code> vérifie que le buffer de test est bien celui attendu
après le passage du bloc <code>Execute</code>.</p>

<p>Il existe aussi un bloc <code>Do</code>, qui simule le mode normal:</p>

<pre><code>Given (Some text):
  Make a title of this
  and not of this one

Do (To title 1):
  gg
  :QuickMarkdownTitle1\&lt;Enter&gt;

Expect (to be a level 1 title):
  Make a title of this
  ====================
  and not of this one
</code></pre>

<p>On lance Vader simplement avec:</p>

<p><code>vim
:Vader
</code></p>

<p>et le framework ouvre un nouveau buffer avec toutes les informations
nécessaires:</p>

<pre><code>Starting Vader: 1 suite(s), 6 case(s)
  Starting Vader: /home/xavier/devel/vim/quickmarkdown/test/titles.vader
    (1/6) [  GIVEN] A line of text
    (1/6) [EXECUTE] To level 1 title
    (1/6) [ EXPECT] to be a level 1 title
    (2/6) [  GIVEN] A line of text
    (2/6) [EXECUTE] To level 2 title
    (2/6) [ EXPECT] to be a level 2 title
    (3/6) [  GIVEN] A line of text
    (3/6) [EXECUTE] To level 3 title
    (3/6) [ EXPECT] to be a level 3 title
    (4/6) [  GIVEN] Some text
    (4/6) [     DO] To title 1
    (4/6) [ EXPECT] to be a level 1 title
    (5/6) [  GIVEN] Some text
    (5/6) [     DO] To title 2
    (5/6) [ EXPECT] to be a level 2 title
    (6/6) [  GIVEN] Some text
    (6/6) [     DO] To title 3
    (6/6) [ EXPECT] to be a level 3 title
  Success/Total: 6/6
Success/Total: 6/6 (assertions: 0/0)
Elapsed time: 0.419884 sec.
</code></pre>

<p>Vader est «livré» avec coloration syntaxique, ftplugin, plusieurs exemples
d'utilisations. Il peut aussi faire des hooks <code>before</code> et <code>after</code>, inclure des
fichiers et d'autres choses encore…</p>

<p>Une très bonne découverte, très agréable à utiliser.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Apprendre Ruby en faisant des maths 7: Tests unitaires simples]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/11/14/apprendre-ruby-en-faisant-des-maths-7-tests-unitaires-simples/"/>
    <updated>2013-11-14T13:22:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/11/14/apprendre-ruby-en-faisant-des-maths-7-tests-unitaires-simples</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Si vous voulez vraiment apprendre Ruby, vous <em>devriez</em> aussi apprendre
à faire des tests automatisés: c'est le meilleur moyen d'avoir confiance
en son code. Et la question se pose de savoir quel framework utiliser ?
Il en existe plusieurs: unit/test, minitest, RSpec, Shoulda, Cucumber et
j'en oublie… Chaque développeur a ses préférences, et c'est bien normal.</p>

<p><code>&lt;opinion&gt;</code></p>

<p>Mais souvent les développeurs ont aussi des convictions, ce qui est parfois
problématique. Un framework de test est un outil, comme tant d'autres.
Un outil X peut être parfait pour telle application et bien moins bon pour
telle autre application. Autrement dit, <strong>LE</strong> framework de test n'existe
pas. Quand vous en aurez testé quelques uns, vous aurez une préférence,
d'accord, pas de soucis. Mais s'il vous plait, avant d'avoir une conviction,
attendez d'en avoir <em>utilisé</em> 3 ou 4, et chacun dans différents types de
projet.</p>

<p><code>&lt;/opinion&gt;</code></p>

<!-- more -->


<p>Aujourd'hui on va apprendre à tester le module créé <a href="http://lkdjiin.github.io/blog/2013/11/01/apprendre-ruby-en-faisant-des-maths-6-methodes-utilitaires-et-module/">la dernière fois</a>
à l'aide du framework test/unit. Pas parce que ce framework est le
meilleur, pas parce que j'ai une préférence pour ce framework mais parce qu'il
est livré avec Ruby et qu'il ne necessite donc pas d'installation.</p>

<h2>Le fichier de test</h2>

<p>Voici le code à mettre dans un fichier nommé <code>tc_number.rb</code>:</p>

<p>``` ruby tc_number.rb
require_relative &ldquo;number&rdquo;
require &ldquo;test/unit&rdquo;</p>

<p>class TestNumber &lt; Test::Unit::TestCase
  def test_divisors</p>

<pre><code>assert_equal [1, 2, 4, 8], Number.divisors(4)
</code></pre>

<p>  end
end
```</p>

<p>Le fichier <code>tc_number.rb</code> contient le code pour tester notre module <code>Number</code>,
qui est dans le fichier <code>number.rb</code>. Veillez à garder les deux fichiers dans
le même dossier.</p>

<h2>Explications</h2>

<p>Voici les explications, ligne par ligne:</p>

<pre><code>require_relative "number"
</code></pre>

<p>On charge notre module <code>Number</code>.</p>

<pre><code>require "test/unit"
</code></pre>

<p>On charge la bibliothèque <code>test/unit</code>, qui contient plusieurs classes/modules
et méthodes qui vont nous permettre d'écrire nos tests.</p>

<pre><code>class TestNumber &lt; Test::Unit::TestCase
</code></pre>

<p>On crée une classe <code>TestNumber</code>. Vous remarquez que c'est le nom de notre
module à tester, préfixé par Test. Cette classe hérite de
<code>Test::Unit::TestCase</code>. Si vous ne savez pas encore ce qu'est une classe,
dites vous que c'est un module un peu spécial. Si vous ne savez pas
encore ce qu'est l'héritage, ce n'est pas grave.</p>

<pre><code>def test_divisors
</code></pre>

<p>On définit un test de la méthode <code>divisors</code>, à travers la méthodes
<code>test_divisors</code>. Vous remarquez que c'est le nom de notre méthode à tester,
préfixé par <code>test_</code>.</p>

<pre><code>assert_equal [1, 2, 4, 8], Number.divisors(4)
</code></pre>

<p>Voici enfin le test proprement dit. La méthode <code>assert_equal</code> s'assure
que ses deux arguments sont égaux. On veut savoir si <code>Number.divisors(4)</code>
est bien égal à l'Array (la liste) <code>[1, 2, 3, 4]</code>, <em>ce qui est faux</em>.</p>

<h2>Utilisation</h2>

<p>Voici la sortie:</p>

<pre><code>[~]⇒ ruby tc_number.rb 
Run options: 

# Running tests:

F

Finished tests in 0.002405s, 415.8087 tests/s, 415.8087 assertions/s.

  1) Failure:
test_divisors(TestNumber) [tc_number.rb:6]:
&lt;[1, 2, 4, 8]&gt; expected but was
&lt;[1, 2, 4]&gt;.

1 tests, 1 assertions, 1 failures, 0 errors, 0 skips
</code></pre>

<p>La section <code>1) Failure:</code> est particulièrement intéressante et nous indique
que la liste <code>[1, 2, 3, 4]</code> était attendue, mais que c'est la liste
<code>[1, 2, 4]</code> qui a été reçue.</p>

<p>Si on corrige notre test:</p>

<p>``` ruby tc_number.rb
require_relative &ldquo;number&rdquo;
require &ldquo;test/unit&rdquo;</p>

<p>class TestNumber &lt; Test::Unit::TestCase
  def test_divisors</p>

<pre><code>assert_equal [1, 2, 4], Number.divisors(4)
</code></pre>

<p>  end
end
```</p>

<p>Cette fois-ci la sortie nous indique que tout va bien:</p>

<pre><code>[~]⇒ ruby tc_number.rb 
Run options: 

# Running tests:

.

Finished tests in 0.000644s, 1553.5887 tests/s, 1553.5887 assertions/s.

1 tests, 1 assertions, 0 failures, 0 errors, 0 skips
</code></pre>

<h2>Plus de tests</h2>

<p>Nous pouvons ajouter un autre test pour la méthode <code>divisors</code>:</p>

<p>``` ruby
  def test_divisors</p>

<pre><code>assert_equal [1, 2, 4], Number.divisors(4)
assert_equal [1, 17], Number.divisors(17)
</code></pre>

<p>  end
```</p>

<p>Mais aussi tester les autres méthodes de notre module, selon le même
modèle:</p>

<p>``` ruby tc_number.rb
require_relative &ldquo;number&rdquo;
require &ldquo;test/unit&rdquo;</p>

<p>class TestNumber &lt; Test::Unit::TestCase
  def test_divisors</p>

<pre><code>assert_equal [1, 2, 4], Number.divisors(4)
assert_equal [1, 17], Number.divisors(17)
</code></pre>

<p>  end</p>

<p>  def test_proper_divisors</p>

<pre><code>assert_equal [1, 2], Number.proper_divisors(4)
assert_equal [1], Number.proper_divisors(17)
</code></pre>

<p>  end</p>

<p>  def test_sum_of_proper_divisors</p>

<pre><code>assert_equal 3, Number.sum_of_proper_divisors(4)
assert_equal 1, Number.sum_of_proper_divisors(17)
</code></pre>

<p>  end
end
```</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
