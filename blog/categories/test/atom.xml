<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : test | Xavier Nayrac]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/test/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2019-11-10T11:16:39+01:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Clojure, tests et couleurs]]></title>
    <link href="http://lkdjiin.github.io/blog/2017/02/26/clojure-tests-et-couleurs/"/>
    <updated>2017-02-26T10:53:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2017/02/26/clojure-tests-et-couleurs</id>
    <content type="html"><![CDATA[<p>En ce moment je regarde le langage Clojure de plus près.  J’utilise Leiningen
pour gérer les projets, et je voudrais maintenant utiliser la technique du
<em>Test Driven Development</em> pour faire quelques projets.</p>

<p><strong>Problème</strong> : la sortie de <code>lein test</code> n’est pas en couleur. Quand on fait du TDD
avoir une sortie rouge en cas d’échec et verte en cas de succès est vraiment
confortable, ça évite d’avoir à lire. (<em>Notez que Fish m’indique indirectement
l’échec en colorant le <code>$</code> de mon prompt en rouge. C’est déjà ça, mais j’en
voudrais un peu plus.</em>)</p>

<p>J’ai donc cherché et trouvé <a href="https://github.com/venantius/ultra">Ultra</a>, un
plugin pour Leiningen. Il fait bien le boulot, et même plus.</p>

<p><strong>Nouveau problème</strong> : Je passe de 3 secondes d’attente sans le plugin à 7 secondes
avec le plugin. Ce qui a évidemment tendance à <em>casser</em> le flot du TDD, pour le dire
gentiment.</p>

<p>```
$ time lein test
#…
Ran 1 tests containing 1 assertions.
#…</p>

<h1 id="sans-couleurs-276-secondes">=&gt; Sans couleurs 2.76 secondes</h1>
<p>#=&gt; Avec couleurs 6.81 secondes
```</p>

<p><strong>D’où ma question pour ceux/celles qui savent : avez vous une solution pour avoir
une sortie couleur des tests <em>et à la fois</em> un temps de réponse acceptable ?</strong></p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Comment écrire un framework de test pour Ruby]]></title>
    <link href="http://lkdjiin.github.io/blog/2016/11/02/comment-ecrire-un-framework-de-test-pour-ruby/"/>
    <updated>2016-11-02T09:06:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2016/11/02/comment-ecrire-un-framework-de-test-pour-ruby</id>
    <content type="html"><![CDATA[<p>Si vous souhaitez comprendre le fonctionnement d’un framework de test, si vous
voulez écrire votre propre framework et que vous ressentiez le besoin d’un coup
de pouce, cet article est fait pour vous. Nous verrons étape par étape comment écrire
une telle chose. Le framework que nous réaliserons tiendra en quelques dizaines de
lignes de Ruby et pourra être utilisé comme une base pour vos futures
réalisations.</p>

<p><img class="center" src="/images/colorful-test-tubes.jpg"></p>

<!-- more -->

<h2 id="par-o-commencer-">Par où commencer ?</h2>

<p>Pour ce genre de problématique, je trouve qu’il est plus simple de partir d’un
exemple concret du <strong>langage</strong>, de l’<strong>API</strong>, que l’on souhaite obtenir. Dans notre
cas, nous pouvons déjà écrire quelques tests même si nous ne pouvons pas encore
les faire tourner.</p>

<p>Voici 3 tests pour une classe Rover. Classe qui aura une position x,y et une
direction :</p>

<p>```ruby
# fichier test_rover.rb final.</p>

<p>require ‘rover’</p>

<p>class TestRover &lt; Tasty::Unit</p>

<p>def test_it_has_a_position
    rover = Rover.new(3, 2)
    assert(rover.position == [3, 2])
  end</p>

<p>def test_it_has_a_direction_by_default
    rover = Rover.new(3, 2)
    assert(rover.direction == ‘north’)
  end</p>

<p>def test_it_has_a_given_direction
    rover = Rover.new(3, 2, ‘west’)
    assert(rover.direction == ‘west’)
  end</p>

<p>end
```</p>

<p>J’ai cherché à faire au plus simple. Tout se passe à l’intérieur d’une classe.
Ça nous permettra d’hériter facilement de certains comportements, comme la
méthode <code>assert</code> qui sera définit dans la classe <code>Tasty::Unit</code>.</p>

<p>Chaque méthode qui commence par <code>test_</code> représente un test, et <code>assert</code> se
contente de vérifier si son argument est vrai ou faux.</p>

<p>On lancera le programme avec le nom d’un fichier de test, par exemple
<code>tasty test_rover.rb</code>. Mais par souci de simplicité, nous nous contenterons
d’utiliser directement l’interpréteur Ruby de cette manière :
<code>ruby tasty.rb test_rover.rb</code>.</p>

<p>Voici ce que j’imagine en terme d’affichage :</p>

<pre><code>$ ruby tasty.rb test_rover.rb
ok - test_it_has_a_position
not ok - test_it_has_a_given_direction
&lt;&lt; ERROR REPORT GOES HERE &gt;&gt;
ok - test_it_has_a_direction_by_default
</code></pre>

<p>Le nom d’un test est précédé de “ok” si il a réussi, ou de “not ok” si il a
échoué. Le rapport d’erreur est affiché aussitôt après une ligne “not ok”.</p>

<h2 id="retrouver-la-classe-de-test">Retrouver la classe de test</h2>

<p>Commençons par le plus simple, définissons une classe Rover dans un fichier
<code>rover.rb</code> :</p>

<p>```ruby
# fichier rover.rb</p>

<p>class Rover
end
```</p>

<p>Puis définissons notre premier test, dans un fichier <code>test_rover.rb</code>. Ce
premier test va nous guider pendant un bout de temps :</p>

<p>```ruby
# fichier test_rover.rb</p>

<p>require_relative ‘rover’</p>

<p>class TestRover &lt; Tasty::Unit</p>

<p>def test_it_has_a_position
    rover = Rover.new(3, 2)
    assert(rover.position == [3, 2])
  end</p>

<p>end
```</p>

<p>Maintenant, dans un fichier <code>tasty.rb</code>, définissons le namespace Tasty et une
classe principale. Nous initialiserons cette classe avec le nom de fichier
passé en argument sur la ligne de commande. Nous afficherons un message
temporaire pour nous assurer que nous sommes sur la bonne voie :</p>

<p>```ruby
# fichier tasty.rb</p>

<p>module Tasty</p>

<p>class Main
    def initialize(filename)
      puts “Testing #{filename}”
    end
  end</p>

<p>end</p>

<p>main = Tasty::Main.new(ARGV[0])
```</p>

<p>L’essai est concluant :</p>

<pre><code>$ ruby tasty.rb test_rover.rb
Testing test_rover.rb
</code></pre>

<p>Tant qu’on y est, mieux vaut définir tout de suite la classe <code>Tasty::Unit</code>,
voici à quoi devrait ressembler votre fichier <code>tasty.rb</code> :</p>

<p>```ruby
# fichier tasty.rb</p>

<p>module Tasty</p>

<p>class Unit
  end</p>

<p>class Main
    def initialize(filename)
      puts “Testing #{filename}”
    end
  end</p>

<p>end</p>

<p>main = Tasty::Main.new(ARGV[0])
```</p>

<p>Passons maintenant au sujet principal de cette section : nous devons retrouver
le nom de la classe de test, à savoir <code>TestRover</code>, depuis la classe
<code>Tasty::Main</code>. Pour ce faire nous pourrions écrire un parser qui
analyserait le contenu du fichier passé en argument. Ou bien nous pouvons
compter sur les facilités d’introspection du langage Ruby. Je parie volontiers
sur cette seconde solution. Nous laisserons Ruby charger et parser le fichier de
test pour nous. Nous chargerons le fichier de la même manière qu’un autre, avec
un <code>require</code>. Puis nous utilerons <code>Object.constants</code> pour accéder à toutes les
constantes définies jusqu’ici (une classe est représentée par une constante) :</p>

<p>```ruby
module Tasty</p>

<p>class Main
    def initialize(filename)
      require File.join(Dir.pwd, filename)
      puts Object.constants
    end
  end</p>

<p>end
```</p>

<p>Si vous lancez ce programme, vous verrez une liste de toutes les constantes
définies, dont celle que nous cherchons, <code>TestRover</code> :</p>

<pre><code>$ ruby tasty.rb test_rover.rb 
Object
Module
Class
BasicObject
...
SimpleDelegator
Tasty
Rover
TestRover # &lt;============================
RUBYGEMS_ACTIVATION_MONITOR
</code></pre>

<p>Attention, il s’agit d’un tableau de symboles. Vous pouvez vous en convaincre
en changeant de méthode d’affichage. Remplacez <code>puts</code> par <code>p</code> :</p>

<p><code>ruby
def initialize(filename)
  require File.join(Dir.pwd, filename)
  p Object.constants
end
</code></p>

<p>Vous pouvez voir qu’il s’agit de symboles :</p>

<pre><code>$ ruby tasty.rb test_rover.rb 
[:Object, :Module, :Class, :BasicObject, :Kernel, :NilClass, :NIL, :Data,
...
:SimpleDelegator, :Tasty, :Rover, :TestRover, :RUBYGEMS_ACTIVATION_MONITOR]
</code></pre>

<p>Nous pouvons sélectionner uniquement les classes commençant par <code>Test</code> :</p>

<p>```ruby
# fichier tasty.rb</p>

<p>module Tasty</p>

<p>class Unit
  end</p>

<p>class Main
    def initialize(filename)
      require File.join(Dir.pwd, filename)
      p Object.constants.select { |name| name.to_s.start_with?(‘Test’) }
    end
  end</p>

<p>end</p>

<p>main = Tasty::Main.new(ARGV[0])
```</p>

<p>Nous avons réduit le tableau aux seules classes de test. Nous en avons une
seule ici, mais nous pourrions très bien en avoir plusieurs :</p>

<pre><code>$ ruby tasty.rb test_rover.rb 
[:TestRover]
</code></pre>

<p>Il y a une convention qui est à l’oeuvre : seule une classe de test peut
commencer par <code>Test</code>. Ça n’est pas un bien grand sacrifice, et nous pourrions
y remédier si besoin.</p>

<h2 id="les-mthodes-de-test">Les méthodes de test</h2>

<p>La prochaine étape consistera à récupérer les méthodes qui sont dans la classe
de test, et à les lancer.</p>

<p>Un peu de recherche, dans une session irb et avec la <a href="http://ruby-doc.org/">documentation Ruby</a>,
nous montrera que nous pouvons transformer un symbole en une classe, et aussi
instancier cette classe, à l’aide de <code>Object.const_get</code> :</p>

<p><code>irb
$ irb
&gt;&gt; :Module
:Module
&gt;&gt; Object.const_get(:Module)
Module &lt; Object
&gt;&gt; Object.const_get(:Module).new
#&lt;Module:0x0055e0036e5580&gt;
</code>
On peut donc transformer notre tableau de symboles selon cette méthode :</p>

<p><code>ruby
class Main
  def initialize(filename)
    require File.join(Dir.pwd, filename)
    classes = Object.constants.select { |name| name.to_s.start_with?('Test') }
    classes.map! { |name| Object.const_get(name) }
  end
end
</code></p>

<p>Retournons dans une session irb pour voir comment obtenir les méthodes d’une
classe quelconque.  Définissons une classe <code>C</code> avec une méthode
<code>method_in_class_c</code> pour les besoins de la cause :</p>

<p><code>irb
$ irb
&gt;&gt; class C
&gt;&gt;   def method_in_class_c; end
&gt;&gt; end
</code></p>

<p>La méthode <code>instance_methods</code> appliquée sur une classe liste les méthodes de
cette classe. Nous retrouvons notre méthode <code>method_in_class_c</code>, parmi plein
d’autres :</p>

<p><code>irb
&gt;&gt; puts C.instance_methods
method_in_class_c # &lt;--------------------
methods
singleton_methods
protected_methods
private_methods
public_methods
instance_of?
...
</code></p>

<p>D’où viennent ces autres méthodes ? Ce sont les méthodes héritées ou incluses.
Pour restreindre les méthodes à celles définies dans la classe C, nous devons
utiliser un artifice :</p>

<p><code>irb
&gt;&gt; puts C.instance_methods(false)
method_in_class_c
</code></p>

<p>Nous pouvons nous servir de ce nouveau savoir pour lister les méthodes de test :</p>

<p>```ruby
# fichier tasty.rb</p>

<p>module Tasty</p>

<p>class Unit
  end</p>

<p>class Main
    def initialize(filename)
      require File.join(Dir.pwd, filename)
      classes = Object.constants.select { |name| name.to_s.start_with?(‘Test’) }
      classes.map! { |name| Object.const_get(name) }</p>

<pre><code>  classes.each do |c|
    c.instance_methods(false).each do |m|
      puts m
    end
  end
end   end
</code></pre>

<p>end</p>

<p>main = Tasty::Main.new(ARGV[0])
```</p>

<p>Nous l’avons trouvé :</p>

<pre><code>$ ruby tasty.rb test_rover.rb 
test_it_has_a_position
</code></pre>

<p>Il reste à lancer chaque test en se servant de la méthode <a href="http://ruby-doc.org/core-2.3.1/Object.html#method-i-send">send</a> sur une
instance de la classe de test. Nous ferons cela ailleurs que dans le
constructeur de la classe Tasty::Main. Dans une méthode <code>run</code> par exemple, ça
sera plus propre :</p>

<p>```ruby
# fichier tasty.rb</p>

<p>module Tasty</p>

<p>class Unit
  end</p>

<p>class Main
    def initialize(filename)
      require File.join(Dir.pwd, filename)
      @classes = Object.constants.select { |name| name.to_s.start_with?(‘Test’) }
      @classes.map! { |name| Object.const_get(name) }
    end</p>

<pre><code>def run
  @classes.each do |class_under_test|
    instance = class_under_test.new
    class_under_test.instance_methods(false).each do |m|
      instance.send(m)
    end
  end
end   end
</code></pre>

<p>end</p>

<p>main = Tasty::Main.new(ARGV[0])
main.run
```</p>

<p>Alors, et si on lançait les tests :</p>

<pre><code>$ ruby tasty.rb test_rover.rb 
test_rover.rb:6:in `initialize':
  wrong number of arguments (given 2, expected 0) (ArgumentError)
  from test_rover.rb:6:in `new'
  from test_rover.rb:6:in `test_it_has_a_position'
</code></pre>

<p>Déçu ? Vous ne devriez pas, ça a parfaitement fonctionné. Le programme nous dit
qu’en ligne 6 du fichier <code>test_rover.rb</code> nous tentons d’initialiser un rover
avec 2 arguments alors que la méthode <code>initialize</code> de rover attends 0
arguments. Voyons cette fameuse ligne 6, dans le test nous cherchons à
initialiser un rover avec des coordonnées x et y :</p>

<p><code>ruby
rover = Rover.new(3, 2)
</code></p>

<p>Et comme notre classe <code>Rover</code> est déséspérement vide, il est normal que Ruby
crashe.</p>

<h2 id="passons-le-premier-test">Passons le premier test</h2>

<p>Dotons la méthode <code>Rover#initialize</code> de deux arguments, comme attendu :</p>

<p><code>
# fichier rover.rb
class Rover
  def initialize(x, y)
  end
end
</code></p>

<p>Et le programme nous emmène au prochain problème :</p>

<pre><code>$ ruby tasty.rb test_rover.rb 
test_rover.rb:7:in `test_it_has_a_position': undefined method `position'
for #&lt;Rover:0x0055778cf43a90&gt; (NoMethodError)
</code></pre>

<p>On en vient facilement à bout en ajoutant la méthode <code>Rover#position</code> :</p>

<p>```
# fichier rover.rb
class Rover
  def initialize(x, y)
  end</p>

<p>def position
  end
end
```</p>

<p>L’erreur suivante est beaucoup plus intéressante :</p>

<pre><code>$ ruby tasty.rb test_rover.rb 
test_rover.rb:7:in `test_it_has_a_position': undefined method `assert'
for #&lt;TestRover:0x00558edbe7a828&gt; (NoMethodError)
</code></pre>

<p>Nous devons coder <code>assert</code> de telle manière qu’elle produise une erreur si son
argument est différent de <code>true</code>.  Et pour que les classes de test puissent y
accéder, nous la placerons dans <code>Tasty::Unit</code>. Nous utiliserons aussi une erreur
custom, <code>AssertionError</code> :</p>

<p>```ruby
module Tasty</p>

<p>class AssertionError &lt; StandardError
  end</p>

<p>class Unit
    def assert(boolean)
      raise AssertionError unless boolean
    end
  end</p>

<p>end
```</p>

<p>Nous y sommes presque. La méthode <code>assert</code> est codée et produit l’erreur attendue :</p>

<pre><code>$ ruby tasty.rb test_rover.rb 
tasty.rb:8:in `assert': Tasty::AssertionError (Tasty::AssertionError)
  from test_rover.rb:7:in `test_it_has_a_position'
</code></pre>

<p>Que se passerait-il si nous implémentions <code>Rover</code> de telle manière qu’elle
passe le test ?</p>

<p>```ruby
# fichier rover.rb
class Rover
  def initialize(x, y)
    @x = x
    @y = y
  end</p>

<p>def position
    [@x, @y]
  end
end
```</p>

<p>Et bien rien. Il ne se passe rien.</p>

<pre><code>$ ruby tasty.rb test_rover.rb 
$ # &lt;---- Cruelle absence d'affichage
</code></pre>

<p>En l’occurence, ce rien signifie quand même que nous avons réussi cette
partie !  Le test est passé ! Ajoutons un petit quelque chose pour être tenu au
courant :</p>

<p><code>ruby
module Tasty
  class Main
    def run
      @classes.each do |class_under_test|
        instance = class_under_test.new
        class_under_test.instance_methods(false).each do |m|
          instance.send(m)
          puts "ok - #{m}" # &lt;---------------
        end
      end
    end
  end
end
</code></p>

<p>Et c’est la victoire :</p>

<p><code>
$ ruby tasty.rb test_rover.rb 
ok - test_it_has_a_position
</code></p>

<h2 id="les-autres-tests">Les autres tests</h2>

<p>Ajoutons le second test, mais plaçons le avant le premier (!) pour observer un
phénomène curieux :</p>

<p>```ruby
# fichier test_rover.rb
require_relative ‘rover’</p>

<p>class TestRover &lt; Tasty::Unit</p>

<p>def test_it_has_a_direction_by_default
    rover = Rover.new(3, 2)
    assert(rover.direction == ‘north’)
  end</p>

<p>def test_it_has_a_position
    rover = Rover.new(3, 2)
    assert(rover.position == [3, 2])
  end</p>

<p>end
```</p>

<p>Le programme reporte bien le nouveau problème qui se trouve dans la méthode
<code>test_it_has_a_direction_by_default</code> mais il n’y a aucune mention de
<code>test_it_has_a_position</code> qui fonctionnait pourtant bien.</p>

<pre><code>$ ruby tasty.rb test_rover.rb 
test_rover.rb:7:in `test_it_has_a_direction_by_default': undefined method
`direction' for #&lt;Rover:0x0055a03b444db0 @x=3, @y=2&gt; (NoMethodError)
</code></pre>

<p>Lorsqu’une erreur se produit dans <code>Tasty::Main#run</code>, le programme s’arrête
purement et simplement. Ce n’est pas du tout ce que nous voulons. Nous voulons
qu’une erreur soit rapportée, et que le programme continue en traitant le test
suivant. Commençons par remanier un peu la méthode <code>run</code> en la splittant en
deux parties :</p>

<p>```ruby
class Main
  def run
    @classes.each do |under_test|
      instance = under_test.new
      under_test.instance_methods(false).each { |m| run_test(instance, m) }
    end
  end</p>

<p>def run_test(instance, method)
    instance.send(method)
    puts “ok - #{m}”
  end
end
```</p>

<p>Nous pouvons alors <em>attraper</em> les erreurs facilement dans la méthode <code>run_test</code> :</p>

<p><code>ruby
  def run_test(instance, method)
    instance.send(method)
    puts "ok - #{method}"
  rescue =&gt; ex
    puts "not ok - #{method}"
    puts ex.inspect
    puts ex.backtrace
  end
</code></p>

<p>Et voilà le résultat, nous affichons à la fois les tests qui passent et ceux
qui échouent :</p>

<pre><code>$ ruby tasty.rb test_rover.rb 
not ok - test_it_has_a_direction_by_default
#&lt;NoMethodError: undefined method `direction' for #&lt;Rover:0x0055a7709c03c0 @x=3, @y=2&gt;&gt;
test_rover.rb:7:in `test_it_has_a_direction_by_default'
...
ok - test_it_has_a_position
</code></pre>

<p>En dotant <code>Rover</code> de la méthode <code>position</code> qui suit, les tests passent :</p>

<p><code>ruby
def position
  'north'
end
</code></p>

<pre><code>$ ruby tasty.rb test_rover.rb 
ok - test_it_has_a_direction_by_default
ok - test_it_has_a_position
</code></pre>

<p>Faire passer le 3ème test implique seulement d’implémenter la classe <code>Rover</code> de
façon correcte. Il n’y a rien à ajouter ou à modifier dans notre framework
<code>Tasty</code>.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Nous venons d’écrire un framework de test en quelques dizaines de lignes de
code grâce aux facultés d’introspection de Ruby. C’est maintenant à votre tour
de jouer en l’améliorant.  Voici quelques idées :</p>

<ul>
  <li>Faire jouer les tests dans un ordre aléatoire</li>
  <li>Afficher une ligne de résultat final : <code>X tests, Y errors</code></li>
  <li>La sortie console devrait se faire en couleur, les lignes “ok” en vert, les
lignes “not ok” en rouges, et le reste en normal</li>
  <li>Écrire <code>ok - it has a position</code> plutôt que <code>ok - test_it_has_a_position</code></li>
  <li>Faire en sorte que des classes autres que celles de test puissent commencer par <code>Test</code>.</li>
  <li>Le must pour un compilateur, c’est d’être écrit dans son langage. Faire
pareil ici : tester Tasty avec Tasty</li>
</ul>

<p>Pour finir, voici le code complet :</p>

<p>```ruby
# fichier rover.rb
class Rover
  def initialize(x, y, direction=’north’)
    @x = x
    @y = y
    @direction = direction
  end</p>

<p>def position
    [@x, @y]
  end</p>

<p>attr_reader :direction
end
```</p>

<p>```ruby
# fichier test_rover.rb
require_relative ‘rover’</p>

<p>class TestRover &lt; Tasty::Unit</p>

<p>def test_it_has_a_direction_by_default
    rover = Rover.new(3, 2)
    assert(rover.direction == ‘north’)
  end</p>

<p>def test_it_has_a_position
    rover = Rover.new(3, 2)
    assert(rover.position == [3, 2])
  end</p>

<p>def test_it_has_a_given_direction
    rover = Rover.new(3, 2, ‘west’)
    assert(rover.direction == ‘west’)
  end</p>

<p>end
```</p>

<p>```ruby
# fichier tasty.rb
module Tasty</p>

<p>class AssertionError &lt; StandardError
  end</p>

<p>class Unit
    def assert(boolean)
      raise AssertionError unless boolean
    end
  end</p>

<p>class Main
    def initialize(filename)
      require File.join(Dir.pwd, filename)
      @classes = Object.constants.select { |name| name.to_s.start_with?(‘Test’) }
      @classes.map! { |name| Object.const_get(name) }
    end</p>

<pre><code>def run
  @classes.each do |under_test|
    instance = under_test.new
    under_test.instance_methods(false).each { |m| run_test(instance, m) }
  end
end

def run_test(instance, method)
  instance.send(method)
  puts "ok - #{method}"
rescue =&gt; ex
  puts "not ok - #{method}"
  puts ex.message
  puts ex.backtrace
end   end
</code></pre>

<p>end</p>

<p>main = Tasty::Main.new(ARGV[0])
main.run
```</p>

<p>Bons tests ! À plus tard.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Coco version 0.13.0]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/07/29/coco-version-0-dot-13-dot-0/"/>
    <updated>2015-07-29T10:50:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/07/29/coco-version-0-dot-13-dot-0</id>
    <content type="html"><![CDATA[<p>Je me rend compte que j’ai sorti la version 0.13.0 de
<a href="https://github.com/lkdjiin/coco">coco</a>
il y a près d’un mois et que je n’ai pas encore écrit une seule ligne sur le
sujet !</p>

<p>Coco est un outil de <strong>co</strong>uverture de <strong>co</strong>de pour Ruby — <strong>co</strong>de
<strong>co</strong>verage en anglais —. En gros, coco vous dit quels sont les fichiers d’un
projet qui ne sont pas suffisamment testés :</p>

<p><img class="center" src="/images/coco-shot-1.png"></p>

<!-- more -->

<p>Puis, pour les fichiers qui ne sont pas couverts à 100% par les tests, vous
pouvez visualiser les parties du code qui ne sont pas couvertes (ici en rouge) :</p>

<p><img class="center" src="/images/coco-shot-2.png"></p>

<p>Qu’y a-t-il de nouveau dans cette version 0.13.0 ? J’ai essentiellement
travaillé sur l’aspect du rapport HTML, afin qu’il soit un peu plus agréable
à regarder (je ne suis toujours ni graphiste ni designer, mais je crois que
cette fois ça n’est pas trop mal). On peut retenir aussi que les versions de
Ruby inférieures à 2 ne sont plus supportées.</p>

<p>Il ne reste plus grand chose à faire avant la <a href="https://github.com/lkdjiin/coco/issues">version 1.0</a>. Ça sera peut-être pour la fin de cette année, 5 ans après la première release, qui sait ?</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Comportement inattendu de Rspec]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/06/30/comportement-inattendu-de-rspec/"/>
    <updated>2015-06-30T15:37:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/06/30/comportement-inattendu-de-rspec</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Je suis tombé aujourd’hui sur un comportement inattendu de Rspec.
Je ne dis pas que le comportement est mauvais, seulement je m’attendais à
autre chose qui me semble plus logique. Quoiqu’il en soit, je partage mes
réflexions avec vous.</p>

<!-- more -->

<p>J’utilise beaucoup Rspec que j’aime bien. Pourtant je connais assez mal sa
mécanique interne. Un pattern dont je me sers de temps
en temps est de définir des méthodes helper dans le fichier de test :</p>

<p>``` ruby spec/thing1_spec.rb
require ‘spec_helper’</p>

<p>describe Thing1 do</p>

<p>it “returns ‘foo’” do
    expect(Thing1.new.get).to eq result
  end</p>

<p>end</p>

<p>def result
  ‘foo’
end
```</p>

<p>Avec <code>Thing1</code> défini ainsi :</p>

<p><code>ruby thing1.rb
class Thing1
  def get
    'foo'
  end
end
</code></p>

<p>Ça marche très bien :</p>

<pre><code>$ rspec -I. spec/thing1_spec.rb 
.

Finished in 0.00184 seconds (files took 0.23569 seconds to load)
1 example, 0 failures
</code></pre>

<p>Là où ça devient problématique, c’est si j’utilise le même nom de méthode helper
dans un autre fichier de test :</p>

<p>``` ruby spec/thing2_spec.rb
require ‘spec_helper’</p>

<p>describe Thing2 do</p>

<p>it “returns ‘bar’” do
    expect(Thing2.new.get).to eq result
  end</p>

<p>end</p>

<p>def result
  ‘bar’
end
```</p>

<p>Avec <code>Thing2</code> comme ceci :</p>

<p><code>ruby thing2.rb
class Thing2
  def get
    'bar'
  end
end
</code></p>

<p>Dans ce cas un test échoue :</p>

<pre><code>$ rspec -I.
F.

Failures:

  1) Thing1 returns 'foo'
     Failure/Error: expect(Thing1.new.get).to eq result
       
       expected: "bar"
            got: "foo"
       
       (compared using ==)
     # ./spec/thing1_spec.rb:6:in `block (2 levels) in &lt;top (required)&gt;'

Finished in 0.00232 seconds (files took 0.21784 seconds to load)
2 examples, 1 failure

Failed examples:

rspec ./spec/thing1_spec.rb:5 # Thing1 returns 'foo'
</code></pre>

<p>J’ai tenté de les jouer de différentes manières : seulement l’un, puis
seulement l’autre, Thing1 puis Thing2, Thing2 puis Thing1, pour voir…</p>

<p>J’en arrive à la conclusion que Rspec charge tous les fichiers de test avant de
démarrer un test. Comme Ruby est dynamique, c’est la dernière méthode <code>result</code> chargée qui, en quelque sorte, à raison.</p>

<p>La solution est donc simple, il faut <em>rentrer</em> les méthodes helper dans le
bloc <code>describe</code> :</p>

<p>``` ruby
require ‘spec_helper’</p>

<p>describe Thing1 do</p>

<p>it “returns ‘foo’” do
    expect(Thing1.new.get).to eq result
  end</p>

<p>def result
    ‘foo’
  end</p>

<p>end
```</p>

<p>Maintenant les deux tests fonctionnent comme attendu :</p>

<pre><code>$ rspec -I.
..

Finished in 0.00283 seconds (files took 0.21533 seconds to load)
2 examples, 0 failures
</code></pre>

<p><strong>Je m’attendais à ce que les différents fichiers de test soient joués en
isolation totale</strong>, sans connexion si mince soit elle avec d’autres fichiers.
Manifestement c’est pas le cas.</p>

<p>Pour être exhaustif voici le contenu du <em>spec helper</em> :</p>

<p><code>ruby spec/spec_helper.rb
require 'thing1'
require 'thing2'
</code></p>

<p>Et voici les fichiers :</p>

<pre><code>$ \tree
.
|-- spec
|   |-- spec_helper.rb
|   |-- thing1_spec.rb
|   `-- thing2_spec.rb
|-- thing1.rb
`-- thing2.rb
</code></pre>

<p>Si vous avez un avis sur la question il m’intéresse beaucoup, n’hésitez donc pas à laisser un
commentaire.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby CSV tests et quelques questions]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/07/03/ruby-csv-tests-et-quelques-questions/"/>
    <updated>2014-07-03T21:31:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/07/03/ruby-csv-tests-et-quelques-questions</id>
    <content type="html"><![CDATA[<p>Ça fait une semaine que je travaille sur des exports de statisques au format
CSV en Ruby. Ce n’est pas la première fois que je bosse sur ce genre de
fonctionnalité, que ce soit en Ruby ou dans un autre langage, et j’ai
toujours et encore le même problême: les tests.</p>

<!-- more -->

<p>Je m’explique. J’aime avoir des tests d’intégration qui s’assurent que les
bons fichiers soient produits. Par exemple:</p>

<pre><code>A, B, C, D ...
1, 2, 3, 4 ...
.
.
.
</code></pre>

<p>J’aime pouvoir contrôler la production de plusieurs fichiers, un pour chaque
scénario. Le gros soucis avec ce genre de test, c’est leur fragilité,
quand, par exemple, les utilisateurs s’aperçoivent que l’ordre des champs serait mieux
ainsi:</p>

<pre><code>A, C, D, B ...
1, 3, 4, 2 ...
.
.
.
</code></pre>

<p>Et là, il faut réécrire tous les fichiers de contrôle. Certains pouvant
contenir des dizaines de champs…</p>

<p>J’ai donc une question pour vous: comment faites vous pour faciliter ce
genre de tests ?</p>

<script id="fb33k8u">(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
