<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : julia | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/julia/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2014-06-01T19:23:24+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Un algorithme génétique en Julia - partie 14]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/06/01/un-algorithme-genetique-en-julia-partie-14/"/>
    <updated>2014-06-01T18:53:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/06/01/un-algorithme-genetique-en-julia-partie-14</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Ça y est ! J'ai enfin un algorithme génétique écrit en Julia. Le programme
est certainement maladroit par endroit, mais il fonctionne.</p>

<!-- more -->


<p>``` julia main.jl
type Chromosome
  genes
end</p>

<p>create_genes(size) = rand(0:1, size)</p>

<p>function create_population(size, chromosome_size)
  [ Chromosome(create_genes(chromosome_size)) for _ in 1:size ]
end</p>

<p>score(population) = map(x &ndash;> sum(x.genes), population)</p>

<p>function fight(scores, index1, index2)
  if rand() &lt; 0.8</p>

<pre><code>scores[index1] &gt; scores[index2] ? index1 : index2
</code></pre>

<p>  else</p>

<pre><code>scores[index1] &gt; scores[index2] ? index2 : index1
</code></pre>

<p>  end
end</p>

<p>function tournament(scores)
  population_size = length(scores)
  selection_size = population_size * 2
  [ fight(scores, rand(1:population_size), rand(1:population_size))</p>

<pre><code>for _ in 1:selection_size ]
</code></pre>

<p>end</p>

<p>function crossover(chromosome1, chromosome2)
  cut_point = rand(1:length(chromosome1.genes))
  first_part = chromosome1.genes[1:cut_point]
  second_part = chromosome2.genes[cut_point + 1:end]
  mutate(Chromosome([ first_part, second_part]))
end</p>

<p>function reproduction(new_population, current_population, selection)
  if selection == []</p>

<pre><code>return new_population
</code></pre>

<p>  else</p>

<pre><code>father = current_population[selection[1]]
mother = current_population[selection[2]]
child = crossover(father, mother)
reproduction([new_population, child], current_population, selection[3:end])
</code></pre>

<p>  end
end</p>

<p>function mutate(ch)
  mutator(g) = if rand(1:400) == 1</p>

<pre><code>g == 1 ? 0 : 1
</code></pre>

<p>  else</p>

<pre><code>g
</code></pre>

<p>  end
  Chromosome([ mutator(x)::Int for x in ch.genes ])
end</p>

<p>function run()
  current = create_population(400, 20)
  for i in 1:50</p>

<pre><code>scores = score(current)
best = maximum(scores)
println("Generation $i Best $best")
selection = tournament(scores)
current = reproduction([], current, selection)
</code></pre>

<p>  end
end
```</p>

<p>Voici un exemple d'utilisation:</p>

<pre><code>julia&gt; include("main.jl")
run (generic function with 1 method)

julia&gt; run()
Generation 1 Best 18
Generation 2 Best 18
Generation 3 Best 17
Generation 4 Best 17
Generation 5 Best 18
Generation 6 Best 17
Generation 7 Best 18
Generation 8 Best 19
Generation 9 Best 19
Generation 10 Best 19
Generation 11 Best 20
...
</code></pre>

<p>Il me reste encore pas mal de choses à faire pour améliorer ce programme,
mais c'était un bon début pour apprendre le langage Julia.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Un algorithme génétique en Julia - partie 13]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/05/31/un-algorithme-genetique-en-julia-partie-13/"/>
    <updated>2014-05-31T21:18:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/05/31/un-algorithme-genetique-en-julia-partie-13</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>On peut améliorer la fonction <code>fight</code>, pour qu'elle ne choisisse pas toujours
le meilleur individu. Il serait bon que, dans une faible proportion, elle
choisisse parfois le plus faible des deux combattants ; ceci pour assurer
qu'on ne perde pas de matériel génétique.</p>

<!-- more -->


<p>Voici donc la nouvelle fonction <code>fight</code>:</p>

<p>``` julia
function fight(scores, index1, index2)
  if rand() &lt; 0.8</p>

<pre><code>scores[index1] &gt; scores[index2] ? index1 : index2
</code></pre>

<p>  else</p>

<pre><code>scores[index1] &gt; scores[index2] ? index2 : index1
</code></pre>

<p>  end
end
```</p>

<p>Dans 80% des cas, elle selectionne le meilleur individu, et dans 20% des
cas, elle selectionne le plus faible.</p>

<p>Je pense qu'on a maintenant tous les éléments nécessaire à la finalisation
de l'algorithme.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Un algorithme génétique en Julia - partie 12]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/05/30/un-algorithme-genetique-en-julia-partie-12/"/>
    <updated>2014-05-30T21:11:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/05/30/un-algorithme-genetique-en-julia-partie-12</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Avec ce que j'ai compris au <a href="blog/2014/05/29/un-algorithme-genetique-en-julia-partie-11/">dernier épisode</a>
à propos des types, je peux améliorer la fonction <code>mutate</code>:</p>

<p>``` julia
function mutate(ch)
  mutator(g) = if rand(1:10) == 1</p>

<pre><code>g == 1 ? 0 : 1
</code></pre>

<p>  else</p>

<pre><code>g
</code></pre>

<p>  end
  Chromosome([ mutator(x)::Int for x in ch.genes ])
end
```</p>

<!-- more -->


<p>Maintenant les gènes des chromosomes restent toujours des tableaux de
<em>Int</em>:</p>

<pre><code>julia&gt; include("main.jl")
mutate (generic function with 1 method)

julia&gt; pop = create_population(8, 20)
8-element Array{Chromosome,1}:
 Chromosome([0,0,0,0,1,0,0,0,1,0,0,1,1,1,0,1,0,1,1,1])
 Chromosome([1,1,1,1,1,0,0,0,0,1,0,0,0,0,0,0,1,1,0,1])
 Chromosome([1,1,1,0,1,1,0,0,0,1,1,0,1,0,0,0,0,1,1,0])
 Chromosome([0,0,1,0,0,1,1,0,1,0,1,0,1,0,0,0,0,0,1,1])
 Chromosome([0,1,0,1,0,1,1,0,1,0,1,0,1,1,0,0,0,0,1,1])
 Chromosome([0,0,0,1,0,1,1,1,0,0,1,0,1,0,0,0,0,1,0,0])
 Chromosome([0,1,1,0,0,0,1,0,0,0,0,1,0,0,1,0,0,1,1,1])
 Chromosome([0,0,1,1,0,0,0,0,0,0,0,0,0,1,0,1,0,1,0,1])

julia&gt; scores = score(pop)
8-element Array{Int32,1}:
  9
  9
 10
  8
 10
  7
  8
  6

julia&gt; selection = tournament(scores)
16-element Array{Int32,1}:
 7
 2
 7
 5
 2
 7
 3
 7
 2
 2
 1
 3
 6
 5
 2
 3

julia&gt; gen2 = reproduction([], pop, selection)
8-element Array{Chromosome,1}:
 Chromosome([1,1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,1])
 Chromosome([0,1,1,0,0,0,1,1,0,0,0,1,0,0,1,0,0,1,1,1])
 Chromosome([1,1,1,1,1,0,0,0,0,1,0,1,0,0,1,0,0,1,1,1])
 Chromosome([0,0,1,0,1,1,0,0,0,0,1,0,1,0,0,0,0,1,0,1])
 Chromosome([1,1,1,0,1,0,1,0,0,1,0,0,0,1,0,0,1,0,0,0])
 Chromosome([0,0,1,0,1,1,0,0,1,1,1,0,1,0,0,0,0,1,0,0])
 Chromosome([0,0,0,1,0,0,1,1,0,0,1,0,1,1,0,0,1,0,1,1])
 Chromosome([1,0,1,0,1,1,0,0,0,1,1,0,1,0,1,0,1,1,1,0])
</code></pre>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Un algorithme génétique en Julia - partie 11]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/05/29/un-algorithme-genetique-en-julia-partie-11/"/>
    <updated>2014-05-29T21:13:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/05/29/un-algorithme-genetique-en-julia-partie-11</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Hier on a vu qu'il y avait une légère différence de <em>type</em> entre les gènes
d'un chromosome avant et après la mutation:</p>

<pre><code>julia&gt; c = Chromosome(create_genes(10))
Chromosome([0,0,0,1,1,1,1,1,0,1])

julia&gt; d = mutate(c)
Chromosome({0,0,0,1,1,1,1,1,0,1})

julia&gt; c.genes
10-element Array{Int32,1}:

julia&gt; d.genes
10-element Array{Any,1}:
</code></pre>

<p>C'est l'occasion de regarder un peu les types en Julia.</p>

<!-- more -->


<p>Voici une fonction <code>foo</code> qui additionne deux nombres:</p>

<pre><code>julia&gt; foo(a, b) = a + b
foo (generic function with 1 method)

julia&gt; foo(1, 2)
3
</code></pre>

<p>Que se passe-t-il si je lui passe deux chaînes de caractères ?</p>

<pre><code>julia&gt; foo("he", "llo")
ERROR: no method +(ASCIIString, ASCIIString)
</code></pre>

<p>C'est une erreur, puisque la fonction <code>+</code> ne sait pas additionner des
chaînes.</p>

<p>Très bien, apprenons à <code>foo</code> l'addition de chaînes. Pour cela, on indique
à Julia ce qu'il faut faire lorsque les arguments reçus par <code>foo</code> sont de
type <code>String</code>:</p>

<pre><code>julia&gt; foo(a::String, b::String) = "$a$b"
foo (generic function with 2 methods)

julia&gt; foo("he", "llo")
"hello"
</code></pre>

<p>Et <code>foo</code> fonctionne toujours avec des nombres:</p>

<pre><code>julia&gt; foo(1, 2)
3
</code></pre>

<p>La fonction <code>foo</code> possède 2 <em>méthodes</em>, une à utiliser quand elle reçoit des
arguments <em>String</em>, et une autre, à utiliser dans tous les autres cas:</p>

<pre><code>julia&gt; methods(foo)
# 2 methods for generic function "foo":
foo(a::String,b::String) at none:1
foo(a,b) at none:1
</code></pre>

<p>La prochaine fois on arrangera notre fonction <code>mutate</code> pour que les gènes
conservent le même type.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Un algorithme génétique en Julia - partie 10]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/05/28/un-algorithme-genetique-en-julia-partie-10/"/>
    <updated>2014-05-28T21:19:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/05/28/un-algorithme-genetique-en-julia-partie-10</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Voici le nouveau code de l'algorithme:</p>

<p>``` julia main.jl
type Chromosome
  genes
end</p>

<p>create_genes(size) = rand(0:1, size)</p>

<p>function create_population(size, chromosome_size)
  [ Chromosome(create_genes(chromosome_size)) for _ in 1:size ]
end</p>

<p>score(population) = map(x &ndash;> sum(x.genes), population)</p>

<p>function fight(scores, index1, index2)
  scores[index1] > scores[index2] ? index1 : index2
end</p>

<p>function tournament(scores)
  population_size = length(scores)
  selection_size = population_size * 2
  [ fight(scores, rand(1:population_size), rand(1:population_size))</p>

<pre><code>for _ in 1:selection_size ]
</code></pre>

<p>end</p>

<p>function crossover(chromosome1, chromosome2)
  cut_point = rand(1:length(chromosome1.genes))
  first_part = chromosome1.genes[1:cut_point]
  second_part = chromosome2.genes[cut_point + 1:end]
  mutate(Chromosome([ first_part, second_part]))
end</p>

<p>function reproduction(new_population, current_population, selection)
  if selection == []</p>

<pre><code>return new_population
</code></pre>

<p>  else</p>

<pre><code>father = current_population[selection[1]]
mother = current_population[selection[2]]
child = crossover(father, mother)
reproduction([new_population, child], current_population, selection[3:end])
</code></pre>

<p>  end
end</p>

<p>function mutate(ch)
  mutator(g) = if rand(1:10) == 1</p>

<pre><code>g == 1 ? 0 : 1
</code></pre>

<p>  else</p>

<pre><code>g
</code></pre>

<p>  end
  Chromosome([ mutator(x) for x in ch.genes ])
end
```</p>

<!-- more -->


<p>J'ai simplement ajouter la fonction <code>mutate</code> dans <code>crossover</code>:</p>

<p><code>julia
function crossover(chromosome1, chromosome2)
  cut_point = rand(1:length(chromosome1.genes))
  first_part = chromosome1.genes[1:cut_point]
  second_part = chromosome2.genes[cut_point + 1:end]
  mutate(Chromosome([ first_part, second_part]))
end
</code></p>

<p>Et ça fonctionne:</p>

<pre><code>julia&gt; include("main.jl")

julia&gt; pop = create_population(8, 20)
8-element Array{Chromosome,1}:
 Chromosome([0,0,0,1,1,1,0,0,0,0,0,1,1,0,1,1,0,1,0,1])
 Chromosome([1,0,1,1,0,0,0,0,1,1,0,1,1,0,1,0,1,0,1,1])
 Chromosome([1,0,1,1,1,0,1,0,0,0,1,0,0,1,0,1,0,0,0,1])
 Chromosome([1,1,1,1,1,0,0,0,0,0,1,1,0,1,1,0,1,0,0,1])
 Chromosome([0,1,1,0,0,0,0,0,0,1,1,1,0,1,0,0,1,0,1,0])
 Chromosome([0,1,0,1,1,0,0,1,0,0,1,1,1,1,0,0,0,0,0,1])
 Chromosome([1,1,1,0,0,0,1,1,0,1,1,0,0,0,1,1,1,0,0,0])
 Chromosome([1,0,0,0,1,0,0,1,0,1,0,1,0,0,0,0,1,0,0,0])

julia&gt; scores = score(pop)
8-element Array{Int32,1}:
  9
 11
  9
 11
  8
  9
 10
  6

julia&gt; selection = tournament(scores)
16-element Array{Int32,1}:
 7
 7
 7
 7
 ...
 4
 1
 1

julia&gt; gen2 = reproduction([], pop, selection)
8-element Array{Chromosome,1}:
 Chromosome({1,1,1,0,0,0,1,1,0,1,1,0,1,0,1,1,1,0,0,0})
 Chromosome({1,1,1,0,0,0,1,0,0,1,1,0,0,0,1,1,0,0,0,0})
 Chromosome({0,1,0,0,1,0,0,1,0,1,1,1,1,0,1,0,1,0,1,1})
 Chromosome({1,0,1,0,0,1,0,0,1,1,1,1,0,1,0,0,1,0,1,1})
 Chromosome({1,0,1,1,0,0,0,0,1,0,0,1,1,0,1,1,0,0,0,1})
 Chromosome({1,1,1,1,1,1,0,0,0,0,1,1,0,1,1,1,1,0,0,0})
 Chromosome({0,1,1,0,0,0,1,0,0,0,1,1,0,1,1,0,1,0,0,1})
 Chromosome({0,0,0,1,1,1,0,0,0,1,0,1,1,0,1,1,0,1,0,1})
</code></pre>

<p>Mais un truc me dérange toujours, le tableau est <em>modifié</em> après passage
dans <code>mutate</code>:</p>

<pre><code>julia&gt; c = chromosome(create_genes(10))
chromosome([0,0,0,1,1,1,1,1,0,1])

julia&gt; d = mutate(c)
Chromosome({0,0,0,1,1,1,1,1,0,1})

julia&gt; c.genes
10-element Array{Int32,1}:
...

julia&gt; d.genes
10-element Array{Any,1}:
...
</code></pre>

<p>C'est bien ça, le tableau n'est pas du même type. Bon, ça ne dérange pas
l'algorithme et c'est l'occasion d'un prochain article sur Julia ;)</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
