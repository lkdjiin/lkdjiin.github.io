<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : julia | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/julia/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2014-05-27T21:28:58+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Un algorithme génétique en Julia - partie 9]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/05/27/un-algorithme-genetique-en-julia-partie-9/"/>
    <updated>2014-05-27T21:16:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/05/27/un-algorithme-genetique-en-julia-partie-9</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Voici une fonction de mutation pour nos chromosomes.</p>

<p>``` julia
function mutate(ch)
  mutator(gene) = if rand(1:10) == 1</p>

<pre><code>gene == 1 ? 0 : 1
</code></pre>

<p>  else</p>

<pre><code>gene
</code></pre>

<p>  end
  Chromosome([ mutator(x) for x in ch.genes ])
end
```</p>

<!-- more -->


<p>Le code me semble un peu <em>maladroit</em>, mais a l'air de fonctionner pas trop
mal ;) La fonction <code>mutate</code> prend en entrée un chromosome et produit un autre
chromosome en sortie. On peut voir qu'une seconde fonction, <code>mutator</code>, est
définie à l'intérieur.</p>

<p>Ça marche pas mal, même si il faudra faire quelque chose pour l'<em>intervalle magique</em> <code>rand(1:10)</code>:</p>

<pre><code>julia&gt; include("main.jl")
mutate (generic function with 1 method)

julia&gt; c = Chromosome(create_genes(20))
Chromosome([0,1,1,0,1,0,1,0,0,0,1,1,0,1,1,0,0,0,1,1])

julia&gt; mutate(c)
Chromosome({0,1,1,0,1,0,1,0,0,0,1,1,0,1,0,0,0,0,0,1})
</code></pre>

<p>Le seul petit truc qui me dérange, c'est qu'on a <code>[...]</code> en entrée et
<code>{...}</code> en sortie. Je ne sais ni pourquoi, ni ce que c'est… On verra bien
au prochain épisode si c'est grave ;)</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Un algorithme génétique en Julia - partie 8]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/05/25/un-algorithme-genetique-en-julia-partie-8/"/>
    <updated>2014-05-25T19:03:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/05/25/un-algorithme-genetique-en-julia-partie-8</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Voici le programme actuel, qui tient compte de l'utilisation du type
<code>Chromosome</code>, ajouté dans la partie 7.</p>

<!-- more -->


<p>``` julia main.jl
type Chromosome
  genes
end</p>

<p>create_genes(size) = rand(0:1, size)</p>

<p>function create_population(size, chromosome_size)
  [ Chromosome(create_genes(chromosome_size)) for _ in 1:size ]
end</p>

<p>score(population) = map(x &ndash;> sum(x.genes), population)</p>

<p>function fight(scores, index1, index2)
  scores[index1] > scores[index2] ? index1 : index2
end</p>

<p>function tournament(scores)
  population_size = length(scores)
  selection_size = population_size * 2
  [ fight(scores, rand(1:population_size), rand(1:population_size))</p>

<pre><code>for _ in 1:selection_size ]
</code></pre>

<p>end</p>

<p>function crossover(chromosome1, chromosome2)
  cut_point = rand(1:length(chromosome1.genes))
  first_part = chromosome1.genes[1:cut_point]
  second_part = chromosome2.genes[cut_point + 1:end]
  Chromosome([ first_part, second_part])
end</p>

<p>function reproduction(new_population, current_population, selection)
  if selection == []</p>

<pre><code>return new_population
</code></pre>

<p>  else</p>

<pre><code>father = current_population[selection[1]]
mother = current_population[selection[2]]
child = crossover(father, mother)
reproduction([new_population, child], current_population, selection[3:end])
</code></pre>

<p>  end
end
```</p>

<p>Le changement le plus important est l'utilisation d'une fonction anonyme:</p>

<p><code>julia
score(population) = map(x -&gt; sum(x.genes), population)
</code></p>

<p>On arrive bien à calculer la génération suivante:</p>

<pre><code>julia&gt; include("main.jl")
reproduction (generic function with 1 method)

julia&gt; pop = create_population(8, 20)
8-element Array{Chromosome,1}:
 Chromosome([1,0,1,1,1,0,0,1,0,0,0,1,0,0,0,0,0,0,0,1])
 Chromosome([0,1,0,0,1,1,1,0,1,0,0,1,0,1,1,0,1,0,0,0])
 Chromosome([0,0,1,0,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,0])
 Chromosome([0,0,0,1,1,0,0,0,1,1,0,0,0,1,1,0,0,1,0,0])
 Chromosome([1,1,0,1,1,0,0,0,1,1,0,0,0,1,0,1,0,1,0,0])
 Chromosome([1,0,1,1,1,1,0,0,1,0,0,0,1,0,0,0,0,1,1,1])
 Chromosome([1,1,0,0,1,0,1,0,0,1,0,1,0,1,0,0,1,1,1,1])
 Chromosome([0,1,1,0,0,1,0,1,0,1,1,0,0,0,1,0,1,1,1,0])

julia&gt; scores = score(pop)
8-element Array{Int32,1}:
  7
  9
  5
  7
  9
 10
 11
 10

julia&gt; selection = tournament(scores)
16-element Array{Int32,1}:
 2
 4
 6
 1
 6
 5
 8
 7
 5
 7
 5
 6
 8
 4
 6
 6

julia&gt; generation2 = reproduction([], pop, selection)
8-element Array{Chromosome,1}:
 Chromosome([0,1,0,0,1,1,1,0,1,1,0,0,0,1,1,0,0,1,0,0])
 Chromosome([1,0,1,1,1,0,0,1,0,0,0,1,0,0,0,0,0,0,0,1])
 Chromosome([1,0,1,1,1,1,0,0,1,0,0,0,1,0,0,0,0,1,0,0])
 Chromosome([0,1,1,0,0,1,1,0,0,1,0,1,0,1,0,0,1,1,1,1])
 Chromosome([1,1,0,1,1,0,0,0,1,1,0,0,0,1,0,0,1,1,1,1])
 Chromosome([1,1,0,1,1,1,0,0,1,0,0,0,1,0,0,0,0,1,1,1])
 Chromosome([0,1,1,0,0,1,0,1,0,1,1,0,0,0,1,0,1,1,0,0])
 Chromosome([1,0,1,1,1,1,0,0,1,0,0,0,1,0,0,0,0,1,1,1])
</code></pre>

<p>La première version de l'algorithme est bientôt finie…</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Un algorithme génétique en Julia - partie 7]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/05/23/un-algorithme-genetique-en-julia-partie-7/"/>
    <updated>2014-05-23T21:15:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/05/23/un-algorithme-genetique-en-julia-partie-7</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Dans le <a href="blog/2014/05/18/un-algorithme-genetique-en-julia-partie-6/">dernier article</a> sur Julia, j'avais eu un problème avec les
tableaux. En effet, leur comportement n'est pas celui que j'attendais:</p>

<pre><code>julia&gt; a = [1, 2]
julia&gt; b = [3, 4]

julia&gt; [a, b]
4-element Array{Int32,1}:
 1
 2
 3
 4

julia&gt; append!(a, b)
4-element Array{Int32,1}:
 1
 2
 3
 4
</code></pre>

<p>Alors que j'attendais plutôt ceci : <code>[ [1, 2], [3, 4] ]</code>.</p>

<!-- more -->


<p>Pour régler ça, on doit pouvoir utiliser les tableaux multi-dimensionnels,
que Julia à tendance à nommer des «matrices». Vu mon niveau en math, ça
ne m'a pas vraiment attiré ;)</p>

<p>J'ai préféré regarder du coté des types. Pour l'instant, je comprends les
types comme des structures dans le genre de C, c'est-à-dire un ensemble de
donnés regroupées au sein d'une même référence.</p>

<p>J'ai donc besoin d'un type, que j'appelerais <code>Chromosome</code>, qui va contenir
le tableau des gènes:</p>

<p><code>julia
type Chromosome
  genes
end
</code></p>

<p>On l'utilise comme ceci:</p>

<pre><code>julia&gt; Chromosome([1, 2, 3])
Chromosome([1,2,3])
</code></pre>

<p>Je vais devoir modifier un peu les fonctions définies jusqu'ici pour qu'elle
fonctionnent avec des <code>Chromosome</code>s. Par exemple, pour créer la population:</p>

<p>``` julia
create_chromosome(size) = rand(0:1, size)</p>

<p>function create_population(size, chromosome_size)
  [ Chromosome(create_chromosome(chromosome_size)) for _ in 1:size ]
end
```</p>

<p>Ce qui donne:</p>

<pre><code>julia&gt; pop = create_population(8, 20)
8-element Array{Chromosome,1}:
 Chromosome([0,1,0,0,0,1,0,0,0,0,0,1,1,0,0,1,0,1,0,0])
 Chromosome([1,1,0,0,0,1,1,1,0,1,0,0,0,1,0,0,0,1,0,1])
 Chromosome([1,1,0,0,0,1,1,0,1,1,0,0,0,1,1,1,1,1,0,1])
 Chromosome([1,1,1,1,1,0,0,0,0,1,0,1,1,1,1,1,0,0,0,1])
 Chromosome([0,0,0,0,1,0,0,1,1,0,0,1,1,0,0,0,0,1,0,1])
 Chromosome([1,0,1,1,0,0,0,1,1,0,1,0,1,1,1,1,0,0,0,1])
 Chromosome([1,0,1,1,1,1,1,0,0,1,1,1,1,0,0,0,0,0,1,0])
 Chromosome([1,1,1,1,1,0,0,1,1,1,1,0,0,1,0,1,1,1,1,0])
</code></pre>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Un algorithme génétique en Julia - partie 6]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/05/18/un-algorithme-genetique-en-julia-partie-6/"/>
    <updated>2014-05-18T20:47:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/05/18/un-algorithme-genetique-en-julia-partie-6</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Aujourd'hui je tente d'écrire une fonction de reproduction.
Je me dis qu'une fonction récursive serait ici la bienvenue:</p>

<p>``` julia
function reproduction(new_population, current_population, selection)
  if selection == []</p>

<pre><code>return new_population
</code></pre>

<p>  else</p>

<pre><code>father = current_population[selection[1]]
mother = current_population[selection[2]]
child = crossover(father, mother)
reproduction([new_population, child], current_population, selection[3:end])
</code></pre>

<p>  end
end
```</p>

<!-- more -->


<p>Explications ligne par ligne:</p>

<pre><code>function reproduction(new_population, current_population, selection)
</code></pre>

<p><code>new_population</code> est un accumulateur, qui débute comme un tableau vide.
<code>current_population</code> est un tableau qui contient la génération courante et qui
ne changera pas. <code>selection</code> est un tableau qui contient les indexs des
reproducteurs par rapport à <code>current_population</code>.</p>

<pre><code>if selection == []
  return new_population
</code></pre>

<p>C'est la condition de sortie de cette fonction récursive. Au fur et à mesure,
<code>selection</code> va être vidé des ses éléments.</p>

<pre><code>father = current_population[selection[1]]
mother = current_population[selection[2]]
child = crossover(father, mother)
</code></pre>

<p>On produit un nouvel individu (<code>child</code>) par le croisement de deux éléments de
<code>current_population</code>, pointés par les deux premiers éléments de <code>selection</code>.</p>

<pre><code>reproduction([new_population, child], current_population, selection[3:end])
</code></pre>

<p>On appelle à nouveau la fonction <code>reproduction</code>, en ajoutant le nouvel individu
et en retirant les deux premiers éléments de <code>selection</code>.</p>

<p>Ça fonctionne presque, mais pas tout à fait !
En effet:</p>

<pre><code>julia&gt; include("main.jl")
reproduction (generic function with 1 method)

julia&gt; population = create_population(8, 20)
8-element Array{Array{Int32,1},1}:
 [1,0,1,1,1,1,0,0,1,0,0,0,0,0,1,0,1,0,1,0]
 [0,1,0,1,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,1]
 [0,1,1,0,1,0,1,0,0,0,1,0,0,1,1,0,0,1,0,1]
 [1,1,0,1,1,1,0,1,0,0,0,0,1,0,0,1,1,1,0,1]
 [1,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,1,1]
 [0,0,0,1,0,1,1,0,0,1,0,0,0,0,0,1,0,0,0,0]
 [1,0,0,0,1,0,1,1,1,1,1,1,0,1,0,0,0,0,1,1]
 [0,1,0,0,0,1,0,0,1,1,1,0,1,0,0,1,0,0,0,1]

julia&gt; scores = score(population)
8-element Array{Int32,1}:
  9
  9
  9
 11
 11
  5
 11
  8

julia&gt; selection = tournament(scores)
16-element Array{Int32,1}:
 2
 5
 4
 1
 5
 6
 5
 5
 4
 4
 6
 5
 4
 1
 1
 6

julia&gt; selection = tournament(scores)
16-element Array{Int32,1}:
 2
 7
 3
 1
 3
 3
 1
 4
 7
 7
 7
 8
 5
 4
 7
 4

julia&gt; generation2 = reproduction([], population, selection)
160-element Array{Int32,1}:
 0
 1
 0
 1
 0
 0
 0
 0
 1
 1
 ⋮
 1
 1
 0
 1
 0
 0
 0
 0
 1
 1
</code></pre>

<p>La fonction <code>reproduction</code> ne produit pas un tableau de 8 chromosomes de
longueur 20, mais un tableau de 160 entiers. Je sens qu'il y a un truc
vraiment cool avec les tableaux en Julia, mais j'ai la preuve que je n'ai pas
encore tout compris ;)</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Un algorithme génétique en Julia - partie 5]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/05/17/un-algorithme-genetique-en-julia-partie-5/"/>
    <updated>2014-05-17T15:38:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/05/17/un-algorithme-genetique-en-julia-partie-5</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Aujourd'hui je cherche à faire une fonction <code>crossover</code>, pour effectuer un
croisement entre deux chromosomes.</p>

<p>Soit les deux chromosomes suivants:</p>

<pre><code>julia&gt; a = [1, 2, 3, 4, 5]

julia&gt; b = [6, 7, 8, 9, 0]
</code></pre>

<!-- more -->


<p>Pour obtenir la taille d'un tableau:</p>

<pre><code>julia&gt; length(a)
5
</code></pre>

<p>Pour obtenir le <em>point de croisement</em>, on tire au hasard:</p>

<pre><code>julia&gt; cut_point = rand(1:length(a))
4
</code></pre>

<p>Le nouveau chromosome sera composé du début du premier, jusqu'au point de
croisement:</p>

<pre><code>julia&gt; cut_point = 3
3
julia&gt; a[1:cut_point]
3-element Array{Int32,1}:
 1
 2
 3
</code></pre>

<p>Puis de la fin du second chromosome:</p>

<pre><code>julia&gt; a[cut_point + 1:end]
2-element Array{Int32,1}:
 4
 5
</code></pre>

<p>Si on rassemble tout ça dans un tableau, on obtient notre nouveau
chromosome:</p>

<pre><code>julia&gt; [ a[1:cut_point], b[cut_point + 1:end] ]
5-element Array{Int32,1}:
 1
 2
 3
 9
 0
</code></pre>

<p>Il ne reste plus qu'à en faire une fonction:</p>

<p><code>julia
function crossover(chromosome1, chromosome2)
  cut_point = rand(1:length(chromosome1))
  [ chromosome1[1:cut_point], chromosome2[cut_point + 1:end] ]
end
</code></p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
