<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : julia | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/julia/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2014-06-23T21:32:11+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Un algorithme génétique en Julia - partie 17]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/06/04/un-algorithme-genetique-en-julia-partie-17/"/>
    <updated>2014-06-04T21:59:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/06/04/un-algorithme-genetique-en-julia-partie-17</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Aujourd'hui j'ai envie de faire une version récursive de la fonction
<code>run</code>. Voici la version actuelle:</p>

<p>``` julia
function run(population_size, genes_size, generations, fight_rate)
  current = create_population(population_size, genes_size)
  for i in 1:generations</p>

<pre><code>scores = score(current)
best = maximum(scores)
println("Generation $i Best $best")
selection = tournament(scores, fight_rate)
current = reproduction([], current, selection, population_size)
</code></pre>

<p>  end
end
```</p>

<!-- more -->


<p>Et en voici une version récursive (avec un <em>helper</em>):</p>

<p>``` julia
function run(population_size, genes_size, generations, fight_rate)
  current = create_population(population_size, genes_size)
  run_helper(current, population_size, fight_rate, generations)
end</p>

<p>function run_helper(current, population_size, fight_rate, generations,</p>

<pre><code>                generation = 1)
</code></pre>

<p>  scores = score(current)
  best = maximum(scores)
  println(&ldquo;Generation $generation Best $best&rdquo;)
  if generation &lt; generations</p>

<pre><code>selection = tournament(scores, fight_rate)
current = reproduction([], current, selection, population_size)
run_helper(current, population_size, fight_rate, generations, generation + 1)
</code></pre>

<p>  end
end
```</p>

<p>Alors je me doute que je suis sûrement assez maladroit avec Julia, que
j'apprend, et avec le style récursif, qui ne coule pas de source chez moi,
mais j'ai quand même l'impression que ça n'apporte rien du tout au
programme !</p>

<p>Pour l'instant, je pense que je vais me limiter souvent à des boucles
<code>for</code> ;)</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Un algorithme génétique en Julia - partie 16]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/06/03/un-algorithme-genetique-en-julia-partie-16/"/>
    <updated>2014-06-03T21:02:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/06/03/un-algorithme-genetique-en-julia-partie-16</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>J'ai retiré les nombres magiques et renommé les quelques variables qui étaient
abrégées. Puis j'ai voulu commencer à documenter le code. Là je me suis
aperçu que le <em>typage</em> était une bonne façon de documenter Julia. Par
exemple:</p>

<p><code>julia
type Chromosome
  genes::Array{Int}
end
</code></p>

<p>m'apparait quasiment comme étant <em>auto-documenté</em>, comparé à la version
précédente:</p>

<p><code>julia
type Chromosome
  genes
end
</code></p>

<!-- more -->


<p>Plus de documentation plus tard, quand j'aurais trouvé si il y a un
<em>standard</em> en Julia (j'ai bien l'impression qu'il n'y en a pas :( ).</p>

<p>Pour l'instant, voici le code après son enième remaniement:</p>

<p>``` julia main.jl
type Chromosome
  genes::Array{Int}
end</p>

<p>create_genes(size) = rand(0:1, size)</p>

<p>function create_population(size, chromosome_size)
  [ Chromosome(create_genes(chromosome_size)) for _ in 1:size ]
end</p>

<p>score(population) = map(chromosome &ndash;> sum(chromosome.genes), population)</p>

<p>function fight(scores, index1, index2, rate)
  if rand() &lt; rate</p>

<pre><code>scores[index1] &gt; scores[index2] ? index1 : index2
</code></pre>

<p>  else</p>

<pre><code>scores[index1] &gt; scores[index2] ? index2 : index1
</code></pre>

<p>  end
end</p>

<p>function tournament(scores, rate)
  population_size = length(scores)
  selection_size = population_size * 2
  [ fight(scores, rand(1:population_size), rand(1:population_size), rate)</p>

<pre><code>for _ in 1:selection_size ]
</code></pre>

<p>end</p>

<p>function crossover(chromosome1, chromosome2, population_size)
  cut_point = rand(1:length(chromosome1.genes))
  first_part = chromosome1.genes[1:cut_point]
  second_part = chromosome2.genes[cut_point + 1:end]
  mutate(Chromosome([ first_part, second_part]), population_size)
end</p>

<p>function reproduction(new_population, current_population, selection,</p>

<pre><code>                  population_size)
</code></pre>

<p>  if selection == []</p>

<pre><code>return new_population
</code></pre>

<p>  else</p>

<pre><code>father = current_population[selection[1]]
mother = current_population[selection[2]]
child = crossover(father, mother, population_size)
reproduction([new_population, child], current_population, selection[3:end],
             population_size)
</code></pre>

<p>  end
end</p>

<p>function mutate(chromosome, population_size)
  mutator(gene) = if rand(1:population_size) == 1</p>

<pre><code>gene == 1 ? 0 : 1
</code></pre>

<p>  else</p>

<pre><code>gene
</code></pre>

<p>  end
  Chromosome([ mutator(gene) for gene in chromosome.genes ])
end</p>

<p>function run(population_size, genes_size, generations, fight_rate)
  current = create_population(population_size, genes_size)
  for i in 1:generations</p>

<pre><code>scores = score(current)
best = maximum(scores)
println("Generation $i Best $best")
selection = tournament(scores, fight_rate)
current = reproduction([], current, selection, population_size)
</code></pre>

<p>  end
end
```</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Un algorithme génétique en Julia - partie 15]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/06/02/un-algorithme-genetique-en-julia-partie-15/"/>
    <updated>2014-06-02T21:02:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/06/02/un-algorithme-genetique-en-julia-partie-15</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Après avoir pondu <a href="blog/2014/06/01/un-algorithme-genetique-en-julia-partie-14/">une première version</a>
de l'algorithme hier, je me demande ce que je pourrais améliorer. C'était
un programme sympa pour découvrir Julia, mais je n'ai fait que gratter la
surface de ce langage.</p>

<!-- more -->


<p>Donc, voici ce que je compte/espère faire encore avec ce programme pour
comprendre un peu mieux Julia:</p>

<ul>
<li>Retirer les nombres magiques restants.</li>
<li>Retirer les abbreviations restantes.</li>
<li>Documenter les fonctions, sinon dans un mois, j'aurais tout oublié !</li>
<li>Essayer une version récursive de la fonction <code>run</code>.</li>
<li>Lire quelques tutos pour voir ce que je peux en tirer.</li>
<li>Lire du code julia pour mieux <em>sentir</em> (le code source de Julia <em>itself</em>
serait un bon début).</li>
<li>Mettre le code sur github et le donner à lire/critiquer à des développeurs qui
connaissent le langage.</li>
<li>Comprendre pourquoi avec 10.000 individus de 100 gènes, l'empreinte
mémoire est de 800 Mo ! Ça me semble beaucoup…</li>
<li>Écrire le même en Ruby et comparer le temps d'exécution.</li>
</ul>


<p>Voilà, il devrait donc y avoir encore pas mal d'articles sur le langage
Julia ;)</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Un algorithme génétique en Julia - partie 14]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/06/01/un-algorithme-genetique-en-julia-partie-14/"/>
    <updated>2014-06-01T18:53:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/06/01/un-algorithme-genetique-en-julia-partie-14</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Ça y est ! J'ai enfin un algorithme génétique écrit en Julia. Le programme
est certainement maladroit par endroit, mais il fonctionne.</p>

<!-- more -->


<p>``` julia main.jl
type Chromosome
  genes
end</p>

<p>create_genes(size) = rand(0:1, size)</p>

<p>function create_population(size, chromosome_size)
  [ Chromosome(create_genes(chromosome_size)) for _ in 1:size ]
end</p>

<p>score(population) = map(x &ndash;> sum(x.genes), population)</p>

<p>function fight(scores, index1, index2)
  if rand() &lt; 0.8</p>

<pre><code>scores[index1] &gt; scores[index2] ? index1 : index2
</code></pre>

<p>  else</p>

<pre><code>scores[index1] &gt; scores[index2] ? index2 : index1
</code></pre>

<p>  end
end</p>

<p>function tournament(scores)
  population_size = length(scores)
  selection_size = population_size * 2
  [ fight(scores, rand(1:population_size), rand(1:population_size))</p>

<pre><code>for _ in 1:selection_size ]
</code></pre>

<p>end</p>

<p>function crossover(chromosome1, chromosome2)
  cut_point = rand(1:length(chromosome1.genes))
  first_part = chromosome1.genes[1:cut_point]
  second_part = chromosome2.genes[cut_point + 1:end]
  mutate(Chromosome([ first_part, second_part]))
end</p>

<p>function reproduction(new_population, current_population, selection)
  if selection == []</p>

<pre><code>return new_population
</code></pre>

<p>  else</p>

<pre><code>father = current_population[selection[1]]
mother = current_population[selection[2]]
child = crossover(father, mother)
reproduction([new_population, child], current_population, selection[3:end])
</code></pre>

<p>  end
end</p>

<p>function mutate(ch)
  mutator(g) = if rand(1:400) == 1</p>

<pre><code>g == 1 ? 0 : 1
</code></pre>

<p>  else</p>

<pre><code>g
</code></pre>

<p>  end
  Chromosome([ mutator(x)::Int for x in ch.genes ])
end</p>

<p>function run()
  current = create_population(400, 20)
  for i in 1:50</p>

<pre><code>scores = score(current)
best = maximum(scores)
println("Generation $i Best $best")
selection = tournament(scores)
current = reproduction([], current, selection)
</code></pre>

<p>  end
end
```</p>

<p>Voici un exemple d'utilisation:</p>

<pre><code>julia&gt; include("main.jl")
run (generic function with 1 method)

julia&gt; run()
Generation 1 Best 18
Generation 2 Best 18
Generation 3 Best 17
Generation 4 Best 17
Generation 5 Best 18
Generation 6 Best 17
Generation 7 Best 18
Generation 8 Best 19
Generation 9 Best 19
Generation 10 Best 19
Generation 11 Best 20
...
</code></pre>

<p>Il me reste encore pas mal de choses à faire pour améliorer ce programme,
mais c'était un bon début pour apprendre le langage Julia.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Un algorithme génétique en Julia - partie 13]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/05/31/un-algorithme-genetique-en-julia-partie-13/"/>
    <updated>2014-05-31T21:18:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/05/31/un-algorithme-genetique-en-julia-partie-13</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>On peut améliorer la fonction <code>fight</code>, pour qu'elle ne choisisse pas toujours
le meilleur individu. Il serait bon que, dans une faible proportion, elle
choisisse parfois le plus faible des deux combattants ; ceci pour assurer
qu'on ne perde pas de matériel génétique.</p>

<!-- more -->


<p>Voici donc la nouvelle fonction <code>fight</code>:</p>

<p>``` julia
function fight(scores, index1, index2)
  if rand() &lt; 0.8</p>

<pre><code>scores[index1] &gt; scores[index2] ? index1 : index2
</code></pre>

<p>  else</p>

<pre><code>scores[index1] &gt; scores[index2] ? index2 : index1
</code></pre>

<p>  end
end
```</p>

<p>Dans 80% des cas, elle selectionne le meilleur individu, et dans 20% des
cas, elle selectionne le plus faible.</p>

<p>Je pense qu'on a maintenant tous les éléments nécessaire à la finalisation
de l'algorithme.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
