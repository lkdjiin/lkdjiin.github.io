<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : julia | Xavier Nayrac]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/julia/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2016-11-02T09:47:03+01:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Les langages que j'aimerais (ré)apprendre]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/06/18/les-langages-que-jaimerais-re-apprendre/"/>
    <updated>2015-06-18T10:46:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/06/18/les-langages-que-jaimerais-re-apprendre</id>
    <content type="html"><![CDATA[<p>Ça fait 5 ans que je fais presque exclusivement du Ruby.  J’ai envie que ça
change. Je n’ai pas de problème avec Ruby ; j’aime toujours autant ce langage ;
je pense qu’il a encore pas mal d’avenir (inertie des projets rails, ruby
dans le navigateur avec opal.rb, ruby dans l’embarqué avec mruby) ; c’est juste
que j’ai besoin d’air frais.</p>

<p>Voici une liste de 8 langages informatiques que j’aimerais apprendre,
réapprendre, tester ou approfondir, plus ou moins dans l’ordre.</p>

<h2 id="r">R</h2>

<p>Le langage de base du <em>data scientist</em>. Je m’y met à fond en ce moment.
Ce langage est parfois bizarre, mais parfait pour l’exploration des données,
les statistiques et les graphes en interactif dans la console.</p>

<!-- more -->

<h2 id="jruby">JRuby</h2>

<p>Bon ok, c’est pas un langage. Mais je ne me suis jamais intéressé à JRuby.
C’est peut-être le moment d’essayer. Je me dis que JRuby pourrait pallier les
lacunes de Ruby en matière de graphisme.</p>

<h2 id="java">Java</h2>

<p>Des fois je ressens le besoin de faire des programmes rapides. J’ai fait du
Java pendant des années, il est peut-être temps de voir les nouveautés que ce
langage a à m’offrir.</p>

<h2 id="assembleur">Assembleur</h2>

<p>J’ai fait de l’assembleur il y a longtemps. Ça ne m’a jamais vraiment manqué,
mais j’explorerais bien les micro contrôleurs en assembleur, par exemple.</p>

<h2 id="elm">Elm</h2>

<p>Un langage fonctionnel, réactif, sympa pour les jeux en
2D. Pas besoin d’en dire plus, je suis intrigué et je veux l’essayer, même si
ça se passe dans le navigateur.</p>

<h2 id="julia">Julia</h2>

<p>Lui, il veut carrément remplacer R, matlab, Octave, etc. Et d’après ce que j’en
ai déjà vu, il pourrait en avoir les moyens. Par contre je ne pense pas
apprendre R <strong>et</strong> Julia en même temps, donc Julia devra attendre.</p>

<h2 id="c">C</h2>

<p>Je n’avais pas fait de C depuis plusieurs années, à part avec l’Arduino mais ça
compte pas vraiment, n’est-ce pas ? Dernièrement j’ai écris un patch en C pour
le langage R et ça m’a donné envie de m’y remettre. Mais bon, c’est juste une
envie.</p>

<h2 id="f-sharp">F sharp</h2>

<p>Certainement que ça n’arrivera jamais (parce que pas le besoin) mais je trouve la
syntaxe élégante et intrigante. J’aimerais bien l’essayer.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Le jeu de la vie en Julia - partie 3]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/12/26/le-jeu-de-la-vie-en-julia-partie-3/"/>
    <updated>2014-12-26T15:06:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/12/26/le-jeu-de-la-vie-en-julia-partie-3</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>C’est la troisième et dernière partie du jeu de la vie en Julia. Déjà.
J’aime tellement découvrir et utiliser ce langage que ça me rend triste.</p>

<p>Tout d’abord, le code du <a href="https://github.com/lkdjiin/game-of-life-julia">jeu de la vie en Julia</a>
est disponible sur Github, pour celles et ceux qui veulent y jeter un oeil.</p>

<h2 id="calculer-la-gnration-suivante">Calculer la génération suivante</h2>

<p>Maintenant, en avant pour la suite. Encore une fonction, et ça sera terminé. Il faut calculer la génération
suivante à partir de la génération courante:</p>

<p>``` julia test.jl
generation = [ 0 1 0 1 ;
               1 1 1 1 ;
               0 0 0 0 ;
               1 0 1 0 ]</p>

<h1 id="section">…</h1>

<p>@test Generation.next(generation) == [ 1 1 0 1 ;
                                       1 1 0 1 ;
                                       1 0 0 1 ;
                                       0 0 0 0 ]
```</p>

<!-- more -->

<p>``` julia generation.jl
module Generation</p>

<p>using ..Neighborhood: extract, state
using ..Cell</p>

<h1 id="section-1">…</h1>

<p>function next(generation)
    duplicate = zeros(generation)
    height, width = size(generation)
    for x in 1:width
        for y in 1:height
            neighborhood = extract(generation, y, x)
            newstate = Cell.next(generation[y, x], state(neighborhood))
            duplicate[y, x] = newstate
        end
    end
    duplicate
end</p>

<h1 id="section-2">…</h1>
<p>```</p>

<p>Le code est un peu plus complexe que dans les 2 premiers articles, et il m’a
fallu un peu de temps avant de réussir à utiliser les modules.</p>

<p>Je vais utiliser les fonctions <code>extract</code> et <code>state</code> du module <code>Neighborhood</code>,
module qui est défini dans le module parent, d’où les <code>..</code>.</p>

<pre><code>using ..Neighborhood: extract, state
</code></pre>

<p>Je crée un nouveau tableau, aux mêmes dimensions que <code>generation</code>, et remplis
de zéros.</p>

<pre><code>duplicate = zeros(generation)
</code></pre>

<p>Ensuite, c’est une boucle dans une boucle qui se sert du code des articles
précédents, avant de renvoyer le tableau <code>duplicate</code>. C’est pas très beau, mais
comme le test passe, ça me va pour l’instant.</p>

<p>Il reste à se servir de ce code dans le fichier principal:</p>

<p>``` julia main.jl
include(“neighborhood.jl”)
include(“cell.jl”)
include(“generation.jl”)
include(“display.jl”)</p>

<p>function main(height, width, number_of_generation)
    generation = Generation.create(height, width)
    for i in 1:number_of_generation
        Display.draw(generation)
        sleep(0.8)
        generation = Generation.next(generation)
    end
end</p>

<p>main(20, 80, 50)
```</p>

<p>Et voilà, c’est terminé ! Le reste de l’article se consacre à l’amélioration
de la fonction <code>Generation.next</code>.</p>

<h2 id="un-peu-de-refactoring">Un peu de refactoring</h2>

<p>Pour améliorer <code>Generation.next</code>, il y a la fonction
<a href="http://julia.readthedocs.org/en/latest/stdlib/base/#Base.eachindex">eachindex</a>,
malheureusement elle n’est pas encore disponible dans la dernière version stable.
J’ai donc cherché autre chose.</p>

<p>Ma première tentative : utiliser une compréhension de liste avec <code>reshape</code>.</p>

<p><code>julia
function next(generation)
    duplicate = zeros(generation)
    height, width = size(generation)
    indexes = reshape([(h,w) for h in 1:height, w in 1:width], length(generation))
    for (y, x) in indexes
        neighborhood = extract(generation, y, x)
        newstate = Cell.next(generation[y, x], state(neighborhood))
        duplicate[y, x] = newstate
    end
    duplicate
end
</code></p>

<p>La compréhension de liste génère la liste des indexs:</p>

<pre><code>julia&gt; [(h,w) for h in 1:3, w in 1:4]
3x4 Array{(Int32,Int32),2}:
 (1,1)  (1,2)  (1,3)  (1,4)
 (2,1)  (2,2)  (2,3)  (2,4)
 (3,1)  (3,2)  (3,3)  (3,4)
</code></pre>

<p>Et <code>reshape</code> change les dimensions du tableau, ici pour une seule dimension de la bonne longueur:</p>

<pre><code>julia&gt; reshape([(h,w) for h in 1:3, w in 1:4], 3 * 4)
12-element Array{(Int32,Int32),1}:
 (1,1)
 (2,1)
 (3,1)
 (1,2)
 (2,2)
 (3,2)
 (1,3)
 (2,3)
 (3,3)
 (1,4)
 (2,4)
 (3,4)
</code></pre>

<p>Vous avez peut-être remarqué le pattern (a-t-il un nom ?):</p>

<ol>
  <li>Création d’une variable</li>
  <li>Transformation de cette variable</li>
  <li>Renvoi de la variable</li>
</ol>

<p>En général, on peut se passer de la création et du retour explicite en utilisant
un <code>map</code>. Ici, j’ai créé une fonction <code>newstate</code> à l’intérieur de <code>next</code>.</p>

<p><code>julia
function next(generation)
    height, width = size(generation)
    indexes = [(h,w) for h in 1:height, w in 1:width]
    function newstate(y,x)
        neighborhood = extract(generation, y, x)
        Cell.next(generation[y, x], state(neighborhood))
    end
    map((yx) -&gt; newstate(first(yx), last(yx)), indexes)
end
</code></p>

<p>On peut simplifier la fonction anonyme à l’aide du <em>splat</em>:</p>

<p><code>julia
  map((yx) -&gt; newstate(yx...), indexes)
</code></p>

<p>Finalement, deux fonctions séparées me semble bien plus lisibles:</p>

<p>``` julia
function next(generation)
    height, width = size(generation)
    indexes = [(y, x) for y in 1:height, x in 1:width]
    map((yx) -&gt; newstate(generation, yx…), indexes)
end</p>

<p>function newstate(generation, y, x)
    neighborhood = extract(generation, y, x)
    Cell.next(generation[y, x], state(neighborhood))
end
```</p>

<p>Voilà. Le code est disponible sur Gitub : <a href="https://github.com/lkdjiin/game-of-life-julia">le jeu de la vie en Julia</a>.</p>

<p>La prochaine fois, ce sera du Haskell.</p>

<script id="fb33k8u">(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Le jeu de la vie en Julia - partie 2]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/12/24/le-jeu-de-la-vie-en-julia-partie-2/"/>
    <updated>2014-12-24T10:03:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/12/24/le-jeu-de-la-vie-en-julia-partie-2</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<h2 id="calcul-du-prochain-tat-dun-cellule">Calcul du prochain état d’un cellule</h2>

<p>Au départ je voulais écrire une fonction <code>nextcellstate</code>. C’est la convention
en Julia: séparer les mots par des underscores seulement si c’est
incompréhensible.  Je ne sais pas pour vous, mais moi je trouve <code>nextcellstate</code>
incompréhensible.  Donc ça devient <code>next_cell_state</code>. C’est mieux. Mais on te
dis aussi que si tu ressens le besoin de mettre des underscores, c’est
peut-être parce que ta fonction en fait trop. Bon conseil.</p>

<p>Alors, cette fonction pourrait appartenir à un module <code>Cell</code>. Elle devient donc
<code>Cell.nextstate</code>. Pardon, <code>Cell.next_state</code>, c’est mieux. Mais j’ai encore <code>next</code> et
<code>state</code>, qui font deux choses différentes.</p>

<p><code>state</code> calcule l’état d’un voisinage (<em>neighborhood</em>) de cellules, c’est à dire le
nombre de <code>1</code> (cellule vivante) parmi 9 cellules: celle qui nous intéresse et ses
8 voisines.</p>

<p><code>next</code> calcule le prochain état d’une cellule (1 ou 0, vivante ou morte) selon son
état actuel et l’état de son voisinage.</p>

<p>J’ai donc décidé d’avoir une fonction <code>Neighborhood.state</code> plus une fonction
<code>Cell.next</code>.  Voici le test pour <code>Neighborhood.state</code>, c’est loin d’être
exhaustif, mais j’ai envie d’avancer:</p>

<p>``` julia test.jl
include(“generation.jl”)
include(“neighborhood.jl”)</p>

<h1 id="section">…</h1>

<p>@test Neighborhood.state([ 0 1 1 0 0 0 1 1 1]) == 5
```</p>

<p>Et la fonction:</p>

<p>``` julia neighborhood.jl
module Neighborhood</p>

<p>state(cells) = countnz(cells)</p>

<p>end
```</p>

<!-- more -->

<p><code>countnz</code> compte tout simplement le nombre d’éléments différents de zéro.</p>

<p>Passons à <code>Cell.next</code>:</p>

<p>``` julia test.jl
include(“generation.jl”)
include(“neighborhood.jl”)
include(“cell.jl”)</p>

<h1 id="section-1">…</h1>

<p>ALIVE = 1
DEAD  = 0</p>

<p>@test Cell.next(ALIVE, 5) == 0
@test Cell.next(DEAD, 3) == 1
@test Cell.next(DEAD, 4) == 0
@test Cell.next(ALIVE, 4) == 1
```</p>

<p>``` julia cell.jl
module Cell</p>

<p>function next(cell, neighborhood)
    if neighborhood == 3
        1
    elseif neighborhood == 4
        cell
    else
        0
    end
end</p>

<p>end
```</p>

<p>Il semble que Julia n’ai pas de switch/case, dommage.</p>

<p>Maintenant je passe à l’extraction d’une génération, c’est à dire les 9 cellules
composées de notre cellule cible et de ses 8 voisines.</p>

<p>``` julia test.jl
# …</p>

<p>generation = [ 0 1 0 1 ;
               1 1 1 1 ;
               0 0 0 0 ;
               1 0 1 0 ]
@test Neighborhood.extract(generation, 2, 3) == [ 1 0 1 ; 1 1 1 ; 0 0 0 ]
@test Neighborhood.extract(generation, 3, 2) == [ 1 1 1 ; 0 0 0 ; 1 0 1 ]
```</p>

<p><code>julia neighborhood.jl
extract(generation, y, x) = generation[y-1:y+1, x-1:x+1]
</code></p>

<p>C’est tellement simple à implémenter… J’aime de plus en plus Julia.</p>

<p>Ensuite viennent les tests des cas exceptionnels. Je ne vous en montre que 3:</p>

<p>``` julia test.jl
generation = [ 0 1 0 1 ;
               1 1 1 1 ;
               0 0 0 0 ;
               1 0 1 0 ]</p>

<h1 id="section-2">…</h1>

<p>@test Neighborhood.extract(generation, 1, 2) == [ 0 1 0 ; 1 1 1 ]</p>

<p>@test Neighborhood.extract(generation, 3, 1) == [ 1 1 ; 0 0 ; 1 0 ]</p>

<p>@test Neighborhood.extract(generation, 1, 1) == [ 0 1 ; 1 1 ]
```</p>

<p>Là encore, l’implémentation est simple:</p>

<p><code>julia neighborhood.jl
function extract(generation, y, x)
    height, width = size(generation)
    y_low = y == 1 ? 1 : y - 1
    y_up  = y == height ? height : y + 1
    x_low = x == 1 ? 1 : x - 1
    x_up  = x == width ? width : x + 1
    generation[y_low:y_up, x_low:x_up]
end
</code></p>

<p>Ce qu’on peut ré-arrenger un peu, par exemple ainsi:</p>

<p>``` julia neighborhood.jl
function extract(generation, y, x)
    height, width = size(generation)
    yrange = range_for(y, height)
    xrange = range_for(x, width)
    generation[yrange, xrange]
end</p>

<p>function range_for(coordinate, dimension)
    low = coordinate == 1 ? 1 : coordinate - 1
    up  = coordinate == dimension ? dimension : coordinate + 1
    low:up
end
```</p>

<p>Rendez-vous dans le prochain article pour la fin du jeu de la vie en Julia.</p>

<script id="fb33k8u">(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Le jeu de la vie en Julia - partie 1]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/12/23/le-jeu-de-la-vie-en-julia-partie-1/"/>
    <updated>2014-12-23T14:50:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/12/23/le-jeu-de-la-vie-en-julia-partie-1</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Voici la première partie du jeu de la vie en Julia.
Pour installer la dernière version stable (0.3.3), rendez-vous sur le
<a href="https://github.com/JuliaLang/julia">Github de Julia</a>.</p>

<p>Julia est un langage jeune et en pleine effervescence et plusieurs frameworks
de tests sont en cours de création. J’ai notamment remarqué:</p>

<ul>
  <li><a href="https://github.com/JuliaLang/FactCheck.jl">FactCheck.jl</a></li>
  <li><a href="https://github.com/arypurnomoz/JulieTest.jl">JulieTest.jl</a></li>
  <li><a href="https://github.com/Veraticus/testfast.jl">testfast.jl</a></li>
</ul>

<h2 id="cration-dune-gnration">Création d’une génération</h2>

<p>Mais pour ce que je compte faire ici, Julia possède une macro très simple,
<a href="http://julia.readthedocs.org/en/latest/stdlib/test/">@test</a>. Même si <code>@test</code>
est très minimal, ça sera suffisant pour ce programme. Voici donc les
tests de la fonction <code>create</code> du module <code>Generation</code>:</p>

<p>``` julia test.jl
include(“generation.jl”)</p>

<p>using Base.Test</p>

<p>HEIGHT = 3
WIDTH = 4</p>

<p>created_generation = Generation.create(HEIGHT, WIDTH)
@test typeof(created_generation) == Array{Int,2}
@test size(created_generation) == (HEIGHT, WIDTH)
for i in 1:length(created_generation)
    @test created_generation[i] in 0:1
end
```</p>

<!-- more -->

<p>Et voici les explications ligne par ligne. D’abord je rends disponible le code du futur fichier <code>generation.jl</code>:</p>

<pre><code>include("generation.jl")
</code></pre>

<p>Ensuite je demande à utiliser le module <code>Test</code>, pour avoir accès à la macro <code>@test</code>:</p>

<pre><code>using Base.Test
</code></pre>

<p>Définition des <em>constantes</em> pour la hauteur et la largeur de la génération:</p>

<pre><code>HEIGHT = 3
WIDTH = 4
</code></pre>

<p>Création d’une génération, c’est cette fonction qu’il m’intéresse de tester:</p>

<pre><code>created_generation = Generation.create(HEIGHT, WIDTH)
</code></pre>

<p>Je m’assure que <code>create</code> renvoie un tableau d’entiers à 2 dimensions:</p>

<pre><code>@test typeof(created_generation) == Array{Int,2}
</code></pre>

<p>Je m’assure que le tableau renvoyé par <code>create</code> possède bien les dimensions
voulues:</p>

<pre><code>@test size(created_generation) == (HEIGHT, WIDTH)
</code></pre>

<p>Je m’assure enfin que chaque cellule du tableau est un 1 ou un 0:</p>

<pre><code>for i in 1:length(created_generation)
    @test created_generation[i] in 0:1
end
</code></pre>

<p>Pour lancer ces tests : <code>julia test.jl</code>.</p>

<p>Voici maintenant la fonction <code>create</code> qui fera passer les tests ci-dessus:</p>

<p>``` julia generation.jl
module Generation</p>

<p>create(height, width) = rand(0:1, height, width)</p>

<p>end
```</p>

<p>Notez l’efficacité de la fonction <code>rand</code>. Sans argument, elle produit
classiquement un nombre aléatoire entre 0 et 1:</p>

<pre><code>julia&gt; rand()
0.7084513868758786
</code></pre>

<p>Avec un <em>range</em>, elle sort un nombre compris dans ce <em>range</em>:</p>

<pre><code>julia&gt; rand(0:1)
1
</code></pre>

<p>Si j’ajoute en plus une dimension, elle renvoie un tableau:</p>

<pre><code>julia&gt; rand(0:1, 3)
3-element Array{Int32,1}:
 0
 0
 1
</code></pre>

<p>Avec deux dimensions:</p>

<pre><code>julia&gt; rand(0:1, 3, 4)
3x4 Array{Int32,2}:
 0  0  0  1
 1  1  1  1
 1  1  0  0
</code></pre>

<p>Et même pour le fun, avec 3 dimensions:</p>

<pre><code>julia&gt; rand(0:1, 3, 4, 3)
3x4x3 Array{Int32,3}:
[:, :, 1] =
 1  1  1  1
 0  1  0  0
 0  0  1  0

[:, :, 2] =
 1  1  0  1
 0  0  0  0
 1  1  1  1

[:, :, 3] =
 0  0  0  1
 1  0  0  1
 1  1  0  0
</code></pre>

<p>Vous pouvez aussi tester avec encore plus de dimensions, ça fonctionnera.</p>

<h2 id="affichage-dune-gnration">Affichage d’une génération</h2>

<p>Bon, Julia est jeune, je l’ai déjà dit. Je n’ai rien trouvé de simple pour faire
un peu de graphisme, donc je vais faire les sorties dans la console.</p>

<p>``` julia display.jl
module Display</p>

<p>function draw(generation)
    run(<code>clear</code>)
    println(replace(repr(generation)[2:end-1], “ “, “”))
end</p>

<p>end
```</p>

<p>La première ligne de la fonction, <code>run</code>, appelle la commande système
<code>clear</code>, qui efface l’écran du terminal.</p>

<p>La seconde demande à être décomposée. Soit la génération suivante:</p>

<pre><code>julia&gt; generation = rand(0:1, 2, 3)
2x3 Array{Int32,2}:
 0  0  1
 0  1  0
</code></pre>

<p><code>repr</code> nous donne la représentation en chaîne de caractères:</p>

<pre><code>julia&gt; repr(generation)
"[0 0 1\n 0 1 0]"
</code></pre>

<p>On peut accéder à une chaîne comme un tableau, ici je conserve ce qui se trouve
entre le second et l’avant-dernier élément:</p>

<pre><code>julia&gt; repr(generation)[2:end-1]
"0 0 1\n 0 1 0"
</code></pre>

<p><strong>Je m’aperçois que j’ai oublié de parler d’un truc important: l’indexation les
tableaux en Julia commence à 1.</strong></p>

<p>Pour finir je supprime les espaces avec <code>replace</code>:</p>

<pre><code>julia&gt; replace(repr(generation)[2:end-1], " ", "")
"001\n010"
</code></pre>

<p>Et quand on combine tout ça dans un fichier <code>main.jl</code>, voici le résultat:</p>

<p>``` julia main.jl
include(“generation.jl”)
include(“display.jl”)</p>

<p>height = 20
width = 80</p>

<p>generation = Generation.create(height, width)
Display.draw(generation)
```</p>

<pre><code>$ julia main.jl
00010111100111000011100111001010001101000010110111000111101101110101000011100000
00001101010010101111001010110101100101001000001011010001010110010100011011011011
01001000011101000001101110010010110000100101011110001001110110101111010001001001
11111110011101100001111010110101110000101011011000000011110000010011011100111111
11100100000011100001111111101010011000110011010101011100011110101110111111001111
11110011000101101010110010110011101101000111000111111111001110010100011101010101
10011101010110011110100101110110111101111101100110011011011001011100000110110000
01001110010101111101110001000110110100001101100100000010011101111000001010111100
00011001011000000000000111010000100001100000001110101110000010100010101111011111
00101011011010000001111001001011111101101110111000101100000100001101110110101100
10000010100100011111111101010101001010001010111111001111100001010001011010000001
11000011000001001101011001111101111111111111011111100101100101010000101111101001
11010111011111101001111110100000001011100100010100100100000010001011000010101110
10011000100111111100011010010100110001101110001001100100100000010100111001111011
11110001001011000101100001001110010100010011100101001101010111111100011100111101
11001111000101101111001110010010101001110010101100010100101011101011000101000000
01001111111101010010001100010011000001110110001110110101010101010000111010111000
01101001011011011001110010010010000101000111111111010101001011101011111001101010
00101111001100011111110110000110011100001011011100101101011001111111111100011110
01110001110010001001011100100000100000010110001100011011101001010011111011110100
</code></pre>

<p>Pour rendre la sortie écran un peu plus présentable, <em>effaçons</em> les 0, en les
remplaçant par des espaces, et remplaçons les 1 par des @:</p>

<p>``` julia display.jl
module Display</p>

<p>function draw(generation)
    run(<code>clear</code>)
    output = replace(repr(generation)[2:end-1], “ “, “”)
    output = replace(output, “1”, “@”)
    output = replace(output, “0”, “ “)</p>

<pre><code>println(output) end
</code></pre>

<p>end
```</p>

<p>Pour terminer, voici une petite boucle pour afficher une dizaine de générations:</p>

<p>``` julia main.jl
include(“generation.jl”)
include(“display.jl”)</p>

<p>height = 20
width = 80</p>

<p>for _ in 1:10
    generation = Generation.create(height, width)
    sleep(0.8)
    Display.draw(generation)
end
```</p>

<script id="fb33k8u">(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Le jeu de la vie dans sept langages différents]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/10/08/le-jeu-de-la-vie-dans-sept-langages-differents/"/>
    <updated>2014-10-08T12:30:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/10/08/le-jeu-de-la-vie-dans-sept-langages-differents</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Je vais écrire le <a href="http://en.wikipedia.org/wiki/Conway%27s_Game_of_Life">jeu de la vie</a> dans 7 langages, et
en utilisant le TDD (sauf pour l’affichage).
Ça va me permettre de réviser certains langages et d’en apprendre de nouveaux
d’une manière amusante. Après tout, quoi de plus <em>fun</em> qu’un jeu pour zéro
joueur.</p>

<h2 id="lalgorithme">L’algorithme</h2>

<p>L’idée directrice, c’est de faire au plus simple.
L’algorithme général sera le suivant :</p>

<ol>
  <li>obtenir une première génération au hasard</li>
  <li>afficher la génération</li>
  <li>calculer la nouvelle génération et retour au point 2.</li>
</ol>

<p>Discutons un peu chacun des trois points.</p>

<!-- more -->

<h3 id="obtenir-une-premire-gnration-au-hasard">Obtenir une première génération au hasard</h3>

<p>Cette génération sera stockée dans un tableau (une liste). Suivant le
langage, j’utiliserais un tableau à 1 ou 2 dimensions.</p>

<h3 id="afficher-la-gnration">Afficher la génération</h3>

<p>Il s’agit d’afficher à l’écran le tableau calculé précédement. Chaque élément
du tableau représente une cellule du jeu de la vie, et une cellule sera
représentée à l’écran par un pixel. Alors un pixel pour une cellule, ça risque
d’être assez moche sur la plupart des dispositifs, mais c’est le plus simple.
J’améliorerais peut-être cet affichage plus tard.</p>

<h3 id="calculer-la-nouvelle-gnration">Calculer la nouvelle génération</h3>

<p>Là encore, j’essaye d’aller au plus simple. On va calculer la
nouvelle génération dans un second tableau. Une fois ce calcul effectué, ce
second tableau remplacera le premier.</p>

<p>Pour calculer le nouvel état d’une cellule, on devra observer la cellule et
ces 8 voisins. Autrement dit on observe une fenêtre de 9 cellules et on veut
connaitre le nouvel état de la cellule centrale. Il y a 3 cas possibles:</p>

<ol>
  <li>Si la somme des cellules vivantes est 3, alors la nouvelle cellule sera
vivante.</li>
  <li>Si la somme des cellules vivantes est 4, alors la nouvelle cellule conserve
son ancien état.</li>
  <li>Dans tous les autres cas, la nouvelle cellule est morte.</li>
</ol>

<p>Il faut encore parler du cas des cellules qui se trouvent sur les bords du
<em>plateau de jeu</em>. Normalement, le jeu de la vie est infini. Mais l’infini, c’est
pas simple. Dans une première itération, le <em>plateau de jeu</em> aura des
dimensions finies et les cellules qui se trouvent sur les bords se verront
ajoutées arbitrairement des voisins morts.</p>

<p>Une seconde itération pourrait implémenter une espèce de <a href="http://en.wikipedia.org/wiki/Torus">tore</a> pour avoir une surface
de jeu sans bordures.</p>

<h2 id="les-langages-cibls">Les langages ciblés</h2>

<p>Je vais écrire le jeu de la vie dans 7 langages différents:</p>

<ul>
  <li>ruby</li>
  <li>javascript</li>
  <li>racket</li>
  <li>logo</li>
  <li>julia</li>
  <li>haskell</li>
  <li>rust</li>
</ul>

<h3 id="pourquoi-ces-langages-">Pourquoi ces langages ?</h3>

<p><strong>Ruby</strong></p>

<p>Ça peut paraitre bizarre. Après tout j’écris en Ruby toute la journée, c’est
mon métier. Pourquoi vouloir en faire encore pendant mon temps libre ?
En fait, ce qui m’intéresse vraiment ici, c’est <a href="http://opalrb.org/">Opal.rb</a>. Peut-être aussi
que j’en ferais une seconde version avec <a href="http://www.libgosu.org/">Gosu</a>.</p>

<p><strong>Javascript</strong></p>

<p>Après des années passées à tenter d’éviter d’écrire la moindre ligne de
Javascript, je m’intéresse de nouveau à ce langage. Après tout, c’est un
incontournable du Web et il commence à me plaire. Et puis j’ai trop tardé à
faire du TDD avec Javascript, je crois que <a href="http://jasmine.github.io/">Jasmine</a> est devenu très bon.</p>

<p><strong>Racket</strong></p>

<p>Je crois que tout développeur devrait étudier un <em>Lisp like</em>. Lisp t’oblige à
penser autrement et du coup tu trouves des solutions différentes à des
problèmes de programmation de tout les jours.</p>

<p><strong>Logo</strong></p>

<p>Le <a href="http://fr.wikipedia.org/wiki/Logo_%28langage%29">Logo</a>, c’est ma <a href="http://fr.wikipedia.org/wiki/Madeleine_%28cuisine%29#La_madeleine_de_Proust">madeleine de Proust</a> ! Voilà. Encore un <em>Lisp like</em>,
mais différent (on l’appelait Lisp sans parenthèses). J’espère que je trouverais
encore des ressources pour celui-ci.</p>

<p><strong>Julia</strong></p>

<p>Je pense que les langages fonctionnels ont un grand avenir. Ils résolvent au
moins deux soucis. En ce concentrant sur la transformation des données plutôt
que sur l’état de ces données, ils facilitent les tests et l’utilisation des
multi-coeurs.</p>

<p><strong>Haskell</strong></p>

<p>Encore un langage fonctionnel, et celui-ci me fait un peu peur. Mais je me dis
que je devrais y goûter.</p>

<p><strong>Rust</strong></p>

<p>Je voulais un langage système dans cette liste, ce sera <a href="http://www.rust-lang.org/">Rust</a>.</p>

<h2 id="frquence-de-publication">Fréquence de publication</h2>

<p>Je ne m’avancerais pas sur une fréquence de publication. J’imagine qu’il y
aura 3 ou 4 articles par langage. Et suivant le temps dont je disposerais, ça
pourrat-être aussi bien un article par mois ou trois articles par semaine.</p>

<p>Allez, la prochaine fois on commence avec Ruby/Opal.</p>

<script id="fb33k8u">(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>

<p></p>
]]></content>
  </entry>
  
</feed>
