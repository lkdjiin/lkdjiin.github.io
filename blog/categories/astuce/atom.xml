<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : astuce | Xavier Nayrac]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/astuce/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2018-07-21T09:20:07+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Affichage de toutes les tâches rake]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/06/25/affichage-de-toutes-les-taches-rake/"/>
    <updated>2014-06-25T20:54:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/06/25/affichage-de-toutes-les-taches-rake</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Hier je parlais des switchs <code>-T</code> et <code>-D</code> de l’executable <code>rake</code> pour
obtenir la liste des tâches, respectivement tronquées ou détaillées.</p>

<p>Aujourd’hui, pour ceux qui aurait la flemme de lire la sortie de
<code>rake --help</code>, c’est comment les obtenir <strong>toutes</strong>, car il y en a souvent
plus que l’on croit ;)</p>

<!-- more -->

<p>En effet, les switchs <code>-T</code> et <code>-D</code> n’affichent que les tâches possédant
une description. Et quand on débarque sur un projet Rails, ou Ruby, il
n’est pas rare qu’une petite armée de développeurs soient passés avant
vous en ajoutant plusieurs tâches bien utiles, mais sans description.</p>

<p>Pour en avoir la liste sans avoir à lire les nombreux fichiers <code>*.rake</code>,
il vous suffit d’utiliser le switch <code>--all</code>:</p>

<pre><code>$ rake --all -T
</code></pre>

<script id="fb33k8u">(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Description détaillée des tâches rake]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/06/24/description-detaillee-des-taches-rake/"/>
    <updated>2014-06-24T21:15:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/06/24/description-detaillee-des-taches-rake</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Vous savez certainement comment obtenir la liste des tâches <code>rake</code> disponibles
dans votre projet Rails ou dans votre gem Ruby. Il faut utiliser le switch
<code>-T</code>. Par exemple, à partir d’un projet Rails bidon:</p>

<pre><code>$ rake -T
rake about                              # List versions of all Rails framew...
rake assets:clean[keep]                 # Remove old compiled assets
rake assets:clobber                     # Remove compiled assets
rake assets:environment                 # Load asset compile environment
rake assets:precompile                  # Compile all the assets named in c...
rake cache_digests:dependencies         # Lookup first-level dependencies f...
rake cache_digests:nested_dependencies  # Lookup nested dependencies for TE...
rake db:create                          # Creates the database from DATABAS...
rake db:drop                            # Drops the database from DATABASE_...
</code></pre>

<!-- more -->

<p>Et il y en a quelques dizaines d’autres. Vous remarquez que certaines descriptions sont
tronquées, comme <code># Compile all the assets named in c...</code>. Lorsqu’il s’agit d’une
tâche qu’on ne connait pas très bien, on aimerait pouvoir lire la description
complête. Pour cela, il faut utiliser le switch <code>-D</code>:</p>

<pre><code>$ rake -D
rake about
    List versions of all Rails frameworks and the environment

rake assets:clean[keep]
    Remove old compiled assets

rake assets:clobber
    Remove compiled assets

rake assets:environment
    Load asset compile environment

rake assets:precompile
    Compile all the assets named in config.assets.precompile

rake cache_digests:dependencies
    Lookup first-level dependencies for TEMPLATE (like messages/show or comments/_comment.html)
</code></pre>

<p>Pour en savoir plus sur les switchs de rake, tapez <code>rake --help</code>.</p>

<script id="fb33k8u">(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rechercher avec grep dans un fichier compressé]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/05/22/recherchez-avec-grep-dans-un-fichier-compresse/"/>
    <updated>2014-05-22T21:10:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/05/22/recherchez-avec-grep-dans-un-fichier-compresse</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Il vous arrive peut-être parfois d’avoir à fouiller des fichiers de log ?
Vous utiliser <code>grep</code> pour ça ? Et comment faire quand les logs sont
compressés ?</p>

<!-- more -->

<p>Lorsque le log est normal, c’est à dire non-compressé, on peut utiliser la
commande <code>grep</code> suivante:</p>

<p><code>bash
$ grep --color 'LOWER' test.log
  User Exists (0.8ms)  SELECT 1 AS one FROM "users" WHERE LOWER("users"."email")   = LOWER('foo@example.com') LIMIT 1
</code></p>

<p>Elle va afficher toutes les lignes du fichier <code>test.log</code> qui contiennent le
mot <code>LOWER</code>.</p>

<p>Mais si on fait la même chose sur un log compressé:</p>

<p><code>bash
$ grep --color 'LOWER' test.log.1.gz
$ 1
</code></p>

<p>Ça ne fonctionne pas. Ci-dessus, le <code>$ 1</code>, c’est mon shell qui m’affiche
une erreur sous la forme du code de retour (une idée pour un futur article).</p>

<p>Pour chercher dans un fichier compressé avec <code>grep</code>, on peut utiliser très
simplement la commande <code>zgrep</code>:</p>

<p><code>bash
$ zgrep --color 'LOWER' test.log.1.gz
  User Exists (0.8ms)  SELECT 1 AS one FROM "users" WHERE LOWER("users"."email")   = LOWER('foo@example.com') LIMIT 1
</code></p>

<p>Et voilà.</p>

<script id="fb33k8u">(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>

<p>À demain.</p>

<p></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Insérer le contenu d'un fichier ou d'une commande shell dans Vim]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/04/29/inserer-le-contenu-dun-fichier-ou-dune-commande-shell-dans-vim/"/>
    <updated>2014-04-29T21:49:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/04/29/inserer-le-contenu-dun-fichier-ou-dune-commande-shell-dans-vim</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Pour insérer le contenu d’un fichier quelconque dans le buffer courant de
Vim, utilisez la commande <code>:r</code>:</p>

<!-- more -->

<p>Comme dans: <code>:r /mon/fichier/quelconque</code>.</p>

<p>C’est vraiment utile parfois, le problème est que le nom du fichier doit
être
absolu, ou doit commencer par le tilde (<code>~</code>). Ce qui dans certains cas
limite pas mal l’usage de cette commande.</p>

<p>Au fait, <code>r</code> est le petit nom de <code>read</code> :)</p>

<p>La version avec un point d’exclamation <code>:r!</code> est aussi très intéressante
puisqu’elle insère la sortie d’une commande shell. Par exemple, si je tape:</p>

<pre><code>:r! cal
</code></pre>

<p>Cela va insèrer le calendrier du mois dans cet article, comme ceci:</p>

<pre><code>     Avril 2014
di lu ma me je ve sa
       1  2  3  4  5
 6  7  8  9 10 11 12
13 14 15 16 17 18 19
20 21 22 23 24 25 26
27 28 29 30
</code></pre>

<p>Mais là encore j’ai un souci. Ça ne fonctionne qu’avec des commandes shell
et automatiquement dans mon <em>home</em>. Je m’explique:</p>

<ol>
  <li>Si j’édite un fichier <code>~/dossier/fichier</code> et que je veuille insérer le
contenu de <code>dossier</code>, je dois écrire <code>:r! ls ~/dossier</code>. Alors que
j’aimerais écrire juste <code>:r! ls</code>.</li>
  <li>J’aimerais bien pouvoir insérer avec <code>r</code> la sortie de mes tests Rspec,
par exemple. Mais <code>:r! rspec ~/mon/fichier</code> ne fonctionne pas, <code>rspec</code>
n’étant pas reconnu par Vim comme étant une commande.</li>
</ol>

<p>Enfin, bref, si tu sais comment venir à bout de ses limitations, ton
commentaire m’intéresse. Sinon, il m’intéresse aussi ;)</p>

<script id="fb33k8u">(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>

<p>À demain.</p>

<p></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vim - Comment ouvrir la fenêtre courante dans un nouvel onglet]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/03/26/vim-comment-ouvrir-la-fenetre-courante-dans-un-nouvel-onglet/"/>
    <updated>2014-03-26T21:09:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/03/26/vim-comment-ouvrir-la-fenetre-courante-dans-un-nouvel-onglet</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Vous avez un écran bien large ? Vous travaillez régulierement avec 4 ou 5
fenêtres dans le même onglet, voir plus ?
Parfois vous aimeriez bien ouvrir rapidement une de ces fenêtres dans un
nouvel onglet ?</p>

<!-- more -->

<p>Alors ça va peut-être bien être l’article le plus court de l’histoire de ce
blog:</p>

<p><code>vim
:tab sp
</code></p>

<p>Et la fenêtre courante s’ouvre dans un nouvel onglet (<code>sp</code> est l’abréviation
de <code>split</code>).</p>

<script id="fb33k8u">(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>

<p>À demain.</p>

<p></p>

]]></content>
  </entry>
  
</feed>
