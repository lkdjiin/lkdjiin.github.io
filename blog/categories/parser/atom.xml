<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : parser | Xavier Nayrac]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/parser/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2015-12-13T17:22:09+01:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Une machine de Turing en Ruby - Le parser]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/02/02/une-machine-de-turing-en-ruby-le-parser/"/>
    <updated>2015-02-02T18:04:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/02/02/une-machine-de-turing-en-ruby-le-parser</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>La machine de Turing réalisée dans le <a href="/blog/2015/02/01/une-machine-de-turing-en-ruby/">dernier article</a>
était seulement un brouillon, et elle souffre de plusieurs limitations.
J’aimerais maintenant faire évoluer le programme en permettant à l’utilisateur
de charger un jeu d’instructions quelconque. Pour cela j’aurai besoin
d’un <em>parser</em>, qui sera vite écrit grâce à Ruby.</p>

<p><img class="center" src="/images/gears4.jpg"></p>

<!-- more -->

<p>Un jeu d’instruction pour la machine de Turing ressemblera à ceci (si vous avez
besoin du code, <a href="https://github.com/lkdjiin/turing_machine">il est ici</a>):</p>

<p><code>raw instruction_sets/busy_beaver_3
0 A =&gt; 1 R B
1 A =&gt; 1 L C
0 B =&gt; 1 L A
1 B =&gt; 1 R B
0 C =&gt; 1 L B
1 C =&gt; 1 R HALT
</code></p>

<p>C’est l’algorithme <em>busy beaver à 3 états</em> que j’ai utilisé pour coder la
première version de la machine. Il faut écrire un <em>parser</em> qui va transformer
ce <em>code source</em> en ce hash Ruby, utilisé en interne par la machine:</p>

<p><code>
{
  ['0', 'A'] =&gt; {write: '1', move: 'R', next_state: 'B'},
  ['1', 'A'] =&gt; {write: '1', move: 'L', next_state: 'C'},
  ['0', 'B'] =&gt; {write: '1', move: 'L', next_state: 'A'},
  ['1', 'B'] =&gt; {write: '1', move: 'R', next_state: 'B'},
  ['0', 'C'] =&gt; {write: '1', move: 'L', next_state: 'B'},
  ['1', 'C'] =&gt; {write: '1', move: 'R', next_state: 'HALT'},
}
</code></p>

<p>Voici le parser, qui est construit autour de la méthode <code>String#split</code>.</p>

<p>``` ruby lib/turing_machine/instructions_parser.rb
module TuringMachine</p>

<p>class InstructionsParser</p>

<pre><code>def initialize(raw_instructions)
  @lines = raw_instructions.split("\n")
  @instructions = {}
end

def parse
  build_instructions
  @instructions
end

private

def build_instructions
  @lines.each do |instruction|
    keys, value = instruction.split('=&gt;')
    key_symbol, key_state = keys.split
    write, move, next_state = value.split
    @instructions[[key_symbol, key_state]] = {
      write: write, move: move, next_state: next_state
    }
  end
end
</code></pre>

<p>end</p>

<p>end
```</p>

<p>On va l’utiliser comme ça:</p>

<p><code>ruby
raw_instructions = IO.read(ARGV[0])
parser = InstructionsParser.new(raw_instructions)
instructions = parser.parse
</code></p>

<p>Je vais expliquer plus en détail. Tout d’abord dans le constructeur, on divise
la grande chaîne de caractères en entrée en autant de lignes indépendantes:</p>

<pre><code>@lines = raw_instructions.split("\n")
</code></pre>

<p>Puis dans la méthode privée <code>build_instructions</code>, on itère sur chacune des
lignes pour construire le hash:</p>

<pre><code>@lines.each do |instruction|
</code></pre>

<p>Chaque ligne est d’abord divisé en deux parties, de chaque coté de <code>=&gt;</code>:</p>

<pre><code>keys, value = instruction.split('=&gt;')
</code></pre>

<p>La partie des clés (celle de gauche) est à son tour divisé en deux, le symbole
sous la tête de lecture et l’état de la machine:</p>

<pre><code>key_symbol, key_state = keys.split
</code></pre>

<p>Ensuite c’est au tour de la partie de droite, celle qui représente la prochaine
instruction:</p>

<pre><code>write, move, next_state = value.split
</code></pre>

<p>Enfin, on ajoute clé et valeur dans le hash:</p>

<pre><code>@instructions[[key_symbol, key_state]] = {
  write: write, move: move, next_state: next_state
}
</code></pre>

<p>Pour finir, voici mon premier jeu d’instructions pour une machine de Turing:</p>

<p><code>raw instruction_sets/write101
0 A =&gt; 1 R B
0 B =&gt; 0 R C
0 C =&gt; 1 R HALT
</code></p>

<p>Ça fait quoi ? Ça écrit 101, tout simplement :</p>

<pre><code> turing_machine instruction_sets/write101 
  1 0000000000000000000000000000000000000000 A -&gt; 1RB
                       ^
  2 0000000000000000000100000000000000000000 B -&gt; 0RC
                        ^
  3 0000000000000000000100000000000000000000 C -&gt; 1RHALT
                         ^
  4 0000000000000000000101000000000000000000 HALT
</code></pre>

<p>Je vous rappelle que vous pouvez consulter le code de la
<a href="https://github.com/lkdjiin/turing_machine">machine de Turing</a>.</p>

<p>Voilà, avec l’aide de <code>String#split</code> il est facile d’écrire un parser simple.
Alors bien sûr, ce parser n’est pas vraiment complet, il manque par exemple la
gestion des erreurs. Mais il y a des choses plus urgentes à implémenter, comme
le mouvement nul, le ruban infini, ou la possibilité de commencer le programme
avec un ruban qui contient des données…</p>

<p>À plus tard.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
