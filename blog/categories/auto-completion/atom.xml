<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : auto complétion | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/auto-completion/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2014-01-13T20:57:39+01:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[L'auto-complétion programmable en Bash - partie 3]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/01/13/lauto-completion-programmable-en-bash-partie-3/"/>
    <updated>2014-01-13T20:50:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/01/13/lauto-completion-programmable-en-bash-partie-3</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Cet article est la suite de:
<a href="http://lkdjiin.github.io/blog/2014/01/11/lauto-completion-en-bash-partie-2/">L'auto complétion programmable en bash: partie 2</a>.</p>

<p>Je joue donc quelques minutes avec la commande <code>compgen</code>, juste pour voir
de quoi il s'agit. L'option <code>-W</code> retient particulièrement mon attention.
On lui passe une liste de mots entre guillemets et ça nous les renvoient:</p>

<pre><code>[~]⇒ compgen -W "foo bar baz"
foo
bar
baz
</code></pre>

<!-- more -->


<p>Ok, on va pas se mentir, vous ne voyez pas tellement l'intérêt, hein ?
Et si on passait un second argument à <code>compgen</code>, comme le début d'un
mot:</p>

<pre><code>[~]⇒ compgen -W "foo bar baz" f
foo
</code></pre>

<p>Ou bien encore:</p>

<pre><code>[~]⇒ compgen -W "foo bar baz" ba
bar
baz
</code></pre>

<p>Voilà qui est intéressant. Et si on lui donne un début de mot inexistant:</p>

<pre><code>[~]⇒ compgen -W "foo bar baz" o
[~]⇒ 
</code></pre>

<p>Les sections <strong>complete</strong> et surtout <strong>programmable completion</strong> de la page
de man sont particulièrement indigestes. Je me doute que je devrais les lire
si je veux aller plus loin, mais ça attendra encore.
Donc je google «bash programmable completion» et je trouve ce qu'il me faut pour
commencer. La suite la prochaine fois.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[L'auto-complétion programmable en Bash - partie 2]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/01/11/lauto-completion-en-bash-partie-2/"/>
    <updated>2014-01-11T20:33:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/01/11/lauto-completion-en-bash-partie-2</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Cet article est la suite de:
<a href="http://lkdjiin.github.io/blog/2014/01/10/lauto-completion-programmable-en-bash-partie-1/">L'auto complétion programmable en bash: partie 1</a>.</p>

<h2>Une première piste</h2>

<p>En parcourant rapidement la page de man de bash, je tombe sur une commande
pleine de promesse: la commande <code>compgen</code>.</p>

<!-- more -->


<p>Voici un extrait de la documentation:</p>

<p><strong>compgen</strong> [<em>option</em>] [<em>word</em>] <br/>
Generate possible completion matches for word according to the options, which
may be any option accepted by the <strong>complete</strong> builtin with the exception of -p
and -r, and write the matches to the standard output. When using the -F or -C
options, the various shell variables set by the <strong>programmable completion</strong>
<em>[&hellip;]</em></p>

<p>J'ai donc une commande <code>compgen</code>, qui semble fournir les différentes
possibilités de complétions pour un mot. J'ai aussi une commande <code>complete</code>,
dont le nom sonne vraiment bien. Et on me confirme que bash peut faire de
la <code>programmable completion</code>, même si je sais pas encore trop de quoi on
parle ici… Je vais devoir fouiller un peu les options de <code>complete</code> pour
apprendre comment fonctionne <code>compgen</code>. Ah, les joies du man Unix !</p>

<p>Mon voyage dans le monde de l'auto-complétion débute avec une page de man.
Y a plus sexy, mais bon, il faut bien commencer quelque part ;)</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[L'auto complétion programmable en bash: partie 1]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/01/10/lauto-completion-programmable-en-bash-partie-1/"/>
    <updated>2014-01-10T21:41:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/01/10/lauto-completion-programmable-en-bash-partie-1</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<h2>Ou comment git, apt-get et les autres l'utilisent</h2>

<p>L'auto-complétion de la ligne de commande sur unix, c'est à priori
très simple. Si je tape dans un terminal <code>ec</code> suivi de la touche tabulation:</p>

<pre><code>[~]⇒ ec[TAB]
</code></pre>

<p>C'est à dire les deux lettres &ldquo;ec&rdquo; suivies de la touche tabulation, la
commande est étendue en :</p>

<pre><code>echo 
</code></pre>

<p>Si il y a plusieurs choix possibles, Bash me les fournis:</p>

<pre><code>[~]⇒ apti
aptitude                      aptitude-curses
aptitude-create-state-bundle  aptitude-run-state-bundle
</code></pre>

<!-- more -->


<p>Ça devient plus intéressant quand ça fonctionne aussi avec les <em>arguments</em> des
commandes, qu'à priori, le shell ne connait pas. Par exemple :</p>

<pre><code>[~]⇒ apt-get upg[TAB]
</code></pre>

<p>devient :</p>

<pre><code>apt-get upgrade
</code></pre>

<p>Ou encore :</p>

<pre><code>[~]⇒ git fi[TAB]
</code></pre>

<p>qui devient :</p>

<pre><code>git filter-branch
</code></pre>

<p>Et ça devient carrément magique &ndash; <em>en tout cas pour moi</em> &ndash; quand la commande
git réussit l'auto-complétion d'une commande que j'ai ajouté moi-même.  Je
m'explique. J'ai par exemple, dans mon PATH, le fichier bash <code>git-pom</code> suivant:</p>

<p>``` bash git-pom</p>

<h1>!/bin/bash</h1>

<p>git push origin master
```</p>

<p>Si je tape :</p>

<pre><code>[~]⇒ git p[TAB]
</code></pre>

<p>ça devient :</p>

<pre><code>pom           pull          push          push-branch   
[~]⇒  git p
</code></pre>

<p>Git, ou bash, ou je ne sais quoi a trouvé la commande <code>pom</code> ! Moi ça m'épate
à chaque fois. Notez au passage que le fichier qui contient la nouvelle commande
s'appelle <code>git-pom</code> et qu'on peut taper <code>git pom</code>. Alors, comment ça
marche ?</p>

<p>Et bien je dois avouer que je n'en sais rien ! J'ai bien une petite idée
des mécanismes en jeu, mais aucunes connaissances sur le sujet. On va
donc découvrir cela ensemble au fil des articles suivants.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
