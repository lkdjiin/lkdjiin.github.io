<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : bash | Xavier Nayrac]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/bash/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2018-10-17T15:57:14+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Lister un dossier tout en nettoyant l'écran]]></title>
    <link href="http://lkdjiin.github.io/blog/2018/02/14/lister-un-dossier-tout-en-nettoyant-lecran/"/>
    <updated>2018-02-14T10:28:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2018/02/14/lister-un-dossier-tout-en-nettoyant-lecran</id>
    <content type="html"><![CDATA[<p>Deux ou trois fois dans l’année j’analyse mon usage du clavier pour tenter
d’augmenter mon confort quotidien. Lisez : Je regarde de près ce que je
tape pour faire en sorte de taper toujours moins.</p>

<p>J’ai remarqué récemment que j’aimais de plus en plus avoir un écran vide avant
d’entreprendre une série de commande. Pour effacer l’écran, on utilise la commande
<code>clear</code> ou son raccourci <code>Ctrl+L</code>. Et depuis quelques temps je me suis habitué
à systématiquement vider l’écran avant de lister le contenu d’un répertoire.
Autrement dit je répète très souvent la séquence de touche suivante :</p>

<center><b>Ctrl + l + l + s + Enter</b></center>

<p>Soit 5 touches.</p>

<p>Donc, beaucoup trop.</p>

<!-- more -->

<h2 id="alias-s">Alias S</h2>

<p>Un petit alias sera la solution pour prendre soin de mes poignets fragiles ;)
Je vais utiliser la lettre <code>s</code> parce que sa touche tombe particulièrement bien
sous mes doigts.</p>

<center><b>s + Enter</b></center>

<p>Soit 2 touches.</p>

<p>Donc, je suis content :)</p>

<h2 id="bash">Bash</h2>

<p>Avec Bash, que j’utilise essentiellement sur serveurs distants, voici comment
procéder :</p>

<p><code>bash
alias s='clear;ls' # List directory on a clean screen
</code></p>

<p>Je place mes alias Bash dans un fichier <code>~/.bash_aliases</code> que j’inclus depuis
le fichier <code>~/.bashrc</code> comme ceci :</p>

<p>```bash
# Alias definitions.
# You may want to put all your additions into a separate file like
# ~/.bash_aliases, instead of adding them here directly.
# See /usr/share/doc/bash-doc/examples in the bash-doc package.</p>

<p>if [ -f ~/.bash_aliases ]; then
    . ~/.bash_aliases
fi
```</p>

<h2 id="fish">Fish</h2>

<p>Avec Fish, que j’utilise sur mes machines perso, c’est un peu différent. Fish
n’a pas de commande <code>alias</code>, il suffit d’écrire une fonction au bon endroit.</p>

<p><code>
# Fichier ~/.config/fish/functions/s.fish
function s --description 'List directory on a clean, cleared screen'
  	clear
    ls
end
</code></p>

<h2 id="conclusion">Conclusion</h2>

<p>Je ne sais pas si je vais beaucoup me servir de cette commande <code>s</code>.
J’ai toujours eu du mal à m’habituer aux commandes d’une seule lettre, je sais
pas pourquoi. On verra bien…</p>

<p>Si vous avez des astuces dans le même genre, faites moi en part dans un
commentaire, ça pourrait servir ;)</p>

<p>À bientôt.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Changer de shell, de Bash à Fish]]></title>
    <link href="http://lkdjiin.github.io/blog/2016/12/13/changer-de-shell-de-bash-a-fish/"/>
    <updated>2016-12-13T19:34:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2016/12/13/changer-de-shell-de-bash-a-fish</id>
    <content type="html"><![CDATA[<p>J’avais remarqué le shell Fish il y a plusieurs années. Mais l’accroche de son
site web m’avais plutôt fait penser à une blague :</p>

<blockquote>
  <p>Finally, a command line shell for the 90s</p>
</blockquote>

<p>Heureusement pour moi, j’y suis repassé il y a quelques mois. Et cette fois
j’ai compris que c’était du sérieux. Je me suis promis de revenir dès que
possible pour essayer ce shell.</p>

<p>On est le week end. J’ai quelques heures devant moi. C’est parti pour
un test. Et comme directement c’est l’effet WAO, je me dis que je
vais y aller <em>à la dure</em>, en l’installant sur l’ordinateur du boulot.</p>

<p>Voici mes premières impressions après deux jours d’utilisation.</p>

<!-- more -->

<h2 id="auto-compltion">Auto complétion</h2>

<p>La première chose qui me saute aux yeux, c’est l’auto complétion, qui va de pair
avec les suggestions faites par le shell.</p>

<p>L’auto complétion par la touche TAB semble bien plus performante qu’en Bash. Un
coup d’œil dans la doc me dit qu’il sera aussi plus simple de fournir les
auto complétions pour mes propres programmes.</p>

<p>Ensuite, des suggestions apparaissent au fur et à mesure que l’on entre des
caractères et c’est puissant. Ça n’existe tout simplement pas dans Bash. Ctrl+F
permet d’accepter toute la ligne, alors que Alt+F accepte un seul mot.</p>

<h2 id="coloration-syntaxique">Coloration syntaxique</h2>

<p>Fish colore votre ligne de commande en temps réel. Y a pas à dire, ça change de
Bash. Et c’est utile : une commande inconnue ou mal orthographiée apparait en
rouge, on repère une variable au milieu d’une chaîne de caractères, etc.</p>

<h2 id="retrouver-les-anciennes-commandes">Retrouver les anciennes commandes</h2>

<p>Avec Bash, j’ai une configuration qui me permet de taper les premières lettres
d’une commande, et de faire défiler (avec les touches fléchées) toutes les
commandes historiques qui commencent par ces quelques lettres.</p>

<p>Avec Fish, pas besoin de configurer quoi que ce soit. Ça existe d’emblée, mais
en plus puissant.</p>

<h2 id="raccourcis-clavier">Raccourcis clavier</h2>

<p>Pour l’instant je ne retrouve pas tous mes raccourcis (ou astuces).
<del>Par exemple avec Bash <code>Esc+.</code> affiche l’argument de la dernière commande. Ça
me manque avec Fish.</del> (Edit: à partir de la version 2.3 <code>Esc+.</code> fonctionne)
Mais comme un principe de Fish est «<em>on peut faire tous ce que peuvent faire
les autres shells</em>», j’attends de voir.</p>

<h2 id="ruby"> Ruby</h2>

<p>J’utilise <code>chruby</code> depuis un certain temps comme <em>version manager</em> et j’ai eu
une petite frayeur en constatant que plus rien ne fonctionnait avec Fish.
Pour mon premier jour sous Fish au boulot, ça a donc été mitigé, même si j’utilise
moins Ruby ces temps ci. Je repassais sous Bash quand il fallait faire du Ruby.</p>

<p>Dans l’après midi je me suis décidé à chercher, et j’ai trouvé ça:
<a href="https://github.com/JeanMertz/chruby-fish">chruby-fish</a>. Sans ce projet j’aurais
certainement cesser là mon utilisation de Fish. Donc un grand merci à son
créateur.</p>

<p>Ça fait très bien le boulot, avec un petit bug tout de même:</p>

<p><code>
$ chruby 2.3.1
mkdir: cannot create directory ‘/opt/rubies/ruby-2.3.1/lib/ruby/gems/2.3.0/bin’: Permission denied
</code></p>

<p>Pour chaque version de Ruby, il faudra donc créer ce dossier à la main:</p>

<pre><code>sudo mkdir /opt/rubies/ruby-2.3.1/lib/ruby/gems/2.3.0/bin
</code></pre>

<h2 id="prompt-thmes">Prompt, thèmes</h2>

<p>Je ne vais pas m’étendre sur le sujet, y a tout ce qu’il faut pour
personnaliser son terminal à grands coups de variables et de fonctions.</p>

<h2 id="alias-et-fonctions">Alias et fonctions</h2>

<p>Un truc qui m’a fort surpris au tout début : Fish n’a pas d’alias, il faut
utiliser des fonctions à la place. À la fin du deuxième jour d’utilisation
c’était adopté et validé. Voici un classique pour l’exemple, je veux pouvoir
taper <code>la</code> à la place de <code>ls -A</code> :</p>

<p><code>
function la --description 'Like ls with hidden file'
    ls -A $argv
end
</code></p>

<p>Un excellent point à propos des fonctions dans Fish : elles sont chargées
<em>paresseusement</em>. C’est à dire qu’une fonction est chargée automatiquement la
première fois qu’on l’utilise.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Le truc avec Fish, c’est que <em>ça juste marche</em> ™. Avec Bash, il faut des
années de configuration pour obtenir quelque chose de valable. Avec Fish, ton
premier fichier de configuration est vide, inexistant, parce que pas besoin. Et
pourtant ça fonctionne, tout simplement.</p>

<p>Maintenant ça ne fait que deux jours que je suis dessus… C’est le début, tout
est beau. Je verrai à l’usage.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Utiliser Bash pour supprimer les encodages magiques de Ruby 1.9]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/08/06/utiliser-bash-pour-supprimer-les-encodages-magiques-de-ruby-1-dot-9/"/>
    <updated>2015-08-06T17:27:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/08/06/utiliser-bash-pour-supprimer-les-encodages-magiques-de-ruby-1-dot-9</id>
    <content type="html"><![CDATA[<p>Si vous avez travaillé sur des projets écrit avec Ruby 1.9, vous avez peut-être
utilisé les encodages magiques (souvent appelés <em>magic comment</em>). Il s’agit
d’un commentaire en début de fichier qui définit l’encodage :</p>

<p><code>ruby
# -*- encoding: UTF-8 -*-
</code></p>

<p>Récemment j’ai passé plusieurs projets de Ruby 1.9.x à Ruby 2.x et j’ai
naturellement voulu supprimer ces <em>directives d’encodage</em> qui ne sont plus
nécessaires.</p>

<p>J’imagine qu’un IDE ou un autre doit être capable de faire ça (<code>&lt;mode troll&gt;</code>
sinon quel intérêt à utiliser un IDE ? <code>&lt;/mode troll&gt;</code>). Toujours est-il que
quelques commandes dans Bash et hop, terminé ;)</p>

<p>Voici comment faire, sans trop entrer dans les détails. J’espère juste vous
donner envie d’utiliser Bash, ou un autre shell (si ça n’est pas déjà le cas).</p>

<!-- more -->

<p>De quoi a-t-on besoin ?  <code>find</code>, <code>sed</code> et <code>xargs</code> :</p>

<p><code>bash
$ find . -type f -name '*.rb' | xargs sed -i '1{/encoding/d}'
$ find . -type f -name '*.rb' | xargs sed -i -n '/./,$p'
</code></p>

<p>La première commande efface la première ligne des fichiers ruby si cette
ligne contient <code>encoding</code>. La seconde commande enlève la première ligne si
cette ligne est vide.</p>

<h2 id="find">find</h2>

<pre><code>find . -type f -name '*.rb'
</code></pre>

<p>Cherche tout les fichiers dont le nom se termine par <code>.rb</code> et les affichent
les uns après les autres.  Ça donne quelque chose comme ça :</p>

<pre><code>./fichier1.rb
./fichier2.rb
./dossier1/fichier1.rb
./dossier1/fichier2.rb
./dossier2/fichier1.rb
[...]
</code></pre>

<h2 id="xargs">xargs</h2>

<p>Pour donner les noms de fichier à manger à sed, il faut qu’ils soient sur une
seule ligne. C’est à dire les uns à coté des autres comme on écrirait des
paramètres, et pas les uns en dessous des autres comme ce qui sort de <code>find</code>.</p>

<p>Voilà donc <code>xargs</code> :</p>

<p><code>bash
$ echo -e "a\nb\nc"
a
b
c
$ echo -e "a\nb\nc" | xargs
a b c
</code></p>

<p>– <em>Le switch <code>-e</code> de echo interprète la séquence \n comme un saut de ligne.</em> —</p>

<h2 id="sed">sed</h2>

<p>Le switch <code>-i</code> c’est pour <em>in place</em>. On modifie vraiment les fichiers.</p>

<pre><code>sed -i '1{/encoding/d}'
</code></pre>

<p>Supprime (<code>d</code>) la ligne qui contient <code>encoding</code>. Ne s’applique qu’à la 1ère
ligne <code>1{}</code>.</p>

<pre><code>sed -i -n '/./,$p'
</code></pre>

<p>Supprime la 1ère ligne si elle est vide. Je trouve que cette ligne mérite bien
un article à elle toute seule. Alors son explication sera pour une prochaine
fois ;)</p>

<p>Et vous, comment auriez vous fait ? Avec un shell ? Un IDE ?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Extraction des tags de mon blog en ligne de commande]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/07/11/extraction-des-tags-de-mon-blog-en-ligne-de-commande/"/>
    <updated>2015-07-11T17:08:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/07/11/extraction-des-tags-de-mon-blog-en-ligne-de-commande</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>J’aimerais savoir quels sont les tags que j’ai le plus employé sur ce blog.
Pour cela il va d’abord falloir les extraire, si possible dans un fichier csv.</p>

<p>Comment ? En Ruby ? En R ? Non non, en Bash, ça va être beaucoup plus drôle.</p>

<p>Petite étude de cas pour découvrir la puissance de la ligne de commande, ou
pour rafraichir ses connaissances ;)</p>

<p><img class="center" src="/images/tags-cloud.png"></p>

<!-- more -->

<p>Si vous voulez reproduire l’analyse en même temps que moi, les
<a href="https://github.com/lkdjiin/lkdjiin.github.io/tree/source/source/_posts">articles sont ici</a>.</p>

<p>Voyons à quoi ressemble le début d’un article au hasard avec <code>head</code>.
Octopress, le framework que j’utilise pour ce blog, appelle les tags des
<em>categories</em>. Mais c’est pareil.</p>

<p><code>bash
$ head 2013-10-20-les-algorithmes-genetiques-demystifies-35.markdown
---
layout: post
title: "Les algorithmes génétiques démystifiés 35"
date: 2013-10-20 21:21
comments: true
categories: [imagerie, algorithme génétique, intermédiaire, javascript]
#...
</code></p>

<p>L’entête d’un article a toujours la même structure. Avec <code>head *.markdown</code>
j’affiche le début de tous les articles, les uns à la suite des autres.
Avec <code>sed</code> je peux extraire uniquement les lignes qui commencent par <code>cat</code> :</p>

<p><code>bash
$ head *.markdown | sed -n '/^cat/p'
categories: [annonce, défi]
categories: [vim, conseil, débutant]
categories: [ruby, code propre, intermédiaire]
categories: [ruby, eigenclass, object, intermédiaire]
#...
</code></p>

<p>Gardons seulement les tableaux. <code>cut -f1</code> <em>découpe</em> le premier champ, <code>-d' '</code>
indique que le séparateur de champ est l’espace, et <code>--complement</code> indique
qu’on veut conserver le complément. Autrement dit tout sauf la première
colonne.</p>

<p><code>bash
$ head *.markdown | sed -n '/^cat/p' |
&gt; cut -f1 -d' ' --complement
[annonce, défi]
[vim, conseil, débutant]
[ruby, code propre, intermédiaire]
[ruby, eigenclass, object, intermédiaire]
#...
</code></p>

<p>Supprimons les crochets à l’aide de <code>sed</code> et d’une regex rigolote.</p>

<p><code>bash
$ head *.markdown | sed -n '/^cat/p' | cut -f1 -d' ' --complement |
&gt; sed 's/[][]//g'
annonce, défi
vim, conseil, débutant
ruby, code propre, intermédiaire
ruby, eigenclass, object, intermédiaire
#...
</code></p>

<p>Supprimons les espaces inutiles. Attention, certains tags contiennent des
espaces.</p>

<p><code>bash
$ head *.markdown | sed -n '/^cat/p' | cut -f1 -d' ' --complement |
&gt; sed 's/[][]//g' |
&gt; sed 's/, /,/g'
annonce,défi
vim,conseil,débutant
ruby,code propre,intermédiaire
ruby,eigenclass,object,intermédiaire
#...
</code></p>

<p>Grâce à <code>tr</code>, je remplace chaque virgule par un retour à la ligne. Ça
commence à prendre forme.</p>

<p><code>bash
$ head *.markdown | sed -n '/^cat/p' | cut -f1 -d' ' --complement |
&gt; sed 's/[][]//g' | sed 's/, /,/g' |
&gt; tr ',' '\n'
annonce
défi
vim
conseil
débutant
ruby
code propre
intermédiaire
ruby
eigenclass
#...
</code></p>

<p>Trions par ordre alphabétique.</p>

<p>``` bash
$ head *.markdown | sed -n ‘/^cat/p’ | cut -f1 -d’ ‘ –complement |
&gt; sed ‘s/[][]//g’ | sed ‘s/, /,/g’ | tr ‘,’ ‘\n’ |
&gt; sort</p>

<p>ack
activerecord
activerecord
ag
airline
airline
airline
airline
algorithme génétique
#…
```</p>

<p>Réduisons les occurrences et comptons les avec <code>uniq -c</code>.</p>

<p><code>bash
$ head *.markdown | sed -n '/^cat/p' | cut -f1 -d' ' --complement |
&gt; sed 's/[][]//g' | sed 's/, /,/g' | tr ',' '\n' | sort |
&gt; uniq -c
      1 
      1 ack
      2 activerecord
      1 ag
      4 airline
     70 algorithme génétique
      1 alias
     16 annonce
      3 app
      1 application
#...
</code></p>

<p>Trions à nouveau, cette fois sur le nombre et du plus grand au plus petit.</p>

<p><code>bash
$ head *.markdown | sed -n '/^cat/p' | cut -f1 -d' ' --complement |
&gt; sed 's/[][]//g' | sed 's/, /,/g' | tr ',' '\n' | sort | uniq -c |
&gt; sort -nr
    213 ruby
    176 intermédiaire
    171 débutant
     70 algorithme génétique
     55 vim
     26 tutoriel
     26 julia
     26 javascript
#...
      1 application
      1 alias
      1 ag
      1 ack
      1 
</code></p>

<p>Vous avez remarquez ? Un tag est vide. Ça pourrait poser problème pour la
suite. Avec <code>sed</code> on peut facilement supprimer la dernière ligne.</p>

<p><code>bash
$ head *.markdown | sed -n '/^cat/p' | cut -f1 -d' ' --complement |
&gt; sed 's/[][]//g' | sed 's/, /,/g' | tr ',' '\n' | sort | uniq -c |
&gt; sort -nr | sed '$d'
    213 ruby
    176 intermédiaire
    171 débutant
#...
      1 alias
      1 ag
      1 ack
</code></p>

<p>À la réflexion je préfère faire comme si il y avait plusieurs lignes vides et
les supprimer toutes. Ça pourrait être plus réutilisable.</p>

<p><code>bash
$ head *.markdown | sed -n '/^cat/p' | cut -f1 -d' ' --complement |
&gt; sed 's/[][]//g' | sed 's/, /,/g' | tr ',' '\n' |
&gt; sed '/^$/d' |
&gt; sort | uniq -c | sort -nr
</code></p>

<p>Il est temps de sortir une regex un peu plus complexe pour inverser les deux
champs et ajouter une virgule entre eux.</p>

<p><code>bash
$ head *.markdown | sed -n '/^cat/p' | cut -f1 -d' ' --complement |
&gt; sed 's/[][]//g' | sed 's/, /,/g' | tr ',' '\n' | sed '/^$/d' |
&gt; sort | uniq -c | sort -nr |
&gt; sed -r 's/\s+([0-9]+) (.*)/\2,\1/'
ruby,213
intermédiaire,176
débutant,171
algorithme génétique,70
#...
</code></p>

<p>C’est quasiment terminé. Il reste à ajouter l’entête du fichier csv. Pour cela
je vais utiliser une commande non standard mais bien pratique, <code>header</code>.</p>

<p><code>bash
$ head *.markdown | sed -n '/^cat/p' | cut -f1 -d' ' --complement |
&gt;  sed 's/[][]//g' | sed 's/, /,/g' | tr ',' '\n' | sed '/^$/d' |
&gt; sort | uniq -c | sort -nr | sed -r 's/\s+([0-9]+) (.*)/\2,\1/' |
&gt; header -a tag,frequency
tag,frequency
ruby,213
intermédiaire,176
débutant,171
algorithme génétique,70
#...
</code></p>

<p>On a terminé. C’est un beau pipeline, non ? Enregistrons le résultat dans un
fichier.</p>

<p><code>bash
$ head *.markdown | sed -n '/^cat/p' | cut -f1 -d' ' --complement |
&gt;  sed 's/[][]//g' | sed 's/, /,/g' | tr ',' '\n' | sed '/^$/d' |
&gt; sort | uniq -c | sort -nr | sed -r 's/\s+([0-9]+) (.*)/\2,\1/' |
&gt; header -a tag,frequency &gt; tags.csv
</code></p>

<p>En bonus, voici le code R qui produit l’image qui illustre cet article.</p>

<p>``` r
library(wordcloud)</p>

<p>d &lt;- read.csv(‘tags.csv’)</p>

<p>colors &lt;- brewer.pal(12, ‘Paired’)
colors &lt;- colors[seq(2, 10, by=2)]</p>

<p>wordcloud(d$tag, d$frequency, colors=colors, min.freq=1, scale=c(5, .6),
          rot.per=.25, random.order=FALSE, random.color=TRUE)
```</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Créer plusieurs fichiers en Bash]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/05/15/creer-plusieurs-fichiers-en-bash/"/>
    <updated>2015-05-15T13:46:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/05/15/creer-plusieurs-fichiers-en-bash</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p><em>Faire deux fois la même chose, c’est une coincidence ; faire
trois fois la même chose, c’est déjà deux de trop.</em></p>

<p>Mettons que j’ai besoin de créer 20 fichiers quelconques (ici en Ruby) nommés ainsi :</p>

<ul>
  <li><code>asm01.rb</code></li>
  <li><code>asm02.rb</code></li>
  <li><code>asm03.rb</code></li>
  <li>etcétéra jusqu’à <code>asm20.rb</code></li>
</ul>

<!-- more -->

<p>Je peux les créer les uns après les autres de cette manière :</p>

<p><code>bash
$ touch lib/c8dasm/assemblies/asm01.rb
$ touch lib/c8dasm/assemblies/asm02.rb
$ touch lib/c8dasm/assemblies/asm03.rb
$ # même chose jusqu'à :
$ touch lib/c8dasm/assemblies/asm20.rb
</code></p>

<p>Imaginez si vous deviez en faire 200 comme cela ! Et même s’il n’y en avait que
10, c’est juste ennuyeux au possible. En tant que développeurs, <strong>nous devrions
apprendre à automatiser ces tâches pour notre confort</strong>.</p>

<p>On peut utiliser une boucle pour résoudre ce problème :</p>

<p><code>bash
$ for i in {01..20}; do
… &gt; touch lib/c8dasm/assemblies/asm$i.rb
… &gt; done
</code></p>

<p>Ou bien la version sur une seule ligne :</p>

<p><code>bash
$ for i in {01..20}; do touch lib/c8dasm/assemblies/asm$i.rb; done
</code></p>

<p>À bientôt.</p>

<p></p>

]]></content>
  </entry>
  
</feed>
