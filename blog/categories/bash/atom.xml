<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : bash | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/bash/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2014-01-23T20:53:02+01:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[L'auto-complétion en Bash - partie 5]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/01/15/lauto-completion-en-bash-partie-5/"/>
    <updated>2014-01-15T20:44:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/01/15/lauto-completion-en-bash-partie-5</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Cet article est la suite de:
<a href="http://lkdjiin.github.io/blog/2014/01/14/lauto-completion-programmable-en-bash-partie-4/">L'auto complétion programmable en bash: partie 4</a>.</p>

<h2>Les bases de l'auto complétion programmable</h2>

<p>Une application peut proposer ses services d'auto complétion en déposant
un fichier bash dans le dossier <code>/etc/bash_completion.d/</code>.
On y voit un tas de fichiers, pour des programmes bien connus:</p>

<pre><code>[~]⇒ ls /etc/bash_completion.d/
abook
ant
apache2.2-common
apache2ctl
apt
...
git
...
</code></pre>

<p>Il suffit juste de savoir quoi mettre dedans. Allons-y:</p>

<!-- more -->


<p><code>bash /etc/bash_completion.d/mytool
complete -W "new compile test" mytool
</code></p>

<p>Le fichier sera chargé automatiquement au lancement de bash. Donc pour que
ça fonctionne maintenant, soit vous le sourcez, soit vous lancez une
nouvelle console et, &ndash; <em>roulements de tambours</em>&ndash;</p>

<pre><code>[~]⇒ mytool [TAB]
compile  new      test     
[~]⇒ mytool 
</code></pre>

<p>Magique, non ? Il faut noter que l'auto complétion fonctionnera aussi
avec des options:</p>

<p><code>bash /etc/bash_completion.d/mytool
complete -W "new compile test --verbose" mytool
</code></p>

<pre><code>[~]⇒ mytool c[TAB] -[TAB]
mytool compile --verbose
</code></pre>

<p>Donc, comment ça marche ? Voici la traduction de l'aide de <code>complete</code>,
simplifiée au maximum:</p>

<p><strong>complete</strong> [<em>options</em>] <em>name</em>   <br/>
Spécifie comment les arguments doivent être complétés, pour chaque <em>name</em>.</p>

<p>L'option <code>-W</code> permet de lui passer une liste de mots. Finalement c'était
facile ? Humm… En fait ce sera rarement aussi simple. Pour continuer notre
jeu de rôle, disons que l'option <code>--verbose</code> peut s'appliquer uniquement
à l'argument <code>new</code>, et pas aux deux autres. Du coup, notre commande
<code>complete</code> ne suffit plus. Il va falloir trouver autre chose et c'est ce
qu'on verra dans un prochain article.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[L'auto-complétion programmable en bash - partie 4]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/01/14/lauto-completion-programmable-en-bash-partie-4/"/>
    <updated>2014-01-14T20:54:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/01/14/lauto-completion-programmable-en-bash-partie-4</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Cet article est la suite de:
<a href="http://lkdjiin.github.io/blog/2014/01/13/lauto-completion-programmable-en-bash-partie-3/">L'auto complétion programmable en bash: partie 3</a>.</p>

<h2>Un programme bidon pour tester</h2>

<p>On va faire un petit jeu de rôle : Vous avez écrit un nouveau langage
informatique revolutionnaire, et maintenant vous voulez lui adjoindre
un outil pour faciliter la gestion des projets. Ce fameux programme, qui
va s'appeller «mytool» aura 3 commandes: <code>new</code>, pour créer un projet,
<code>compile</code>, pour compiler le projet, et <code>test</code>, pour le tester. Et bien sûr,
vous voulez profiter des joies de l'auto complétion:</p>

<pre><code>mytool c[TAB]
</code></pre>

<p>devra devenir:</p>

<pre><code>mytool compile
</code></pre>

<!-- more -->


<p>Pour comprendre les prochains articles, on est pas obligé d'avoir un «vrai»
programme. Mais c'est quand même plus drôle pour faire tout un tas de tests.
Voici donc le magnifique programme <code>mytool</code>:</p>

<p>``` bash mytool</p>

<h1>!/usr/bin/env bash</h1>

<p>case $1 in
  new )</p>

<pre><code>echo Project created ;;
</code></pre>

<p>  test )</p>

<pre><code>echo Project tested ;;
</code></pre>

<p>  compile )</p>

<pre><code>echo Project compiled ;;
</code></pre>

<ul>
<li>)
echo error ;;
esac
```</li>
</ul>


<p>Assurez vous que le programme ait les droits d'exécution (<code>chmod +x</code>)
et qu'il soit dans votre PATH:</p>

<pre><code>[~]⇒ mytool new
Project created
[~]⇒ mytool test
Project tested
[~]⇒ mytool compile
Project compiled
[~]⇒ mytool
error
</code></pre>

<p>La prochaine, promis, on commencera vraiment à faire de l'auto-complétion.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[L'auto-complétion programmable en Bash - partie 3]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/01/13/lauto-completion-programmable-en-bash-partie-3/"/>
    <updated>2014-01-13T20:50:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/01/13/lauto-completion-programmable-en-bash-partie-3</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Cet article est la suite de:
<a href="http://lkdjiin.github.io/blog/2014/01/11/lauto-completion-en-bash-partie-2/">L'auto complétion programmable en bash: partie 2</a>.</p>

<p>Je joue donc quelques minutes avec la commande <code>compgen</code>, juste pour voir
de quoi il s'agit. L'option <code>-W</code> retient particulièrement mon attention.
On lui passe une liste de mots entre guillemets et ça nous les renvoient:</p>

<pre><code>[~]⇒ compgen -W "foo bar baz"
foo
bar
baz
</code></pre>

<!-- more -->


<p>Ok, on va pas se mentir, vous ne voyez pas tellement l'intérêt, hein ?
Et si on passait un second argument à <code>compgen</code>, comme le début d'un
mot:</p>

<pre><code>[~]⇒ compgen -W "foo bar baz" f
foo
</code></pre>

<p>Ou bien encore:</p>

<pre><code>[~]⇒ compgen -W "foo bar baz" ba
bar
baz
</code></pre>

<p>Voilà qui est intéressant. Et si on lui donne un début de mot inexistant:</p>

<pre><code>[~]⇒ compgen -W "foo bar baz" o
[~]⇒ 
</code></pre>

<p>Les sections <strong>complete</strong> et surtout <strong>programmable completion</strong> de la page
de man sont particulièrement indigestes. Je me doute que je devrais les lire
si je veux aller plus loin, mais ça attendra encore.
Donc je google «bash programmable completion» et je trouve ce qu'il me faut pour
commencer. La suite la prochaine fois.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[L'auto-complétion programmable en Bash - partie 2]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/01/11/lauto-completion-en-bash-partie-2/"/>
    <updated>2014-01-11T20:33:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/01/11/lauto-completion-en-bash-partie-2</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Cet article est la suite de:
<a href="http://lkdjiin.github.io/blog/2014/01/10/lauto-completion-programmable-en-bash-partie-1/">L'auto complétion programmable en bash: partie 1</a>.</p>

<h2>Une première piste</h2>

<p>En parcourant rapidement la page de man de bash, je tombe sur une commande
pleine de promesse: la commande <code>compgen</code>.</p>

<!-- more -->


<p>Voici un extrait de la documentation:</p>

<p><strong>compgen</strong> [<em>option</em>] [<em>word</em>] <br/>
Generate possible completion matches for word according to the options, which
may be any option accepted by the <strong>complete</strong> builtin with the exception of -p
and -r, and write the matches to the standard output. When using the -F or -C
options, the various shell variables set by the <strong>programmable completion</strong>
<em>[&hellip;]</em></p>

<p>J'ai donc une commande <code>compgen</code>, qui semble fournir les différentes
possibilités de complétions pour un mot. J'ai aussi une commande <code>complete</code>,
dont le nom sonne vraiment bien. Et on me confirme que bash peut faire de
la <code>programmable completion</code>, même si je sais pas encore trop de quoi on
parle ici… Je vais devoir fouiller un peu les options de <code>complete</code> pour
apprendre comment fonctionne <code>compgen</code>. Ah, les joies du man Unix !</p>

<p>Mon voyage dans le monde de l'auto-complétion débute avec une page de man.
Y a plus sexy, mais bon, il faut bien commencer quelque part ;)</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[L'auto complétion programmable en bash: partie 1]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/01/10/lauto-completion-programmable-en-bash-partie-1/"/>
    <updated>2014-01-10T21:41:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/01/10/lauto-completion-programmable-en-bash-partie-1</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<h2>Ou comment git, apt-get et les autres l'utilisent</h2>

<p>L'auto-complétion de la ligne de commande sur unix, c'est à priori
très simple. Si je tape dans un terminal <code>ec</code> suivi de la touche tabulation:</p>

<pre><code>[~]⇒ ec[TAB]
</code></pre>

<p>C'est à dire les deux lettres &ldquo;ec&rdquo; suivies de la touche tabulation, la
commande est étendue en :</p>

<pre><code>echo 
</code></pre>

<p>Si il y a plusieurs choix possibles, Bash me les fournis:</p>

<pre><code>[~]⇒ apti
aptitude                      aptitude-curses
aptitude-create-state-bundle  aptitude-run-state-bundle
</code></pre>

<!-- more -->


<p>Ça devient plus intéressant quand ça fonctionne aussi avec les <em>arguments</em> des
commandes, qu'à priori, le shell ne connait pas. Par exemple :</p>

<pre><code>[~]⇒ apt-get upg[TAB]
</code></pre>

<p>devient :</p>

<pre><code>apt-get upgrade
</code></pre>

<p>Ou encore :</p>

<pre><code>[~]⇒ git fi[TAB]
</code></pre>

<p>qui devient :</p>

<pre><code>git filter-branch
</code></pre>

<p>Et ça devient carrément magique &ndash; <em>en tout cas pour moi</em> &ndash; quand la commande
git réussit l'auto-complétion d'une commande que j'ai ajouté moi-même.  Je
m'explique. J'ai par exemple, dans mon PATH, le fichier bash <code>git-pom</code> suivant:</p>

<p>``` bash git-pom</p>

<h1>!/bin/bash</h1>

<p>git push origin master
```</p>

<p>Si je tape :</p>

<pre><code>[~]⇒ git p[TAB]
</code></pre>

<p>ça devient :</p>

<pre><code>pom           pull          push          push-branch   
[~]⇒  git p
</code></pre>

<p>Git, ou bash, ou je ne sais quoi a trouvé la commande <code>pom</code> ! Moi ça m'épate
à chaque fois. Notez au passage que le fichier qui contient la nouvelle commande
s'appelle <code>git-pom</code> et qu'on peut taper <code>git pom</code>. Alors, comment ça
marche ?</p>

<p>Et bien je dois avouer que je n'en sais rien ! J'ai bien une petite idée
des mécanismes en jeu, mais aucunes connaissances sur le sujet. On va
donc découvrir cela ensemble au fil des articles suivants.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
