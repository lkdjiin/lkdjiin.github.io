<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : bash | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/bash/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2014-02-20T21:09:01+01:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Astuce Bash - Améliorer l'historique]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/02/20/astuce-bash-ameliorer-lhistorique/"/>
    <updated>2014-02-20T21:02:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/02/20/astuce-bash-ameliorer-lhistorique</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Dans Bash, chaque appui sur la touche «flêche vers le haut» fait défiler
l'historique des commandes. Si la commande recherchée se situe à quelques
dizaines d'appuis, ça n'est pas très pratique. Voici une astuce pour
aller plus vite.</p>

<!-- more -->


<p>Ajoutez les lignes suivantes dans votre fichier <code>~/.inputrc</code>. Si ce dernier
n'existe pas, créez le.</p>

<p><code>bash ~/.input
"\e[A": history-search-backward
"\e[B": history-search-forward
set show-all-if-ambiguous on
set completion-ignore-case on
</code></p>

<p>Maintenant il suffit de saisir les premières lettres de la commande
recherchée et la flêche vers le haut ne fera défilée que les commandes
de votre historique qui commencent par ces caractères.</p>

<p>Quand j'aurais plus de temps, j'aimerais revenir sur ces lignes pour
fournir une explication, en attendant je vous souhaite une bonne
utilisation de votre historique boosté ;)</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Astuce pour Git - merge et checkout en une commande]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/02/19/astuce-pour-git-merge-et-checkout-en-une-commande/"/>
    <updated>2014-02-19T20:49:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/02/19/astuce-pour-git-merge-et-checkout-en-une-commande</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Aujourd'hui, je vous présente un petit script pour Git. Il vous permettra,
en une commande, de merger la branche courante dans <code>master</code> et de vous
retrouver sur <code>master</code>.</p>

<!-- more -->


<p>Ce script, <code>merge-me</code>, est a placer quelquepart dans votre <code>$PATH</code>.
N'oubliez pas de lui fournir les droits d'exécution (<code>chmod +x</code>).</p>

<p>``` bash merge-me</p>

<h1>!/bin/bash</h1>

<p>BRANCH_TO_MERGE=<code>git rev-parse --abbrev-ref HEAD</code>
git checkout master
git merge $BRANCH_TO_MERGE
```</p>

<p>Une fois installé, en partant d'une branche <code>ma-branche</code>, vous tapez:</p>

<pre><code>git merge-me
</code></pre>

<p>et la branche <code>ma-branche</code> sera mergée dans la branche <code>master</code>.</p>

<p>N'hésitez pas à vous en servir comme d'un point de départ et à le modifier,
à lui ajouter des fonctionnalités.</p>

<p>Tiens, d'ailleurs ! Vous y ajouteriez quoi ?</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Afficher l'arborescence d'un dossier dans le terminal]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/02/17/afficher-larborescence-dun-dossier-dans-le-terminal/"/>
    <updated>2014-02-17T20:56:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/02/17/afficher-larborescence-dun-dossier-dans-le-terminal</id>
    <content type="html"><![CDATA[<p>Pour comprendre l'arborescence des dossiers d'un projet, rien de mieux
que de l'afficher. On peut le faire dans l'explorateur graphique fournit
par l'OS, ou bien dans son éditeur/EDI, ou encore dans le terminal.</p>

<!-- more -->


<p>Je travaille depuis janvier sur OS X et je n'arrive pas à me faire à son
explorateur. Dans Vim, je n'ai pas de plugin pour faire ça, et je n'en veux
pas. Il ne me restait plus qu'à renouer avec une vieille copine, la commande
<code>tree</code>.</p>

<h2>Installation</h2>

<p><code>tree</code> n'est pas installée par défaut, il faut donc passer par le gestionnaire
de paquet.</p>

<pre><code>apt-get install tree # Debian, Ubuntu, etc

brew install tree # OS X
</code></pre>

<h2>Utilisation</h2>

<p>Afficher l'arborescence du dossier courant:</p>

<pre><code>tree
</code></pre>

<p>Afficher l'arborescence d'un sous-dossier:</p>

<pre><code>tree sous/dossier
</code></pre>

<h2>Options utiles</h2>

<p>Du moins celles que j'utilise couramment.</p>

<p>Pour avoir la couleur:</p>

<pre><code>tree -C
</code></pre>

<p>Pour un affichage graphique plus sympa:</p>

<pre><code>tree -A
</code></pre>

<p>Pour inclure les fichiers et dossiers cachés:</p>

<pre><code>tree -a
</code></pre>

<p>Pour n'afficher que les dossiers:</p>

<pre><code>tree -d
</code></pre>

<p>Pour limiter la profondeur:</p>

<pre><code>tree -L 2 # N'affiche que les sous-dossiers directs
</code></pre>

<h2>Alias</h2>

<p>Pour finir, voici les alias que j'utilise:</p>

<p><code>bash
alias tree='tree -CA'
alias dirtree='tree -d'
</code></p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Quelques commandes Git par Michael Hartl]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/02/12/quelques-commandes-git-par-michael-hartl/"/>
    <updated>2014-02-12T20:29:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/02/12/quelques-commandes-git-par-michael-hartl</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Michael Hartl, l'auteur de <a href="http://ruby.railstutorial.org/">Ruby on Rails Tutorial</a>
a écrit plusieurs commandes Git bien utiles.</p>

<!-- more -->


<p>Le code se trouve sur Github : <a href="https://github.com/mhartl/git-utils">git-utils</a>.
On y trouve par exemple une commande <code>git cleanup</code>, qui supprime toutes
les branches locales qui ne sont pas encore mergées dans la branche
courante. Ou encore <code>git merge-branch</code>, qui merge la branche courante
dans master par défaut.</p>

<p>Aujourd'hui, toutes ces commandes sont écrites en Ruby, mais avant
elle l'était en Bash, comme la suivante:</p>

<p>``` bash</p>

<h1>!/bin/bash git-merge-branch</h1>

<h1>Copyright &copy; 2013 Michael Hartl</h1>

<h1>Released under the MIT License (<a href="http://opensource.org/licenses/MIT">http://opensource.org/licenses/MIT</a>)</h1>

<h1>Merges the current branch into the given branch (defaults to master).</h1>

<h1>E.g., &lsquo;git merge-branch foobar&rsquo; merges the current branch into foobar.</h1>

<h1>&lsquo;git merge-branch&rsquo;, merges the current branch into master.</h1>

<h1>git merge-branch uses the &mdash;no-ff &mdash;log options to ensure that the</h1>

<h1>merge creates a new commit object and that the individual commits appear</h1>

<h1>in the log file.</h1>

<p>CURRENT_BRANCH=<code>git rev-parse --abbrev-ref HEAD</code>
if [ $# -eq 1 ]
then
  TARGET_BRANCH=$1
else
  TARGET_BRANCH=&ldquo;master&rdquo;
fi
git checkout $TARGET_BRANCH
git merge &mdash;no-ff &mdash;log $CURRENT_BRANCH
```</p>

<p>Essayez les, certaines pourraient bien vous changer la vie.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[L'auto-complétion programmable en Bash - partie 10]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/02/10/lauto-completion-programmable-en-bash-partie-10/"/>
    <updated>2014-02-10T20:45:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/02/10/lauto-completion-programmable-en-bash-partie-10</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-3'>Niveau : <span>avancé</span></div></p>

<p>Cet article est la suite de:
<a href="/blog/2014/02/09/lauto-completion-programmable-en-bash-partie-9/">L'auto complétion programmable en bash: partie 9</a>.</p>

<h2>Complétion des options longues</h2>

<p>Aujourd'hui j'ai envie de voir comment on pourrait utiliser
l'auto-complétion pour les options longues, du genre
<code>--format=documentation</code>.</p>

<!-- more -->


<p>L'option <code>--format=</code> peut prendre deux valeurs: <code>dot</code> ou <code>documentation</code>.
Je veux donc obtenir ceci:</p>

<pre><code>$ mytool test -[TAB]
$ mytool test --format=[TAB]
documentation  dot            
$ mytool test --format=do

$ mytool test --format=doc[TAB]
$ mytool test --format=documentation 
</code></pre>

<p>Voici une manière d'obtenir ça:</p>

<p>``` bash
_mytool_long_options()
{</p>

<pre><code>case $1 in
    --format)
        options='dot documentation'
        ;;
esac
COMPREPLY=( $( compgen -W "$options" -- "$2" ) )
</code></pre>

<p>}</p>

<p>_mytool()
{</p>

<pre><code>local cur prev command options
COMPREPLY=( )
_get_comp_words_by_ref cur prev
commands='new compile test'

if [[ $COMP_CWORD -eq 1 ]]; then
    COMPREPLY=( $( compgen -W "$commands" -- "$cur" ) )
elif [[ "$prev" == = ]]; then
    _mytool_long_options "${COMP_WORDS[COMP_CWORD-2]}" "$cur"
elif [[ "$cur" == = ]]; then
    _mytool_long_options "$prev"
elif [[ "$cur" == -* ]]; then
    command=${COMP_WORDS[1]}
    case $command in
        new)
            options='--without-test'
            ;;
        compile)
            options='--verbose'
            ;;
        test)
            options='--format='
            compopt -o nospace
            ;;
    esac
    COMPREPLY=( $( compgen -W "$options" -- "$cur" ) )
fi
</code></pre>

<p>}
complete -F _mytool mytool</p>

<h1>vim: ft=sh ts=4 sw=4</h1>

<p>```</p>

<p>La fonction <code>_mytool_long_options</code> prend un paramètre obligatoire et
un second optionnel. Le premier est le mot <em>avant</em> le signe <code>=</code> et le
second est l'éventuel mot <em>après</em> le signe <code>=</code>:</p>

<p>``` bash
_mytool_long_options()
{</p>

<pre><code>case $1 in
    --format)
        options='dot documentation'
        ;;
esac
COMPREPLY=( $( compgen -W "$options" -- "$2" ) )
</code></pre>

<p>}
```</p>

<p>J'ai ajouté deux <code>elif</code>, qui regarde si le mot sous le curseur (<code>$cur</code>)
ou le mot précédent (<code>$pre</code>) est le caractère <code>=</code>. Dans ce cas,
on appelle la fonction <code>_mytool_long_options</code> qui s'occupe de gérer
la complétion des options du style <code>--foo=bar</code>:</p>

<p>``` bash</p>

<pre><code>elif [[ "$prev" == = ]]; then
    _mytool_long_options "${COMP_WORDS[COMP_CWORD-2]}" "$cur"
elif [[ "$cur" == = ]]; then
    _mytool_long_options "$prev"
</code></pre>

<p>```</p>

<p>Même si cela fonctionne, je pense pouvoir trouver plus simple, et c'est
ce que j'espère faire dans un prochain article.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
