<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : bash | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/bash/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2014-04-20T13:11:42+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Comment réduire les erreurs de frappe dans la console]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/04/06/comment-reduire-les-erreurs-de-frappe-dans-la-console/"/>
    <updated>2014-04-06T20:52:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/04/06/comment-reduire-les-erreurs-de-frappe-dans-la-console</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Régulièrement j'analyse mon fichier <code>~/.bash_history</code>.
Régulièrement ça veut dire 2 ou 3 fois par an. Et je regarde ce qui revient
le plus pour voir si je peux en transformer certaines en alias.
Quel rapport avec les fautes de frappe ?</p>

<!-- more -->


<p>La dernière fois que je l'ai regardé, ce fameux fichier <code>~/.bash_history</code>,
j'ai trouvé un nombre non négligeable de lignes qui débutaient par <code>gti</code>.
Et oui, j'écris souvent <code>gti</code> au lieu de <code>git</code> ! On a tous des petits
défauts de ce type, non ?</p>

<p>J'imagine que nombre d'entre vous ont déjà ce genre de choses dans
leur fichier <code>~/.bashrc</code> (ou <code>~/.bash_profile</code>), mais pour ceux qui n'y
avait pas encore pensé, la solution consiste à faire un alias:</p>

<p><code>bash
alias gti='git'
</code></p>

<p>Alors d'accord, le titre de cet article ment un peu ;) Ça ne réduit pas
mes fautes de frappes, mais ça les rend transparentes, c'est déjà très bien.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Redis - Comment supprimer un ensemble de clés]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/03/21/redis-comment-supprimer-un-ensemble-de-cles/"/>
    <updated>2014-03-21T21:44:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/03/21/redis-comment-supprimer-un-ensemble-de-cles</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Tiens, mon premier article sur Redis ! Normal, c'est une technologie que
j'ai découvert il y a peu…</p>

<!-- more -->


<p>Pour supprimer une clé dans Redis, on se connecte et on utilise la commande
<code>del</code>:</p>

<pre><code>$ redis-cli
&gt; del "nom:de:la:clef"
</code></pre>

<p>Mais quand on a des dizaines/centaines de clés, bof… Bien souvent (toujours
même ça vaut mieux) le nom des clés suit un motif. Par exemple:</p>

<pre><code>"motif:foo"
"motif:bar"
"motif:baz"
etc...
</code></pre>

<p>Dans ce cas on peut utiliser Bash pour s'en sortir rapidement:</p>

<p><code>bash
redis-cli keys "*motif*" | xargs redis-cli del
</code></p>

<p>Et voilà, au revoir toutes les clés.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[L'auto-complétion programmable en Bash - partie 11]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/02/21/lauto-completion-programmable-en-bash-partie-11/"/>
    <updated>2014-02-21T20:53:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/02/21/lauto-completion-programmable-en-bash-partie-11</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-3'>Niveau : <span>avancé</span></div></p>

<p>Cet article est la suite de:
<a href="/blog/2014/02/10/lauto-completion-programmable-en-bash-partie-10/">L'auto complétion programmable en bash: partie 10</a>.</p>

<h2>Complétion des options longues &ndash; suite</h2>

<p>Aujourd'hui on voit que <code>_get_comp_words_by_ref</code> peut être appellée
avec une option bien utile qui modifie <code>COMP_WORDBREAKS</code>.</p>

<!-- more -->


<p>La variable <code>COMP_WORDBREAKS</code> contient les caractères qui permettent
de splitter les mots pour la complétion. Voici son contenu:</p>

<pre><code>$  echo $COMP_WORDBREAKS 
"'&gt;&lt;=;|&amp;(:
</code></pre>

<p>On voit que <code>=</code> en fait partie, et c'est ce qui rendait un peu compliqué
le <a href="/blog/2014/02/10/lauto-completion-programmable-en-bash-partie-10/">code de la dernière fois</a>.
Grâce à l'option <code>-n</code> de la fonction <code>_get_comp_words_by_ref</code>, on va pouvoir
simplifier ça:</p>

<p>``` bash
_mytool_long_options()
{</p>

<pre><code>case $1 in
    --format)
        options='dot documentation'
        ;;
esac
COMPREPLY=( $( compgen -W "$options" -- "$2" ) )
</code></pre>

<p>}</p>

<p>_mytool()
{</p>

<pre><code>local cur prev command options
COMPREPLY=( )
_get_comp_words_by_ref -n = cur prev
commands='new compile test'

if [[ $COMP_CWORD -eq 1 ]]; then
    COMPREPLY=( $( compgen -W "$commands" -- "$cur" ) )
elif [[ "$cur" == --*=* ]]; then
    _split_longopt
    _mytool_long_options "$prev" "$cur" 
elif [[ "$cur" == -* ]]; then
    command=${COMP_WORDS[1]}
    case $command in
        new)
            options='--without-test'
            ;;
        compile)
            options='--verbose'
            ;;
        test)
            options='--format='
            compopt -o nospace
            ;;
    esac
    COMPREPLY=( $( compgen -W "$options" -- "$cur" ) )
fi
</code></pre>

<p>}
complete -F _mytool mytool
```</p>

<p>Ce code fait la même chose que celui du <a href="/blog/2014/02/10/lauto-completion-programmable-en-bash-partie-10/">dernier article</a>,
mais est bien plus simple et lisible.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Astuce Bash - Améliorer l'historique]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/02/20/astuce-bash-ameliorer-lhistorique/"/>
    <updated>2014-02-20T21:02:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/02/20/astuce-bash-ameliorer-lhistorique</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Dans Bash, chaque appui sur la touche «flêche vers le haut» fait défiler
l'historique des commandes. Si la commande recherchée se situe à quelques
dizaines d'appuis, ça n'est pas très pratique. Voici une astuce pour
aller plus vite.</p>

<!-- more -->


<p>Ajoutez les lignes suivantes dans votre fichier <code>~/.inputrc</code>. Si ce dernier
n'existe pas, créez le.</p>

<p><code>bash ~/.input
"\e[A": history-search-backward
"\e[B": history-search-forward
set show-all-if-ambiguous on
set completion-ignore-case on
</code></p>

<p>Maintenant il suffit de saisir les premières lettres de la commande
recherchée et la flêche vers le haut ne fera défilée que les commandes
de votre historique qui commencent par ces caractères.</p>

<p>Quand j'aurais plus de temps, j'aimerais revenir sur ces lignes pour
fournir une explication, en attendant je vous souhaite une bonne
utilisation de votre historique boosté ;)</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Astuce pour Git - merge et checkout en une commande]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/02/19/astuce-pour-git-merge-et-checkout-en-une-commande/"/>
    <updated>2014-02-19T20:49:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/02/19/astuce-pour-git-merge-et-checkout-en-une-commande</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Aujourd'hui, je vous présente un petit script pour Git. Il vous permettra,
en une commande, de merger la branche courante dans <code>master</code> et de vous
retrouver sur <code>master</code>.</p>

<!-- more -->


<p>Ce script, <code>merge-me</code>, est a placer quelquepart dans votre <code>$PATH</code>.
N'oubliez pas de lui fournir les droits d'exécution (<code>chmod +x</code>).</p>

<p>``` bash merge-me</p>

<h1>!/bin/bash</h1>

<p>BRANCH_TO_MERGE=<code>git rev-parse --abbrev-ref HEAD</code>
git checkout master
git merge $BRANCH_TO_MERGE
```</p>

<p>Une fois installé, en partant d'une branche <code>ma-branche</code>, vous tapez:</p>

<pre><code>git merge-me
</code></pre>

<p>et la branche <code>ma-branche</code> sera mergée dans la branche <code>master</code>.</p>

<p>N'hésitez pas à vous en servir comme d'un point de départ et à le modifier,
à lui ajouter des fonctionnalités.</p>

<p>Tiens, d'ailleurs ! Vous y ajouteriez quoi ?</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
