<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : bash | Xavier Nayrac]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/bash/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2016-01-18T09:34:57+01:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Utiliser Bash pour supprimer les encodages magiques de Ruby 1.9]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/08/06/utiliser-bash-pour-supprimer-les-encodages-magiques-de-ruby-1-dot-9/"/>
    <updated>2015-08-06T17:27:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/08/06/utiliser-bash-pour-supprimer-les-encodages-magiques-de-ruby-1-dot-9</id>
    <content type="html"><![CDATA[<p>Si vous avez travaillé sur des projets écrit avec Ruby 1.9, vous avez peut-être
utilisé les encodages magiques (souvent appelés <em>magic comment</em>). Il s’agit
d’un commentaire en début de fichier qui définit l’encodage :</p>

<p><code>ruby
# -*- encoding: UTF-8 -*-
</code></p>

<p>Récemment j’ai passé plusieurs projets de Ruby 1.9.x à Ruby 2.x et j’ai
naturellement voulu supprimer ces <em>directives d’encodage</em> qui ne sont plus
nécessaires.</p>

<p>J’imagine qu’un IDE ou un autre doit être capable de faire ça (<code>&lt;mode troll&gt;</code>
sinon quel intérêt à utiliser un IDE ? <code>&lt;/mode troll&gt;</code>). Toujours est-il que
quelques commandes dans Bash et hop, terminé ;)</p>

<p>Voici comment faire, sans trop entrer dans les détails. J’espère juste vous
donner envie d’utiliser Bash, ou un autre shell (si ça n’est pas déjà le cas).</p>

<!-- more -->

<p>De quoi a-t-on besoin ?  <code>find</code>, <code>sed</code> et <code>xargs</code> :</p>

<p><code>bash
$ find . -type f -name '*.rb' | xargs sed -i '1{/encoding/d}'
$ find . -type f -name '*.rb' | xargs sed -i -n '/./,$p'
</code></p>

<p>La première commande efface la première ligne des fichiers ruby si cette
ligne contient <code>encoding</code>. La seconde commande enlève la première ligne si
cette ligne est vide.</p>

<h2 id="find">find</h2>

<pre><code>find . -type f -name '*.rb'
</code></pre>

<p>Cherche tout les fichiers dont le nom se termine par <code>.rb</code> et les affichent
les uns après les autres.  Ça donne quelque chose comme ça :</p>

<pre><code>./fichier1.rb
./fichier2.rb
./dossier1/fichier1.rb
./dossier1/fichier2.rb
./dossier2/fichier1.rb
[...]
</code></pre>

<h2 id="xargs">xargs</h2>

<p>Pour donner les noms de fichier à manger à sed, il faut qu’ils soient sur une
seule ligne. C’est à dire les uns à coté des autres comme on écrirait des
paramètres, et pas les uns en dessous des autres comme ce qui sort de <code>find</code>.</p>

<p>Voilà donc <code>xargs</code> :</p>

<p><code>bash
$ echo -e "a\nb\nc"
a
b
c
$ echo -e "a\nb\nc" | xargs
a b c
</code></p>

<p>– <em>Le switch <code>-e</code> de echo interprète la séquence \n comme un saut de ligne.</em> —</p>

<h2 id="sed">sed</h2>

<p>Le switch <code>-i</code> c’est pour <em>in place</em>. On modifie vraiment les fichiers.</p>

<pre><code>sed -i '1{/encoding/d}'
</code></pre>

<p>Supprime (<code>d</code>) la ligne qui contient <code>encoding</code>. Ne s’applique qu’à la 1ère
ligne <code>1{}</code>.</p>

<pre><code>sed -i -n '/./,$p'
</code></pre>

<p>Supprime la 1ère ligne si elle est vide. Je trouve que cette ligne mérite bien
un article à elle toute seule. Alors son explication sera pour une prochaine
fois ;)</p>

<p>Et vous, comment auriez vous fait ? Avec un shell ? Un IDE ?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Extraction des tags de mon blog en ligne de commande]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/07/11/extraction-des-tags-de-mon-blog-en-ligne-de-commande/"/>
    <updated>2015-07-11T17:08:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/07/11/extraction-des-tags-de-mon-blog-en-ligne-de-commande</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>J’aimerais savoir quels sont les tags que j’ai le plus employé sur ce blog.
Pour cela il va d’abord falloir les extraire, si possible dans un fichier csv.</p>

<p>Comment ? En Ruby ? En R ? Non non, en Bash, ça va être beaucoup plus drôle.</p>

<p>Petite étude de cas pour découvrir la puissance de la ligne de commande, ou
pour rafraichir ses connaissances ;)</p>

<p><img class="center" src="/images/tags-cloud.png"></p>

<!-- more -->

<p>Si vous voulez reproduire l’analyse en même temps que moi, les
<a href="https://github.com/lkdjiin/lkdjiin.github.io/tree/source/source/_posts">articles sont ici</a>.</p>

<p>Voyons à quoi ressemble le début d’un article au hasard avec <code>head</code>.
Octopress, le framework que j’utilise pour ce blog, appelle les tags des
<em>categories</em>. Mais c’est pareil.</p>

<p><code>bash
$ head 2013-10-20-les-algorithmes-genetiques-demystifies-35.markdown
---
layout: post
title: "Les algorithmes génétiques démystifiés 35"
date: 2013-10-20 21:21
comments: true
categories: [imagerie, algorithme génétique, intermédiaire, javascript]
#...
</code></p>

<p>L’entête d’un article a toujours la même structure. Avec <code>head *.markdown</code>
j’affiche le début de tous les articles, les uns à la suite des autres.
Avec <code>sed</code> je peux extraire uniquement les lignes qui commencent par <code>cat</code> :</p>

<p><code>bash
$ head *.markdown | sed -n '/^cat/p'
categories: [annonce, défi]
categories: [vim, conseil, débutant]
categories: [ruby, code propre, intermédiaire]
categories: [ruby, eigenclass, object, intermédiaire]
#...
</code></p>

<p>Gardons seulement les tableaux. <code>cut -f1</code> <em>découpe</em> le premier champ, <code>-d' '</code>
indique que le séparateur de champ est l’espace, et <code>--complement</code> indique
qu’on veut conserver le complément. Autrement dit tout sauf la première
colonne.</p>

<p><code>bash
$ head *.markdown | sed -n '/^cat/p' |
&gt; cut -f1 -d' ' --complement
[annonce, défi]
[vim, conseil, débutant]
[ruby, code propre, intermédiaire]
[ruby, eigenclass, object, intermédiaire]
#...
</code></p>

<p>Supprimons les crochets à l’aide de <code>sed</code> et d’une regex rigolote.</p>

<p><code>bash
$ head *.markdown | sed -n '/^cat/p' | cut -f1 -d' ' --complement |
&gt; sed 's/[][]//g'
annonce, défi
vim, conseil, débutant
ruby, code propre, intermédiaire
ruby, eigenclass, object, intermédiaire
#...
</code></p>

<p>Supprimons les espaces inutiles. Attention, certains tags contiennent des
espaces.</p>

<p><code>bash
$ head *.markdown | sed -n '/^cat/p' | cut -f1 -d' ' --complement |
&gt; sed 's/[][]//g' |
&gt; sed 's/, /,/g'
annonce,défi
vim,conseil,débutant
ruby,code propre,intermédiaire
ruby,eigenclass,object,intermédiaire
#...
</code></p>

<p>Grâce à <code>tr</code>, je remplace chaque virgule par un retour à la ligne. Ça
commence à prendre forme.</p>

<p><code>bash
$ head *.markdown | sed -n '/^cat/p' | cut -f1 -d' ' --complement |
&gt; sed 's/[][]//g' | sed 's/, /,/g' |
&gt; tr ',' '\n'
annonce
défi
vim
conseil
débutant
ruby
code propre
intermédiaire
ruby
eigenclass
#...
</code></p>

<p>Trions par ordre alphabétique.</p>

<p>``` bash
$ head *.markdown | sed -n ‘/^cat/p’ | cut -f1 -d’ ‘ –complement |
&gt; sed ‘s/[][]//g’ | sed ‘s/, /,/g’ | tr ‘,’ ‘\n’ |
&gt; sort</p>

<p>ack
activerecord
activerecord
ag
airline
airline
airline
airline
algorithme génétique
#…
```</p>

<p>Réduisons les occurrences et comptons les avec <code>uniq -c</code>.</p>

<p><code>bash
$ head *.markdown | sed -n '/^cat/p' | cut -f1 -d' ' --complement |
&gt; sed 's/[][]//g' | sed 's/, /,/g' | tr ',' '\n' | sort |
&gt; uniq -c
      1 
      1 ack
      2 activerecord
      1 ag
      4 airline
     70 algorithme génétique
      1 alias
     16 annonce
      3 app
      1 application
#...
</code></p>

<p>Trions à nouveau, cette fois sur le nombre et du plus grand au plus petit.</p>

<p><code>bash
$ head *.markdown | sed -n '/^cat/p' | cut -f1 -d' ' --complement |
&gt; sed 's/[][]//g' | sed 's/, /,/g' | tr ',' '\n' | sort | uniq -c |
&gt; sort -nr
    213 ruby
    176 intermédiaire
    171 débutant
     70 algorithme génétique
     55 vim
     26 tutoriel
     26 julia
     26 javascript
#...
      1 application
      1 alias
      1 ag
      1 ack
      1 
</code></p>

<p>Vous avez remarquez ? Un tag est vide. Ça pourrait poser problème pour la
suite. Avec <code>sed</code> on peut facilement supprimer la dernière ligne.</p>

<p><code>bash
$ head *.markdown | sed -n '/^cat/p' | cut -f1 -d' ' --complement |
&gt; sed 's/[][]//g' | sed 's/, /,/g' | tr ',' '\n' | sort | uniq -c |
&gt; sort -nr | sed '$d'
    213 ruby
    176 intermédiaire
    171 débutant
#...
      1 alias
      1 ag
      1 ack
</code></p>

<p>À la réflexion je préfère faire comme si il y avait plusieurs lignes vides et
les supprimer toutes. Ça pourrait être plus réutilisable.</p>

<p><code>bash
$ head *.markdown | sed -n '/^cat/p' | cut -f1 -d' ' --complement |
&gt; sed 's/[][]//g' | sed 's/, /,/g' | tr ',' '\n' |
&gt; sed '/^$/d' |
&gt; sort | uniq -c | sort -nr
</code></p>

<p>Il est temps de sortir une regex un peu plus complexe pour inverser les deux
champs et ajouter une virgule entre eux.</p>

<p><code>bash
$ head *.markdown | sed -n '/^cat/p' | cut -f1 -d' ' --complement |
&gt; sed 's/[][]//g' | sed 's/, /,/g' | tr ',' '\n' | sed '/^$/d' |
&gt; sort | uniq -c | sort -nr |
&gt; sed -r 's/\s+([0-9]+) (.*)/\2,\1/'
ruby,213
intermédiaire,176
débutant,171
algorithme génétique,70
#...
</code></p>

<p>C’est quasiment terminé. Il reste à ajouter l’entête du fichier csv. Pour cela
je vais utiliser une commande non standard mais bien pratique, <code>header</code>.</p>

<p><code>bash
$ head *.markdown | sed -n '/^cat/p' | cut -f1 -d' ' --complement |
&gt;  sed 's/[][]//g' | sed 's/, /,/g' | tr ',' '\n' | sed '/^$/d' |
&gt; sort | uniq -c | sort -nr | sed -r 's/\s+([0-9]+) (.*)/\2,\1/' |
&gt; header -a tag,frequency
tag,frequency
ruby,213
intermédiaire,176
débutant,171
algorithme génétique,70
#...
</code></p>

<p>On a terminé. C’est un beau pipeline, non ? Enregistrons le résultat dans un
fichier.</p>

<p><code>bash
$ head *.markdown | sed -n '/^cat/p' | cut -f1 -d' ' --complement |
&gt;  sed 's/[][]//g' | sed 's/, /,/g' | tr ',' '\n' | sed '/^$/d' |
&gt; sort | uniq -c | sort -nr | sed -r 's/\s+([0-9]+) (.*)/\2,\1/' |
&gt; header -a tag,frequency &gt; tags.csv
</code></p>

<p>En bonus, voici le code R qui produit l’image qui illustre cet article.</p>

<p>``` r
library(wordcloud)</p>

<p>d &lt;- read.csv(‘tags.csv’)</p>

<p>colors &lt;- brewer.pal(12, ‘Paired’)
colors &lt;- colors[seq(2, 10, by=2)]</p>

<p>wordcloud(d$tag, d$frequency, colors=colors, min.freq=1, scale=c(5, .6),
          rot.per=.25, random.order=FALSE, random.color=TRUE)
```</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Créer plusieurs fichiers en Bash]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/05/15/creer-plusieurs-fichiers-en-bash/"/>
    <updated>2015-05-15T13:46:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/05/15/creer-plusieurs-fichiers-en-bash</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p><em>Faire deux fois la même chose, c’est une coincidence ; faire
trois fois la même chose, c’est déjà deux de trop.</em></p>

<p>Mettons que j’ai besoin de créer 20 fichiers quelconques (ici en Ruby) nommés ainsi :</p>

<ul>
  <li><code>asm01.rb</code></li>
  <li><code>asm02.rb</code></li>
  <li><code>asm03.rb</code></li>
  <li>etcétéra jusqu’à <code>asm20.rb</code></li>
</ul>

<!-- more -->

<p>Je peux les créer les uns après les autres de cette manière :</p>

<p><code>bash
$ touch lib/c8dasm/assemblies/asm01.rb
$ touch lib/c8dasm/assemblies/asm02.rb
$ touch lib/c8dasm/assemblies/asm03.rb
$ # même chose jusqu'à :
$ touch lib/c8dasm/assemblies/asm20.rb
</code></p>

<p>Imaginez si vous deviez en faire 200 comme cela ! Et même s’il n’y en avait que
10, c’est juste ennuyeux au possible. En tant que développeurs, <strong>nous devrions
apprendre à automatiser ces tâches pour notre confort</strong>.</p>

<p>On peut utiliser une boucle pour résoudre ce problème :</p>

<p><code>bash
$ for i in {01..20}; do
… &gt; touch lib/c8dasm/assemblies/asm$i.rb
… &gt; done
</code></p>

<p>Ou bien la version sur une seule ligne :</p>

<p><code>bash
$ for i in {01..20}; do touch lib/c8dasm/assemblies/asm$i.rb; done
</code></p>

<p>À bientôt.</p>

<p></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Comment convertir un nombre décimal en binaire en Bash ?]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/05/02/comment-convertir-un-nombre-decimal-en-binaire-en-bash/"/>
    <updated>2015-05-02T12:20:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/05/02/comment-convertir-un-nombre-decimal-en-binaire-en-bash</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Pour convertir un nombre décimal en binaire, en Bash, suivez ce tweet :
<a href="https://twitter.com/climagic/status/593842202314420224">https://twitter.com/climagic/status/593842202314420224</a>.</p>

<p>Et voici la conversion du décimal 27 en son équivalent binaire :</p>

<p><code>bash
$ Dec2Bin=({0..1}{0..1}{0..1}{0..1}{0..1}{0..1}{0..1}{0..1});echo ${Dec2Bin[27]} 
00011011
</code></p>

<p>Alors, comment ça marche ?</p>

<p><img class="center" src="/images/binary.jpg"></p>

<!-- more -->

<p>Pour commencer, voici comment faire un tableau en bash, qui va contenir les 3
chaînes <code>foo</code>, <code>bar</code>, et <code>baz</code>. Ne soyez pas surpris par le manque de guillemets
autour des chaînes, Bash est fait pour traiter du texte.</p>

<p><code>bash
$ myarray=(foo bar baz)
</code></p>

<p>Et voici comment afficher le contenu de ce tableau.</p>

<p><code>bash
$ echo ${myarray[@]}
foo bar baz
</code></p>

<p>On peut bien sûr accéder aux éléments du tableau séparément :</p>

<p><code>bash
$ echo ${myarray[0]}
foo
$ echo ${myarray[1]}
bar
$ echo ${myarray[2]}
baz
</code></p>

<p>Pour connaître la taille d’un tableau, voici la syntaxe :</p>

<p><code>bash
$ echo ${#myarray[@]}
3
</code></p>

<p>Appliquons ce nouveau savoir au tableau <code>Dec2Bin</code>, qui contient…</p>

<p>…</p>

<p>…des trucs :</p>

<p><code>bash
$ Dec2Bin=({0..1}{0..1}{0..1}{0..1}{0..1}{0..1}{0..1}{0..1})
</code></p>

<p>Combien a-t-il d’éléments ?</p>

<p><code>bash
$ echo ${#Dec2Bin[@]}
256
</code></p>

<p>256 ? Et ça ressemble à quoi ?</p>

<p><code>bash
$ echo ${Dec2Bin[@]}
00000000 00000001 00000010 00000011 00000100 00000101 00000110 00000111 00001000 
00001001 00001010 00001011 00001100 00001101 00001110 00001111 00010000 00010001
...
11101010 11101011 11101100 11101101 11101110 11101111 11110000 11110001 11110010 
11110011 11110100 11110101 11110110 11110111 11111000 11111001 11111010 11111011 
11111100 11111101 11111110 11111111
</code></p>

<p>Tranquille, <code>Dec2Bin</code> est un tableau qui contient 256 chaînes représentant les
nombres binaires de 0 à 255.</p>

<p>Les crochets <code>{}</code> créent un <em>range</em> :</p>

<p><code>bash
$ echo {0..1}
0 1
$ echo {a..f}
a b c d e f
</code></p>

<p>Plusieurs crochets <code>{}</code> les uns à la suite des autres produisent toutes les
permutations possibles :</p>

<p><code>bash
$ echo {0..1}{0..1}
00 01 10 11
</code></p>

<p>Et on peut mettre tout ça dans un tableau :</p>

<p><code>bash
$ a=({0..1})
$ echo ${a[@]}
0 1
$ a=({0..1}{0..1})
$ echo ${a[@]}
00 01 10 11
$ a=({0..1}{0..1}{0..1})
$ echo ${a[@]}
000 001 010 011 100 101 110 111
</code></p>

<p>Et voilà, il faut encore savoir qu’ici, le point-virgule sert à joindre 2 lignes de
code en une seule :</p>

<p><code>bash
$ Dec2Bin=({0..1}{0..1}{0..1}{0..1}{0..1}{0..1}{0..1}{0..1})
$ echo ${Dec2Bin[27]}
00011011
</code></p>

<h2 id="bonus-1---le-mme-en-hexadcimal">Bonus 1 - Le même en hexadécimal</h2>

<p>Et si on voulait convertir un nombre décimal en hexadécimal plutôt qu’en
binaire ? Il faudrait générer toutes les permutations entre deux suites
<code>0 1 2 3 4 5 6 7 8 9 A B C D E F</code> :</p>

<p>
<code>bash
$ echo {{0..9},{A..F}}{{0..9},{A..F}}
00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F 10 11 12 13 14 15 16 17 18 19 1A 
1B 1C 1D 1E 1F 20 21 22 23 24 25 26 27 28 29 2A 2B 2C 2D 2E 2F 30 31 32 33 34 35 
36 37 38 39 3A 3B 3C 3D 3E 3F 40 41 42 43 44 45 46 47 48 49 4A 4B 4C 4D 4E 4F 50 
51 52 53 54 55 56 57 58 59 5A 5B 5C 5D 5E 5F 60 61 62 63 64 65 66 67 68 69 6A 6B 
6C 6D 6E 6F 70 71 72 73 74 75 76 77 78 79 7A 7B 7C 7D 7E 7F 80 81 82 83 84 85 86 
87 88 89 8A 8B 8C 8D 8E 8F 90 91 92 93 94 95 96 97 98 99 9A 9B 9C 9D 9E 9F A0 A1 
A2 A3 A4 A5 A6 A7 A8 A9 AA AB AC AD AE AF B0 B1 B2 B3 B4 B5 B6 B7 B8 B9 BA BB BC 
BD BE BF C0 C1 C2 C3 C4 C5 C6 C7 C8 C9 CA CB CC CD CE CF D0 D1 D2 D3 D4 D5 D6 D7 
D8 D9 DA DB DC DD DE DF E0 E1 E2 E3 E4 E5 E6 E7 E8 E9 EA EB EC ED EE EF F0 F1 F2 
F3 F4 F5 F6 F7 F8 F9 FA FB FC FD FE FF
</code>
</p>

<p>
<code>bash
$ Dec2Hex=({{0..9},{A..F}}{{0..9},{A..F}});echo ${Dec2Hex[27]}
1B
</code>
</p>

<h2 id="bonus-2---le-mme-en-ruby">Bonus 2 - Le même en Ruby</h2>

<p>On peut faire la même chose en Ruby en utilisant <code>repeated_permutation</code> :</p>

<p><code>irb
&gt;&gt; [0,1].repeated_permutation(8).to_a.each{|e| puts e.join}
00000000
00000001
00000010
00000011
00000100
00000101
...
11111010
11111011
11111100
11111101
11111110
11111111
</code></p>

<p>Il peut-être intéressant de comparer les deux versions :</p>

<p><code>bash
$ ruby -e "puts [0,1].repeated_permutation(8).to_a[27].join"
00011011
</code></p>

<p><code>bash
$ Dec2Bin=({0..1}{0..1}{0..1}{0..1}{0..1}{0..1}{0..1}{0..1});echo ${Dec2Bin[27]} 
00011011
</code></p>

<h2 id="bonus-3---encore-plus-court">Bonus 3 - Encore plus court</h2>

<p>Pour finir, on peut faire plus court avec Bash en utilisant <code>{0,1}</code> au lieu de
<code>{0..1}</code> puisqu’il y a seulement deux éléments :</p>

<p><code>bash
$ Dec2Bin=({0,1}{0,1}{0,1}{0,1}{0,1}{0,1}{0,1}{0,1});echo ${Dec2Bin[27]} 
00011011
</code></p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[La balise hr dans votre console]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/05/01/la-balise-hr-dans-votre-console/"/>
    <updated>2014-05-01T16:46:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/05/01/la-balise-hr-dans-votre-console</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Aujourd’hui je vais parler d’un programme rigoureusement inutile. Mais
totalement indispensable. J’ai nommé <strong>hr</strong>. Il va vous permettre
d’obtenir la magnifique ligne suivante dans votre console:</p>

<pre><code>$ hr
########################################################################
$
</code></pre>

<!-- more -->

<p>Sans rire, je l’utilise régulièrement pour séparer visuellement les
commandes avec plein de texte en sortie.</p>

<p>Pour l’installer sur Linux:</p>

<pre><code>curl https://raw.githubusercontent.com/LuRsT/hr/master/hr &gt; ~/bin/hr
chmod +x ~/bin/hr
</code></pre>

<p>Sous OS X:</p>

<pre><code>brew install hr
</code></pre>

<p>Le <a href="https://github.com/LuRsT/hr">projet</a> est sur Github, et si la version
Bash ne vous branche pas, <strong>hr</strong> existe aussi dans d’autres langages.</p>

<script id="fb33k8u">(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>

<p>À demain.</p>

<p></p>

]]></content>
  </entry>
  
</feed>
