<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : bash | Xavier Nayrac]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/bash/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2016-12-20T16:35:12+01:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Changer de shell, de Bash à Fish]]></title>
    <link href="http://lkdjiin.github.io/blog/2016/12/13/changer-de-shell-de-bash-a-fish/"/>
    <updated>2016-12-13T19:34:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2016/12/13/changer-de-shell-de-bash-a-fish</id>
    <content type="html"><![CDATA[<p>J’avais remarqué le shell Fish il y a plusieurs années. Mais l’accroche de son
site web m’avais plutôt fait penser à une blague :</p>

<blockquote>
  <p>Finally, a command line shell for the 90s</p>
</blockquote>

<p>Heureusement pour moi, j’y suis repassé il y a quelques mois. Et cette fois
j’ai compris que c’était du sérieux. Je me suis promis de revenir dès que
possible pour essayer ce shell.</p>

<p>On est le week end. J’ai quelques heures devant moi. C’est parti pour
un test. Et comme directement c’est l’effet WAO, je me dis que je
vais y aller <em>à la dure</em>, en l’installant sur l’ordinateur du boulot.</p>

<p>Voici mes premières impressions après deux jours d’utilisation.</p>

<!-- more -->

<h2 id="auto-compltion">Auto complétion</h2>

<p>La première chose qui me saute aux yeux, c’est l’auto complétion, qui va de pair
avec les suggestions faites par le shell.</p>

<p>L’auto complétion par la touche TAB semble bien plus performante qu’en Bash. Un
coup d’œil dans la doc me dit qu’il sera aussi plus simple de fournir les
auto complétions pour mes propres programmes.</p>

<p>Ensuite, des suggestions apparaissent au fur et à mesure que l’on entre des
caractères et c’est puissant. Ça n’existe tout simplement pas dans Bash. Ctrl+F
permet d’accepter toute la ligne, alors que Alt+F accepte un seul mot.</p>

<h2 id="coloration-syntaxique">Coloration syntaxique</h2>

<p>Fish colore votre ligne de commande en temps réel. Y a pas à dire, ça change de
Bash. Et c’est utile : une commande inconnue ou mal orthographiée apparait en
rouge, on repère une variable au milieu d’une chaîne de caractères, etc.</p>

<h2 id="retrouver-les-anciennes-commandes">Retrouver les anciennes commandes</h2>

<p>Avec Bash, j’ai une configuration qui me permet de taper les premières lettres
d’une commande, et de faire défiler (avec les touches fléchées) toutes les
commandes historiques qui commencent par ces quelques lettres.</p>

<p>Avec Fish, pas besoin de configurer quoi que ce soit. Ça existe d’emblée, mais
en plus puissant.</p>

<h2 id="raccourcis-clavier">Raccourcis clavier</h2>

<p>Pour l’instant je ne retrouve pas tous mes raccourcis (ou astuces).
<del>Par exemple avec Bash <code>Esc+.</code> affiche l’argument de la dernière commande. Ça
me manque avec Fish.</del> (Edit: à partir de la version 2.3 <code>Esc+.</code> fonctionne)
Mais comme un principe de Fish est «<em>on peut faire tous ce que peuvent faire
les autres shells</em>», j’attends de voir.</p>

<h2 id="ruby"> Ruby</h2>

<p>J’utilise <code>chruby</code> depuis un certain temps comme <em>version manager</em> et j’ai eu
une petite frayeur en constatant que plus rien ne fonctionnait avec Fish.
Pour mon premier jour sous Fish au boulot, ça a donc été mitigé, même si j’utilise
moins Ruby ces temps ci. Je repassais sous Bash quand il fallait faire du Ruby.</p>

<p>Dans l’après midi je me suis décidé à chercher, et j’ai trouvé ça:
<a href="https://github.com/JeanMertz/chruby-fish">chruby-fish</a>. Sans ce projet j’aurais
certainement cesser là mon utilisation de Fish. Donc un grand merci à son
créateur.</p>

<p>Ça fait très bien le boulot, avec un petit bug tout de même:</p>

<p><code>
$ chruby 2.3.1
mkdir: cannot create directory ‘/opt/rubies/ruby-2.3.1/lib/ruby/gems/2.3.0/bin’: Permission denied
</code></p>

<p>Pour chaque version de Ruby, il faudra donc créer ce dossier à la main:</p>

<pre><code>sudo mkdir /opt/rubies/ruby-2.3.1/lib/ruby/gems/2.3.0/bin
</code></pre>

<h2 id="prompt-thmes">Prompt, thèmes</h2>

<p>Je ne vais pas m’étendre sur le sujet, y a tout ce qu’il faut pour
personnaliser son terminal à grands coups de variables et de fonctions.</p>

<h2 id="alias-et-fonctions">Alias et fonctions</h2>

<p>Un truc qui m’a fort surpris au tout début : Fish n’a pas d’alias, il faut
utiliser des fonctions à la place. À la fin du deuxième jour d’utilisation
c’était adopté et validé. Voici un classique pour l’exemple, je veux pouvoir
taper <code>la</code> à la place de <code>ls -A</code> :</p>

<p><code>
function la --description 'Like ls with hidden file'
    ls -A $argv
end
</code></p>

<p>Un excellent point à propos des fonctions dans Fish : elles sont chargées
<em>paresseusement</em>. C’est à dire qu’une fonction est chargée automatiquement la
première fois qu’on l’utilise.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Le truc avec Fish, c’est que <em>ça juste marche</em> ™. Avec Bash, il faut des
années de configuration pour obtenir quelque chose de valable. Avec Fish, ton
premier fichier de configuration est vide, inexistant, parce que pas besoin. Et
pourtant ça fonctionne, tout simplement.</p>

<p>Maintenant ça ne fait que deux jours que je suis dessus… C’est le début, tout
est beau. Je verrai à l’usage.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Utiliser Bash pour supprimer les encodages magiques de Ruby 1.9]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/08/06/utiliser-bash-pour-supprimer-les-encodages-magiques-de-ruby-1-dot-9/"/>
    <updated>2015-08-06T17:27:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/08/06/utiliser-bash-pour-supprimer-les-encodages-magiques-de-ruby-1-dot-9</id>
    <content type="html"><![CDATA[<p>Si vous avez travaillé sur des projets écrit avec Ruby 1.9, vous avez peut-être
utilisé les encodages magiques (souvent appelés <em>magic comment</em>). Il s’agit
d’un commentaire en début de fichier qui définit l’encodage :</p>

<p><code>ruby
# -*- encoding: UTF-8 -*-
</code></p>

<p>Récemment j’ai passé plusieurs projets de Ruby 1.9.x à Ruby 2.x et j’ai
naturellement voulu supprimer ces <em>directives d’encodage</em> qui ne sont plus
nécessaires.</p>

<p>J’imagine qu’un IDE ou un autre doit être capable de faire ça (<code>&lt;mode troll&gt;</code>
sinon quel intérêt à utiliser un IDE ? <code>&lt;/mode troll&gt;</code>). Toujours est-il que
quelques commandes dans Bash et hop, terminé ;)</p>

<p>Voici comment faire, sans trop entrer dans les détails. J’espère juste vous
donner envie d’utiliser Bash, ou un autre shell (si ça n’est pas déjà le cas).</p>

<!-- more -->

<p>De quoi a-t-on besoin ?  <code>find</code>, <code>sed</code> et <code>xargs</code> :</p>

<p><code>bash
$ find . -type f -name '*.rb' | xargs sed -i '1{/encoding/d}'
$ find . -type f -name '*.rb' | xargs sed -i -n '/./,$p'
</code></p>

<p>La première commande efface la première ligne des fichiers ruby si cette
ligne contient <code>encoding</code>. La seconde commande enlève la première ligne si
cette ligne est vide.</p>

<h2 id="find">find</h2>

<pre><code>find . -type f -name '*.rb'
</code></pre>

<p>Cherche tout les fichiers dont le nom se termine par <code>.rb</code> et les affichent
les uns après les autres.  Ça donne quelque chose comme ça :</p>

<pre><code>./fichier1.rb
./fichier2.rb
./dossier1/fichier1.rb
./dossier1/fichier2.rb
./dossier2/fichier1.rb
[...]
</code></pre>

<h2 id="xargs">xargs</h2>

<p>Pour donner les noms de fichier à manger à sed, il faut qu’ils soient sur une
seule ligne. C’est à dire les uns à coté des autres comme on écrirait des
paramètres, et pas les uns en dessous des autres comme ce qui sort de <code>find</code>.</p>

<p>Voilà donc <code>xargs</code> :</p>

<p><code>bash
$ echo -e "a\nb\nc"
a
b
c
$ echo -e "a\nb\nc" | xargs
a b c
</code></p>

<p>– <em>Le switch <code>-e</code> de echo interprète la séquence \n comme un saut de ligne.</em> —</p>

<h2 id="sed">sed</h2>

<p>Le switch <code>-i</code> c’est pour <em>in place</em>. On modifie vraiment les fichiers.</p>

<pre><code>sed -i '1{/encoding/d}'
</code></pre>

<p>Supprime (<code>d</code>) la ligne qui contient <code>encoding</code>. Ne s’applique qu’à la 1ère
ligne <code>1{}</code>.</p>

<pre><code>sed -i -n '/./,$p'
</code></pre>

<p>Supprime la 1ère ligne si elle est vide. Je trouve que cette ligne mérite bien
un article à elle toute seule. Alors son explication sera pour une prochaine
fois ;)</p>

<p>Et vous, comment auriez vous fait ? Avec un shell ? Un IDE ?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Extraction des tags de mon blog en ligne de commande]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/07/11/extraction-des-tags-de-mon-blog-en-ligne-de-commande/"/>
    <updated>2015-07-11T17:08:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/07/11/extraction-des-tags-de-mon-blog-en-ligne-de-commande</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>J’aimerais savoir quels sont les tags que j’ai le plus employé sur ce blog.
Pour cela il va d’abord falloir les extraire, si possible dans un fichier csv.</p>

<p>Comment ? En Ruby ? En R ? Non non, en Bash, ça va être beaucoup plus drôle.</p>

<p>Petite étude de cas pour découvrir la puissance de la ligne de commande, ou
pour rafraichir ses connaissances ;)</p>

<p><img class="center" src="/images/tags-cloud.png"></p>

<!-- more -->

<p>Si vous voulez reproduire l’analyse en même temps que moi, les
<a href="https://github.com/lkdjiin/lkdjiin.github.io/tree/source/source/_posts">articles sont ici</a>.</p>

<p>Voyons à quoi ressemble le début d’un article au hasard avec <code>head</code>.
Octopress, le framework que j’utilise pour ce blog, appelle les tags des
<em>categories</em>. Mais c’est pareil.</p>

<p><code>bash
$ head 2013-10-20-les-algorithmes-genetiques-demystifies-35.markdown
---
layout: post
title: "Les algorithmes génétiques démystifiés 35"
date: 2013-10-20 21:21
comments: true
categories: [imagerie, algorithme génétique, intermédiaire, javascript]
#...
</code></p>

<p>L’entête d’un article a toujours la même structure. Avec <code>head *.markdown</code>
j’affiche le début de tous les articles, les uns à la suite des autres.
Avec <code>sed</code> je peux extraire uniquement les lignes qui commencent par <code>cat</code> :</p>

<p><code>bash
$ head *.markdown | sed -n '/^cat/p'
categories: [annonce, défi]
categories: [vim, conseil, débutant]
categories: [ruby, code propre, intermédiaire]
categories: [ruby, eigenclass, object, intermédiaire]
#...
</code></p>

<p>Gardons seulement les tableaux. <code>cut -f1</code> <em>découpe</em> le premier champ, <code>-d' '</code>
indique que le séparateur de champ est l’espace, et <code>--complement</code> indique
qu’on veut conserver le complément. Autrement dit tout sauf la première
colonne.</p>

<p><code>bash
$ head *.markdown | sed -n '/^cat/p' |
&gt; cut -f1 -d' ' --complement
[annonce, défi]
[vim, conseil, débutant]
[ruby, code propre, intermédiaire]
[ruby, eigenclass, object, intermédiaire]
#...
</code></p>

<p>Supprimons les crochets à l’aide de <code>sed</code> et d’une regex rigolote.</p>

<p><code>bash
$ head *.markdown | sed -n '/^cat/p' | cut -f1 -d' ' --complement |
&gt; sed 's/[][]//g'
annonce, défi
vim, conseil, débutant
ruby, code propre, intermédiaire
ruby, eigenclass, object, intermédiaire
#...
</code></p>

<p>Supprimons les espaces inutiles. Attention, certains tags contiennent des
espaces.</p>

<p><code>bash
$ head *.markdown | sed -n '/^cat/p' | cut -f1 -d' ' --complement |
&gt; sed 's/[][]//g' |
&gt; sed 's/, /,/g'
annonce,défi
vim,conseil,débutant
ruby,code propre,intermédiaire
ruby,eigenclass,object,intermédiaire
#...
</code></p>

<p>Grâce à <code>tr</code>, je remplace chaque virgule par un retour à la ligne. Ça
commence à prendre forme.</p>

<p><code>bash
$ head *.markdown | sed -n '/^cat/p' | cut -f1 -d' ' --complement |
&gt; sed 's/[][]//g' | sed 's/, /,/g' |
&gt; tr ',' '\n'
annonce
défi
vim
conseil
débutant
ruby
code propre
intermédiaire
ruby
eigenclass
#...
</code></p>

<p>Trions par ordre alphabétique.</p>

<p>``` bash
$ head *.markdown | sed -n ‘/^cat/p’ | cut -f1 -d’ ‘ –complement |
&gt; sed ‘s/[][]//g’ | sed ‘s/, /,/g’ | tr ‘,’ ‘\n’ |
&gt; sort</p>

<p>ack
activerecord
activerecord
ag
airline
airline
airline
airline
algorithme génétique
#…
```</p>

<p>Réduisons les occurrences et comptons les avec <code>uniq -c</code>.</p>

<p><code>bash
$ head *.markdown | sed -n '/^cat/p' | cut -f1 -d' ' --complement |
&gt; sed 's/[][]//g' | sed 's/, /,/g' | tr ',' '\n' | sort |
&gt; uniq -c
      1 
      1 ack
      2 activerecord
      1 ag
      4 airline
     70 algorithme génétique
      1 alias
     16 annonce
      3 app
      1 application
#...
</code></p>

<p>Trions à nouveau, cette fois sur le nombre et du plus grand au plus petit.</p>

<p><code>bash
$ head *.markdown | sed -n '/^cat/p' | cut -f1 -d' ' --complement |
&gt; sed 's/[][]//g' | sed 's/, /,/g' | tr ',' '\n' | sort | uniq -c |
&gt; sort -nr
    213 ruby
    176 intermédiaire
    171 débutant
     70 algorithme génétique
     55 vim
     26 tutoriel
     26 julia
     26 javascript
#...
      1 application
      1 alias
      1 ag
      1 ack
      1 
</code></p>

<p>Vous avez remarquez ? Un tag est vide. Ça pourrait poser problème pour la
suite. Avec <code>sed</code> on peut facilement supprimer la dernière ligne.</p>

<p><code>bash
$ head *.markdown | sed -n '/^cat/p' | cut -f1 -d' ' --complement |
&gt; sed 's/[][]//g' | sed 's/, /,/g' | tr ',' '\n' | sort | uniq -c |
&gt; sort -nr | sed '$d'
    213 ruby
    176 intermédiaire
    171 débutant
#...
      1 alias
      1 ag
      1 ack
</code></p>

<p>À la réflexion je préfère faire comme si il y avait plusieurs lignes vides et
les supprimer toutes. Ça pourrait être plus réutilisable.</p>

<p><code>bash
$ head *.markdown | sed -n '/^cat/p' | cut -f1 -d' ' --complement |
&gt; sed 's/[][]//g' | sed 's/, /,/g' | tr ',' '\n' |
&gt; sed '/^$/d' |
&gt; sort | uniq -c | sort -nr
</code></p>

<p>Il est temps de sortir une regex un peu plus complexe pour inverser les deux
champs et ajouter une virgule entre eux.</p>

<p><code>bash
$ head *.markdown | sed -n '/^cat/p' | cut -f1 -d' ' --complement |
&gt; sed 's/[][]//g' | sed 's/, /,/g' | tr ',' '\n' | sed '/^$/d' |
&gt; sort | uniq -c | sort -nr |
&gt; sed -r 's/\s+([0-9]+) (.*)/\2,\1/'
ruby,213
intermédiaire,176
débutant,171
algorithme génétique,70
#...
</code></p>

<p>C’est quasiment terminé. Il reste à ajouter l’entête du fichier csv. Pour cela
je vais utiliser une commande non standard mais bien pratique, <code>header</code>.</p>

<p><code>bash
$ head *.markdown | sed -n '/^cat/p' | cut -f1 -d' ' --complement |
&gt;  sed 's/[][]//g' | sed 's/, /,/g' | tr ',' '\n' | sed '/^$/d' |
&gt; sort | uniq -c | sort -nr | sed -r 's/\s+([0-9]+) (.*)/\2,\1/' |
&gt; header -a tag,frequency
tag,frequency
ruby,213
intermédiaire,176
débutant,171
algorithme génétique,70
#...
</code></p>

<p>On a terminé. C’est un beau pipeline, non ? Enregistrons le résultat dans un
fichier.</p>

<p><code>bash
$ head *.markdown | sed -n '/^cat/p' | cut -f1 -d' ' --complement |
&gt;  sed 's/[][]//g' | sed 's/, /,/g' | tr ',' '\n' | sed '/^$/d' |
&gt; sort | uniq -c | sort -nr | sed -r 's/\s+([0-9]+) (.*)/\2,\1/' |
&gt; header -a tag,frequency &gt; tags.csv
</code></p>

<p>En bonus, voici le code R qui produit l’image qui illustre cet article.</p>

<p>``` r
library(wordcloud)</p>

<p>d &lt;- read.csv(‘tags.csv’)</p>

<p>colors &lt;- brewer.pal(12, ‘Paired’)
colors &lt;- colors[seq(2, 10, by=2)]</p>

<p>wordcloud(d$tag, d$frequency, colors=colors, min.freq=1, scale=c(5, .6),
          rot.per=.25, random.order=FALSE, random.color=TRUE)
```</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Créer plusieurs fichiers en Bash]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/05/15/creer-plusieurs-fichiers-en-bash/"/>
    <updated>2015-05-15T13:46:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/05/15/creer-plusieurs-fichiers-en-bash</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p><em>Faire deux fois la même chose, c’est une coincidence ; faire
trois fois la même chose, c’est déjà deux de trop.</em></p>

<p>Mettons que j’ai besoin de créer 20 fichiers quelconques (ici en Ruby) nommés ainsi :</p>

<ul>
  <li><code>asm01.rb</code></li>
  <li><code>asm02.rb</code></li>
  <li><code>asm03.rb</code></li>
  <li>etcétéra jusqu’à <code>asm20.rb</code></li>
</ul>

<!-- more -->

<p>Je peux les créer les uns après les autres de cette manière :</p>

<p><code>bash
$ touch lib/c8dasm/assemblies/asm01.rb
$ touch lib/c8dasm/assemblies/asm02.rb
$ touch lib/c8dasm/assemblies/asm03.rb
$ # même chose jusqu'à :
$ touch lib/c8dasm/assemblies/asm20.rb
</code></p>

<p>Imaginez si vous deviez en faire 200 comme cela ! Et même s’il n’y en avait que
10, c’est juste ennuyeux au possible. En tant que développeurs, <strong>nous devrions
apprendre à automatiser ces tâches pour notre confort</strong>.</p>

<p>On peut utiliser une boucle pour résoudre ce problème :</p>

<p><code>bash
$ for i in {01..20}; do
… &gt; touch lib/c8dasm/assemblies/asm$i.rb
… &gt; done
</code></p>

<p>Ou bien la version sur une seule ligne :</p>

<p><code>bash
$ for i in {01..20}; do touch lib/c8dasm/assemblies/asm$i.rb; done
</code></p>

<p>À bientôt.</p>

<p></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Comment convertir un nombre décimal en binaire en Bash ?]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/05/02/comment-convertir-un-nombre-decimal-en-binaire-en-bash/"/>
    <updated>2015-05-02T12:20:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/05/02/comment-convertir-un-nombre-decimal-en-binaire-en-bash</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Pour convertir un nombre décimal en binaire, en Bash, suivez ce tweet :
<a href="https://twitter.com/climagic/status/593842202314420224">https://twitter.com/climagic/status/593842202314420224</a>.</p>

<p>Et voici la conversion du décimal 27 en son équivalent binaire :</p>

<p><code>bash
$ Dec2Bin=({0..1}{0..1}{0..1}{0..1}{0..1}{0..1}{0..1}{0..1});echo ${Dec2Bin[27]} 
00011011
</code></p>

<p>Alors, comment ça marche ?</p>

<p><img class="center" src="/images/binary.jpg"></p>

<!-- more -->

<p>Pour commencer, voici comment faire un tableau en bash, qui va contenir les 3
chaînes <code>foo</code>, <code>bar</code>, et <code>baz</code>. Ne soyez pas surpris par le manque de guillemets
autour des chaînes, Bash est fait pour traiter du texte.</p>

<p><code>bash
$ myarray=(foo bar baz)
</code></p>

<p>Et voici comment afficher le contenu de ce tableau.</p>

<p><code>bash
$ echo ${myarray[@]}
foo bar baz
</code></p>

<p>On peut bien sûr accéder aux éléments du tableau séparément :</p>

<p><code>bash
$ echo ${myarray[0]}
foo
$ echo ${myarray[1]}
bar
$ echo ${myarray[2]}
baz
</code></p>

<p>Pour connaître la taille d’un tableau, voici la syntaxe :</p>

<p><code>bash
$ echo ${#myarray[@]}
3
</code></p>

<p>Appliquons ce nouveau savoir au tableau <code>Dec2Bin</code>, qui contient…</p>

<p>…</p>

<p>…des trucs :</p>

<p><code>bash
$ Dec2Bin=({0..1}{0..1}{0..1}{0..1}{0..1}{0..1}{0..1}{0..1})
</code></p>

<p>Combien a-t-il d’éléments ?</p>

<p><code>bash
$ echo ${#Dec2Bin[@]}
256
</code></p>

<p>256 ? Et ça ressemble à quoi ?</p>

<p><code>bash
$ echo ${Dec2Bin[@]}
00000000 00000001 00000010 00000011 00000100 00000101 00000110 00000111 00001000 
00001001 00001010 00001011 00001100 00001101 00001110 00001111 00010000 00010001
...
11101010 11101011 11101100 11101101 11101110 11101111 11110000 11110001 11110010 
11110011 11110100 11110101 11110110 11110111 11111000 11111001 11111010 11111011 
11111100 11111101 11111110 11111111
</code></p>

<p>Tranquille, <code>Dec2Bin</code> est un tableau qui contient 256 chaînes représentant les
nombres binaires de 0 à 255.</p>

<p>Les crochets <code>{}</code> créent un <em>range</em> :</p>

<p><code>bash
$ echo {0..1}
0 1
$ echo {a..f}
a b c d e f
</code></p>

<p>Plusieurs crochets <code>{}</code> les uns à la suite des autres produisent toutes les
permutations possibles :</p>

<p><code>bash
$ echo {0..1}{0..1}
00 01 10 11
</code></p>

<p>Et on peut mettre tout ça dans un tableau :</p>

<p><code>bash
$ a=({0..1})
$ echo ${a[@]}
0 1
$ a=({0..1}{0..1})
$ echo ${a[@]}
00 01 10 11
$ a=({0..1}{0..1}{0..1})
$ echo ${a[@]}
000 001 010 011 100 101 110 111
</code></p>

<p>Et voilà, il faut encore savoir qu’ici, le point-virgule sert à joindre 2 lignes de
code en une seule :</p>

<p><code>bash
$ Dec2Bin=({0..1}{0..1}{0..1}{0..1}{0..1}{0..1}{0..1}{0..1})
$ echo ${Dec2Bin[27]}
00011011
</code></p>

<h2 id="bonus-1---le-mme-en-hexadcimal">Bonus 1 - Le même en hexadécimal</h2>

<p>Et si on voulait convertir un nombre décimal en hexadécimal plutôt qu’en
binaire ? Il faudrait générer toutes les permutations entre deux suites
<code>0 1 2 3 4 5 6 7 8 9 A B C D E F</code> :</p>

<p>
<code>bash
$ echo {{0..9},{A..F}}{{0..9},{A..F}}
00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F 10 11 12 13 14 15 16 17 18 19 1A 
1B 1C 1D 1E 1F 20 21 22 23 24 25 26 27 28 29 2A 2B 2C 2D 2E 2F 30 31 32 33 34 35 
36 37 38 39 3A 3B 3C 3D 3E 3F 40 41 42 43 44 45 46 47 48 49 4A 4B 4C 4D 4E 4F 50 
51 52 53 54 55 56 57 58 59 5A 5B 5C 5D 5E 5F 60 61 62 63 64 65 66 67 68 69 6A 6B 
6C 6D 6E 6F 70 71 72 73 74 75 76 77 78 79 7A 7B 7C 7D 7E 7F 80 81 82 83 84 85 86 
87 88 89 8A 8B 8C 8D 8E 8F 90 91 92 93 94 95 96 97 98 99 9A 9B 9C 9D 9E 9F A0 A1 
A2 A3 A4 A5 A6 A7 A8 A9 AA AB AC AD AE AF B0 B1 B2 B3 B4 B5 B6 B7 B8 B9 BA BB BC 
BD BE BF C0 C1 C2 C3 C4 C5 C6 C7 C8 C9 CA CB CC CD CE CF D0 D1 D2 D3 D4 D5 D6 D7 
D8 D9 DA DB DC DD DE DF E0 E1 E2 E3 E4 E5 E6 E7 E8 E9 EA EB EC ED EE EF F0 F1 F2 
F3 F4 F5 F6 F7 F8 F9 FA FB FC FD FE FF
</code>
</p>

<p>
<code>bash
$ Dec2Hex=({{0..9},{A..F}}{{0..9},{A..F}});echo ${Dec2Hex[27]}
1B
</code>
</p>

<h2 id="bonus-2---le-mme-en-ruby">Bonus 2 - Le même en Ruby</h2>

<p>On peut faire la même chose en Ruby en utilisant <code>repeated_permutation</code> :</p>

<p><code>irb
&gt;&gt; [0,1].repeated_permutation(8).to_a.each{|e| puts e.join}
00000000
00000001
00000010
00000011
00000100
00000101
...
11111010
11111011
11111100
11111101
11111110
11111111
</code></p>

<p>Il peut-être intéressant de comparer les deux versions :</p>

<p><code>bash
$ ruby -e "puts [0,1].repeated_permutation(8).to_a[27].join"
00011011
</code></p>

<p><code>bash
$ Dec2Bin=({0..1}{0..1}{0..1}{0..1}{0..1}{0..1}{0..1}{0..1});echo ${Dec2Bin[27]} 
00011011
</code></p>

<h2 id="bonus-3---encore-plus-court">Bonus 3 - Encore plus court</h2>

<p>Pour finir, on peut faire plus court avec Bash en utilisant <code>{0,1}</code> au lieu de
<code>{0..1}</code> puisqu’il y a seulement deux éléments :</p>

<p><code>bash
$ Dec2Bin=({0,1}{0,1}{0,1}{0,1}{0,1}{0,1}{0,1}{0,1});echo ${Dec2Bin[27]} 
00011011
</code></p>

<p></p>
]]></content>
  </entry>
  
</feed>
