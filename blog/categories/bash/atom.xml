<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : bash | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/bash/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2014-02-09T19:03:37+01:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[L'auto-complétion programmable en Bash - partie 9]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/02/09/lauto-completion-programmable-en-bash-partie-9/"/>
    <updated>2014-02-09T18:55:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/02/09/lauto-completion-programmable-en-bash-partie-9</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-3'>Niveau : <span>avancé</span></div></p>

<p>Cet article est la suite de:
<a href="/blog/2014/02/08/lauto-completion-programmable-en-bash-partie-8/">L'auto complétion programmable en bash: partie 8</a>.</p>

<h2>Une complétion améliorée</h2>

<p>On voit aujourd'hui deux fonctions bien utiles lors de l'écriture
de votre script d'auto-complétion: <code>_get_comp_words_by_ref</code> et
<code>compopt</code>.</p>

<!-- more -->


<p>On va ajouter une option <code>--format=</code> à notre commande <code>test</code>. Ce que
je veux, c'est pouvoir écrire quelque chose comme ça:</p>

<pre><code>$ mytool test --format=documentation
</code></pre>

<p>Il faut donc que:</p>

<pre><code>$ mytool test -[TAB]
</code></pre>

<p>nous donne ceci:</p>

<pre><code>$ mytool test --format=
</code></pre>

<p>Mais contrairement à ce qu'il se passe jusqu'ici, je ne veux pas
que l'auto-complétion ajoute un espace après <code>--format=</code>.</p>

<p>Voici tout d'abord le script qui fait ça :</p>

<p>``` bash
_mytool()
{</p>

<pre><code>local cur prev command options
COMPREPLY=( )
_get_comp_words_by_ref cur prev
commands='new compile test'

if [[ $COMP_CWORD -eq 1 ]]; then
    COMPREPLY=( $( compgen -W "$commands" -- "$cur" ) )
elif [[ "$cur" == -* ]]; then
    command=${COMP_WORDS[1]}
    case $command in
        new)
            options='--without-test'
            ;;
        compile)
            options='--verbose'
            ;;
        test)
            options='--format='
            compopt -o nospace
            ;;
    esac
    COMPREPLY=( $( compgen -W "$options" -- "$cur" ) )
fi
</code></pre>

<p>}
complete -F _mytool mytool
```</p>

<p>Et maintenant, je vais détailler les nouveautés. D'abord, vous avez
peut-être remarqué que la ligne:</p>

<p>``` bash</p>

<pre><code>_get_comp_words_by_ref cur prev
</code></pre>

<p>```</p>

<p>a remplacé les deux lignes suivantes
(<a href="">voir article précédent</a>):</p>

<p>``` bash</p>

<pre><code>cur="${COMP_WORDS[COMP_CWORD]}"
prev="${COMP_WORDS[COMP_CWORD-1]}"
</code></pre>

<p>```</p>

<p>C'est plus simple, plus lisible, plus propre. Cette fonction,
<code>_get_comp_words_by_ref</code>, se trouve dans le script <code>/etc/bash_completion</code>,
que je vous invite à étudier. Ce fichier défini plusieurs fonctions
utiles pour la complétion.</p>

<p>Voyons maintenant l'ajout de la nouvelle option:</p>

<p>``` bash</p>

<pre><code>        test)
            options='--format='
            compopt -o nospace
            ;;
</code></pre>

<p>```</p>

<p>La nouveauté est ici <code>compopt -o nospace</code>. La fonction <code>compopt</code> permet
d'allumer/éteindre certaines options pour la complétion en cours. Ici on
demande de ne pas ajouter d'espace à la fin de la chaîne renvoyée par
la complétion.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[L'auto-complétion programmable en Bash - partie 8]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/02/08/lauto-completion-programmable-en-bash-partie-8/"/>
    <updated>2014-02-08T14:10:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/02/08/lauto-completion-programmable-en-bash-partie-8</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-3'>Niveau : <span>avancé</span></div></p>

<p>Cet article est la suite de:
<a href="/blog/2014/02/02/lauto-completion-programmable-en-bash-partie-7/">L'auto complétion programmable en bash: partie 7</a>.</p>

<h2>Une complétion plus étoffée</h2>

<p>Après avoir étudié les variables <code>COMPREPLY</code>, <code>COMP_WORDS</code>, <code>COMP_CWORD</code>,
et le motif minimal, voici maintenant un programme plus utile.</p>

<!-- more -->


<p>Je veux que <code>mytool new</code> réponde à la seule option <code>--without-test</code>.
Donc:</p>

<pre><code>$ mytool new -[TAB]
</code></pre>

<p>doit donner:</p>

<pre><code>$ mytool new --without-test
</code></pre>

<p>Je veux aussi que <code>mytool commpile</code> réponde seulement à <code>--verbose</code>, donc:</p>

<pre><code>$ mytool compile -[TAB]
</code></pre>

<p>doit donner:</p>

<pre><code>$ mytool compile --verbose
</code></pre>

<p>Quant à <code>mytool test</code>, il ne prend aucune option.</p>

<p>Voici sans plus tarder un programme qui fait ça:</p>

<p>``` bash
_mytool()
{</p>

<pre><code>local cur prev command options
COMPREPLY=( )
cur="${COMP_WORDS[COMP_CWORD]}"
prev="${COMP_WORDS[COMP_CWORD-1]}"
commands='new compile test'

if [[ $COMP_CWORD -eq 1 ]] ; then
    COMPREPLY=( $( compgen -W "$commands" -- "$cur" ) )
else
    command=${COMP_WORDS[1]}
    if [[ "$cur" == -* ]]; then
        case $command in
            new)
                options='--without-test'
                ;;
            compile)
                options='--verbose'
                ;;
        esac
        COMPREPLY=( $( compgen -W "$options" -- "$cur" ) )
    fi
fi
</code></pre>

<p>}
complete -F _mytool mytool
```</p>

<p>Ok, Bash n'est pas le plus lisible des langages, mais si vous avez suivi
tous les articles précédent, vous êtes en mesure de suivre la logique
de ce programme. Voilà ce que donne l'algorithme:</p>

<pre><code>Si le curseur est en position 1
  Compléter avec les commandes
Sinon
  Trouver la commande courante
  Si le mot sous le curseur commence par '-'
    Compléter les options suivant la commande courante
</code></pre>

<p>Quelques points précis maintenant : on calcule le mot sous le curseur
dans <code>cur</code> et le mot précédent dans <code>prev</code>:</p>

<p>``` bash</p>

<pre><code>cur="${COMP_WORDS[COMP_CWORD]}"
prev="${COMP_WORDS[COMP_CWORD-1]}"
</code></pre>

<p>```</p>

<p>On place toutes les commandes dans une variable <code>commands</code>,</p>

<p>``` bash</p>

<pre><code>commands='new compile test'
</code></pre>

<p>```</p>

<p>ce qui permet de calculer les complétions possibles de la manière
suivante (plus lisible et flexible quand on a beaucoup de commandes):</p>

<p>``` bash</p>

<pre><code>    COMPREPLY=( $( compgen -W "$commands" -- "$cur" ) )
</code></pre>

<p>```</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[L'auto-complétion programmable en Bash - partie 7]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/02/02/lauto-completion-programmable-en-bash-partie-7/"/>
    <updated>2014-02-02T18:35:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/02/02/lauto-completion-programmable-en-bash-partie-7</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-3'>Niveau : <span>avancé</span></div></p>

<p>Cet article est la suite de:
<a href="/blog/2014/01/29/lauto-completion-programmable-en-bash-partie-6/">L'auto complétion programmable en bash: partie 6</a>.</p>

<h2>Un motif général et basique, la suite</h2>

<p>Après avoir regardé la variable <code>COMPREPLY</code> dans le dernier article,
on étudie aujourd'hui les variables <code>COMP_WORDS</code> et <code>COMP_CWORD</code>.</p>

<!-- more -->


<p>On va encore modifier notre script, cette fois pour examiner le
contenu de la variable <code>COMP_WORDS</code>:</p>

<p>``` bash /etc/bash_completion.d/mytool
_mytool()
{</p>

<pre><code>COMPREPLY=${COMP_WORDS[@]}
</code></pre>

<p>}
complete -F _mytool mytool
```</p>

<p>N'oubliez pas de sourcer:</p>

<pre><code>$ source /etc/bash_completion.d/mytool
</code></pre>

<p>Testons:</p>

<pre><code>$ mytool foo bar[TAB]
</code></pre>

<p>est remplacé par:</p>

<pre><code>$ mytool foo mytool foo bar
</code></pre>

<p>On voit que <code>COMP_WORDS</code> est un tableau qui contient chaque éléments
de notre ligne de commande, au moment où celle ci est envoyée à
l'auto-complétion.</p>

<p>Voyons maintenant <code>COMP_CWORD</code>:</p>

<p>``` bash /etc/bash_completion.d/mytool
_mytool()
{</p>

<pre><code>COMPREPLY=( $COMP_CWORD )
</code></pre>

<p>}
complete -F _mytool mytool
```</p>

<p>Si je tapes:</p>

<pre><code>$ mytool foo bar[TAB]
</code></pre>

<p>Cela va être remplacé par:</p>

<pre><code>$ mytool foo 2
</code></pre>

<p>Donc, <code>COMP_CWORD</code> contient l'index de l'élément de la ligne de
commande dans lequel se trouve le curseur.</p>

<p>On a maintenant tous les éléments en main pour comprendre le script
présenté la dernière fois comme le motif de base pour
l'auto-complétion:</p>

<p>``` bash /etc/bash_completion.d/mytool
_mytool()
{</p>

<pre><code>local current=${COMP_WORDS[COMP_CWORD]}
COMPREPLY=( $(compgen -W "new compile test" -- $current) )
</code></pre>

<p>}
complete -F _mytool mytool
```</p>

<p>Il reste juste à expliquer la dernière ligne:</p>

<p><code>bash
complete -F _mytool mytool
</code></p>

<p>La fonction <code>complete</code>, interne à Bash, s'occupe bien sûr de l'auto-complétion
du programme <code>mytool</code>. Le nombre d'options possibles est important, vous pouvez
jeter un oeil au manuel si vous avez le temps. On se contentera ici de l'option
<code>-F</code>. Cette option est très intéressante, elle prend en argument le nom d'une
fonction (ici <code>_mytool</code>) qui va calculer la complétion. Cette fameuse option
<code>-F</code> permet aussi à <code>complete</code> de savoir qu'elle doit chercher des résultats
dans la variable <code>COMPREPLY</code>. Notez la convention utilisée: la fonction
<code>_mytool</code> calcule la complétion du programme <code>mytool</code>.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[L'auto-complétion programmable en Bash - partie 6]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/01/29/lauto-completion-programmable-en-bash-partie-6/"/>
    <updated>2014-01-29T20:47:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/01/29/lauto-completion-programmable-en-bash-partie-6</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-3'>Niveau : <span>avancé</span></div></p>

<p>Cet article est la suite de:
<a href="/blog/2014/01/15/lauto-completion-en-bash-partie-5/">L'auto complétion programmable en bash: partie 5</a>.</p>

<h2>Un motif général et basique</h2>

<p>Nous avons écrit un petit <a href="/blog/2014/01/14/lauto-completion-programmable-en-bash-partie-4/">programme pour tester</a>,
puis nous avons écrit <a href="/blog/2014/01/15/lauto-completion-en-bash-partie-5/">un script d'auto-complétion très simple</a>.
Reprenons notre jeu de rôle: nous avons un programme <code>mytool</code> qui
attend une des trois commandes suivantes: <code>new</code>, <code>compile</code> ou
<code>test</code>. On va ajouter ceci: la commande <code>new</code> peut prendre
l'option <code>--without-test</code> et la commande <code>compile</code> peut prendre
l'option <code>--verbose</code>. Ça reste encore très simple, mais on ne peut
déjà plus se servir uniquement de la fonction <code>complete</code>, vue
la dernière fois.</p>

<p>Voyons donc le motif général utilisé par beaucoup de scripts
d'auto-complétion:</p>

<!-- more -->


<p>``` bash /etc/bash_completion.d/mytool
_mytool()
{</p>

<pre><code>local current=${COMP_WORDS[COMP_CWORD]}
COMPREPLY=( $(compgen -W "new compile test" -- $current) )
</code></pre>

<p>}
complete -F _mytool mytool
```</p>

<p>Le script ci-dessus fait exactement la même chose que notre simple
script de la dernière fois, qui était le suivant:</p>

<p><code>bash /etc/bash_completion.d/mytool
complete -W "new compile test" mytool
</code></p>

<p>Mais il le fait d'une manière plus compliquée. En effet,
pourquoi faire simple… Les explications viendront plus tard.</p>

<p>En fait, pour aller plus loin, il est important de comprendre le rôle
des variables <code>COMP_WORDS</code>, <code>COMP_CWORD</code> et <code>COMPREPLY</code>. Pour ça, on
va modifier notre script, et chercher à comprendre ce que
représente <code>COMPREPLY</code>:</p>

<p>``` bash /etc/bash_completion.d/mytool
_mytool()
{</p>

<pre><code>COMPREPLY=( this is some replacement )
</code></pre>

<p>}
complete -F _mytool mytool
```</p>

<p>Pour qu'il soit pris en compte tout de suite, il faut le sourcer:</p>

<pre><code>$ source /etc/bash_completion.d/mytool
</code></pre>

<p>Alors, que fait-il ? Si je tapes <code>mytool foo bar[TAB]</code>, voici ce que
le script sort:</p>

<pre><code>$ mytool foo bar[TAB]
is           replacement  some         this   
</code></pre>

<p>COMPREPLY accepte un tableau de chaînes, qui sont les suggestions que
nous renvoit l'auto-complétion. On note au passage que ces suggestions
sont triées alphabétiquement.</p>

<p>Modifions à nouveau notre script:</p>

<p>``` bash /etc/bash_completion.d/mytool
_mytool()
{</p>

<pre><code>COMPREPLY=( replacement )
</code></pre>

<p>}
complete -F _mytool mytool
```</p>

<p>Cette fois, COMPREPLY représente un tableau d'un seul élément.
N'oubliez pas de sourcer le script avant de le tester:</p>

<pre><code>$ mytool foo bar[TAB]
</code></pre>

<p>devient:</p>

<pre><code>$ mytool foo replacement
</code></pre>

<p>Vous devriez maintenant avoir bien compris à quoi sert la variable
<code>COMPREPLY</code>.</p>

<p>La prochaine fois, on regardera en détail les variables <code>COMP_WORDS</code>
et <code>COMP_CWORD</code>.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[L'auto-complétion en Bash - partie 5]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/01/15/lauto-completion-en-bash-partie-5/"/>
    <updated>2014-01-15T20:44:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/01/15/lauto-completion-en-bash-partie-5</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Cet article est la suite de:
<a href="http://lkdjiin.github.io/blog/2014/01/14/lauto-completion-programmable-en-bash-partie-4/">L'auto complétion programmable en bash: partie 4</a>.</p>

<h2>Les bases de l'auto complétion programmable</h2>

<p>Une application peut proposer ses services d'auto complétion en déposant
un fichier bash dans le dossier <code>/etc/bash_completion.d/</code>.
On y voit un tas de fichiers, pour des programmes bien connus:</p>

<pre><code>[~]⇒ ls /etc/bash_completion.d/
abook
ant
apache2.2-common
apache2ctl
apt
...
git
...
</code></pre>

<p>Il suffit juste de savoir quoi mettre dedans. Allons-y:</p>

<!-- more -->


<p><code>bash /etc/bash_completion.d/mytool
complete -W "new compile test" mytool
</code></p>

<p>Le fichier sera chargé automatiquement au lancement de bash. Donc pour que
ça fonctionne maintenant, soit vous le sourcez, soit vous lancez une
nouvelle console et, &ndash; <em>roulements de tambours</em>&ndash;</p>

<pre><code>[~]⇒ mytool [TAB]
compile  new      test     
[~]⇒ mytool 
</code></pre>

<p>Magique, non ? Il faut noter que l'auto complétion fonctionnera aussi
avec des options:</p>

<p><code>bash /etc/bash_completion.d/mytool
complete -W "new compile test --verbose" mytool
</code></p>

<pre><code>[~]⇒ mytool c[TAB] -[TAB]
mytool compile --verbose
</code></pre>

<p>Donc, comment ça marche ? Voici la traduction de l'aide de <code>complete</code>,
simplifiée au maximum:</p>

<p><strong>complete</strong> [<em>options</em>] <em>name</em>   <br/>
Spécifie comment les arguments doivent être complétés, pour chaque <em>name</em>.</p>

<p>L'option <code>-W</code> permet de lui passer une liste de mots. Finalement c'était
facile ? Humm… En fait ce sera rarement aussi simple. Pour continuer notre
jeu de rôle, disons que l'option <code>--verbose</code> peut s'appliquer uniquement
à l'argument <code>new</code>, et pas aux deux autres. Du coup, notre commande
<code>complete</code> ne suffit plus. Il va falloir trouver autre chose et c'est ce
qu'on verra dans un prochain article.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
