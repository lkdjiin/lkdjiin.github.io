<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : orienté objet | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/oriente-objet/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2014-06-23T21:32:11+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Le duck typing avec Ruby]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/04/07/le-duck-typing-avec-ruby/"/>
    <updated>2014-04-07T21:19:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/04/07/le-duck-typing-avec-ruby</id>
    <content type="html"><![CDATA[<p>Vous faites du Ruby depuis peu ? Vous venez d'un langage
orienté objet plus <em>classique</em>, comme par exemple Java ?
Vous entendez parler de <strong>duck typing</strong> régulièrement sans
trop voir de quoi il retourne ?
Aujourd'hui on voit ce qu'est le duck typing.</p>

<!-- more -->


<p>Pour la petite histoire, nous allons faire marcher (<em>walk</em>) des
rats (<em>Rat</em>) et des souris (<em>Mice</em>). Rat et souris étants des
mammifères (<em>Mammal</em>).</p>

<p>En mimant un langage comme Java, nous allons d'abord créer
une classe de base qui implémente une méthode <code>walk</code>:</p>

<p>``` ruby
class Mammal
  def walk</p>

<pre><code>raise NotImplementedError
</code></pre>

<p>  end
end</p>

<p>Mammal.new.walk
```</p>

<p>Vous remarquez que cette méthode <code>walk</code> soulève une
exception si elle est appelée. Elle n'est ici que pour nous
rappeler que les classes filles devront l'implémenter:</p>

<p><code>raw
$ ruby duck.rb
duck.rb:3:in `walk': NotImplementedError (NotImplementedError)
</code></p>

<p>Poursuivons le mimétisme Java en créant les classes <code>Rat</code> et
<code>Mice</code> qui héritent de <code>Mammal</code>, et qui donc implémentent
conciencieusement la méthode <code>walk</code></p>

<p>``` ruby
class Mammal
  def walk</p>

<pre><code>raise NotImplementedError
</code></pre>

<p>  end
end</p>

<p>class Rat &lt; Mammal
  def walk</p>

<pre><code>"I am a Rat and I walk"
</code></pre>

<p>  end
end</p>

<p>class Mice &lt; Mammal
  def walk</p>

<pre><code>"I am a Mice and I walk"
</code></pre>

<p>  end
end</p>

<p>puts Rat.new.walk
puts Mice.new.walk
```</p>

<p>Le résultat est celui qu'on attend:</p>

<p><code>raw
$ ruby duck.rb
I am a Rat and I walk
I am a Mice and I walk
</code></p>

<p>Maintenant ajoutons une classe <code>Laboratory</code> qui a pour rôle
de manipuler nos animaux, en les faisant marcher à la
demande:</p>

<p>``` ruby
class Mammal
  def walk</p>

<pre><code>raise NotImplementedError
</code></pre>

<p>  end
end</p>

<p>class Rat &lt; Mammal
  def walk</p>

<pre><code>"I am a Rat and I walk"
</code></pre>

<p>  end
end</p>

<p>class Mice &lt; Mammal
  def walk</p>

<pre><code>"I am a Mice and I walk"
</code></pre>

<p>  end
end</p>

<p>class Laboratory
  def self.make_walk(pet)</p>

<pre><code>pet.walk
</code></pre>

<p>  end
end</p>

<p>puts Laboratory.make_walk(Rat.new)
puts Laboratory.make_walk(Mice.new)
```</p>

<p><code>raw
$ ruby duck.rb
I am a Rat and I walk
I am a Mice and I walk
</code></p>

<p>Et là, si vous venez d'un langage orienté objet dit
<em>classique</em>, vous devriez avoir tiqué, fait la grimace,
vous être gratté la barbe, etc. Et oui, la classe
<code>Laboratory</code> n'a <em>aucune connaissance</em> de la classe
<code>Mammal</code>. Et pourtant la ligne <code>pet.walk</code> fonctionne
comme un charme. C'est parce que nous sommes en Ruby,
un langage <em>dynamique</em>. On pourrait dire un langage qui
n'a que faire des <em>types</em> (bon c'est exagéré, hein).</p>

<p>Si <code>Laboratory</code> n'utilise pas <code>Mammal</code>, on pourrait
peut-être carrément la supprimer ?
On essaye :</p>

<p>``` ruby
class Rat
  def walk</p>

<pre><code>"I am a Rat and I walk"
</code></pre>

<p>  end
end</p>

<p>class Mice
  def walk</p>

<pre><code>"I am a Mice and I walk"
</code></pre>

<p>  end
end</p>

<p>class Laboratory
  def self.make_walk(pet)</p>

<pre><code>pet.walk
</code></pre>

<p>  end
end</p>

<p>puts Laboratory.make_walk(Rat.new)
puts Laboratory.make_walk(Mice.new)
```</p>

<p><code>raw
$ ruby duck.rb
I am a Rat and I walk
I am a Mice and I walk
</code></p>

<p>C'est ça le duck typing. On ne s'intéresse pas à ce
<strong>qu'est</strong> l'objet mais à ce <strong>qu'il sait faire</strong>.</p>

<p>Alors ça ne veut pas dire pour autant que l'héritage est
inutile ou inutilisé avec Ruby. Mais simplement qu'on
va l'utiliser moins qu'ailleurs parce que 1) on peut le
faire et 2) parce qu'on va se concentrer sur le
comportement et pas sur l'être.</p>

<p>Voilà, c'était une explication parmi d'autres du
duck typing.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby - extend self]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/03/28/ruby-extend-self/"/>
    <updated>2014-03-28T21:16:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/03/28/ruby-extend-self</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Vous débutez en Ruby et vous vous demandez ce que peut bien signifier
ce <code>extend self</code> qu'on rencontre parfois dans un module utilitaire ?</p>

<!-- more -->


<p>Voici un exemple:</p>

<p>``` ruby
module M
  extend self</p>

<p>  def foo</p>

<pre><code>puts 'foo'
</code></pre>

<p>  end
end</p>

<p>M.foo</p>

<h1>=> foo</h1>

<p>```</p>

<p>La ligne <code>extend self</code> nous permet de définir toutes les méthodes du
module comme étant des méthodes de classe. C'est pas plus compliqué que
ça.</p>

<p>On aurait pu écrire à la place:</p>

<p>``` ruby
module M
  def self.foo</p>

<pre><code>puts 'foo'
</code></pre>

<p>  end
end
```</p>

<p>Ou bien encore:</p>

<p>``` ruby
module M
  class &lt;&lt; self</p>

<pre><code>def foo
  puts 'foo'
end
</code></pre>

<p>  end
end
```</p>

<p>Il y a quand même une subtilité qui fait toute la différence !
Sinon ça ne serait pas drôle. En utilisant la syntaxe <code>extend self</code>,
<strong>toutes les méthodes sont des méthodes de classe</strong>, ou de module si
vous préférez ;) La différence est importante puisqu'ainsi on ne pourra
pas mélanger méthodes utilitaires et méthodes à inclure dans une classe.
Ce qui est parfois tentant, mais c'est mal. Mais tentant. Mais mal…</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[La méthode super en Ruby - partie 2]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/03/25/la-methode-super-en-ruby-partie-2/"/>
    <updated>2014-03-25T19:53:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/03/25/la-methode-super-en-ruby-partie-2</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Comme me le faisait remarquer ce matin un lecteur, il manque un cas à
mon article d'hier sur l'utilisation de <code>super</code> en Ruby. C'est d'autant
plus impardonnable que c'est un cas où, pour une fois, les parenthèses
sont <strong>obligatoires</strong> à la fin d'une méthode.</p>

<!-- more -->


<p>Voici donc une classe de base et une classe fille:</p>

<p>``` ruby
class Base
  def foo</p>

<pre><code>puts "Base#foo"
</code></pre>

<p>  end
end</p>

<p>class Child &lt; Base
  def foo(bar)</p>

<pre><code>super
puts "Child#foo with #{bar}"
</code></pre>

<p>  end
end
```</p>

<p>Et maintenant on essaye le tout:</p>

<p>``` ruby
child = Child.new
child.foo</p>

<h1>=> ArgumentError: wrong number of arguments (0 for 1)</h1>

<p>```</p>

<p>Boum ! Comme on l'a vu hier, <code>super</code> passe automatiquement tous les
paramètres de la méthode dans laquelle il est appelé vers la classe
de base. Et là, notre méthode <code>foo</code> dans la classe de base est sans
argument.</p>

<p>Pour résoudre ce problème, on est obligé de mettre des parenthèses
à la suite de <code>super</code>:</p>

<p>``` ruby
class Child &lt; Base
  def foo(bar)</p>

<pre><code>super()
puts "Child#foo with #{bar}"
</code></pre>

<p>  end
end
```</p>

<p><code>ruby
child = Child.new
child.foo('ok')
Base#foo
Child#foo with ok
</code></p>

<p>Voilà, oubli réparé.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[La méthode super en Ruby]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/03/24/la-methode-super-en-ruby/"/>
    <updated>2014-03-24T21:21:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/03/24/la-methode-super-en-ruby</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Aujourd'hui un aperçu de la méthode <code>super</code> pour les débutants en Ruby.
C'est une méthode dont le comportement peut surprendre si vous venez
de certains autres langages…</p>

<!-- more -->


<p>Pour étudier le comportement de <code>super</code> il va nous falloir utiliser
l'héritage. Voici une classe de base toute simple:</p>

<p>``` ruby
class Base
  def foo(bar)</p>

<pre><code>puts "#{bar} from Base"
</code></pre>

<p>  end
end
```</p>

<p>Et voici comment l'utiliser:</p>

<p>``` ruby
base = Base.new
base.foo(&ldquo;Hello&rdquo;)</p>

<h1>=> Hello from Base</h1>

<p>```</p>

<p>Maintenant créons une classe fille qui hérite de <code>Base</code> et
<em>redéfinissons</em> la méthode <code>foo</code>:</p>

<p>``` ruby
class Child &lt; Base
  def foo(bar)</p>

<pre><code>super
puts "#{bar} from Child"
</code></pre>

<p>  end
end
```</p>

<p>Voici ce que ça donne:</p>

<p>``` ruby
child = Child.new
child.foo(&ldquo;Hello&rdquo;)</p>

<h1>=> Hello from Base</h1>

<h1>=> Hello from Child</h1>

<p>```</p>

<p>Il faut noter que:</p>

<ol>
<li>La méthode éponyme <code>foo</code> de la classe de base n'est pas appelée
implicitement. Il faut le faire explicitement avec <code>super</code>.</li>
<li>On est pas limité à un <em>constructeur</em>, on peut appeler <code>super</code> dans
une <em>simple</em> méthode.</li>
<li>Dans ce cas précis, pas besoin de passer l'argument <code>bar</code> à la
méthode <code>super</code>, c'est fait <strong>automagiquement</strong>.</li>
</ol>


<p>Allons plus loin et faisons faire plus de choses à la méthode <code>foo</code> de la
classe fille:</p>

<p>``` ruby
class Child &lt; Base
  def foo(bar, baz)</p>

<pre><code>super
puts "#{bar} #{baz} from Child"
</code></pre>

<p>  end
end
```</p>

<p>Cette fois-ci la magie n'opère plus et nous avons droit à une belle erreur:</p>

<p>``` ruby
child = Child.new
child.foo(&ldquo;Hello&rdquo;, &ldquo;world&rdquo;)</p>

<h1>=> super.rb:2:in `foo': wrong number of arguments (2 for 1) (ArgumentError)</h1>

<p>```</p>

<p>Ruby nous signale que la méthode <code>foo</code> de la classe <code>Base</code> a reçu 2
arguments, alors qu'elle n'en attendait qu'un seul ! Pourquoi, alors que
nous n'avons même pas passé un seul argument ? Parce que <code>super</code>, sans
arguments, prends <strong>tous</strong> les arguments passés à la méthode dans
laquelle il se trouve et les envoient tous vers la méthode éponyme de la
classe de base…</p>

<p>Alors comment on s'en sort ? Très simplement en passant à <code>super</code> les
paramètres que l'on veut:</p>

<p>``` ruby
class Child &lt; Base
  def foo(bar, baz)</p>

<pre><code>super(bar)
puts "#{bar} #{baz} from Child"
</code></pre>

<p>  end
end
```</p>

<p>Et cette fois-ci, ça fonctionne parfaitement:</p>

<p>``` ruby
child = Child.new
child.foo(&ldquo;Hello&rdquo;, &ldquo;world&rdquo;)</p>

<h1>=> Hello from Base</h1>

<h1>=> Hello world from Child</h1>

<p>```</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
