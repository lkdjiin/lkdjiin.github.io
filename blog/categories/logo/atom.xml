<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : logo | Xavier Nayrac]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/logo/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2015-07-27T13:55:24+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Le jeu de la vie en logo - partie 3]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/12/20/le-jeu-de-la-vie-en-logo-partie-3/"/>
    <updated>2014-12-20T17:46:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/12/20/le-jeu-de-la-vie-en-logo-partie-3</id>
    <content type="html"><![CDATA[<p>Suite et fin du jeu de la vie en Logo.</p>

<p>Je ne montrerais pas d’extraits de code, pour la simple raison que
je n’en peux plus du langage Logo.  Ceci dit, pour les curieux, le code complet
se trouve sur <a href="https://github.com/lkdjiin/game-of-life-logo">Github</a>.</p>

<p>Je ne sais pas ce qui m’a pris de
ressortir Logo du placard. Les madeleines de Proust sont faites pour rester à
l’état de souvenirs. Écrire le jeu de la vie en Logo n’a jamais été fun. À
aucun moment.</p>

<!-- more -->

<p>Bref, j’oublie définitivement Logo. La prochaine version sera en Julia, ça
promet d’être bien plus intéressant.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Le jeu de la vie en logo - partie 2]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/12/17/le-jeu-de-la-vie-en-logo-partie-2/"/>
    <updated>2014-12-17T16:35:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/12/17/le-jeu-de-la-vie-en-logo-partie-2</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Cette fois, on affiche la génération de cellules crée la dernière fois.
J’ai déjà eu l’occasion de dire que Logo était spécial, on va voir avec
son système graphique que c’est bien le cas. Je ne vais pas parler de la
métaphore de la <em>tortue</em>, vous trouverez sûrement des ressources là-dessus.
Je voudrais plutôt parler du système de coordonnée. Alors que dans la plupart des
langages (tous ?) les systèmes graphiques proposent de placer le point d’origine (0, 0) en haut à
gauche, Logo le place au centre. En général, l’axe des y croit vers le bas,
en Logo il croit vers le haut.</p>

<p>Selon le manuel d’UCBLogo, voici à quoi s’attendre:</p>

<pre><code>(-100, 100)            (100, 100)

              (0, 0)

(-100, -100)           (100, -100)
</code></pre>

<!-- more -->

<p>Mais en fait, non. J’ai plutôt ça sur la machine où j’utilise Logo:</p>

<pre><code>(-250, 250)            (250, 250)

              (0, 0)

(-250, -250)           (250, -250)
</code></pre>

<p>Quoiqu’il en soit, voici comment ça marche.</p>

<p>``` raw drawing.lg
hideturtle</p>

<p>to draw.generation :generation :size
for [y 1 :size] [p.draw.line :y]
end</p>

<p>to p.draw.line :y
for [x 1 :size] [if (cell.alive? :generation :x :y) [p.draw.cell :x :y ] ]
end</p>

<p>to p.draw.cell :x :y
penup
setxy :x :y
setheading 90
pendown
forward 1
end
```</p>

<p><code>hideturtle</code> cache la tortue, comme son nom l’indique. Parce que, en plus
d’être moche, ça ralenti le dessin, qui n’est déjà pas très rapide.</p>

<p>La procédure <code>draw.generation</code> itère sur chaque ligne de <code>generation</code> et
appelle la procédure <em>privée</em> <code>p.draw.line</code>.</p>

<p><code>p.draw.line</code> itère sur chaque cellule de la ligne. On détermine, avec
<code>cell.alive?</code>, si la cellule est vivante. Si c’est le cas, on appelle
<code>p.draw.cell</code>.</p>

<p><code>p.draw.cell</code> affiche un pixel en (x, y).</p>

<p>Dans le fichier <code>generation.lg</code>, j’ajoute la procédure <code>cell.alive?</code>.</p>

<p><code>raw generation.lg
to cell.alive? :generation :x :y
localmake "line item :y :generation
ifelse (item :x :line) = 1 [output "true] [output "false]
end
</code></p>

<p>Puis on assemble le tout dans un fichier <code>application.lg</code>.</p>

<p>``` raw application.lg
load “generation.lg
load “drawing.lg</p>

<p>make “size 100</p>

<p>draw.generation create.generation :size :size :size
```</p>

<p>Et voici le résultat:</p>

<pre><code>$ tree
.
├── application.lg
├── drawing.lg
├── generation.lg
└── test.generation.lg

$ logo application.lg
</code></pre>

<p><img src="/images/game-of-life-logo.png"></p>

<p>Mouais, un peu moche, non ? J’avoue que je commence déjà à en avoir marre de
Logo.</p>

<script id="fb33k8u">(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Le jeu de la vie en logo - partie 1]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/12/16/le-jeu-de-la-vie-en-logo-partie-1/"/>
    <updated>2014-12-16T18:01:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/12/16/le-jeu-de-la-vie-en-logo-partie-1</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>C’est parti pour la version Logo du jeu de la vie. J’utiliserais
<a href="http://www.cs.berkeley.edu/~bh/logo.html">ucblogo</a> en version 5.5, qui est celle qu’on trouve dans les paquets Debian.
Sur leur site vous trouverez la version 6, si vous souhaitez la compiler.</p>

<pre><code>$ logo
Welcome to Berkeley Logo version 5.5
</code></pre>

<h2 id="introduction">Introduction</h2>

<p>Attention ! Le monde de Logo est autre. Je n’ai pas d’autres formules qui me
viennent à l’esprit.  Si vous utilisez Vim, j’ai écrit un fichier de
<a href="https://github.com/lkdjiin/logo.vim">coloration syntaxique pour Logo</a>,
minimal, mais toujours utile pour ne pas se sentir coincé dans les années 80.
Et comme il n’existe pas de frameworks de test (ou alors ils sont bien cachés),
j’en ai écrit un rudimentaire : <a href="https://github.com/lkdjiin/logo-unit">Logo unit test</a>.</p>

<p>Bref, vous aurez compris que l’éco-système Logo open source est assez pauvre,
voir inexistant.  Je crois qu’il n’y a même pas de tag <code>logo</code> sur
stackoverflow.</p>

<!-- more -->

<h2 id="cration-dune-gnration">Création d’une génération</h2>

<p>Créons un fichier pour les tests, et un fichier pour l’implémentation.</p>

<pre><code>$ tree
.
├── generation.lg
└── test.generation.lg
</code></pre>

<p>En avant pour le premier test, je veux m’assurer que la procédure
<code>create.generation</code> renvoie une liste.</p>

<p>``` raw test.generation.lg
load “generation.lg</p>

<p>to t.create.generation.returns.a.list
assert.list create.generation
end
```</p>

<h3 id="premires-remarques-sur-logo">Premières remarques sur Logo</h3>

<p>Tout d’abord, les points n’ont rien à voir avec des appels de
méthode/fonction/procédure.  C’est juste une manière de nommer les choses. En
Ruby on aurait <code>assert_list</code>, en Java <code>assertList</code>, en Racket <code>assert-list</code>, en
Logo c’est plutôt <code>assert.list</code>.</p>

<p>Ensuite, la première ligne <code>load "generation.lg</code>, qui charge le fichier
<code>generation.lg</code>, ne contient pas de faute de frappe ! Il y a bien un seul
guillement double (<code>"</code>). C’est la façon de dire que <code>generation.lg</code> doit être
pris dans son sens littéral, pas en tant que variable ou procédure, mais bien en
tant que nom.</p>

<h3 id="lancer-les-tests">Lancer les tests</h3>

<p>On lance les tests en chargeant la procédure <code>tt</code>. Logo nous dit <em>je ne sais
pas comment faire pour create.generation</em>. Normal puisque cette procédure
n’existe pas encore.</p>

<pre><code>$ logo
Welcome to Berkeley Logo version 5.5
? tt "test.generation.lg
I don't know how  to create.generation  in t.create.generation.returns.a.list
[assert.list create.generation]
</code></pre>

<h3 id="notre-premire-procdure">Notre première procédure</h3>

<p>Il suffit de renvoyer une liste vide pour faire passer le test. Notez que
<code>output</code> est l’équivalent du plus commun <code>return</code>.</p>

<p><code>raw generation.lg
to create.generation
output []
end
</code></p>

<pre><code>? tt "test.generation.lg
.

1 tests. 0 fail.
</code></pre>

<h3 id="une-liste--plusieurs-dimensions">Une liste à plusieurs dimensions</h3>

<p>Notre liste devra avoir une largeur (x) et une hauteur (y), commençons par
tester la hauteur.</p>

<p>``` raw test.generation.lg
load “generation.lg</p>

<p>to t.create.generation.returns.a.list
assert.list create.generation 3
end</p>

<p>to t.create.generation.have.a.height
assert.equal 3 count create.generation 3
end
```</p>

<p>Voici le code permettant de faire passer nos nouveaux tests.</p>

<p><code>raw generation.lg
to create.generation :height
output cascade :height [lput # ?] []
end
</code></p>

<p><code>cascade</code> prend un nombre d’itération, un template et une valeur de départ.
<code>lput</code> (pour <em>last put</em>) ajoute une valeur à la fin d’une liste. <code>#</code> dans le
template est remplacé par l’itération.</p>

<p>Ensuite, nouveaux tests pour s’assurer qu’on a aussi une largeur.</p>

<p>``` raw test.generation.lg
load “generation.lg</p>

<p>to t.create.generation.returns.a.list
assert.list create.generation 4 3
end</p>

<p>to t.create.generation.have.a.height
assert.equal 3 count create.generation 4 3
end</p>

<p>to t.create.generation.have.a.width
assert.equal 4 count first create.generation 4 3
end
```</p>

<p>On implémente notre liste à 2 dimensions.</p>

<p>``` raw generation.lg
to create.generation :width :height
output cascade :height [lput (p.create.line :width) ?] []
end</p>

<p>to p.create.line :width
output cascade :width [lput 0 ?] []
end
```</p>

<p>Le <code>p.</code> en tête d’un nom de procédure est une convention que j’ai utilié pour
signifier que la procédure est privée.</p>

<p>Les tests passent.</p>

<pre><code>? tt "test.generation.lg
...

3 tests. 0 fail.
</code></pre>

<p>On peut regarder à quoi ressemble la sortie de notre procédure.</p>

<pre><code>? print create.generation 4 3
[0 0 0 0] [0 0 0 0] [0 0 0 0]
</code></pre>

<h3 id="un-peu-de-hasard">Un peu de hasard</h3>

<p>Les cellules du jeu de la vie sont représentées soit par un 0 (cellule
morte), soit par un 1 (cellule vivante). Je teste que <code>create.generation</code>
produit bien une suite de 0 et de 1.</p>

<p><code>raw test.generation.lg
to t.create.generation.produces.0s.or.1s
rerandom
localmake "result create.generation 3 2
assert.equal :result [[1 0 1] [1 1 1]]
end
</code></p>

<p><code>rerandom</code> place le générateur de nombre aléatoire dans un état reproductible,
pour pouvoir tester facilement. <code>localmake</code> déclare une variable locale, ici
<code>result</code> qui va contenir la sortie de <code>create.generation 3 2</code>.</p>

<p>Et j’implémente avec la procédure <code>random</code> qui renvoie un nombre aléatoire.</p>

<p><code>raw generation.lg
to p.create.line :width
output cascade :width [lput (random 2) ?] []
end
</code></p>

<p>Et voilà, les tests passent.</p>

<pre><code>? tt "test.generation.lg
....

4 tests. 0 fail.
? print create.generation 9 3
[0 0 1 0 1 1 0 0 0] [1 1 1 1 0 0 0 1 1] [1 0 1 0 1 1 1 1 0]
</code></pre>

<h2 id="la-porte-des-variables-en-logo">La portée des variables en Logo</h2>

<p>Le code précédent fonctionne très bien, par contre on peut faire un refactoring
intéressant qui va me permettre de parler d’un phénomène étrange en Logo.</p>

<p>``` raw generation.lg
to create.generation :width :height
output cascade :height [lput p.create.line ?] []
end</p>

<p>to p.create.line
output cascade :width [lput (random 2) ?] []
end
```</p>

<p>Vous remarquerez que j’ai enlevé le paramêtre <code>width</code> de la procédure
<code>p.create.line</code> et que ce <code>width</code> n’est plus passé par <code>create.generation</code>.
Pourtant le code continue de fonctionner comme un charme.</p>

<p>C’est que Logo a une notion toute particulière de la <em>localité</em> des variables.
Une variable locale à une procédure est connue dans cette même procédure
<strong>et aussi</strong> dans les sous-procédures appelées par cette même procédure.
Autrement dit, <code>p.create.line</code> connait les variables <code>width</code> et <code>height</code>
puisqu’elle est appelée par <code>create.generation</code>.</p>

<p>Ce n’est pas le seul langage à fonctionner comme ça (les premiers Lisp et
Perl, il me semble). Par contre je me demande toujours si c’est génial, ou
irresponsable.</p>

<script id="fb33k8u">(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Le jeu de la vie dans sept langages différents]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/10/08/le-jeu-de-la-vie-dans-sept-langages-differents/"/>
    <updated>2014-10-08T12:30:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/10/08/le-jeu-de-la-vie-dans-sept-langages-differents</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Je vais écrire le <a href="http://en.wikipedia.org/wiki/Conway%27s_Game_of_Life">jeu de la vie</a> dans 7 langages, et
en utilisant le TDD (sauf pour l’affichage).
Ça va me permettre de réviser certains langages et d’en apprendre de nouveaux
d’une manière amusante. Après tout, quoi de plus <em>fun</em> qu’un jeu pour zéro
joueur.</p>

<h2 id="lalgorithme">L’algorithme</h2>

<p>L’idée directrice, c’est de faire au plus simple.
L’algorithme général sera le suivant :</p>

<ol>
  <li>obtenir une première génération au hasard</li>
  <li>afficher la génération</li>
  <li>calculer la nouvelle génération et retour au point 2.</li>
</ol>

<p>Discutons un peu chacun des trois points.</p>

<!-- more -->

<h3 id="obtenir-une-premire-gnration-au-hasard">Obtenir une première génération au hasard</h3>

<p>Cette génération sera stockée dans un tableau (une liste). Suivant le
langage, j’utiliserais un tableau à 1 ou 2 dimensions.</p>

<h3 id="afficher-la-gnration">Afficher la génération</h3>

<p>Il s’agit d’afficher à l’écran le tableau calculé précédement. Chaque élément
du tableau représente une cellule du jeu de la vie, et une cellule sera
représentée à l’écran par un pixel. Alors un pixel pour une cellule, ça risque
d’être assez moche sur la plupart des dispositifs, mais c’est le plus simple.
J’améliorerais peut-être cet affichage plus tard.</p>

<h3 id="calculer-la-nouvelle-gnration">Calculer la nouvelle génération</h3>

<p>Là encore, j’essaye d’aller au plus simple. On va calculer la
nouvelle génération dans un second tableau. Une fois ce calcul effectué, ce
second tableau remplacera le premier.</p>

<p>Pour calculer le nouvel état d’une cellule, on devra observer la cellule et
ces 8 voisins. Autrement dit on observe une fenêtre de 9 cellules et on veut
connaitre le nouvel état de la cellule centrale. Il y a 3 cas possibles:</p>

<ol>
  <li>Si la somme des cellules vivantes est 3, alors la nouvelle cellule sera
vivante.</li>
  <li>Si la somme des cellules vivantes est 4, alors la nouvelle cellule conserve
son ancien état.</li>
  <li>Dans tous les autres cas, la nouvelle cellule est morte.</li>
</ol>

<p>Il faut encore parler du cas des cellules qui se trouvent sur les bords du
<em>plateau de jeu</em>. Normalement, le jeu de la vie est infini. Mais l’infini, c’est
pas simple. Dans une première itération, le <em>plateau de jeu</em> aura des
dimensions finies et les cellules qui se trouvent sur les bords se verront
ajoutées arbitrairement des voisins morts.</p>

<p>Une seconde itération pourrait implémenter une espèce de <a href="http://en.wikipedia.org/wiki/Torus">tore</a> pour avoir une surface
de jeu sans bordures.</p>

<h2 id="les-langages-cibls">Les langages ciblés</h2>

<p>Je vais écrire le jeu de la vie dans 7 langages différents:</p>

<ul>
  <li>ruby</li>
  <li>javascript</li>
  <li>racket</li>
  <li>logo</li>
  <li>julia</li>
  <li>haskell</li>
  <li>rust</li>
</ul>

<h3 id="pourquoi-ces-langages-">Pourquoi ces langages ?</h3>

<p><strong>Ruby</strong></p>

<p>Ça peut paraitre bizarre. Après tout j’écris en Ruby toute la journée, c’est
mon métier. Pourquoi vouloir en faire encore pendant mon temps libre ?
En fait, ce qui m’intéresse vraiment ici, c’est <a href="http://opalrb.org/">Opal.rb</a>. Peut-être aussi
que j’en ferais une seconde version avec <a href="http://www.libgosu.org/">Gosu</a>.</p>

<p><strong>Javascript</strong></p>

<p>Après des années passées à tenter d’éviter d’écrire la moindre ligne de
Javascript, je m’intéresse de nouveau à ce langage. Après tout, c’est un
incontournable du Web et il commence à me plaire. Et puis j’ai trop tardé à
faire du TDD avec Javascript, je crois que <a href="http://jasmine.github.io/">Jasmine</a> est devenu très bon.</p>

<p><strong>Racket</strong></p>

<p>Je crois que tout développeur devrait étudier un <em>Lisp like</em>. Lisp t’oblige à
penser autrement et du coup tu trouves des solutions différentes à des
problèmes de programmation de tout les jours.</p>

<p><strong>Logo</strong></p>

<p>Le <a href="http://fr.wikipedia.org/wiki/Logo_%28langage%29">Logo</a>, c’est ma <a href="http://fr.wikipedia.org/wiki/Madeleine_%28cuisine%29#La_madeleine_de_Proust">madeleine de Proust</a> ! Voilà. Encore un <em>Lisp like</em>,
mais différent (on l’appelait Lisp sans parenthèses). J’espère que je trouverais
encore des ressources pour celui-ci.</p>

<p><strong>Julia</strong></p>

<p>Je pense que les langages fonctionnels ont un grand avenir. Ils résolvent au
moins deux soucis. En ce concentrant sur la transformation des données plutôt
que sur l’état de ces données, ils facilitent les tests et l’utilisation des
multi-coeurs.</p>

<p><strong>Haskell</strong></p>

<p>Encore un langage fonctionnel, et celui-ci me fait un peu peur. Mais je me dis
que je devrais y goûter.</p>

<p><strong>Rust</strong></p>

<p>Je voulais un langage système dans cette liste, ce sera <a href="http://www.rust-lang.org/">Rust</a>.</p>

<h2 id="frquence-de-publication">Fréquence de publication</h2>

<p>Je ne m’avancerais pas sur une fréquence de publication. J’imagine qu’il y
aura 3 ou 4 articles par langage. Et suivant le temps dont je disposerais, ça
pourrat-être aussi bien un article par mois ou trois articles par semaine.</p>

<p>Allez, la prochaine fois on commence avec Ruby/Opal.</p>

<script id="fb33k8u">(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Dans le grenier: Le premier pas vers l'an 2000]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/09/22/dans-le-grenier-le-premier-pas-vers-lan-2000/"/>
    <updated>2013-09-22T21:51:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/09/22/dans-le-grenier-le-premier-pas-vers-lan-2000</id>
    <content type="html"><![CDATA[<p>En fouillant dans le grenier, j’ai retrouvé un livre de 1989 au titre
évocateur : «Devenir champion de Logo plus».</p>

<p><img src="/images/livre_logo.jpg"></p>

<!-- more -->

<p>C’est une phrase sur la quatrième de couverture qui m’a le plus frappé:
«En route vers l’an 2000». Assez drôle avec le recul, mais à l’époque on
voyait ça partout.</p>

<p>Mon souvenir du langage Logo est assez nostalgique. J’ai beaucoup
apprécié de l’utiliser. 25 ans plus tard, je me demande si je
l’apprécierai toujours autant ? Je pense que je vais consacrer quelques
articles à ce langage, histoire de me remémorer ses particularités.</p>

<script id="fb33k8u">(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>

<p>À demain.</p>

]]></content>
  </entry>
  
</feed>
