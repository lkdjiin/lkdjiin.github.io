<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : duck typing | Xavier Nayrac]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/duck-typing/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2016-01-18T08:34:08+01:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Le duck typing avec Ruby]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/04/07/le-duck-typing-avec-ruby/"/>
    <updated>2014-04-07T21:19:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/04/07/le-duck-typing-avec-ruby</id>
    <content type="html"><![CDATA[<p>Vous faites du Ruby depuis peu ? Vous venez d’un langage
orienté objet plus <em>classique</em>, comme par exemple Java ?
Vous entendez parler de <strong>duck typing</strong> régulièrement sans
trop voir de quoi il retourne ?
Aujourd’hui on voit ce qu’est le duck typing.</p>

<!-- more -->

<p>Pour la petite histoire, nous allons faire marcher (<em>walk</em>) des
rats (<em>Rat</em>) et des souris (<em>Mice</em>). Rat et souris étants des
mammifères (<em>Mammal</em>).</p>

<p>En mimant un langage comme Java, nous allons d’abord créer
une classe de base qui implémente une méthode <code>walk</code>:</p>

<p>``` ruby
class Mammal
  def walk
    raise NotImplementedError
  end
end</p>

<p>Mammal.new.walk
```</p>

<p>Vous remarquez que cette méthode <code>walk</code> soulève une
exception si elle est appelée. Elle n’est ici que pour nous
rappeler que les classes filles devront l’implémenter:</p>

<p><code>raw
$ ruby duck.rb 
duck.rb:3:in `walk': NotImplementedError (NotImplementedError)
</code></p>

<p>Poursuivons le mimétisme Java en créant les classes <code>Rat</code> et
<code>Mice</code> qui héritent de <code>Mammal</code>, et qui donc implémentent
conciencieusement la méthode <code>walk</code></p>

<p>``` ruby
class Mammal
  def walk
    raise NotImplementedError
  end
end</p>

<p>class Rat &lt; Mammal
  def walk
    “I am a Rat and I walk”
  end
end</p>

<p>class Mice &lt; Mammal
  def walk
    “I am a Mice and I walk”
  end
end</p>

<p>puts Rat.new.walk
puts Mice.new.walk
```</p>

<p>Le résultat est celui qu’on attend:</p>

<p><code>raw
$ ruby duck.rb 
I am a Rat and I walk
I am a Mice and I walk
</code></p>

<p>Maintenant ajoutons une classe <code>Laboratory</code> qui a pour rôle
de manipuler nos animaux, en les faisant marcher à la
demande:</p>

<p>``` ruby
class Mammal
  def walk
    raise NotImplementedError
  end
end</p>

<p>class Rat &lt; Mammal
  def walk
    “I am a Rat and I walk”
  end
end</p>

<p>class Mice &lt; Mammal
  def walk
    “I am a Mice and I walk”
  end
end</p>

<p>class Laboratory
  def self.make_walk(pet)
    pet.walk
  end
end</p>

<p>puts Laboratory.make_walk(Rat.new)
puts Laboratory.make_walk(Mice.new)
```</p>

<p><code>raw
$ ruby duck.rb 
I am a Rat and I walk
I am a Mice and I walk
</code></p>

<p>Et là, si vous venez d’un langage orienté objet dit
<em>classique</em>, vous devriez avoir tiqué, fait la grimace,
vous être gratté la barbe, etc. Et oui, la classe
<code>Laboratory</code> n’a <em>aucune connaissance</em> de la classe
<code>Mammal</code>. Et pourtant la ligne <code>pet.walk</code> fonctionne
comme un charme. C’est parce que nous sommes en Ruby,
un langage <em>dynamique</em>. On pourrait dire un langage qui
n’a que faire des <em>types</em> (bon c’est exagéré, hein).</p>

<p>Si <code>Laboratory</code> n’utilise pas <code>Mammal</code>, on pourrait
peut-être carrément la supprimer ?
On essaye :</p>

<p>``` ruby
class Rat
  def walk
    “I am a Rat and I walk”
  end
end</p>

<p>class Mice
  def walk
    “I am a Mice and I walk”
  end
end</p>

<p>class Laboratory
  def self.make_walk(pet)
    pet.walk
  end
end</p>

<p>puts Laboratory.make_walk(Rat.new)
puts Laboratory.make_walk(Mice.new)
```</p>

<p><code>raw
$ ruby duck.rb 
I am a Rat and I walk
I am a Mice and I walk
</code></p>

<p>C’est ça le duck typing. On ne s’intéresse pas à ce
<strong>qu’est</strong> l’objet mais à ce <strong>qu’il sait faire</strong>.</p>

<p>Alors ça ne veut pas dire pour autant que l’héritage est
inutile ou inutilisé avec Ruby. Mais simplement qu’on
va l’utiliser moins qu’ailleurs parce que 1) on peut le
faire et 2) parce qu’on va se concentrer sur le
comportement et pas sur l’être.</p>

<p>Voilà, c’était une explication parmi d’autres du
duck typing.</p>

<script id="fb33k8u">(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>

<p>À demain.</p>

<p></p>

]]></content>
  </entry>
  
</feed>
