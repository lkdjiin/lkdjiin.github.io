<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : gosu | Xavier Nayrac]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/gosu/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2016-02-13T16:37:27+01:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Écrire un jeu en 2d avec Ruby et Gosu - partie 4]]></title>
    <link href="http://lkdjiin.github.io/blog/2016/02/13/ecrire-un-jeu-en-2d-avec-ruby-et-gosu-partie-4/"/>
    <updated>2016-02-13T16:19:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2016/02/13/ecrire-un-jeu-en-2d-avec-ruby-et-gosu-partie-4</id>
    <content type="html"><![CDATA[<p>Dans cet article on va s’occuper de gérer les vies de notre joueur.
On va les afficher et les perdre.</p>

<p><img class="center" src="/images/gosu5.png"></p>

<!-- more -->

<ol>
  <li><a href="/blog/2016/02/10/ecrire-un-jeu-en-2d-avec-ruby-et-gosu-partie-1/">Installation de Gosu, affichage d’images statiques</a></li>
  <li><a href="/blog/2016/02/11/ecrire-un-jeu-en-2d-avec-ruby-et-gosu-partie-2/">Déplacer le joueur et pluie de smileys</a></li>
  <li><a href="/blog/2016/02/12/ecrire-un-jeu-en-2d-avec-ruby-et-gosu-partie-3/">Beep, fonte et collecte des smileys</a></li>
  <li>On s’occupe des vies</li>
</ol>

<h2 id="sourire--lenvers--autre-son-et-pas-de-points">Sourire à l’envers : autre son et pas de points</h2>

<p>Pour l’instant notre joueur collecte tout les smileys. Quel qu’ils soient.
Or, si les smiley oranges (sourire à l’endroit) doivent rapporter des points, les
smileys verts (sourire à l’envers) doivent eux faire perdre une vie à notre joueur.</p>

<p>On va commencer simplement par ne pas augmenter le score et jouer un son
différent quand le joueur entre en collision avec un smiley vert.
Dans la classe Player on charge le nouveau son (<code>life-lost.wav</code>) et on
modifie la méthode <code>collision</code> pour qu’elle réagisse au type du smiley:</p>

<p>```ruby
class Player</p>

<p>def initialize
    # …
    @sound_life_lost = Gosu::Sample.new(“assets/sound/life-lost.wav”)
  end</p>

<p>def collect(items)
    items.reject! {|item| collide?(item) ? collision(item.type) : false }
  end</p>

<p>def collision(type)
    case type
    when :smiley_up
      @score += 10
      @sound_collect.play(1.0)
    when :smiley_down
      @sound_life_lost.play(1.0)
    end</p>

<pre><code>true   end
</code></pre>

<p>end
```</p>

<p>Il ne faut pas oublier d’ajouter une méthode <code>type</code> à la classe Smiley:</p>

<p>```ruby
class Smiley
  attr_reader :x, :y, :type</p>

<p>def initialize(type)
    @type = type
    # …
  end</p>

<p>end
```</p>

<p>Avouez que c’était simple…</p>

<h2 id="afficher-les-vies">Afficher les vies</h2>

<p>L’objectif de cet article est de gérer les vies du joueur. Pour cela,
commençons par lui en donner 3:</p>

<p>```ruby player.rb
class Player</p>

<p># …</p>

<p>attr_reader :score, :lives</p>

<p>def initialize
    # …
    @lives = 3
  end</p>

<p>end
```</p>

<p>Les vies seront affichées au niveau de l’UI, c’est donc dans la classe du même
nom que cela va se passer. Jusqu’ici l’UI n’affichait que le score, et c’était
ce score que recevait en paramètre la méthode <code>draw</code>. On va modifier cela pour
pouvoir afficher le score et les vies.</p>

<p>On charge une nouvelle image, <code>heart.gif</code>, qui va symboliser une vie.
Puis dans <code>draw_lives</code> on affiche autant de <code>heart.gif</code> qu’il y a de vies:</p>

<p>```ruby ui.rb
class UI
  ScoreX = 10
  ScoreY = 10
  ScoreColor = 0xff_ffff00</p>

<p>LivesX = 10
  LivesXShift = 20
  LivesY = 30</p>

<p>def initialize
    @font = Gosu::Font.new(20, name: “assets/fonts/VT323/VT323-Regular.ttf”)
    @heart = Gosu::Image.new(“assets/images/heart.gif”)
  end</p>

<p>def draw(player)
    draw_score(player.score)
    draw_lives(player.lives)
  end</p>

<p>private</p>

<p>def draw_score(score)
    @font.draw(“Score: #{score}”, ScoreX, ScoreY, ZOrder::UI, 1.0, 1.0,
               ScoreColor)
  end</p>

<p>def draw_lives(number)
    number.times do |index|
      @heart.draw(LivesXShift * index + LivesX, LivesY, ZOrder::UI)
    end
  end
end
```</p>

<p>L’affichage des vies commence à la coordonnée x <code>LiveX</code> (soit 10), et se
poursuit en étant décalé à chaque fois de <code>LivesXShift</code> pixels vers la droite (soit 20).</p>

<p>Pour finir, il faut modifier l’appel à <code>UI#draw</code> depuis la classe <code>Window</code>:</p>

<p><code>ruby window.rb
class Window &lt; Gosu::Window
  def draw
    # ...
    @ui.draw(@player)
  end
end
</code></p>

<h2 id="perdre-une-vie">Perdre une vie</h2>

<p>Maintenant qu’on peut comptabiliser et afficher les vies du joueur, on est
prêt à lui en faire perdre. Il n’y a qu’une seule ligne à ajouter:</p>

<p>```ruby
class Player
  def collision(type)
    case type
    when :smiley_up
      @score += 10
      @sound_collect.play(1.0)
    when :smiley_down
      @lives -= 1                # &lt;—————– Ici
      @sound_life_lost.play(1.0)
    end</p>

<pre><code>true   end end ```
</code></pre>

<p>Cette méthode <code>collision</code> est déjà trop longue à mon goût, mais je préfère
attendre qu’elle enfle encore avant d’y remédier. Je veux être certain que
même les plus débutant(e)s d’entre vous puissent voir cette méthode devenir
hors de contrôle avant de proposer une solution qui pourrait être vue comme
trop compliquée dans cette version.</p>

<p>Pour finir, voici le contenu du jeu pour l’instant:</p>

<pre><code>$ tree
.
├── assets
│   ├── fonts
│   │   └── VT323
│   │       ├── OFL.txt
│   │       └── VT323-Regular.ttf
│   ├── images
│   │   ├── background.png
│   │   ├── heart.gif
│   │   ├── player.png
│   │   ├── smiley-green.png
│   │   └── smiley-yellow.png
│   └── sound
│       ├── collect.wav
│       └── life-lost.wav
├── main.rb
├── player.rb
├── smiley.rb
├── ui.rb
├── window.rb
└── z_order.rb
</code></pre>

<p>Le code et les assets se trouvent <a href="https://github.com/lkdjiin/collect-the-smiles">sur Github</a>.
La version précise pour cet article est la <a href="https://github.com/lkdjiin/collect-the-smiles/releases/tag/v0.4.0">version 0.4.0</a>.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Écrire un jeu en 2d avec Ruby et Gosu - partie 3]]></title>
    <link href="http://lkdjiin.github.io/blog/2016/02/12/ecrire-un-jeu-en-2d-avec-ruby-et-gosu-partie-3/"/>
    <updated>2016-02-12T09:49:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2016/02/12/ecrire-un-jeu-en-2d-avec-ruby-et-gosu-partie-3</id>
    <content type="html"><![CDATA[<p>On continue notre jeu en 2d en comptabilisant et en affichant le score.
Au passage on voit aussi comment utiliser une fonte précise et comment jouer
un son.</p>

<p><img class="center" src="/images/gosu4.png"></p>

<!-- more -->

<p>La totalité des articles:</p>

<ol>
  <li><a href="/blog/2016/02/10/ecrire-un-jeu-en-2d-avec-ruby-et-gosu-partie-1/">Installation de Gosu, affichage d’images statiques</a></li>
  <li><a href="/blog/2016/02/11/ecrire-un-jeu-en-2d-avec-ruby-et-gosu-partie-2/">Déplacer le joueur et pluie de smileys</a></li>
  <li>Beep, fonte et collecte des smileys</li>
  <li><a href="/blog/2016/02/13/ecrire-un-jeu-en-2d-avec-ruby-et-gosu-partie-4/">On s’occupe des vies</a></li>
</ol>

<h2 id="beep-et-collecte">Beep et collecte</h2>

<p>Pour donner l’illusion que le joueur attrape un smiley, dès que les deux images
entre en collision on supprime le smiley et on joue un petit son. Le cœur de
la fonctionnalité se passera au sein de la méthode <code>Player#collect</code>, qu’on
déclenchera depuis la classe Window:</p>

<p>```ruby window.rb
class Window &lt; Gosu::Window</p>

<p>def update_player
    # …
    @player.collect(@items)
  end</p>

<p>end
```</p>

<p>Voici ce qui change dans la classe Player. On en discute après:</p>

<p>```ruby player.rb
class Player</p>

<p># …
  DistanceOfCollision = 35</p>

<p>def initialize
    # …
    @sound_collect = Gosu::Sample.new(“assets/sound/collect.wav”)
  end</p>

<p># …</p>

<p>def collect(items)
    items.reject! {|item| collide?(item) ? collision : false }
  end</p>

<p>private</p>

<p>def collide?(item)
    distance = Gosu::distance(x_center_of_mass, y_center_of_mass,
                              item.x_center_of_mass, item.y_center_of_mass)
    distance &lt; DistanceOfCollision
  end</p>

<p>def x_center_of_mass
    @x + @image.width / 2
  end</p>

<p>def y_center_of_mass
    Y + @image.height / 4
  end</p>

<p>def collision
    @sound_collect.play(1.0)
    true
  end
end
```</p>

<p>Tout d’abord, on charge un son comme on charge une image, sauf qu’on utilise
<code>Sample</code> au lieu de <code>Image</code>:</p>

<p><code>ruby
    @sound_collect = Gosu::Sample.new("assets/sound/collect.wav")
</code></p>

<p>Ensuite, la méthode <code>collect</code>. On doit trouver le ou les objets (si il y en a)
qui sont en collision avec le joueur. On teste justement cette éventuelle
collision avec un smiley avec la méthode <code>collide?</code>. Si collision il y a,
l’objet sera supprimé (voir <code>collision</code> plus loin):</p>

<p><code>ruby
  def collect(items)
    items.reject! {|item| collide?(item) ? collision : false }
  end
</code></p>

<blockquote>
  <p>Modifier un objet sans vraiment le dire, par effet de bord, par exemple avec
<code>reject!</code> comme ci-dessus ne manquera pas de remplir d’horreur les tenants de la
programmation fonctionnelle. Mais comme le paradigme ici est la programmation
orienté objet, je ne vois pas de problèmes ;)</p>
</blockquote>

<p>Pour détecter si il y a eu collision entre deux objets, il existe plusieurs
méthodes. Comme Gosu fournit une méthode pour connaître la distance entre deux
points (<code>Gosu::distance</code>), voici ce que nous allons faire: le joueur et les smileys vont être
chacun représentés par un seul point précis. Si la distance entre ses deux points
tombe sous un certain seuil, nous considèrerons qu’il y a collision.</p>

<p>Le joueur est représenté par le point (<code>x_center_of_mass</code>, <code>y_center_of_mass</code>)
et un smiley par le point (<code>item.x_center_of_mass</code>, <code>item.y_center_of_mass</code>):</p>

<p><code>ruby
  def collide?(item)
    distance = Gosu::distance(x_center_of_mass, y_center_of_mass,
                              item.x_center_of_mass, item.y_center_of_mass)
    distance &lt; DistanceOfCollision
  end
</code></p>

<p>Pour le joueur, la coordonnée x utilisée pour la détection de collision est
pile au milieu:</p>

<p><code>ruby
  def x_center_of_mass
    @x + @image.width / 2
  end
</code></p>

<p>Pour la coordonnée y, c’est le quart en partant du haut:</p>

<p><code>ruby
  def y_center_of_mass
    Y + @image.height / 4
  end
</code></p>

<p>Enfin, lors d’une collision il faut émettre un son et retourner <code>true</code> pour que
<code>reject!</code> sache qu’il faut supprimer ce smiley de la collection. Le paramètre
de <code>play</code> est le volume, de 0.0 à 1.0:</p>

<p><code>ruby
  def collision
    @sound_collect.play(1.0)
    true
  end
</code></p>

<p>Le point d’un smiley utilisé pour détecter une collision est le milieu de
la largeur pour x et le haut pour y:</p>

<p>```ruby smiley.rb
class Smiley
  attr_reader :x, :y</p>

<p># …</p>

<p>def x_center_of_mass
    @x + @image.width / 2
  end</p>

<p>def y_center_of_mass
    @y
  end</p>

<p>end
```</p>

<p>N’hésitez pas à modifier ces points de détection ainsi que la constante
<code>DistanceOfCollision</code> pour trouver les valeurs qui vous conviennent.</p>

<h2 id="compter-et-afficher-les-points">Compter et afficher les points</h2>

<p>On va ajouter 10 points quelque soit le type de smiley collecté. Et on va
afficher le score dans le coin supérieur gauche. Les sorties informatives
telles que le score, les vies, etc, seront gérées depuis la classe <code>UI</code>:</p>

<p><code>ruby main.rb
# ...
require_relative 'z_order'
require_relative 'player'
require_relative 'smiley'
require_relative 'ui'
require_relative 'window'
# ...
</code></p>

<p>Un pattern commence à se dessiner, on crée un objet dans l’initialisation de
<code>Window</code> et on appelle sa méthode <code>draw</code>:</p>

<p>```ruby window.rb
class Window &lt; Gosu::Window</p>

<p>def initialize(width, height)
    # …
    @ui = UI.new
    # …
  end</p>

<p>def draw
    # …
    @ui.draw(score: @player.score)
  end</p>

<p>end
```</p>

<p>Les sorties de l’UI doivent être toujours visibles, on leurs donnera donc le
ZOrder le plus grand:</p>

<p>```ruby z_order.rb
module ZOrder</p>

<p>Background = 0
  Items      = 1
  Player     = 2
  UI         = 3</p>

<p>end
```</p>

<p>La classe Player est un bon endroit pour tenir compte du score et le mettre à
jour lors d’une collision avec un smiley:</p>

<p>```ruby player.rb
class Player
  # …</p>

<p>attr_reader :score</p>

<p>def initialize
    # …
    @score = 0
  end</p>

<p>def collision
    @score += 10
    # …
  end</p>

<p>end
```</p>

<p>Finalement voici un peu de nouveauté avec la classe UI et l’utilisation d’une
fonte pour afficher du texte.  Pour info, j’ai trouvé la police
<code>VT323-Regular.ttf</code> sur Google Font.  Le chargement d’une police de caractères
nécessite de fournir la taille et le fichier de la police:</p>

<p>```ruby ui.rb
class UI</p>

<p>def initialize
    @font = Gosu::Font.new(20, name: “assets/fonts/VT323/VT323-Regular.ttf”)
  end</p>

<p>def draw(score:)
    @font.draw(“Score: #{score}”, 10, 10, ZOrder::UI, 1.0, 1.0, 0xff_ffff00)
  end</p>

<p>end
```</p>

<p>Quant à la méthode <code>draw</code> d’une fonte, je vous invite à regarder
<a href="https://www.libgosu.org/rdoc/Gosu/Font.html#draw-instance_method">sa documentation</a>
pour connaître les paramètres à fournir.</p>

<p>Une explication toutefois, ceci:</p>

<pre><code>0xff_ffff00
</code></pre>

<p>…est une couleur au format alpha, rouge, vert, bleu en hexadécimal. Le
<em>underscore</em> est juste une fonctionnalité de Ruby qui permet d’écrire les nombres
avec des underscores pour faciliter la lecture. Par exemple les deux nombres
qui suivent sont identiques, lequel est le plus simple à lire ?</p>

<pre><code>1000000000

1_000_000_000
</code></pre>

<p>Et ça marche pareil avec l’hexadécimal.</p>

<p>Pour finir, voici le contenu du jeu pour l’instant:</p>

<pre><code>$ tree
.
├── assets
│   ├── fonts
│   │   └── VT323
│   │       ├── OFL.txt
│   │       └── VT323-Regular.ttf
│   ├── images
│   │   ├── background.png
│   │   ├── player.png
│   │   ├── smiley-green.png
│   │   └── smiley-yellow.png
│   └── sound
│       └── collect.wav
├── main.rb
├── player.rb
├── smiley.rb
├── ui.rb
├── window.rb
└── z_order.rb
</code></pre>

<p>Le code et les assets se trouvent <a href="https://github.com/lkdjiin/collect-the-smiles">sur Github</a>.
La version précise pour cet article est la <a href="https://github.com/lkdjiin/collect-the-smiles/releases/tag/v0.3.0">version 0.3.0</a>.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Écrire un jeu en 2d avec Ruby et Gosu - partie 2]]></title>
    <link href="http://lkdjiin.github.io/blog/2016/02/11/ecrire-un-jeu-en-2d-avec-ruby-et-gosu-partie-2/"/>
    <updated>2016-02-11T09:40:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2016/02/11/ecrire-un-jeu-en-2d-avec-ruby-et-gosu-partie-2</id>
    <content type="html"><![CDATA[<p>Aujourd’hui on voit comment déplacer et contrôler le joueur, ainsi que
comment faire tomber une pluie de smileys.</p>

<p><img class="center" src="/images/gosu3.png"></p>

<!-- more -->

<p>La totalité des articles:</p>

<ol>
  <li><a href="/blog/2016/02/10/ecrire-un-jeu-en-2d-avec-ruby-et-gosu-partie-1/">Installation de Gosu, affichage d’images statiques</a></li>
  <li>Déplacer le joueur et pluie de smileys</li>
  <li><a href="/blog/2016/02/12/ecrire-un-jeu-en-2d-avec-ruby-et-gosu-partie-3/">Beep, fonte et collecte des smileys</a></li>
  <li><a href="/blog/2016/02/13/ecrire-un-jeu-en-2d-avec-ruby-et-gosu-partie-4/">On s’occupe des vies</a></li>
</ol>

<h2 id="dplacer-le-joueur">Déplacer le joueur</h2>

<p>On ajoute la méthode <code>update</code> à la classe <code>Window</code>. À l’instar de <code>draw</code>
cette méthode vient aussi de <code>Gosu::Window</code> et est appelée régulièrement.
Dans <code>draw</code> on dessine, on affiche. Dans <code>update</code> on calcule, on met à jour
les éléments du jeu.</p>

<blockquote>
  <p><code>update</code> sera appelée 60 fois par seconde quoiqu’il arrive, par contre
<code>draw</code> pourra être appelée plus ou moins souvent suivant les besoins de
l’OS. C’est pour cela qu’il est important de séparer le calcul de l’affichage.
Cette division entre calcul et affichage est d’ailleurs typique d’un framework de jeu,
ou même GUI, quelque soit le langage utilisé.</p>
</blockquote>

<p>Le nouveau code de <code>Window</code> est le suivant:</p>

<p>```ruby window.rb
class Window &lt; Gosu::Window</p>

<p>def initialize(width, height)
    super
    self.caption = “Collect The Smile!”</p>

<pre><code>@background_image = Gosu::Image.new("assets/images/background.png")

@player = Player.new   end
</code></pre>

<p>def update
    @player.go_left if Gosu::button_down?(Gosu::KbLeft)
    @player.go_right if Gosu::button_down?(Gosu::KbRight)</p>

<pre><code>@player.move   end
</code></pre>

<p>def draw
    @background_image.draw(0, 0, ZOrder::Background)
    @player.draw
  end</p>

<p>end
```</p>

<p>Dans <code>update</code> on utilise la méthode <code>button_down?</code> de Gosu pour tester si le
joueur appuit sur la touche gauche et/ou la touche droite. L’appui simultané sur
les deux touches <em>annulera</em> en quelque sorte le déplacement. Et dans tout les cas
on déplace le joueur avec <code>@player.move</code>.</p>

<p>Voyons maintenant la classe <code>Player</code>, qui a gagné plusieurs nouvelles méthodes
par rapport au dernier article:</p>

<p>```ruby player.rb
class Player</p>

<p>Y = 390</p>

<p>def initialize
    @x = WindowHeight / 2
    @velocity = 0.0
    @image = Gosu::Image.new(“assets/images/player.png”)
  end</p>

<p>def draw
    @image.draw(@x, Y, ZOrder::Player)
  end</p>

<p>def go_left
    @velocity -= 0.5
  end</p>

<p>def go_right
    @velocity += 0.5
  end</p>

<p>def move
    @x += @velocity
    @x %= WindowWidth
    @velocity *= 0.96
  end</p>

<p>end
```</p>

<p>Le joueur se déplaçant toujours sur la même ligne, sa coordonnée y ne change
pas, j’en ai donc fait une constante.</p>

<p>L’idée générale pour le déplacement, c’est qu’il soit <em>smooth</em>, avec une
accélération progressive et une glisse finale. On a donc un facteur
d’accélération de 0.5 et un facteur de glisse de 0.96. Prenez le temps de jouer
avec ces valeurs pour les comprendre, et peut-être pour en trouver d’autres qui vous
conviennent mieux.</p>

<p>Comme toujours, nous convertirons ces nombres magiques en constantes:</p>

<p>```ruby player.rb
class Player</p>

<p>Y = 390
  AccelerationFactor = 0.5
  SkidingFactor = 0.96</p>

<p># …</p>

<p>def go_left
    @velocity -= AccelerationFactor
  end</p>

<p>def go_right
    @velocity += AccelerationFactor
  end</p>

<p>def move
    @x += @velocity
    @x %= WindowWidth
    @velocity *= SkidingFactor
  end</p>

<p>end
```</p>

<h2 id="une-pluie-de-smileys">Une pluie de smileys</h2>

<p>Il est temps de faire pleuvoir des smileys !</p>

<p>Ajoutez un fichier <code>smiley.rb</code>:</p>

<p>```ruby main.rb
require ‘gosu’</p>

<p>require_relative ‘z_order’
require_relative ‘player’
require_relative ‘smiley’
require_relative ‘window’</p>

<h1 id="section">…</h1>
<p>```</p>

<p>Et remplissez le avec le code suivant:</p>

<p>```ruby smiley.rb
class Smiley
  attr_reader :y</p>

<p>def initialize(type)
    @image = if type == :smiley_up
               Gosu::Image.new(“assets/images/smiley-yellow.png”)
             elsif type == :smiley_down
               Gosu::Image.new(“assets/images/smiley-green.png”)
             end</p>

<pre><code>@velocity = Gosu::random(0.8, 3.3)

@x = rand * (WindowWidth - @image.width)
@y = 0   end
</code></pre>

<p>def update
    @y += @velocity
  end</p>

<p>def draw
    @image.draw(@x, @y, ZOrder::Items)
  end</p>

<p>end
```</p>

<p>Il n’y a rien de vraiment nouveau par rapport à ce qu’on a vu jusqu’ici.
Je peux toutefois signaler la méthode <code>Gosu::random(0.8, 3.3)</code>, qui retourne
un Float entre 0.8 inclus et 3.3 exclus. Et aussi le calcul de <code>@x</code>:</p>

<pre><code>@x = rand * (WindowWidth - @image.width)
</code></pre>

<p>qui soustrait la largeur du smiley de la largeur de la fenêtre pour s’assurer
qu’un smiley sera toujours dans les limites de la fenêtre (visible, donc).</p>

<p>Pour intégrer les smileys au jeu, vous devez modifier les méthodes
<code>initialize</code>, <code>update</code> et <code>draw</code> de la classe Window:</p>

<p>```ruby window.rb
class Window &lt; Gosu::Window</p>

<p>def initialize(width, height)</p>

<pre><code># ...

@items = []   end
</code></pre>

<p>def update
    unless @items.size &gt;= 15
      r = rand
      if r &lt; 0.035
        @items.push(Smiley.new(:smiley_up))
      elsif r &lt; 0.040
        @items.push(Smiley.new(:smiley_down))
      end
    end
    @items.each(&amp;:update)
    @items.reject! {|item| item.y &gt; WindowHeight }</p>

<pre><code># Les 3 lignes suivantes sont décrites dans l'article précédent.
@player.go_left if Gosu::button_down?(Gosu::KbLeft)
@player.go_right if Gosu::button_down?(Gosu::KbRight)
@player.move   end
</code></pre>

<p>def draw
    @background_image.draw(0, 0, ZOrder::Background)</p>

<pre><code># Ça c'est la nouvelle ligne:
@items.each(&amp;:draw)

@player.draw   end
</code></pre>

<p>end
```</p>

<p>La nouvelle méthode <code>update</code> mérite bien quelques explications !
Tout d’abord je veux afficher un maximum de 15 smileys à l’écran:</p>

<p><code>ruby
  def update
    if @items.size &lt; 15
</code></p>

<p>S’il y en a moins de 15, il y a <em>à chaque update</em> 3.5% de chances (0.035)
de créer un sourire à l’endroit, et 0.5% de chances (0.04 - 0.035) de créer un
sourire à l’envers:</p>

<p><code>ruby
      r = rand
      if r &lt; 0.035
        @items.push(Smiley.new(:smiley_up))
      elsif r &lt; 0.040
        @items.push(Smiley.new(:smiley_down))
      end
    end
</code></p>

<p>Dans tous les cas on met à jour les smileys existants (c’est à dire qu’on change leur
coordonnée y):</p>

<p><code>ruby
    @items.each(&amp;:update)
</code></p>

<p>Et on supprime les smileys qui sont sortit de la fenêtre de jeu (par le bas):</p>

<p><code>ruby
    @items.reject! {|item| item.y &gt; WindowHeight }
</code></p>

<p>Ce code est hideux et il faut faire quelque chose pour lui ;)
On commence le refactoring de la classe Window en extrayant les deux méthodes
<code>update_items</code> et <code>update_player</code>:</p>

<p>```ruby window.rb
class Window
  # …</p>

<p>def update
    update_items
    update_player
  end</p>

<p>private</p>

<p>def update_items
    unless @items.size &gt;= 15
      r = rand
      if r &lt; 0.035
        @items.push(Smiley.new(:smiley_up))
      elsif r &lt; 0.040
        @items.push(Smiley.new(:smiley_down))
      end
    end
    @items.each(&amp;:update)
    @items.reject! {|item| item.y &gt; WindowHeight }
  end</p>

<p>def update_player
    @player.go_left if Gosu::button_down?(Gosu::KbLeft)
    @player.go_right if Gosu::button_down?(Gosu::KbRight)
    @player.move
  end</p>

<p>end
```</p>

<p>La nouvelle méthode <code>update_items</code> mérite aussi sa petite extraction:</p>

<p>```ruby window.rb
  def update_items
    populate_items
    @items.each(&amp;:update)
    @items.reject! {|item| item.y &gt; WindowHeight }
  end</p>

<p>def populate_items
    return if @items.size &gt;= 15</p>

<pre><code>type = rand
if type &lt; 0.035
  @items.push(Smiley.new(:smiley_up))
elsif type &lt; 0.040
  @items.push(Smiley.new(:smiley_down))
end   end ```
</code></pre>

<p>Maintenant <code>populate_items</code> est toujours moche, et on sent que cette méthode
risque d’enfler dans l’avenir. Mais je pense que c’est le moment d’arrêter le refactoring
pour éviter de tomber dans l’<a href="https://en.wikipedia.org/wiki/Overengineering">overengineering</a>
et aussi parce que
<a href="http://martinfowler.com/bliki/Yagni.html">YAGNI</a> !.</p>

<p>Pour finir, voici le contenu du jeu pour l’instant:</p>

<pre><code>$ tree
.
├── assets
│   └── images
│       ├── background.png
│       ├── player.png
│       ├── smiley-green.png
│       └── smiley-yellow.png
├── main.rb
├── player.rb
├── smiley.rb
├── window.rb
└── z_order.rb
</code></pre>

<p>Le code et les assets se trouvent <a href="https://github.com/lkdjiin/collect-the-smiles">sur Github</a>.
La version précise pour cet article est la <a href="https://github.com/lkdjiin/collect-the-smiles/releases/tag/v0.2.0">version 0.2.0</a>.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Écrire un jeu en 2d avec Ruby et Gosu - partie 1]]></title>
    <link href="http://lkdjiin.github.io/blog/2016/02/10/ecrire-un-jeu-en-2d-avec-ruby-et-gosu-partie-1/"/>
    <updated>2016-02-10T10:44:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2016/02/10/ecrire-un-jeu-en-2d-avec-ruby-et-gosu-partie-1</id>
    <content type="html"><![CDATA[<p>Voici une série d’articles sur l’écriture d’un jeu en 2d avec Ruby et Gosu.
Dans ce premier article on verra comment installer Gosu, créer une
fenêtre et afficher des images statiques les unes au dessus des autres.</p>

<p><img class="center" src="/images/gosu0.png"></p>

<!-- more -->

<p>La totalité des articles:</p>

<ol>
  <li>Installation de Gosu, affichage d’images statiques</li>
  <li><a href="/blog/2016/02/11/ecrire-un-jeu-en-2d-avec-ruby-et-gosu-partie-2/">Déplacer le joueur et pluie de smileys</a></li>
  <li><a href="/blog/2016/02/12/ecrire-un-jeu-en-2d-avec-ruby-et-gosu-partie-3/">Beep, fonte et collecte des smileys</a></li>
  <li><a href="/blog/2016/02/13/ecrire-un-jeu-en-2d-avec-ruby-et-gosu-partie-4/">On s’occupe des vies</a></li>
</ol>

<h2 id="les-outils">Les outils</h2>

<p>Avant d’écrire la première ligne de code, assurez vous d’avoir installé correctement Ruby et la
gem Gosu.</p>

<h3 id="ruby">Ruby</h3>

<p>J’utiliserai Ruby en version 2.3 (la plus récente à ce jour). Si vous
utilisez une version de Ruby plus ancienne, vous devrez peut-être adapter le
code ici ou là. Pour gérer les différentes version de Ruby, j’utilise
indifféremment <a href="https://rvm.io/">rvm</a> ou
<a href="https://github.com/postmodern/chruby">chruby</a>
<em>— mais pas les deux sur la même machine, hein ;) —</em>.</p>

<blockquote>
  <p>Si vous n’avez jamais utilisé de gestionnaire de version pour Ruby, je
conseille de commencer par <strong>chruby</strong>. Si je préfère personnellement
<strong>rvm</strong> que je trouve plus complet, <strong>chruby</strong> s’avère
indéniablement plus simple à installer, à prendre en main, et à utiliser sur le
long terme.</p>
</blockquote>

<h3 id="gosu">Gosu</h3>

<p>Gosu est la gem qui nous fournira les méthodes basiques pour développer notre
jeu. J’ai installé la dernière version en date : gosu 0.10.5.</p>

<p>Sur <strong>Debian</strong> il faut d’abord s’assurer qu’on dispose des packages suivants:</p>

<pre><code>sudo apt-get install build-essential libsdl2-dev libsdl2-ttf-dev \
                     libpango1.0-dev libgl1-mesa-dev libfreeimage-dev \
                     libopenal-dev libsndfile1-dev
</code></pre>

<p>Et ensuite seulement on peut installer la gem Gosu:</p>

<pre><code>gem install gosu
</code></pre>

<p>Vous pouvez installer Gosu sur d’autres versions de Linux, sur OS X, ou sur
Windows:</p>

<ul>
  <li><a href="https://github.com/gosu/gosu/wiki/Getting-Started-on-Linux">Installation sur Linux</a></li>
  <li><a href="https://github.com/gosu/gosu/wiki/Getting-Started-on-OS-X">Installation sur OS X</a></li>
  <li><a href="https://github.com/gosu/gosu/wiki/Getting-Started-on-Windows">Installation sur Windows</a></li>
</ul>

<p>Enfin, vous pourrez trouver de l’aide sur <a href="https://github.com/gosu/gosu/wiki">le wiki</a>
et <a href="https://www.libgosu.org/rdoc/">la documentation de Gosu</a> pour le langage Ruby.</p>

<h2 id="du-son-des-images-etc">Du son, des images, etc</h2>

<p>Dans cette série d’articles nous allons coder un jeu. Pour ce qui est du son
et des images, on va laisser faire les gens qui savent ;) Mes deux sources
préférées pour les assets open source sont <a href="http://freesound.org/browse/">freesound.org</a>
et <a href="http://opengameart.org/">opengameart.org</a>.</p>

<p>J’utilise <strong>Gimp</strong> pour retoucher les images : découpe, mise à l’échelle,
changement de couleur, etc. Et j’utilise <strong>Audacity</strong> pour retravailler les
fichiers sonores : suppression des silences en début de fichier, conversion de
format (par exemple mp3 en ogg puisque Gosu ne lit pas le mp3).</p>

<h2 id="crer-une-fentre-pour-le-jeu">Créer une fenêtre pour le jeu</h2>

<p>Ça y est ! Ruby et Gosu sont installés, vous savez où trouver des images et du
son open source, on peut commencer en créant une fenêtre. Mettez le code
suivant dans un fichier <code>window.rb</code>:</p>

<p>```ruby window.rb
require ‘gosu’</p>

<p>class Window &lt; Gosu::Window</p>

<p>def initialize
    super(640, 480)
    self.caption = “Collect The Smile!”
  end</p>

<p>end</p>

<p>window = Window.new
window.show
```</p>

<p>Le code est suffisamment simple pour que vous puissiez le comprendre sans
explications superflues. Pour savoir si vous avez bien installé Gosu, lancez
le programme:</p>

<pre><code>$ ruby window.rb
</code></pre>

<p>Et admirez le résultat:</p>

<p><img class="center" src="/images/gosu1.png"></p>

<p>Même avec si peu de code, on peut déjà refactorer. Le fichier précédent
a deux problèmes. Un, il mélange la définition d’une classe et le lancement du
jeu. Et deux, il utilise deux nombres magiques. Si on n’y prends pas garde, les
nombres magiques vont vite devenir un fléau pour notre jeu. Les jeux ont tendance
à être saturés de nombres magiques, alors autant s’atteler à ce problème dès le début.</p>

<p>Après refactoring,
nous avons donc d’une part le code de lancement, avec des constantes pour les
dimensions.  On n’a plus à deviner ce que représente les nombres 640 et 480,
c’est inscrit dans le code:</p>

<p>```ruby main.rb
require ‘gosu’</p>

<p>require_relative ‘window’</p>

<p>WindowWidth  = 640
WindowHeight = 480</p>

<p>window = Window.new(WindowWidth, WindowHeight)
window.show
```</p>

<p>Et d’autre part la classe <code>Window</code>, tranquille dans son propre fichier:</p>

<p>```ruby window.rb
class Window &lt; Gosu::Window</p>

<p>def initialize(width, height)
    super
    self.caption = “Collect The Smile!”
  end</p>

<p>end
```</p>

<p>La structure du dossier est pour l’instant la suivante:</p>

<pre><code>$ tree
.
├── window.rb
└── main.rb
</code></pre>

<p>Et nous lancerons donc le jeu avec la commande <code>ruby main.rb</code>.</p>

<h2 id="afficher-des-images">Afficher des images</h2>

<p>Maintenant qu’on sait créer une fenêtre, l’étape suivante sera l’affichage
d’images statiques. Nous allons afficher une image de fond, et par-dessus
l’image du joueur.</p>

<p>Toutes les images du jeu seront rangées dans le dossier <code>assets/images</code>:</p>

<pre><code>$ tree
.
├── assets
│   └── images
│       ├── background.png
│       └── player.png
├── window.rb
└── main.rb
</code></pre>

<p>```ruby window.rb
class Window &lt; Gosu::Window</p>

<p>def initialize(width, height)
    super
    self.caption = “Collect The Smile!”</p>

<pre><code>@background_image = Gosu::Image.new("assets/images/background.png")
@player_image = Gosu::Image.new("assets/images/player.png")   end
</code></pre>

<p>def draw
    @background_image.draw(0, 0, 0)
    @player_image.draw(width / 2, height / 2, 1)
  end</p>

<p>end
```</p>

<p>Pendant l’initialisation on charge les images en mémoire avec
<code>Gosu::Image.new</code>.  Puis l’affichage se fait avec <strong>les</strong> méthodes <code>draw</code>. La
méthode <code>draw</code> de la classe <code>Window</code> est hérité de <code>Gosu::Window</code> et appelée 60
fois par seconde.  Dans cette méthode, on appelle la méthode <code>draw</code> des images.
Celle-ci prends trois paramètres : les coordonnées <strong>x</strong>, <strong>y</strong> et <strong>z</strong>.
La coordonnée z est le plan d’affichage. Au dessus ou en dessous. Plus le
nombre est haut, plus l’image sera affichée au-dessus des autres. Ici l’image
de fond a un z de 0, et l’image du joueur a un z de 1, donc le joueur est
affiché au-dessus du fond.</p>

<p>Le joueur est affiché <em>à peu près</em> au milieu de la surface de jeu (<code>width / 2</code>
et <code>height / 2</code>). À peu près, puisque les paramètres x et y de la méthode
<code>draw</code> définissent les coordonnées du coin supérieur gauche de l’image.</p>

<p><img class="center" src="/images/gosu2.png"></p>

<p>Ce code souffre lui aussi de certains problèmes.</p>

<ol>
  <li>S’il est acceptable que l’image de fond <em>appartienne</em> à la fenêtre de jeu,
c’est absurde en ce qui concerne l’image du joueur.</li>
  <li>Il y a des nouveaux nombres magiques : les coordonnées z.</li>
</ol>

<p>On va donc créer deux nouvelles classes (en fait une classe et un module),
<code>ZOrder</code> et <code>Player</code>:</p>

<p>```ruby main.rb
require ‘gosu’</p>

<p>require_relative ‘z_order’
require_relative ‘player’
require_relative ‘window’</p>

<p>WindowWidth  = 640
WindowHeight = 480</p>

<p>window = Window.new(WindowWidth, WindowHeight)
window.show
```</p>

<p>Le contenu du module <code>ZOrder</code> est simpliste (c’est ni plus ni moins qu’un enum),
il définit les différents plans:</p>

<p>```ruby z_order.rb
module ZOrder</p>

<p>Background = 0
  Player     = 1</p>

<p>end
```</p>

<p>La classe <code>Player</code> est simple elle aussi.</p>

<blockquote>
  <p>C’est l’avantage écrasant d’éclater le code en petites classes ayant chacune
une seule responsabilité : le code devient simplissime.</p>
</blockquote>

<p>L’image <em>appartient</em> désormais au joueur, tout comme ses coordonnées. Et c’est
le joueur lui-même qui <em>sait</em> comment s’afficher. La classe <code>Window</code> aura
juste à déclencher cet affichage.</p>

<p>```ruby player.rb
class Player</p>

<p>def initialize(x, y)
    @x = x
    @y = y
    @image = Gosu::Image.new(“assets/images/player.png”)
  end</p>

<p>def draw
    @image.draw(@x, @y, ZOrder::Player)
  end</p>

<p>end
```</p>

<p>```ruby window.rb
class Window &lt; Gosu::Window</p>

<p>def initialize(width, height)
    super
    self.caption = “Collect The Smile!”</p>

<pre><code>@background_image = Gosu::Image.new("assets/images/background.png")

@player = Player.new(width / 2, height / 2)   end
</code></pre>

<p>def draw
    @background_image.draw(0, 0, ZOrder::Background)
    @player.draw
  end</p>

<p>end
```</p>

<p>Pour finir, voici le contenu du jeu pour l’instant:</p>

<pre><code>$ tree
.
├── assets
│   └── images
│       ├── background.png
│       └── player.png
├── main.rb
├── player.rb
├── window.rb
└── z_order.rb
</code></pre>

<p>Le code et les assets se trouvent <a href="https://github.com/lkdjiin/collect-the-smiles">sur Github</a>.
La version précise pour cet article est la <a href="https://github.com/lkdjiin/collect-the-smiles/releases/tag/v0.1.0">version 0.1.0</a>.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
