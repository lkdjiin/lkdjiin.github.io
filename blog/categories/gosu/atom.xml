<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : gosu | Xavier Nayrac]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/gosu/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2018-07-21T09:20:07+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Écrire un jeu en 2d avec Ruby et Gosu - partie 7]]></title>
    <link href="http://lkdjiin.github.io/blog/2016/05/01/ecrire-un-jeu-en-2d-avec-ruby-et-gosu-partie-7/"/>
    <updated>2016-05-01T09:29:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2016/05/01/ecrire-un-jeu-en-2d-avec-ruby-et-gosu-partie-7</id>
    <content type="html"><![CDATA[<p>Ça fait plus de 2 mois que je dois terminer ce jeu et cette série d’article, alors au boulot !</p>

<p>Pour cette nouvelle version je voudrais ajouter une musique différente pour le
game over.  Et aussi pouvoir enfin recommencer une nouvelle partie après
un <em>game over</em>.</p>

<p><img class="center" src="/images/gosu8.png"></p>

<!-- more -->

<p>La totalité des articles:</p>

<ol>
  <li><a href="/blog/2016/02/10/ecrire-un-jeu-en-2d-avec-ruby-et-gosu-partie-1/">Installation de Gosu, affichage d’images statiques</a></li>
  <li><a href="/blog/2016/02/11/ecrire-un-jeu-en-2d-avec-ruby-et-gosu-partie-2/">Déplacer le joueur et pluie de smileys</a></li>
  <li><a href="/blog/2016/02/12/ecrire-un-jeu-en-2d-avec-ruby-et-gosu-partie-3/">Beep, fonte et collecte des smileys</a></li>
  <li><a href="/blog/2016/02/13/ecrire-un-jeu-en-2d-avec-ruby-et-gosu-partie-4/">On s’occupe des vies</a></li>
  <li><a href="/blog/2016/02/15/ecrire-un-jeu-en-2d-avec-ruby-et-gosu-partie-5/">Musique et game over</a></li>
  <li><a href="/blog/2016/02/25/ecrire-un-jeu-en-2d-avec-ruby-et-gosu-partie-6/">Affichage selon un angle</a></li>
  <li>Plusieurs musiques et reset de la partie</li>
</ol>

<h2 id="plusieurs-musiques">Plusieurs musiques</h2>

<p>Nous allons devoir gérer plusieurs musiques. Donnons leur des noms plus simple
à manipuler que leurs <em>paths</em> :</p>

<p><code>ruby song.rb
module Song
  GameOver = "assets/songs/In early time.ogg"
  Level1   = "assets/songs/Around the Bend.ogg"
end
</code></p>

<p>Et avec quoi écoute-t-on de la musique ? Avec un <em>song player</em> :</p>

<p><code>ruby song_player.rb
class SongPlayer
  def play(file)
    @song.stop if @song
    @song = Gosu::Song.new(file)
    @song.volume = 0.25
    @song.play(true)
  end
end
</code></p>

<p>Dans la classe <code>Window</code> on remplace l’ancienne manière de jouer une musique :</p>

<p><code>ruby
@song = Gosu::Song.new("assets/songs/Around the Bend.ogg")
@song.volume = 0.25
@song.play(true)
</code></p>

<p>par notre nouvelle abstraction :</p>

<p><code>ruby
@song_player = SongPlayer.new
@song_player.play(Song::Level1)
</code></p>

<p>N’oubliez pas d’ajouter les require qui vont bien dans le fichier <code>main.rb</code> :</p>

<p><code>ruby main.rb
require_relative 'song'
require_relative 'song_player'
</code></p>

<p>Trouver un bon endroit où mettre le code pour changer la musique après un
<em>game over</em> n’est pas si 
évident que ça. Le moment où l’on capte que le jeu est dans l’état game over est
la méthode <code>update_player</code> :</p>

<p><code>ruby
def update_player
  @player.update(@items)
  @game_over = true if @player.lives &lt;= 0
end
</code></p>

<p>Et il semblerait vraiment bizarre de modifier la musique alors qu’on est
sensé mettre à jour le joueur. Autrement dit, le code suivant ne me plait pas :</p>

<p><code>ruby
def update_player
  @player.update(@items)
  if @player.lives &lt;= 0
    @game_over = true
    @song_player.play(Song::GameOver)
  end
end
</code></p>

<p>À bien y réfléchir, le problème vient d’avant. On ne devrait pas changer l’état
de <code>@game_over</code> ici, mais plutôt dans la méthode <code>update</code> :</p>

<p>```ruby window.rb
class Window &lt; Gosu::Window
  def update
    return if @game_over</p>

<pre><code>@game_over = true if @player.lives &lt;= 0
update_items
update_player   end
</code></pre>

<p>def update_player
    @player.update(@items)
  end
end
```</p>

<p>Changer la musique se fera donc de cette manière :</p>

<p>```ruby
def update
  return if @game_over</p>

<p>if @player.lives &lt;= 0
    @game_over = true
    @song_player.play(Song::GameOver)
  end</p>

<p>update_items
  update_player
end
```</p>

<p>Après extraction d’une nouvelle méthode, nous obtenons un code plus clair :</p>

<p>```ruby
def update
  return if @game_over</p>

<p>update_game_over
  update_items
  update_player
end</p>

<p>def update_game_over
  return unless @player.lives &lt;= 0</p>

<p>@game_over = true
  @song_player.play(Song::GameOver)
end
```</p>

<h2 id="nouvelle-partie">Nouvelle partie</h2>

<p>Ok, il est temps maintenant de pouvoir jouer une nouvelle partie après un
game over. Pour cela, il faut regarder si le joueur appuie sur la touche
espace pendant l’état game over, et dans ce cas faire un reset :</p>

<p>```ruby
def update
  reset if @game_over &amp;&amp; Button.space?</p>

<p>return if @game_over</p>

<p>update_game_over
  update_items
  update_player
end
```</p>

<p>On peut tout de suite extraire une méthode <code>new_game?</code> :</p>

<p>```ruby
def update
  reset if new_game?
  # […]
end</p>

<p>def new_game?
  @game_over &amp;&amp; Button.space?
end
```</p>

<p>On peut maintenant réfléchir à la méthode <code>reset</code>, qui a son tour appellera
la méthode <code>reset</code> du joueur. Ces deux méthodes sont évidentes :</p>

<p><code>ruby window.rb
class Window &lt; Gosu::Window
  def reset
    @items = []
    @player.reset
    @song_player.play(Song::Level1)
    @game_over = false
  end
end
</code></p>

<p><code>ruby player.rb
class Player
  def reset
    @score = 0
    @lives = 3
    @angle = 0.0
    @velocity = 0.0
  end
end
</code></p>

<p>Pour terminer cette version, on va ajouter un message «press space to start»
qui bouge pour attirer l’attention. Pour ça, on varie régulièrement d’une
petite quantité la coordonnée <strong>y</strong> du message.</p>

<p>```ruby
class UI
  # …
  PressSpaceLow = 210
  PressSpaceHigh = 270</p>

<p>def initialize
    # …
    @y = 240
    @y_velocity = -0.3
  end</p>

<p>private</p>

<p>def draw_game_over
    @big_font.draw_rel(“Game Over”, WindowWidth / 2, WindowHeight / 3,
                       ZOrder::UI, 0.5, 0.5)
    @big_font.draw_rel(“Press Space To Start”, WindowWidth / 2, y,
                       ZOrder::UI, 0.5, 0.5)
  end</p>

<p>def y
    @y += y_velocity
  end</p>

<p>def y_velocity
    if @y &lt; PressSpaceLow || @y &gt; PressSpaceHigh
      @y_velocity = -@y_velocity
    end
    @y_velocity
  end
end
```</p>

<p>Pour finir, voici le contenu du jeu pour l’instant:</p>

<pre><code>$ tree
.
├── assets
│   ├── fonts
│   │   └── VT323
│   │       ├── OFL.txt
│   │       └── VT323-Regular.ttf
│   ├── images
│   │   ├── background.png
│   │   ├── heart.gif
│   │   ├── player.png
│   │   ├── smiley-green.png
│   │   └── smiley-yellow.png
│   ├── songs
│   │   ├── Around the Bend.ogg
│   │   └── In early time.ogg
│   └── sound
│       ├── collect.wav
│       └── life-lost.wav
├── button.rb
├── main.rb
├── player.rb
├── smiley.rb
├── song_player.rb
├── song.rb
├── ui.rb
├── window.rb
└── z_order.rb
</code></pre>

<p>Le code et les assets se trouvent <a href="https://github.com/lkdjiin/collect-the-smiles">sur Github</a>.
La version précise pour cet article est la <a href="https://github.com/lkdjiin/collect-the-smiles/releases/tag/v0.7.0">version 0.7.0</a>.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Écrire un jeu en 2d avec Ruby et Gosu - partie 6]]></title>
    <link href="http://lkdjiin.github.io/blog/2016/02/25/ecrire-un-jeu-en-2d-avec-ruby-et-gosu-partie-6/"/>
    <updated>2016-02-25T11:37:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2016/02/25/ecrire-un-jeu-en-2d-avec-ruby-et-gosu-partie-6</id>
    <content type="html"><![CDATA[<p>Pour augmenter l’effet dramatique lorsque le joueur perd une vie, je voudrais
que celui-ci se mette à tourner sur lui-même. Pour ça, on affichera l’image du
joueur selon un certain angle, et cet angle sera mis à jour à chaque appel de
<code>update</code>. Voyons cela pas à pas.</p>

<p><img class="center" src="/images/gosu7.png"></p>

<!-- more -->

<p>La totalité des articles:</p>

<ol>
  <li><a href="/blog/2016/02/10/ecrire-un-jeu-en-2d-avec-ruby-et-gosu-partie-1/">Installation de Gosu, affichage d’images statiques</a></li>
  <li><a href="/blog/2016/02/11/ecrire-un-jeu-en-2d-avec-ruby-et-gosu-partie-2/">Déplacer le joueur et pluie de smileys</a></li>
  <li><a href="/blog/2016/02/12/ecrire-un-jeu-en-2d-avec-ruby-et-gosu-partie-3/">Beep, fonte et collecte des smileys</a></li>
  <li><a href="/blog/2016/02/13/ecrire-un-jeu-en-2d-avec-ruby-et-gosu-partie-4/">On s’occupe des vies</a></li>
  <li><a href="/blog/2016/02/15/ecrire-un-jeu-en-2d-avec-ruby-et-gosu-partie-5/">Musique et game over</a></li>
  <li>Affichage selon un angle</li>
  <li><a href="/blog/2016/05/01/ecrire-un-jeu-en-2d-avec-ruby-et-gosu-partie-7/">Plusieurs musiques et reset de la partie</a></li>
</ol>

<h2 id="affichage-selon-un-angle">Affichage selon un angle</h2>

<p>Il nous faut d’abord un angle:</p>

<p><code>ruby player.rb
  def initialize
    # ...
    @angle = 0.0
  end
</code></p>

<p>Ensuite nous ajoutons une méthode <code>update</code> à la classe Player. Quand le joueur
vient de perdre une vie, la seule chose à mettre à jour est l’angle. Dans les
autres cas, on fait la même mise à jour qu’avant:</p>

<p><code>ruby player.rb
  def update(items)
    just_lost_a_life? ? update_angle : update_general(items)
  end
</code></p>

<p>La mise à jour de l’angle d’affichage de l’image du joueur ne demande pas
d’explications:</p>

<p><code>ruby player.rb
  def update_angle
    @angle += 10
  end
</code></p>

<p>En ce qui concerne la mise à jour générale, j’ai effectué un petit refactoring
pour passer dans la classe Player du code venant de la classe Window, et qui
n’avait pas à s’y trouver. Au passage j’ai aussi créé le module <code>Button</code> qu’on
verra plus tard:</p>

<p><code>ruby player.rb
  def update_general(items)
    go_left if Button.left?
    go_right if Button.right?
    move
    collect(items)
  end
</code></p>

<p>On peut maintenant regarder l’affichage. Pour afficher une image selon un
certain angle, Gosu propose la méthode <code>draw_rot</code>. L’image sera orientée par
rapport à un point précis, ici je choisi le centre de l’image:</p>

<p>```ruby player.rb
  def draw
    if just_lost_a_life?
      @image.draw_rot(x_middle, y_middle, ZOrder::Player, @angle)
    else
      @image.draw(@x, Y, ZOrder::Player)
    end
  end</p>

<p>alias_method :x_middle, :x_center_of_mass</p>

<p>def y_middle
    Y + @image.height / 2
  end
```</p>

<p>Voici tout ce qui change dans la classe <code>Player</code> en un coup d’œil:</p>

<p>```ruby
class Player</p>

<p>def initialize
    # …
    @angle = 0.0
  end</p>

<p>def update(items)
    just_lost_a_life? ? update_angle : update_general(items)
  end</p>

<p>def draw
    if just_lost_a_life?
      @image.draw_rot(x_middle, y_middle, ZOrder::Player, @angle)
    else
      @image.draw(@x, Y, ZOrder::Player)
    end
  end</p>

<p>alias_method :x_middle, :x_center_of_mass</p>

<p>def y_middle
    Y + @image.height / 2
  end</p>

<p>def update_angle
    @angle += 10
  end</p>

<p>def update_general(items)
    go_left if Button.left?
    go_right if Button.right?
    move
    collect(items)
  end</p>

<p>end
```</p>

<p>Voici maintenant le contenu du module <code>Button</code>:</p>

<p>```ruby
module Button</p>

<p>def self.left?
    Gosu::button_down?(Gosu::KbLeft)
  end</p>

<p>def self.right?
    Gosu::button_down?(Gosu::KbRight)
  end</p>

<p>end
```</p>

<p>On peut légitimement se demander «Mais pourquoi ajouter un tel module ?».
Simplement parce que je préfère 100 fois lire ceci:</p>

<pre><code>do_this if Button.left?
</code></pre>

<p>… plutôt que cela:</p>

<pre><code>do_this if Gosu::button_down?(Gosu::KbLeft)
</code></pre>

<p>Voyons enfin ce qui change dans la classe Window.
J’ai déplacé la ligne <code>return if @player.just_lost_a_life?</code> de la méthode
<code>update</code> vers la méthode <code>update_items</code>. Ainsi la méthode <code>update_player</code> est
toujours appelée et peut changer l’angle d’affichage du joueur:</p>

<p>```ruby
class Window &lt; Gosu::Window
  def update
    return if @game_over</p>

<pre><code>update_items
update_player   end
</code></pre>

<p>def update_items
    return if @player.just_lost_a_life?
    # …
  end</p>

<p>def update_player
    @player.update(@items)
    @game_over = true if @player.lives &lt;= 0
  end</p>

<p>end
```</p>

<p>Pour finir, voici le contenu du jeu pour l’instant:</p>

<pre><code>$ tree
.
├── assets
│   ├── fonts
│   │   └── VT323
│   │       ├── OFL.txt
│   │       └── VT323-Regular.ttf
│   ├── images
│   │   ├── background.png
│   │   ├── heart.gif
│   │   ├── player.png
│   │   ├── smiley-green.png
│   │   └── smiley-yellow.png
│   ├── songs
│   │   └── Around the Bend.ogg
│   └── sound
│       ├── collect.wav
│       └── life-lost.wav
├── button.rb
├── main.rb
├── player.rb
├── smiley.rb
├── ui.rb
├── window.rb
└── z_order.rb
</code></pre>

<p>Le code et les assets se trouvent <a href="https://github.com/lkdjiin/collect-the-smiles">sur Github</a>.
La version précise pour cet article est la <a href="https://github.com/lkdjiin/collect-the-smiles/releases/tag/v0.6.0">version 0.6.0</a>.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Écrire un jeu en 2d avec Ruby et Gosu - partie 5]]></title>
    <link href="http://lkdjiin.github.io/blog/2016/02/15/ecrire-un-jeu-en-2d-avec-ruby-et-gosu-partie-5/"/>
    <updated>2016-02-15T09:12:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2016/02/15/ecrire-un-jeu-en-2d-avec-ruby-et-gosu-partie-5</id>
    <content type="html"><![CDATA[<p>Aujourd’hui on ajoute de la musique de fond, on s’intéresse à ce qui se passe
quand on perd une vie, et on écrit un beau «Game Over» quand on a perdu toutes
les vies.</p>

<p><img class="center" src="/images/gosu6.png"></p>

<!-- more -->

<p>La totalité des articles:</p>

<ol>
  <li><a href="/blog/2016/02/10/ecrire-un-jeu-en-2d-avec-ruby-et-gosu-partie-1/">Installation de Gosu, affichage d’images statiques</a></li>
  <li><a href="/blog/2016/02/11/ecrire-un-jeu-en-2d-avec-ruby-et-gosu-partie-2/">Déplacer le joueur et pluie de smileys</a></li>
  <li><a href="/blog/2016/02/12/ecrire-un-jeu-en-2d-avec-ruby-et-gosu-partie-3/">Beep, fonte et collecte des smileys</a></li>
  <li><a href="/blog/2016/02/13/ecrire-un-jeu-en-2d-avec-ruby-et-gosu-partie-4/">On s’occupe des vies</a></li>
  <li>Musique et game over</li>
  <li><a href="/blog/2016/02/25/ecrire-un-jeu-en-2d-avec-ruby-et-gosu-partie-6/">Affichage selon un angle</a></li>
  <li><a href="/blog/2016/05/01/ecrire-un-jeu-en-2d-avec-ruby-et-gosu-partie-7/">Plusieurs musiques et reset de la partie</a></li>
</ol>

<h2 id="de-la-musique">De la musique</h2>

<p>Ajouter une musique de fond est très simple avec Gosu. On crée la ressource
comme on a créé des sons ou des images. Ensuite on règle le volume entre
0 et 1. Et enfin on appuie sur <code>play</code>:</p>

<p>```ruby
class Window &lt; Gosu::Window</p>

<p>def initialize(width, height)
    # …
    @song = Gosu::Song.new(“assets/songs/Around the Bend.ogg”)
    @song.volume = 0.25
    @song.play(true)
  end</p>

<p>end
```</p>

<p>Le paramètre <code>true</code> passé à la méthode <code>play</code> lui indique qu’on veut jouer la
musique en boucle.</p>

<blockquote>
  <p>Un paramètre booléen est ce que j’appelle un «paramètre de contrôle»
(Martin Fowler appelle ça un <a href="http://martinfowler.com/bliki/FlagArgument.html">Flag argument</a>.
C’est un bon vieux code smell et je suis un peu déçu de trouver ça dans Gosu.
Surtout qu’il est ici facile de s’en débarrasser en proposant deux méthodes sans paramètres,
par exemple <code>play</code> et <code>loop</code>.</p>
</blockquote>

<h2 id="petite-pause-quand-on-perd-une-vie">Petite pause quand on perd une vie</h2>

<p>Pour marquer le coup, je voudrais que le jeu <em>pause</em> pendant un certain temps
(ici une seconde et demi) quand le joueur perd une vie. Voici d’abord le code,
puis les explications:</p>

<p>```ruby
class Player</p>

<p># …
  LifeLostPause = 1500</p>

<p>def initialize
    # …
    @lost_life_at = -20_000
  end</p>

<p>def just_lost_a_life?
    Gosu::milliseconds - @lost_life_at &lt; LifeLostPause
  end</p>

<p>private</p>

<p>def collision(type)
    case type
    when :smiley_up
      # …
    when :smiley_down
      # …
      @lost_life_at = Gosu::milliseconds
    end</p>

<pre><code>true   end
</code></pre>

<p>end
```</p>

<p>Commençons par ce qui change dans <code>collision</code>. Lorsque le joueur entre en
collision avec un smiley à l’envers, j’enregistre l’instant de cette collision.
<code>Gosu::milliseconds</code> retourne le nombre de millisecondes écoulées depuis le
début du jeu.</p>

<p>Pour savoir si le joueur vient de perdre une vie, la méthode <code>just_lost_a_life?</code>
compare le temps présent (<code>Gosu::milliseconds</code>) avec l’instant où le joueur a
perdu une vie (<code>@lost_life_at</code>). Si la différence est de moins de 1500
millisecondes (une seconde et demi) <code>just_lost_a_life?</code> retournera <code>true</code>.</p>

<p>Lors de l’initialisation on trouve cette ligne:</p>

<pre><code>@lost_life_at = -20_000
</code></pre>

<p>… qui est nécessaire pour que <code>@lost_life_at</code> ne soit pas <code>nil</code> au début
du jeu, ce qui provoquerait une erreur dans <code>just_lost_a_life?</code>. Mais pourquoi
-20,000 ? Essayez de la définir à zéro pour voir… En fait -20,000 est une
valeur arbitraire, qui aurait aussi bien pu être -10,000 ou -9999, etc.
Une autre solution aurait été d’écrire <code>just_lost_a_life?</code> comme ceci:</p>

<p><code>ruby
def just_lost_a_life?
  if @lost_life_at
    Gosu::milliseconds - @lost_life_at &lt; LifeLostPause
  else
    false
  end
end
</code></p>

<p>Mais j’aime moins cette solution, pour deux raisons, 1) c’est moins performant
puisqu’on a un test de plus à chaque update (ok c’est pas grand chose, mais ça
plus ça plus ça…, et là c’est très facilement évitable pour rien) et 2) je préfère que toutes les variables d’objets soient
définies dans le constructeur (peut-être un vieux reste de mon passé de
javaïste, ou un truc comme ça).</p>

<p>Quoiqu’il en soit, la ligne <code>@lost_life_at = -20_000</code> mérite un commentaire
expliquant la raison de cette valeur arbitraire. J’espère que ce sera
compréhensible:</p>

<p><code>ruby
    # It's important to note that this value is necessary for the game
    # to avoid to freeze at startup.
    # −20_000 is an arbitrary value. One can use -9999 or -5000 instead.
    @lost_life_at = -20_000
</code></p>

<p>Pour que tout ceci fonctionne, il suffit maintenant d’esquiver les updates au
bon moment:</p>

<p>```ruby
class Window &lt; Gosu::Window</p>

<p>def update
    return if @player.just_lost_a_life?</p>

<pre><code>update_items
update_player   end
</code></pre>

<p>end
```</p>

<h2 id="game-over-quand-0-vies">Game over quand 0 vies</h2>

<p>Vous avez maintenant compris que j’avance par petites itérations successives,
qui ne sont d’ailleurs pas toujours des fonctionnalités complètes.
Cette fois on va afficher «Game Over» et geler le jeu quand le joueur atteint
zéro vies:</p>

<p>```ruby
class Window &lt; Gosu::Window</p>

<p>def initialize(width, height)
    # …
    @game_over = false
  end</p>

<p>def update
    return if @player.just_lost_a_life?
    return if @game_over
    # …
  end</p>

<p>def draw
    # …
    @ui.draw(game_state)
  end</p>

<p>private</p>

<p># …</p>

<p>def update_player
    # …
    @game_over = true if @player.lives &lt;= 0
  end</p>

<p>def game_state
    {
      score: @player.score,
      lives: @player.lives,
      game_over: @game_over,
    }
  end</p>

<p>end
```</p>

<p>Ce qui mérite des explications c’est ce nouveau <code>game_state</code>. Plutôt que
d’envoyer les informations à l’UI sous la forme <code>@ui.draw(@player, @game_over)</code>
je préfère envoyer un <em>état</em> du jeu. Tout d’abord je n’envoie que le nécessaire
et ensuite on a un seul paramètre et non pas une liste de paramètres condamnée
à enfler.</p>

<p>Reste à refléter ça dans la classe UI:</p>

<p>```ruby
class UI
  # …</p>

<p>def initialize
    # …
    @big_font = Gosu::Font.new(80, name: “assets/fonts/VT323/VT323-Regular.ttf”)
  end</p>

<p>def draw(game)
    draw_score(game[:score])
    draw_lives(game[:lives])
    draw_game_over if game[:game_over]
  end</p>

<p>private</p>

<p>def draw_game_over
    @big_font.draw_rel(“Game Over”,
                       WindowWidth / 2, WindowHeight / 2,
                       ZOrder::UI,
                       0.5, 0.5)
  end</p>

<p>end
```</p>

<p>La nouveauté est la méthode <code>draw_rel</code>, qui va écrire son texte
<em>relativement</em> à lui-même. Oui je sais, ça sonne bizarre. Mais si vous
essayez les valeurs 0 et/ou 1 à la place de 0.5, vous devriez vite comprendre.
Là on va centrer le texte autour du milieu de l’écran, à la fois
horizontalement et verticalement.</p>

<blockquote>
  <p>Le fait que <code>draw_rel</code> soit l’abréviation de <code>draw_relative</code> ne sautera pas
forcement aux yeux de tout le monde. Alors pourquoi avoir utilisé une
abréviation ?</p>
</blockquote>

<p>Pour finir, voici le contenu du jeu pour l’instant:</p>

<pre><code>$ tree
.
├── assets
│   ├── fonts
│   │   └── VT323
│   │       ├── OFL.txt
│   │       └── VT323-Regular.ttf
│   ├── images
│   │   ├── background.png
│   │   ├── heart.gif
│   │   ├── player.png
│   │   ├── smiley-green.png
│   │   └── smiley-yellow.png
│   ├── songs
│   │   └── Around the Bend.ogg
│   └── sound
│       ├── collect.wav
│       └── life-lost.wav
├── main.rb
├── player.rb
├── smiley.rb
├── ui.rb
├── window.rb
└── z_order.rb
</code></pre>

<p>Le code et les assets se trouvent <a href="https://github.com/lkdjiin/collect-the-smiles">sur Github</a>.
La version précise pour cet article est la <a href="https://github.com/lkdjiin/collect-the-smiles/releases/tag/v0.5.0">version 0.5.0</a>.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Écrire un jeu en 2d avec Ruby et Gosu - partie 4]]></title>
    <link href="http://lkdjiin.github.io/blog/2016/02/13/ecrire-un-jeu-en-2d-avec-ruby-et-gosu-partie-4/"/>
    <updated>2016-02-13T16:19:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2016/02/13/ecrire-un-jeu-en-2d-avec-ruby-et-gosu-partie-4</id>
    <content type="html"><![CDATA[<p>Dans cet article on va s’occuper de gérer les vies de notre joueur.
On va les afficher et les perdre.</p>

<p><img class="center" src="/images/gosu5.png"></p>

<!-- more -->

<p>La totalité des articles:</p>

<ol>
  <li><a href="/blog/2016/02/10/ecrire-un-jeu-en-2d-avec-ruby-et-gosu-partie-1/">Installation de Gosu, affichage d’images statiques</a></li>
  <li><a href="/blog/2016/02/11/ecrire-un-jeu-en-2d-avec-ruby-et-gosu-partie-2/">Déplacer le joueur et pluie de smileys</a></li>
  <li><a href="/blog/2016/02/12/ecrire-un-jeu-en-2d-avec-ruby-et-gosu-partie-3/">Beep, fonte et collecte des smileys</a></li>
  <li>On s’occupe des vies</li>
  <li><a href="/blog/2016/02/15/ecrire-un-jeu-en-2d-avec-ruby-et-gosu-partie-5/">Musique et game over</a></li>
  <li><a href="/blog/2016/02/25/ecrire-un-jeu-en-2d-avec-ruby-et-gosu-partie-6/">Affichage selon un angle</a></li>
  <li><a href="/blog/2016/05/01/ecrire-un-jeu-en-2d-avec-ruby-et-gosu-partie-7/">Plusieurs musiques et reset de la partie</a></li>
</ol>

<h2 id="sourire--lenvers--autre-son-et-pas-de-points">Sourire à l’envers : autre son et pas de points</h2>

<p>Pour l’instant notre joueur collecte tout les smileys. Quel qu’ils soient.
Or, si les smiley oranges (sourire à l’endroit) doivent rapporter des points, les
smileys verts (sourire à l’envers) doivent eux faire perdre une vie à notre joueur.</p>

<p>On va commencer simplement par ne pas augmenter le score et jouer un son
différent quand le joueur entre en collision avec un smiley vert.
Dans la classe Player on charge le nouveau son (<code>life-lost.wav</code>) et on
modifie la méthode <code>collision</code> pour qu’elle réagisse au type du smiley:</p>

<p>```ruby
class Player</p>

<p>def initialize
    # …
    @sound_life_lost = Gosu::Sample.new(“assets/sound/life-lost.wav”)
  end</p>

<p>def collect(items)
    items.reject! {|item| collide?(item) ? collision(item.type) : false }
  end</p>

<p>def collision(type)
    case type
    when :smiley_up
      @score += 10
      @sound_collect.play(1.0)
    when :smiley_down
      @sound_life_lost.play(1.0)
    end</p>

<pre><code>true   end
</code></pre>

<p>end
```</p>

<p>Il ne faut pas oublier d’ajouter une méthode <code>type</code> à la classe Smiley:</p>

<p>```ruby
class Smiley
  attr_reader :x, :y, :type</p>

<p>def initialize(type)
    @type = type
    # …
  end</p>

<p>end
```</p>

<p>Avouez que c’était simple…</p>

<h2 id="afficher-les-vies">Afficher les vies</h2>

<p>L’objectif de cet article est de gérer les vies du joueur. Pour cela,
commençons par lui en donner 3:</p>

<p>```ruby player.rb
class Player</p>

<p># …</p>

<p>attr_reader :score, :lives</p>

<p>def initialize
    # …
    @lives = 3
  end</p>

<p>end
```</p>

<p>Les vies seront affichées au niveau de l’UI, c’est donc dans la classe du même
nom que cela va se passer. Jusqu’ici l’UI n’affichait que le score, et c’était
ce score que recevait en paramètre la méthode <code>draw</code>. On va modifier cela pour
pouvoir afficher le score et les vies.</p>

<p>On charge une nouvelle image, <code>heart.gif</code>, qui va symboliser une vie.
Puis dans <code>draw_lives</code> on affiche autant de <code>heart.gif</code> qu’il y a de vies:</p>

<p>```ruby ui.rb
class UI
  ScoreX = 10
  ScoreY = 10
  ScoreColor = 0xff_ffff00</p>

<p>LivesX = 10
  LivesXShift = 20
  LivesY = 30</p>

<p>def initialize
    @font = Gosu::Font.new(20, name: “assets/fonts/VT323/VT323-Regular.ttf”)
    @heart = Gosu::Image.new(“assets/images/heart.gif”)
  end</p>

<p>def draw(player)
    draw_score(player.score)
    draw_lives(player.lives)
  end</p>

<p>private</p>

<p>def draw_score(score)
    @font.draw(“Score: #{score}”, ScoreX, ScoreY, ZOrder::UI, 1.0, 1.0,
               ScoreColor)
  end</p>

<p>def draw_lives(number)
    number.times do |index|
      @heart.draw(LivesXShift * index + LivesX, LivesY, ZOrder::UI)
    end
  end
end
```</p>

<p>L’affichage des vies commence à la coordonnée x <code>LiveX</code> (soit 10), et se
poursuit en étant décalé à chaque fois de <code>LivesXShift</code> pixels vers la droite (soit 20).</p>

<p>Pour finir, il faut modifier l’appel à <code>UI#draw</code> depuis la classe <code>Window</code>:</p>

<p><code>ruby window.rb
class Window &lt; Gosu::Window
  def draw
    # ...
    @ui.draw(@player)
  end
end
</code></p>

<h2 id="perdre-une-vie">Perdre une vie</h2>

<p>Maintenant qu’on peut comptabiliser et afficher les vies du joueur, on est
prêt à lui en faire perdre. Il n’y a qu’une seule ligne à ajouter:</p>

<p>```ruby
class Player
  def collision(type)
    case type
    when :smiley_up
      @score += 10
      @sound_collect.play(1.0)
    when :smiley_down
      @lives -= 1                # &lt;—————– Ici
      @sound_life_lost.play(1.0)
    end</p>

<pre><code>true   end end ```
</code></pre>

<p>Cette méthode <code>collision</code> est déjà trop longue à mon goût, mais je préfère
attendre qu’elle enfle encore avant d’y remédier. Je veux être certain que
même les plus débutant(e)s d’entre vous puissent voir cette méthode devenir
hors de contrôle avant de proposer une solution qui pourrait être vue comme
trop compliquée dans cette version.</p>

<p>Pour finir, voici le contenu du jeu pour l’instant:</p>

<pre><code>$ tree
.
├── assets
│   ├── fonts
│   │   └── VT323
│   │       ├── OFL.txt
│   │       └── VT323-Regular.ttf
│   ├── images
│   │   ├── background.png
│   │   ├── heart.gif
│   │   ├── player.png
│   │   ├── smiley-green.png
│   │   └── smiley-yellow.png
│   └── sound
│       ├── collect.wav
│       └── life-lost.wav
├── main.rb
├── player.rb
├── smiley.rb
├── ui.rb
├── window.rb
└── z_order.rb
</code></pre>

<p>Le code et les assets se trouvent <a href="https://github.com/lkdjiin/collect-the-smiles">sur Github</a>.
La version précise pour cet article est la <a href="https://github.com/lkdjiin/collect-the-smiles/releases/tag/v0.4.0">version 0.4.0</a>.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Écrire un jeu en 2d avec Ruby et Gosu - partie 3]]></title>
    <link href="http://lkdjiin.github.io/blog/2016/02/12/ecrire-un-jeu-en-2d-avec-ruby-et-gosu-partie-3/"/>
    <updated>2016-02-12T09:49:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2016/02/12/ecrire-un-jeu-en-2d-avec-ruby-et-gosu-partie-3</id>
    <content type="html"><![CDATA[<p>On continue notre jeu en 2d en comptabilisant et en affichant le score.
Au passage on voit aussi comment utiliser une fonte précise et comment jouer
un son.</p>

<p><img class="center" src="/images/gosu4.png"></p>

<!-- more -->

<p>La totalité des articles:</p>

<ol>
  <li><a href="/blog/2016/02/10/ecrire-un-jeu-en-2d-avec-ruby-et-gosu-partie-1/">Installation de Gosu, affichage d’images statiques</a></li>
  <li><a href="/blog/2016/02/11/ecrire-un-jeu-en-2d-avec-ruby-et-gosu-partie-2/">Déplacer le joueur et pluie de smileys</a></li>
  <li>Beep, fonte et collecte des smileys</li>
  <li><a href="/blog/2016/02/13/ecrire-un-jeu-en-2d-avec-ruby-et-gosu-partie-4/">On s’occupe des vies</a></li>
  <li><a href="/blog/2016/02/15/ecrire-un-jeu-en-2d-avec-ruby-et-gosu-partie-5/">Musique et game over</a></li>
  <li><a href="/blog/2016/02/25/ecrire-un-jeu-en-2d-avec-ruby-et-gosu-partie-6/">Affichage selon un angle</a></li>
  <li><a href="/blog/2016/05/01/ecrire-un-jeu-en-2d-avec-ruby-et-gosu-partie-7/">Plusieurs musiques et reset de la partie</a></li>
</ol>

<h2 id="beep-et-collecte">Beep et collecte</h2>

<p>Pour donner l’illusion que le joueur attrape un smiley, dès que les deux images
entre en collision on supprime le smiley et on joue un petit son. Le cœur de
la fonctionnalité se passera au sein de la méthode <code>Player#collect</code>, qu’on
déclenchera depuis la classe Window:</p>

<p>```ruby window.rb
class Window &lt; Gosu::Window</p>

<p>def update_player
    # …
    @player.collect(@items)
  end</p>

<p>end
```</p>

<p>Voici ce qui change dans la classe Player. On en discute après:</p>

<p>```ruby player.rb
class Player</p>

<p># …
  DistanceOfCollision = 35</p>

<p>def initialize
    # …
    @sound_collect = Gosu::Sample.new(“assets/sound/collect.wav”)
  end</p>

<p># …</p>

<p>def collect(items)
    items.reject! {|item| collide?(item) ? collision : false }
  end</p>

<p>private</p>

<p>def collide?(item)
    distance = Gosu::distance(x_center_of_mass, y_center_of_mass,
                              item.x_center_of_mass, item.y_center_of_mass)
    distance &lt; DistanceOfCollision
  end</p>

<p>def x_center_of_mass
    @x + @image.width / 2
  end</p>

<p>def y_center_of_mass
    Y + @image.height / 4
  end</p>

<p>def collision
    @sound_collect.play(1.0)
    true
  end
end
```</p>

<p>Tout d’abord, on charge un son comme on charge une image, sauf qu’on utilise
<code>Sample</code> au lieu de <code>Image</code>:</p>

<p><code>ruby
    @sound_collect = Gosu::Sample.new("assets/sound/collect.wav")
</code></p>

<p>Ensuite, la méthode <code>collect</code>. On doit trouver le ou les objets (si il y en a)
qui sont en collision avec le joueur. On teste justement cette éventuelle
collision avec un smiley avec la méthode <code>collide?</code>. Si collision il y a,
l’objet sera supprimé (voir <code>collision</code> plus loin):</p>

<p><code>ruby
  def collect(items)
    items.reject! {|item| collide?(item) ? collision : false }
  end
</code></p>

<blockquote>
  <p>Modifier un objet sans vraiment le dire, par effet de bord, par exemple avec
<code>reject!</code> comme ci-dessus ne manquera pas de remplir d’horreur les tenants de la
programmation fonctionnelle. Mais comme le paradigme ici est la programmation
orienté objet, je ne vois pas de problèmes ;)</p>
</blockquote>

<p>Pour détecter si il y a eu collision entre deux objets, il existe plusieurs
méthodes. Comme Gosu fournit une méthode pour connaître la distance entre deux
points (<code>Gosu::distance</code>), voici ce que nous allons faire: le joueur et les smileys vont être
chacun représentés par un seul point précis. Si la distance entre ses deux points
tombe sous un certain seuil, nous considèrerons qu’il y a collision.</p>

<p>Le joueur est représenté par le point (<code>x_center_of_mass</code>, <code>y_center_of_mass</code>)
et un smiley par le point (<code>item.x_center_of_mass</code>, <code>item.y_center_of_mass</code>):</p>

<p><code>ruby
  def collide?(item)
    distance = Gosu::distance(x_center_of_mass, y_center_of_mass,
                              item.x_center_of_mass, item.y_center_of_mass)
    distance &lt; DistanceOfCollision
  end
</code></p>

<p>Pour le joueur, la coordonnée x utilisée pour la détection de collision est
pile au milieu:</p>

<p><code>ruby
  def x_center_of_mass
    @x + @image.width / 2
  end
</code></p>

<p>Pour la coordonnée y, c’est le quart en partant du haut:</p>

<p><code>ruby
  def y_center_of_mass
    Y + @image.height / 4
  end
</code></p>

<p>Enfin, lors d’une collision il faut émettre un son et retourner <code>true</code> pour que
<code>reject!</code> sache qu’il faut supprimer ce smiley de la collection. Le paramètre
de <code>play</code> est le volume, de 0.0 à 1.0:</p>

<p><code>ruby
  def collision
    @sound_collect.play(1.0)
    true
  end
</code></p>

<p>Le point d’un smiley utilisé pour détecter une collision est le milieu de
la largeur pour x et le haut pour y:</p>

<p>```ruby smiley.rb
class Smiley
  attr_reader :x, :y</p>

<p># …</p>

<p>def x_center_of_mass
    @x + @image.width / 2
  end</p>

<p>def y_center_of_mass
    @y
  end</p>

<p>end
```</p>

<p>N’hésitez pas à modifier ces points de détection ainsi que la constante
<code>DistanceOfCollision</code> pour trouver les valeurs qui vous conviennent.</p>

<h2 id="compter-et-afficher-les-points">Compter et afficher les points</h2>

<p>On va ajouter 10 points quelque soit le type de smiley collecté. Et on va
afficher le score dans le coin supérieur gauche. Les sorties informatives
telles que le score, les vies, etc, seront gérées depuis la classe <code>UI</code>:</p>

<p><code>ruby main.rb
# ...
require_relative 'z_order'
require_relative 'player'
require_relative 'smiley'
require_relative 'ui'
require_relative 'window'
# ...
</code></p>

<p>Un pattern commence à se dessiner, on crée un objet dans l’initialisation de
<code>Window</code> et on appelle sa méthode <code>draw</code>:</p>

<p>```ruby window.rb
class Window &lt; Gosu::Window</p>

<p>def initialize(width, height)
    # …
    @ui = UI.new
    # …
  end</p>

<p>def draw
    # …
    @ui.draw(score: @player.score)
  end</p>

<p>end
```</p>

<p>Les sorties de l’UI doivent être toujours visibles, on leurs donnera donc le
ZOrder le plus grand:</p>

<p>```ruby z_order.rb
module ZOrder</p>

<p>Background = 0
  Items      = 1
  Player     = 2
  UI         = 3</p>

<p>end
```</p>

<p>La classe Player est un bon endroit pour tenir compte du score et le mettre à
jour lors d’une collision avec un smiley:</p>

<p>```ruby player.rb
class Player
  # …</p>

<p>attr_reader :score</p>

<p>def initialize
    # …
    @score = 0
  end</p>

<p>def collision
    @score += 10
    # …
  end</p>

<p>end
```</p>

<p>Finalement voici un peu de nouveauté avec la classe UI et l’utilisation d’une
fonte pour afficher du texte.  Pour info, j’ai trouvé la police
<code>VT323-Regular.ttf</code> sur Google Font.  Le chargement d’une police de caractères
nécessite de fournir la taille et le fichier de la police:</p>

<p>```ruby ui.rb
class UI</p>

<p>def initialize
    @font = Gosu::Font.new(20, name: “assets/fonts/VT323/VT323-Regular.ttf”)
  end</p>

<p>def draw(score:)
    @font.draw(“Score: #{score}”, 10, 10, ZOrder::UI, 1.0, 1.0, 0xff_ffff00)
  end</p>

<p>end
```</p>

<p>Quant à la méthode <code>draw</code> d’une fonte, je vous invite à regarder
<a href="https://www.libgosu.org/rdoc/Gosu/Font.html#draw-instance_method">sa documentation</a>
pour connaître les paramètres à fournir.</p>

<p>Une explication toutefois, ceci:</p>

<pre><code>0xff_ffff00
</code></pre>

<p>…est une couleur au format alpha, rouge, vert, bleu en hexadécimal. Le
<em>underscore</em> est juste une fonctionnalité de Ruby qui permet d’écrire les nombres
avec des underscores pour faciliter la lecture. Par exemple les deux nombres
qui suivent sont identiques, lequel est le plus simple à lire ?</p>

<pre><code>1000000000

1_000_000_000
</code></pre>

<p>Et ça marche pareil avec l’hexadécimal.</p>

<p>Pour finir, voici le contenu du jeu pour l’instant:</p>

<pre><code>$ tree
.
├── assets
│   ├── fonts
│   │   └── VT323
│   │       ├── OFL.txt
│   │       └── VT323-Regular.ttf
│   ├── images
│   │   ├── background.png
│   │   ├── player.png
│   │   ├── smiley-green.png
│   │   └── smiley-yellow.png
│   └── sound
│       └── collect.wav
├── main.rb
├── player.rb
├── smiley.rb
├── ui.rb
├── window.rb
└── z_order.rb
</code></pre>

<p>Le code et les assets se trouvent <a href="https://github.com/lkdjiin/collect-the-smiles">sur Github</a>.
La version précise pour cet article est la <a href="https://github.com/lkdjiin/collect-the-smiles/releases/tag/v0.3.0">version 0.3.0</a>.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
