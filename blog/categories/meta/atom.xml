<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : meta | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/meta/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2014-04-10T21:56:29+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Introduction à la meta-programmation en Ruby]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/04/10/introduction-a-la-meta-programmation-en-ruby/"/>
    <updated>2014-04-10T21:15:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/04/10/introduction-a-la-meta-programmation-en-ruby</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>La méta programmation, qu'est-ce que c'est ? C'est le fait
de <em>modifier</em> le code au moment de l'exécution d'un
programme. Par modifier, il faut aussi entendre créer et
supprimer. C'est un peu le pendant naturel de
<a href="http://lkdjiin.github.io/blog/2014/04/08/introduction-a-lintrospection-en-ruby/">l'introspection</a> dont j'ai parlé récemment.</p>

<!-- more -->


<p>Pour cette introduction au concept de méta programmation, on
va y aller en douceur. Prenons la bête classe suivante:</p>

<p>``` ruby
class Greeting
  def alphonse</p>

<pre><code>'Hello Alphonse'
</code></pre>

<p>  end
end</p>

<p>puts Greeting.new.alphonse</p>

<h1>=> Hello Alphonse</h1>

<p>```</p>

<p>On définit la méthode <code>alphonse</code> de manière classique:</p>

<pre><code>def alphonse
  'Hello Alphonse'
end
</code></pre>

<p>C'est comme ça qu'on fait tous les jours ;) En fait cette
façon de définir la méthode <code>alphonse</code> est du
<a href="http://fr.wikipedia.org/wiki/Sucre_syntaxique">sucre syntaxique</a>. Ruby est bourré de sucre syntaxique.
Pour définir notre méthode <code>alphonse</code> on pourrait utiliser…
une méthode ! Voyons l'exemple suivant:</p>

<p>``` ruby
class Greeting
  define_method(&lsquo;alphonse&rsquo;) { &lsquo;Hello Alphonse&rsquo; }
end</p>

<p>puts Greeting.new.alphonse</p>

<h1>=> Hello Alphonse</h1>

<p>```</p>

<p>Le résultat est identique, et pour cause: c'est la même
méthode, on l'a simplement définit autrement.</p>

<p>On a donc:</p>

<pre><code>def alphonse
  'Hello Alphonse'
end
</code></pre>

<p>qui est identique à:</p>

<pre><code>define_method('alphonse') { 'Hello Alphonse' }
</code></pre>

<p>Alors ça nous fait une belle jambe ! Parce que honnêtement,
qu'est-ce qu'on y gagne ? Pas en lisibilité en tous cas.
Alors quoi ? Un indice: <strong>on a utilisé une méthode pour
définir une méthode</strong>. Ce qui nous permet de faire ce qui
suit:</p>

<p>``` ruby
class Greeting
  [&lsquo;alphonse&rsquo;, &lsquo;charlotte&rsquo;, &lsquo;marcel&rsquo;].each do |method|</p>

<pre><code>define_method(method) { "Hello #{method.capitalize}" }
</code></pre>

<p>  end
end</p>

<p>puts Greeting.new.alphonse
puts Greeting.new.charlotte
puts Greeting.new.marcel</p>

<h1>=> Hello Alphonse</h1>

<h1>=> Hello Charlotte</h1>

<h1>=> Hello Marcel</h1>

<p>```</p>

<p>Bon, on a toujours pas gagné en lisibilité. Par contre on
gagne en compacité, imaginez un peu si il y avait 20
méthodes.</p>

<p>Et sinon, concrètement, ça sert à quoi ? Sans cette
capacité de méta programmation, comment feriez vous si,
mettons, les noms des méthodes à implémenter ne sont pas
connus au lancement du programme ? C'est par exemple une
grande par de la <em>magie</em> de Rails. Dans Rails vous pouvez
chercher <code>User.find_by_name('charlotte')</code> alors même que
vous n'avez nulle-part définit cette méthode. C'est grâce
à la méta programmation.</p>

<p>Ça me donne l'idée de faire quelques prochains articles sur
ce sujet.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby Timecop - Comment ça marche ?]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/04/02/ruby-timecop-comment-ca-marche/"/>
    <updated>2014-04-02T21:07:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/04/02/ruby-timecop-comment-ca-marche</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Hier je vous parlais de Timecop, une gem Ruby qui <em>arrête le
temps</em>, très utile pour tester les dates. J'y ai repensé un
peu aujourd'hui sur le mode : «j'aurais pu y penser avant !».</p>

<p>Alors justement, si j'avais eu cette idée, comment j'aurais
fait ? C'est l'occasion de parler de méta-programmation.
Allez j'essaye d'écrire ma propre méthode
<code>Time.freeze</code>, on verra bien…</p>

<!-- more -->


<p>Voilà les étapes qui me semble nécessaires:</p>

<ol>
<li>Geler le temps et le retenir.</li>
<li>Faire un backup de Time.now.</li>
<li>Définir une nouvelle méthode Time.now qui renvoie toujours
le même temps.</li>
<li>Appeler le block passé à la méthode.</li>
<li>Restaurer la méthode Time.now originale.</li>
</ol>


<p>Avant de coder, j'écris un test:</p>

<p>``` ruby
puts &ldquo;Time before #{Time.now}&rdquo;
sleep 3</p>

<p>Time.freeze do
  puts Time.now.to_s
  sleep 3
  puts Time.now.to_s
end</p>

<p>sleep 3
puts &ldquo;Time after #{Time.now}&rdquo;
```</p>

<p>Je veux donc obtenir un affichage du genre:</p>

<pre><code>Time before hh:mm:00
hh:mm:03
hh:mm:03
Time after hh:mm:09
</code></pre>

<p>Ok ? C'est parti.</p>

<h2>Ouvrir la classe Time</h2>

<p><code>ruby
class Time
  def self.freeze
  end
end
</code></p>

<p>Premier truc à savoir, une classe Ruby est toujours ouverte
à la modification. Même si il s'agit d'une classe du coeur
du langage, comme Object ou Kernel. <em>Si vous êtes perdus,
faites une recherche sur «ruby open class».</em></p>

<h2>Arrêter le temps</h2>

<p>``` ruby
class Time
  def self.freeze</p>

<pre><code>freezed = Time.now
</code></pre>

<p>  end
end
```</p>

<p>Pas grand chose à dire. On pourra renvoyer l'objet <code>freezed</code>
chaque fois qu'on nous demandera <code>Time.now</code>.</p>

<h2>Sauvegarder Time.now original</h2>

<p>``` ruby
class Time
  def self.freeze</p>

<pre><code>freezed = Time.now
singleton_class.send(:alias_method, :old_now, :now)
</code></pre>

<p>  end
end
```</p>

<p>Là il y a beaucoup à dire. On rentre dans la
méta-programmation et je n'ai pas la place (ni le temps) dans
cet article pour parler du modêle objet de Ruby.
N'hésitez pas à faire une recherche sur «ruby object model» ou
«ruby eigenclass».</p>

<p>On dit à la classe <code>Time</code> de créer un alias de la méthode de
classe <code>now</code> avec le nom <code>old_now</code>.</p>

<h2>Un nouveau Time.now</h2>

<p>``` ruby
class Time
  def self.freeze</p>

<pre><code>freezed = Time.now
singleton_class.send(:alias_method, :old_now, :now)
define_singleton_method('now') { freezed }
</code></pre>

<p>  end
end
```</p>

<p>Cette fois, je dis à la classe <code>Time</code> de créer une méthode de
classe qui s'appelle <code>now</code> et qui renvoie notre objet
<code>freezed</code>.</p>

<h2>Appeler le block</h2>

<p>``` ruby
class Time
  def self.freeze</p>

<pre><code>freezed = Time.now
singleton_class.send(:alias_method, :old_now, :now)
define_singleton_method('now') { freezed }
yield
</code></pre>

<p>  end
end
```</p>

<p>Bon, ça c'était facile ;)</p>

<h2>Restaurer Time.now</h2>

<p>``` ruby
class Time
  def self.freeze</p>

<pre><code>freezed = Time.now
singleton_class.send(:alias_method, :old_now, :now)
define_singleton_method('now') { freezed }
yield
singleton_class.send(:alias_method, :now, :old_now)
</code></pre>

<p>  end
end
```</p>

<p>Ça me semble tout bon. On teste ?</p>

<h2>Le test</h2>

<p>``` ruby freeze.rb
class Time
  def self.freeze</p>

<pre><code>freezed = Time.now
singleton_class.send(:alias_method, :old_now, :now)
define_singleton_method('now') { freezed }
yield
singleton_class.send(:alias_method, :now, :old_now)
# singleton_class.send(:remove_method, :old_now)
</code></pre>

<p>  end
end</p>

<p>puts &ldquo;Time before #{Time.now}&rdquo;
sleep 3</p>

<p>Time.freeze do
  puts Time.now.to_s
  sleep 3
  puts Time.now.to_s
end</p>

<p>sleep 3
puts &ldquo;Time after #{Time.now}&rdquo;
```</p>

<p><code>bash
$ ruby freeze.rb
Time before 2014-04-02 21:40:57 +0200
2014-04-02 21:41:00 +0200
2014-04-02 21:41:00 +0200
Time after 2014-04-02 21:41:06 +0200
</code></p>

<p>Excellent !</p>

<p>Il reste un léger problème : la méthode <code>Time.old_now</code>
existe toujours, ce qui n'est pas très propre. On pourra
la supprimer ainsi:</p>

<pre><code>singleton_class.send(:remove_method, :old_now)
</code></pre>

<p>Voilà, j'aurais quand même pu y penser avant… J'espère
trouver du temps une prochaine fois pour jeter un coup
d'oeil au code de Timecop pour comparer avec le code
d'aujourd'hui.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
