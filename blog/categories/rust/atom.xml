<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : rust | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/rust/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2015-01-04T18:18:44+01:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Le jeu de la vie en Rust - partie 1]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/01/04/le-jeu-de-la-vie-en-rust-partie-1/"/>
    <updated>2015-01-04T18:04:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/01/04/le-jeu-de-la-vie-en-rust-partie-1</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<h2>Premiers pas avec Rust</h2>

<p>On va écrire une version simple du jeu de la vie en Rust.</p>

<h3>Installer Rust</h3>

<p>Rendez-vous <a href="http://www.rust-lang.org/install.html">sur cette page</a> pour trouver
le type d'installation qui vous convient. Même si on peut trouver que cela pose
des problèmes, j'ai opté pour la méthode la plus simple:</p>

<pre><code>$ curl -s https://static.rust-lang.org/rustup.sh | sudo sh
</code></pre>

<p>Cela installe la version <em>nightly</em> et le gestionnaire de paquet <code>Cargo</code>.
L'installation est très rapide.</p>

<p>Pour information, voici la version que j'ai installé:</p>

<pre><code>$ rustc --version
rustc 0.13.0-nightly (636663172 2014-12-28 16:21:58 +0000)
</code></pre>

<!-- more -->


<h3>Cargo</h3>

<p>Rust fournit un outil très proche du Bundler des rubyistes, il s'agit
de Cargo. On s'en sert pour la création d'un projet, faire les builds,
lancer les tests, gérer les dépendances, etc…</p>

<p>Je crée le projet <code>game_of_life</code>:</p>

<pre><code>$ cargo new game_of_life --bin
$ cd game_of_life
</code></pre>

<p>Ça donne ceci:</p>

<pre><code>$ tree
.
├── Cargo.toml
└── src
    └── main.rs
</code></pre>

<p>Le fichier <code>Cargo.toml</code> est un manifeste et ne nous intéresse pas trop pour
l'instant.</p>

<h3>Création d'une génération de cellules</h3>

<p>Je ne vais pas parler de test aujourd'hui, ça sera pour plus tard. Je vais seulement écrire une
fonction <code>create_generation</code> (ma toute première fonction Rust !) qui va produire un tableau de
cellules, c'est à dire un tableau de 0 et de 1.</p>

<p>Pour représenter une génération, j'ai déjà utilisé dans les articles précédents des tableaux de
tableaux et des tableaux à 2 dimensions. C'est ma dernière chance d'utiliser des tableaux plats.
Voici le code complet du fichier <code>main.rs</code>.</p>

<p>``` rust src/main.rs
use std::rand::Rng;</p>

<p>fn main() {</p>

<pre><code>let gen = create_generation(3, 4);
println!("{}", gen);
</code></pre>

<p>}</p>

<p>fn create_generation(width: uint, height: uint) &ndash;> Vec<uint> {</p>

<pre><code>let size = width * height;
let mut result = Vec::new();
for _ in range(0u, size) {
    let cell = std::rand::task_rng().gen_range(0u, 2u);
    result.push(cell);
}
result
</code></pre>

<p>}
```</p>

<p>Pour le compiler et le lancer, on peut utiliser Cargo:</p>

<pre><code>$ cargo run
     Running `target/game_of_life`
[1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0]
</code></pre>

<p>Je ne suis pas très content de cette fonction <code>create_generation</code>, j'ai bien
conscience qu'elle est maladroite, mais elle a
au moins un mérite: elle fonctionne ! Alors, place aux explications.</p>

<pre><code>fn create_generation(width: uint, height: uint) -&gt; Vec&lt;uint&gt; {
</code></pre>

<p>Rust est statiquement typé, le compilateur doit connaître la signature d'une
fonction. Donc on déclare le type des paramêtres (ici <code>uint</code> pour <em>unsigned int</em>)
et le type de la valeur de retour (ici un <code>Vec</code>teur).</p>

<pre><code>let size = width * height;
</code></pre>

<p>On déclare une variable avec <code>let</code>. Pas besoin de préciser le type de <code>size</code>
puisque le compilateur peut l'inférer.</p>

<pre><code>let mut result = Vec::new();
</code></pre>

<p>Par défaut, une variable ne peut pas être modifiée, comme je désire ajouter des
éléments à <code>result</code>, je dois spécifier <code>mut</code> (pour <em>mutable</em>).</p>

<pre><code>for _ in range(0u, size) {
    let cell = std::rand::task_rng().gen_range(0u, 2u);
    result.push(cell);
}
</code></pre>

<p><code>0u</code> est une autre manière de préciser le type. Ici c'est <code>0</code> de type <code>uint</code>.
Dans la boucle on génère un nombre aléatoire et on l'ajoute dans <code>result</code>.</p>

<pre><code>result
</code></pre>

<p>Finalement on renvoie <code>result</code>. Notez qu'il n'y a pas de point-virgule après
<code>result</code>, c'est voulu, ça ne fonctionnerait pas avec. Par contre j'aurais pu
écrire <code>return result;</code>, et là il faudrait le point-virgule. Je n'ai pas encore
très bien compris le pourquoi du comment, donc je ne vais pas me risquer à vous
fournir une explication foireuse.</p>

<p>Voilà, c'est tout pour ma première approche de Rust. La prochaine fois je
parlerais des tests unitaires.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Le jeu de la vie dans sept langages différents]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/10/08/le-jeu-de-la-vie-dans-sept-langages-differents/"/>
    <updated>2014-10-08T12:30:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/10/08/le-jeu-de-la-vie-dans-sept-langages-differents</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Je vais écrire le <a href="http://en.wikipedia.org/wiki/Conway%27s_Game_of_Life">jeu de la vie</a> dans 7 langages, et
en utilisant le TDD (sauf pour l'affichage).
Ça va me permettre de réviser certains langages et d'en apprendre de nouveaux
d'une manière amusante. Après tout, quoi de plus <em>fun</em> qu'un jeu pour zéro
joueur.</p>

<h2>L'algorithme</h2>

<p>L'idée directrice, c'est de faire au plus simple.
L'algorithme général sera le suivant :</p>

<ol>
<li>obtenir une première génération au hasard</li>
<li>afficher la génération</li>
<li>calculer la nouvelle génération et retour au point 2.</li>
</ol>


<p>Discutons un peu chacun des trois points.</p>

<!-- more -->


<h3>Obtenir une première génération au hasard</h3>

<p>Cette génération sera stockée dans un tableau (une liste). Suivant le
langage, j'utiliserais un tableau à 1 ou 2 dimensions.</p>

<h3>Afficher la génération</h3>

<p>Il s'agit d'afficher à l'écran le tableau calculé précédement. Chaque élément
du tableau représente une cellule du jeu de la vie, et une cellule sera
représentée à l'écran par un pixel. Alors un pixel pour une cellule, ça risque
d'être assez moche sur la plupart des dispositifs, mais c'est le plus simple.
J'améliorerais peut-être cet affichage plus tard.</p>

<h3>Calculer la nouvelle génération</h3>

<p>Là encore, j'essaye d'aller au plus simple. On va calculer la
nouvelle génération dans un second tableau. Une fois ce calcul effectué, ce
second tableau remplacera le premier.</p>

<p>Pour calculer le nouvel état d'une cellule, on devra observer la cellule et
ces 8 voisins. Autrement dit on observe une fenêtre de 9 cellules et on veut
connaitre le nouvel état de la cellule centrale. Il y a 3 cas possibles:</p>

<ol>
<li>Si la somme des cellules vivantes est 3, alors la nouvelle cellule sera
vivante.</li>
<li>Si la somme des cellules vivantes est 4, alors la nouvelle cellule conserve
son ancien état.</li>
<li>Dans tous les autres cas, la nouvelle cellule est morte.</li>
</ol>


<p>Il faut encore parler du cas des cellules qui se trouvent sur les bords du
<em>plateau de jeu</em>. Normalement, le jeu de la vie est infini. Mais l'infini, c'est
pas simple. Dans une première itération, le <em>plateau de jeu</em> aura des
dimensions finies et les cellules qui se trouvent sur les bords se verront
ajoutées arbitrairement des voisins morts.</p>

<p>Une seconde itération pourrait implémenter une espèce de <a href="http://en.wikipedia.org/wiki/Torus">tore</a> pour avoir une surface
de jeu sans bordures.</p>

<h2>Les langages ciblés</h2>

<p>Je vais écrire le jeu de la vie dans 7 langages différents:</p>

<ul>
<li>ruby</li>
<li>javascript</li>
<li>racket</li>
<li>logo</li>
<li>julia</li>
<li>haskell</li>
<li>rust</li>
</ul>


<h3>Pourquoi ces langages ?</h3>

<p><strong>Ruby</strong></p>

<p>Ça peut paraitre bizarre. Après tout j'écris en Ruby toute la journée, c'est
mon métier. Pourquoi vouloir en faire encore pendant mon temps libre ?
En fait, ce qui m'intéresse vraiment ici, c'est <a href="http://opalrb.org/">Opal.rb</a>. Peut-être aussi
que j'en ferais une seconde version avec <a href="http://www.libgosu.org/">Gosu</a>.</p>

<p><strong>Javascript</strong></p>

<p>Après des années passées à tenter d'éviter d'écrire la moindre ligne de
Javascript, je m'intéresse de nouveau à ce langage. Après tout, c'est un
incontournable du Web et il commence à me plaire. Et puis j'ai trop tardé à
faire du TDD avec Javascript, je crois que <a href="http://jasmine.github.io/">Jasmine</a> est devenu très bon.</p>

<p><strong>Racket</strong></p>

<p>Je crois que tout développeur devrait étudier un <em>Lisp like</em>. Lisp t'oblige à
penser autrement et du coup tu trouves des solutions différentes à des
problèmes de programmation de tout les jours.</p>

<p><strong>Logo</strong></p>

<p>Le <a href="http://fr.wikipedia.org/wiki/Logo_%28langage%29">Logo</a>, c'est ma <a href="http://fr.wikipedia.org/wiki/Madeleine_%28cuisine%29#La_madeleine_de_Proust">madeleine de Proust</a> ! Voilà. Encore un <em>Lisp like</em>,
mais différent (on l'appelait Lisp sans parenthèses). J'espère que je trouverais
encore des ressources pour celui-ci.</p>

<p><strong>Julia</strong></p>

<p>Je pense que les langages fonctionnels ont un grand avenir. Ils résolvent au
moins deux soucis. En ce concentrant sur la transformation des données plutôt
que sur l'état de ces données, ils facilitent les tests et l'utilisation des
multi-coeurs.</p>

<p><strong>Haskell</strong></p>

<p>Encore un langage fonctionnel, et celui-ci me fait un peu peur. Mais je me dis
que je devrais y goûter.</p>

<p><strong>Rust</strong></p>

<p>Je voulais un langage système dans cette liste, ce sera <a href="http://www.rust-lang.org/">Rust</a>.</p>

<h2>Fréquence de publication</h2>

<p>Je ne m'avancerais pas sur une fréquence de publication. J'imagine qu'il y
aura 3 ou 4 articles par langage. Et suivant le temps dont je disposerais, ça
pourrat-être aussi bien un article par mois ou trois articles par semaine.</p>

<p>Allez, la prochaine fois on commence avec Ruby/Opal.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p></p>
]]></content>
  </entry>
  
</feed>
