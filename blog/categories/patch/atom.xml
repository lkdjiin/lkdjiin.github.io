<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : patch | Xavier Nayrac]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/patch/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2015-06-08T16:30:12+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Mon patch pour Ruby a été refusé]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/01/02/mon-patch-pour-ruby-a-ete-refuse/"/>
    <updated>2014-01-02T18:53:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/01/02/mon-patch-pour-ruby-a-ete-refuse</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Il y a quelque jours, j’ai présenté les <a href="http://lkdjiin.github.io/blog/2013/12/30/ruby-2-dot-1-les-nouvelles-methodes-de-set/">nouvelles méthodes de la classe
Set</a>, mise à jour avec la sortie de Ruby 2.1.
Un commenteur m’a fait remarquer avec raison que le code pourrait être
bien plus simple. Ni une, ni deux, j’écris un patch, les tests passent,
j’envoie un pull request. Le patch sera gentillement refusé, et c’est
bien normal…</p>

<!-- more -->

<p>Voici le code des méthodes originales:</p>

<p>``` ruby
  def intersect?(set)
    set.is_a?(Set) or raise ArgumentError, “value must be a set”
    if size &lt; set.size
      any? { |o| set.include?(o) }
    else
      set.any? { |o| include?(o) }
    end
  end</p>

<p>def disjoint?(set)
    !intersect?(set)
  end
```</p>

<p>Et voici comment je les ai recodées:</p>

<p>``` ruby
  def intersect?(set)
    !disjoint?(self)
  end</p>

<p>def disjoint?(set)
    set.is_a?(Set) or raise ArgumentError, “value must be a set”
    (self &amp; set).empty?
  end
```</p>

<p>Je trouvais mon nouveau code vraiment très bien foutu: deux fois plus court et
plus simple à lire. Seulement j’avais oublié deux petites choses qui le rendent
moins efficace que le code original:</p>

<p>Premièrement, mon code crée un objet intermédiaire 
(avec <code>self &amp; set</code>) qui n’est pas nécessaire.</p>

<p>Deuxièment, le code original s’arrête dès qu’un élément en commun est trouvé,
alors que le mien remplira un (nouveau) set avec tout les éléments en
communs. C’est évidemment beaucoup moins efficace, surtout avec de gros sets.</p>

<p>Moralité : un code plus court n’est pas toujours synonyme de plus efficace !</p>

<script id="fb33k8u">(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>

<p>À demain.</p>

<p></p>

]]></content>
  </entry>
  
</feed>
