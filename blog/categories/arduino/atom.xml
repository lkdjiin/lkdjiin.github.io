<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : arduino | Xavier Nayrac]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/arduino/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2015-10-29T15:17:17+01:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Fabriquer un sablier à thé électronique]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/10/29/fabriquer-un-sablier-a-the-electronique/"/>
    <updated>2015-10-29T14:59:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/10/29/fabriquer-un-sablier-a-the-electronique</id>
    <content type="html"><![CDATA[<p>Voici un projet que j’avais en route depuis quelques semaines.  L’objectif était de
fabriquer mon premier «objet» grâce à l’arduino, en l’occurrence un <em>sablier à
thé électronique</em>.</p>

<p><img class="center" src="/images/hourglass.jpg"></p>

<p>Un quoi ? En fait il s’agit tout simplement d’un minuteur. Mais je trouve le
nom <em>sablier à thé électronique</em> bien plus évocateur ;) Quand je me fais du thé
je laisse passer 9 fois sur 10 le temps d’infusion et je me retrouve avec un
breuvage imbuvable. J’avais donc envie d’un minuteur simple avec deux boutons,
un buzzer et une LED. Un des boutons lance un décompte de 3 minutes pour le thé
vert, l’autre c’est 5 minutes pour le thé noir. À la fin ça bip bip et ça
clignote jusqu’à ce qu’on l’arrête. Du vraiment simple, quoi. Sauf que je ne
voulais pas mettre un arduino entier dans ce projet alors qu’un petit micro
contrôleur à 60 centimes pourrait faire l’affaire.</p>

<!-- more -->

<p>J’allais donc devoir apprendre à programmer les micro contrôleurs ATtiny de
chez Atmel. Pourquoi ceux-là ? Parce qu’ils sont proches du micro contrôleur
utilisé par l’arduino (le ATmega 328). Bref je gardais quand même un pied en
terrain connu.</p>

<p>J’ai d’abord créé un prototype de ce <em>sablier sonore</em> avec l’arduino, pour être
sûr que je savais comment faire. Niveau schéma ça pourrait donner quelque chose
comme ça:</p>

<p><img class="center" src="/images/attiny45-step4.png"></p>

<p>Au final je n’utilise qu’une seule LED, mais dans le prototype original il y en
avait deux. Et c’est en utilisant ce premier prototype que je me suis aperçu
qu’une seule LED était suffisante.</p>

<p>L’étape suivante fut de réaliser ce montage, et le code, pour un ATtiny45.
Pourquoi ce micro contrôleur précisément ? Parce que 1) j’en avais un dans un
tiroir, et 2) on trouve une pléthore de tutoriels pour programmer un ATtiny45
en se servant d’un arduino. Si vous n’êtes pas familier du terme,
<strong>programmer</strong> un micro contrôleur c’est, en gros, lui transférer son programme
depuis un ordinateur. Pour que les deux cotés communiquent, on utilise un
<strong>programmateur</strong>. Il y a plusieurs façons de faire ça, je voulais utiliser un
arduino comme base de programmateur pour ne rien avoir à acheter de nouveau.
Vous pouvez trouver un bon tutoriel ici:
<a href="http://www.instructables.com/id/Program-an-ATtiny44458485-with-Arduino/">Program an ATtiny44/45/84/85 with Arduino</a>.</p>

<p>Finalement, on peut se créer le programmateur assez facilement pour l’ATtiny45:</p>

<p><img class="center" src="/images/hello_world_bb.png"></p>

<p>Comme j’allais programmer un certain nombre de micro contrôleurs, j’ai préféré
fabriquer un shield. D’abord un temporaire:</p>

<p><img class="center" src="/images/arduino-temp-shield.jpg"></p>

<p>Puis finalement un définitif:</p>

<p><img class="center" src="/images/arduino-shield-attiny45.jpg"></p>

<p>Trop pressé de le réaliser, je me suis trompé de sens pour le socket, ce qui
explique les câbles qui passent d’un coté à l’autre, puisque je n’ai pas
voulu le dessouder. C’est pas grave et il fonctionne très bien ;)</p>

<p>J’étais donc capable de programmer un ATtiny45 (4K de ROM) en utilisant
l’arduino <strong>ET</strong> l’IDE Arduino. C’était un bon début, mais ça n’était pas
suffisant. D’abord je ne voulais pas utiliser l’IDE Arduino, mais plutôt des
outils en ligne de commande, pour des raisons de reproductibilité et d’automatisation, et ensuite
je soupçonnais que le code de mon <em>sablier sonore</em> pouvait tenir sur un
ATtiny13 qui ne posséde que 1K de ROM et est pratiquement deux fois moins cher
que l’ATtiny45.</p>

<p>À suivre…</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Connaitre la taille d'un programme pour Arduino]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/08/20/connaitre-la-taille-dun-programme-pour-arduino/"/>
    <updated>2015-08-20T16:45:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/08/20/connaitre-la-taille-dun-programme-pour-arduino</id>
    <content type="html"><![CDATA[<p>Si j’ai besoin de connaître la taille et la demande en RAM de mes
programmes Arduino, comment je fais ? Et puis d’abord pourquoi je voudrais
connaître leur taille ?</p>

<p><img class="center" src="/images/640-arduino-avr.jpg"></p>

<!-- more -->

<h2 id="o-se-cache-le-programme">Où se cache le programme</h2>

<p>Le programme au format elf se trouve dans un dossier caché. Vous pouvez
constater que sa taille est assez conséquente. Ce n’est pas du tout sa taille
finale pour l’Arduino.</p>

<p><code>bash
$ \ls -lh .build/uno/firmware.elf 
-rwxr-xr-x 1 xavier xavier 40K août  19 21:01 .build/uno/firmware.elf
</code></p>

<p><em>Un dossier caché est un dossier dont le nom commence par un point. On dit
«caché» car sous Linux et OS X ils sont invisibles par défaut.</em></p>

<h2 id="comment-connatre-les-besoins-en-mmoire-dun-programme-arduino">Comment connaître les besoins en mémoire d’un programme Arduino</h2>

<p>C’est le programme <code>avr-size</code> qui va tout nous dire:</p>

<p>```bash
$ avr-size -dC .build/uno/firmware.elf 
AVR Memory Usage
—————-
Device: Unknown</p>

<p>Program:    2786 bytes
(.text + .data + .bootloader)</p>

<p>Data:         34 bytes
(.data + .bss + .noinit)
```</p>

<p>J’utilise 34 octets de RAM et 2786 octets au total.</p>

<p>Le switch <code>-d</code> fournit les valeurs en décimal. Le switch <code>-C</code> spécifie le
format du rapport de <code>avr-size</code> (<code>$ avr-size --help</code> pour voir les autres).</p>

<h2 id="pourquoi-faire">Pourquoi faire</h2>

<p>Les micro contrôleurs ATMEL ont des tailles de mémoire
différentes (mémoire vive et mémoire programme). Par exemple l’ATtiny13 possède 1 Ko pour le programme et 64 octets
de RAM, tandis que le ATtiny85 fait 8 Ko pour le programme et 512 octets pour
la RAM.</p>

<p>Pour les programmes qui sont destinés à quitter la plateforme Arduino pour
rejoindre un micro contrôleur, connaître la taille mémoire permet de savoir
si il est intéressant de passer du temps et de l’énergie à <em>optimiser</em> ces
programmes.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Arduino : Un métronome tap tempo]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/04/03/arduino-un-metronome-tap-tempo/"/>
    <updated>2015-04-03T18:35:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/04/03/arduino-un-metronome-tap-tempo</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>J’aimerais fabriquer un métronome <em>tap tempo</em> avec l’arduino. C’est un projet à
moyen terme, et
comme souvent, il pourrait être bénéfique de diviser le projet en plusieurs
petites parties. Donc, avant de tenter la programmation du tap tempo, je vais
faire un métronome tout simple avec juste une LED.</p>

<h2 id="les-composants">Les composants</h2>

<p>Coté composants, on a seulement besoin d’une LED et d’une résistance (220 Ohms
ça ira).</p>

<p><img class="center" src="/images/metronome1_bb.png"></p>

<!-- more -->

<h2 id="un-premier-code-naif">Un premier code naif</h2>

<p>Le premier jet est tout simple :</p>

<p>``` cpp
const byte LED_PIN = 2;</p>

<p>void setup() {
  pinMode(LED_PIN, OUTPUT);
}</p>

<p>void loop() {
  digitalWrite(LED_PIN, HIGH);
  delay(100);
  digitalWrite(LED_PIN, LOW);
  delay(600);
}
```</p>

<p>Une fois compilé et envoyé dans l’arduino, la LED clignote toutes les 0,7
secondes. Nous avons un métronome visuel !</p>

<p>C’est simple, non ? Mouais. Trop simple, bien sûr. Ce code est problèmatique
pour la fabrication d’un métronome. Alors afin de comprendre pourquoi, parlons
un peu du tempo.</p>

<h2 id="le-tempo">Le tempo</h2>

<p>Pour le musicien, le tempo est une suite de clics (ou tic, ou tac, ou poum, ou
tchak, ou clac). Ces clics, qui ont la particularité de se succéder à
intervalles réguliers, marquent la <strong>vitesse</strong> de la musique.</p>

<p>Le tempo (donc la vitesse de la musique) est indiqué à l’aide d’un nombre qui
représente le nombre de clics par minute.
Par exemple un tempo de 60 nous indique qu’il doit y avoir 60 clics dans une minute,
ou plus simplement 1 clic par seconde. Autre exemple, un tempo de 120 indique
120 clics par minute, soit 2 clics par seconde, ou encore 1 clic toutes les
0,5 secondes.</p>

<p>Voyons maintenant quelques formules. Pour trouver la fréquence F, en secondes,
il faut diviser 60 par le tempo (noté T) :</p>

<p>$$
\begin{align}

F = 60 / T
\end{align}
$$</p>

<p>Pour obtenir cette fréquence en millisecondes, il faut multiplier le résultat
précédent par 1000 ;</p>

<p>$$
\begin{align}

F = 60 / T \times 1000
\end{align}
$$</p>

<p>Le code arduino ci-dessus envoit un clic toutes les 0,7 secondes, à quel
tempo cela correspond-t-il ? Pour calculer le tempo, on divise 60 par la
fréquence en secondes :</p>

<p>$$
\begin{align}

T = 60 / F
\end{align}
$$</p>

<p>Donc, une fréquence de 0,7 seconde, comme celle de notre code arduino,
correspond à un tempo de \(60 / 0,7\). Soit à peu près 86.</p>

<h2 id="le-problme-de-la-boucle-de-code">Le problème de la boucle de code</h2>

<p>Maintenant on peut regarder le souci de ce code :</p>

<p><code>cpp
void loop() {
  digitalWrite(LED_PIN, HIGH);
  delay(100);
  digitalWrite(LED_PIN, LOW);
  delay(600);
}
</code></p>

<p>Partons de l’hypothèse qu’en plus des deux <code>digitalWrite</code>, mon code doit
aussi :</p>

<ul>
  <li>calculer l’intensité de la LED suivant le beat.</li>
  <li>jouer du son et ausssi calculer son intensité suivant le beat.</li>
  <li>s’occuper de plusieurs LEDs, peut-être avec des motifs.</li>
  <li>écrire le tempo et d’autres informations sur un écran LCD.</li>
  <li>tout ce que vous pourrez imaginer d’autre ;)</li>
</ul>

<p>Imaginons maintenant que l’ensemble de ces actions prennent 30 millisecondes
(0,03 secondes). Dans ce cas le tempo sera de \(60 / 0,73\). Soit à peu près 82.
Donc plus du tout la valeur de 86 qu’on avait trouvé tout à l’heure. <strong>Notre
métronome n’est pas fiable !</strong> Il ne vaut rien, arg.</p>

<p><img class="center" src="/images/facepalm.jpg"></p>

<h2 id="faire-et-ne-pas-attendre">Faire et ne pas attendre</h2>

<p>Pour remédier à ce problème nous demandons à l’arduino d’allumer la LED toutes
les 700 millisecondes et non pas <strong>d’attendre</strong> pendant 700 millisecondes.
Pour cela nous gardons une trace du dernier moment où la LED a été allumée
(dans <code>oldTime</code>) et nous comparons cette trace avec le moment présent
(<code>currentTime</code>) à chaque passage dans la boucle :</p>

<p>``` cpp
const byte LED_PIN = 2;
// In millisecondes.
const long FREQUENCY = 700;</p>

<p>long currentTime;
long oldTime;</p>

<p>void setup() {
  pinMode(LED_PIN, OUTPUT);
  currentTime = 0;
  oldTime = 0;
}</p>

<p>void loop() {
  currentTime = millis();</p>

<p>if(currentTime &gt;= oldTime + FREQUENCY) {
    digitalWrite(LED_PIN, HIGH);
    delay(100);
    digitalWrite(LED_PIN, LOW);
    oldTime = currentTime;
  }
}
```</p>

<p>Ça fonctionne pour notre métronome, bien qu’il reste encore 100 millisecondes
gachées (avec <code>delay(100);</code>). La prochaine fois on verra un moyen de se
débarasser de cette attente inutile.</p>

<p></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ce que je n'ai pas fait cette semaine]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/03/22/ce-que-je-nai-pas-fait-cette-semaine/"/>
    <updated>2015-03-22T15:18:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/03/22/ce-que-je-nai-pas-fait-cette-semaine</id>
    <content type="html"><![CDATA[<p><em>Premier article d’une série récurente que je posterai chaque dimanche, voici
ce que je n’ai pas fait cette semaine.</em></p>

<p>Je n’ai pas installé <strong>la dernière version de l’</strong><a href="http://arduino.cc/en/Main/Software">IDE Arduino</a>.
Je ne compte pas l’utiliser, mais il parait qu’elle intègre des outils en ligne
de commande, et ça c’est cool.</p>

<!-- more -->

<p>Je n’ai pas (encore) lu <strong>le livre de Hilary Mason</strong>
<a href="http://www.oreilly.com/data/free/data-driven.csp">Data Driven</a>.</p>

<p>Je n’ai pas acheté <strong>le livre</strong> <a href="https://leanpub.com/developing-games-with-ruby/">Developing Games With Ruby</a>.
J’hésite. Ça pourrait être fun.</p>

<p>Je ne me suis pas abonné à <strong>la version numérique de
Courrier International.</strong>
Je voulais le faire, mais on ne peut payer ni par carte bancaire, ni par
paypal. Et je n’aime pas l’idée du prélèvement bancaire.</p>

<p>Je n’ai pas travaillé sur mon <a href="https://twitter.com/lkdjiin/status/570258711547023362">super algorithme de génération d’immenses
labyrinthes</a> :</p>

<p>Je n’ai pas donné d’argent à <a href="https://rubytogether.org/">RubyTogether</a>.
Je voulais le faire, je voudrais le faire, je pense qu’il est nécessaire
d’avoir une telle structure pour assurer l’avenir de Ruby et de son écosystème
<del>mais le montant unique de 40$ par mois pour un particulier m’a refroidi.</del>
<ins>Et voilà, je réagis à chaud, je m’emporte et donc je
raconte n’importe quoi. On peut maintenant <a href="https://rubytogether.org/friends">faire un don</a>
sans cotiser mensuellement. Alors rendez-vous la semaine prochaine pour savoir
si j’ai donné ;)</ins></p>

<p>Et vous ? Que n’avez-vous pas fait cette semaine ?</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Un jeu de Simon - Étape 1]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/03/01/un-jeu-de-simon-etape-1/"/>
    <updated>2015-03-01T21:00:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/03/01/un-jeu-de-simon-etape-1</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Lors d’un projet du dimanche avec ma fille, j’ai commencé un
<a href="http://fr.wikipedia.org/wiki/Simon_%28jeu%29">jeu de Simon</a> sur l’Arduino.
Nous avons simplifié les règles au maximum (ma fille n’a pas 3 ans) et obtenu
ce que je vous propose dans cet article.</p>

<p>C’est seulement un point de départ, j’ai bien envie d’implémenter le jeu en
entier et d’en faire un objet réel. Il devrait donc y avoir d’autres articles…</p>

<p><img class="center" src="/images/simon-1.jpg"></p>

<!-- more -->

<h2 id="les-rgles">Les règles</h2>

<p>J’ai réduit les règles du jeu au plus simple : Il y a deux couleurs, rouge et
vert. La machine donne une couleur en allumant une LED et le joueur répond en
appuyant sur un bouton de couleur. Si la réponse est juste le joueur gagne et
une nouvelle partie commence. Si la réponse est fausse les LEDs clignotent
quelque temps pour signaler que le jeu est perdu et une nouvelle partie
commence.</p>

<p>Difficile de faire plus simple, hein ?</p>

<h2 id="les-composants">Les composants</h2>

<p>Nous aurons besoin de :</p>

<ul>
  <li>2 LEDs, une rouge et une verte</li>
  <li>2 boutons momentanés, si possible un rouge et un vert (sinon les gris
moches ça marche aussi)</li>
  <li>2 résistances de 220 Ohms pour les LEDs</li>
  <li>2 résistances de 10 kilo Ohms pour les boutons</li>
  <li>du câble</li>
</ul>

<h2 id="lassemblage">L’assemblage</h2>

<p><img class="center" src="/images/simon-etape1-bb.png"></p>

<h2 id="le-code">Le code</h2>

<p>Rien de spécial à dire pour le code, si ce n’est qu’il a été écrit sous la
pression de ma fille et la patience n’est pas son fort. Ça pourrait expliquer
pourquoi le code n’est pas très joli.</p>

<p>``` c
const byte RED = 0;
const byte GREEN = 1;</p>

<p>byte buttonRed = 8;
byte buttonGreen = 9;
byte ledRed = 2;
byte ledGreen = 3;
byte computerTurn = 1;
byte lastPly;</p>

<p>void setup() {
  pinMode(buttonRed, INPUT);
  pinMode(buttonGreen, INPUT);
  pinMode(ledRed, OUTPUT);
  pinMode(ledGreen, OUTPUT);</p>

<p>randomSeed(analogRead(0));
}</p>

<p>void loop() {
  if(computerTurn) {
    lastPly = random(2);
    allLedsOff();
    if(lastPly == RED) {
      digitalWrite(ledRed, HIGH);
    } else {
      digitalWrite(ledGreen, HIGH);
    }
    delay(300);
    allLedsOff();
    computerTurn = 0;
  } else {
    int stateRed = digitalRead(buttonRed);
    int stateGreen = digitalRead(buttonGreen);
    if(stateRed || stateGreen) {
      if(stateRed) {
        lightTheLed(ledRed);
      } else {
        lightTheLed(ledGreen);
      }
      if(stateRed &amp;&amp; lastPly == RED) {
        delay(2000);
      } else if(stateGreen &amp;&amp; lastPly == GREEN) {
        delay(2000);
      } else if((stateRed &amp;&amp; lastPly == GREEN) || (stateGreen &amp;&amp; lastPly == RED)) {
        blinkLeds();
        delay(2000);
      }
      computerTurn = 1;
    }
    delay(1);
  }
}</p>

<p>void allLedsOff() {
  digitalWrite(ledRed, LOW);
  digitalWrite(ledGreen, LOW);
}</p>

<p>void lightTheLed(byte led) {
  digitalWrite(led, HIGH);
  delay(200);
  digitalWrite(led, LOW);
}</p>

<p>void blinkLeds() {
  for(int i = 0; i &lt; 10; i++) {
    digitalWrite(ledRed, HIGH);
    digitalWrite(ledGreen, HIGH);
    delay(100);
    allLedsOff();
    delay(100);
  }
}
```</p>

<h2 id="la-suite">La suite</h2>

<p>Il reste beaucoup de choses à faire… Ajouter le bleu et le jaune ; ajouter du son ;
enregistrer les séquences de couleur ; le vrai jeu de Simon, quoi.
Et ensuite il faudra en faire un objet autonome, sans Arduino.</p>

<p>Alors à la prochaine.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
