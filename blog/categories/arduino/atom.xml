<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : arduino | Xavier Nayrac]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/arduino/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2015-09-11T15:10:15+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Connaitre la taille d'un programme pour Arduino]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/08/20/connaitre-la-taille-dun-programme-pour-arduino/"/>
    <updated>2015-08-20T16:45:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/08/20/connaitre-la-taille-dun-programme-pour-arduino</id>
    <content type="html"><![CDATA[<p>Si j’ai besoin de connaître la taille et la demande en RAM de mes
programmes Arduino, comment je fais ? Et puis d’abord pourquoi je voudrais
connaître leur taille ?</p>

<p><img class="center" src="/images/640-arduino-avr.jpg"></p>

<!-- more -->

<h2 id="o-se-cache-le-programme">Où se cache le programme</h2>

<p>Le programme au format elf se trouve dans un dossier caché. Vous pouvez
constater que sa taille est assez conséquente. Ce n’est pas du tout sa taille
finale pour l’Arduino.</p>

<p><code>bash
$ \ls -lh .build/uno/firmware.elf 
-rwxr-xr-x 1 xavier xavier 40K août  19 21:01 .build/uno/firmware.elf
</code></p>

<p><em>Un dossier caché est un dossier dont le nom commence par un point. On dit
«caché» car sous Linux et OS X ils sont invisibles par défaut.</em></p>

<h2 id="comment-connatre-les-besoins-en-mmoire-dun-programme-arduino">Comment connaître les besoins en mémoire d’un programme Arduino</h2>

<p>C’est le programme <code>avr-size</code> qui va tout nous dire:</p>

<p>```bash
$ avr-size -dC .build/uno/firmware.elf 
AVR Memory Usage
—————-
Device: Unknown</p>

<p>Program:    2786 bytes
(.text + .data + .bootloader)</p>

<p>Data:         34 bytes
(.data + .bss + .noinit)
```</p>

<p>J’utilise 34 octets de RAM et 2786 octets au total.</p>

<p>Le switch <code>-d</code> fournit les valeurs en décimal. Le switch <code>-C</code> spécifie le
format du rapport de <code>avr-size</code> (<code>$ avr-size --help</code> pour voir les autres).</p>

<h2 id="pourquoi-faire">Pourquoi faire</h2>

<p>Les micro contrôleurs ATMEL ont des tailles de mémoire
différentes (mémoire vive et mémoire programme). Par exemple l’ATtiny13 possède 1 Ko pour le programme et 64 octets
de RAM, tandis que le ATtiny85 fait 8 Ko pour le programme et 512 octets pour
la RAM.</p>

<p>Pour les programmes qui sont destinés à quitter la plateforme Arduino pour
rejoindre un micro contrôleur, connaître la taille mémoire permet de savoir
si il est intéressant de passer du temps et de l’énergie à <em>optimiser</em> ces
programmes.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Arduino : Un métronome tap tempo]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/04/03/arduino-un-metronome-tap-tempo/"/>
    <updated>2015-04-03T18:35:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/04/03/arduino-un-metronome-tap-tempo</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>J’aimerais fabriquer un métronome <em>tap tempo</em> avec l’arduino. C’est un projet à
moyen terme, et
comme souvent, il pourrait être bénéfique de diviser le projet en plusieurs
petites parties. Donc, avant de tenter la programmation du tap tempo, je vais
faire un métronome tout simple avec juste une LED.</p>

<h2 id="les-composants">Les composants</h2>

<p>Coté composants, on a seulement besoin d’une LED et d’une résistance (220 Ohms
ça ira).</p>

<p><img class="center" src="/images/metronome1_bb.png"></p>

<!-- more -->

<h2 id="un-premier-code-naif">Un premier code naif</h2>

<p>Le premier jet est tout simple :</p>

<p>``` cpp
const byte LED_PIN = 2;</p>

<p>void setup() {
  pinMode(LED_PIN, OUTPUT);
}</p>

<p>void loop() {
  digitalWrite(LED_PIN, HIGH);
  delay(100);
  digitalWrite(LED_PIN, LOW);
  delay(600);
}
```</p>

<p>Une fois compilé et envoyé dans l’arduino, la LED clignote toutes les 0,7
secondes. Nous avons un métronome visuel !</p>

<p>C’est simple, non ? Mouais. Trop simple, bien sûr. Ce code est problèmatique
pour la fabrication d’un métronome. Alors afin de comprendre pourquoi, parlons
un peu du tempo.</p>

<h2 id="le-tempo">Le tempo</h2>

<p>Pour le musicien, le tempo est une suite de clics (ou tic, ou tac, ou poum, ou
tchak, ou clac). Ces clics, qui ont la particularité de se succéder à
intervalles réguliers, marquent la <strong>vitesse</strong> de la musique.</p>

<p>Le tempo (donc la vitesse de la musique) est indiqué à l’aide d’un nombre qui
représente le nombre de clics par minute.
Par exemple un tempo de 60 nous indique qu’il doit y avoir 60 clics dans une minute,
ou plus simplement 1 clic par seconde. Autre exemple, un tempo de 120 indique
120 clics par minute, soit 2 clics par seconde, ou encore 1 clic toutes les
0,5 secondes.</p>

<p>Voyons maintenant quelques formules. Pour trouver la fréquence F, en secondes,
il faut diviser 60 par le tempo (noté T) :</p>

<p>$$
\begin{align}

F = 60 / T
\end{align}
$$</p>

<p>Pour obtenir cette fréquence en millisecondes, il faut multiplier le résultat
précédent par 1000 ;</p>

<p>$$
\begin{align}

F = 60 / T \times 1000
\end{align}
$$</p>

<p>Le code arduino ci-dessus envoit un clic toutes les 0,7 secondes, à quel
tempo cela correspond-t-il ? Pour calculer le tempo, on divise 60 par la
fréquence en secondes :</p>

<p>$$
\begin{align}

T = 60 / F
\end{align}
$$</p>

<p>Donc, une fréquence de 0,7 seconde, comme celle de notre code arduino,
correspond à un tempo de \(60 / 0,7\). Soit à peu près 86.</p>

<h2 id="le-problme-de-la-boucle-de-code">Le problème de la boucle de code</h2>

<p>Maintenant on peut regarder le souci de ce code :</p>

<p><code>cpp
void loop() {
  digitalWrite(LED_PIN, HIGH);
  delay(100);
  digitalWrite(LED_PIN, LOW);
  delay(600);
}
</code></p>

<p>Partons de l’hypothèse qu’en plus des deux <code>digitalWrite</code>, mon code doit
aussi :</p>

<ul>
  <li>calculer l’intensité de la LED suivant le beat.</li>
  <li>jouer du son et ausssi calculer son intensité suivant le beat.</li>
  <li>s’occuper de plusieurs LEDs, peut-être avec des motifs.</li>
  <li>écrire le tempo et d’autres informations sur un écran LCD.</li>
  <li>tout ce que vous pourrez imaginer d’autre ;)</li>
</ul>

<p>Imaginons maintenant que l’ensemble de ces actions prennent 30 millisecondes
(0,03 secondes). Dans ce cas le tempo sera de \(60 / 0,73\). Soit à peu près 82.
Donc plus du tout la valeur de 86 qu’on avait trouvé tout à l’heure. <strong>Notre
métronome n’est pas fiable !</strong> Il ne vaut rien, arg.</p>

<p><img class="center" src="/images/facepalm.jpg"></p>

<h2 id="faire-et-ne-pas-attendre">Faire et ne pas attendre</h2>

<p>Pour remédier à ce problème nous demandons à l’arduino d’allumer la LED toutes
les 700 millisecondes et non pas <strong>d’attendre</strong> pendant 700 millisecondes.
Pour cela nous gardons une trace du dernier moment où la LED a été allumée
(dans <code>oldTime</code>) et nous comparons cette trace avec le moment présent
(<code>currentTime</code>) à chaque passage dans la boucle :</p>

<p>``` cpp
const byte LED_PIN = 2;
// In millisecondes.
const long FREQUENCY = 700;</p>

<p>long currentTime;
long oldTime;</p>

<p>void setup() {
  pinMode(LED_PIN, OUTPUT);
  currentTime = 0;
  oldTime = 0;
}</p>

<p>void loop() {
  currentTime = millis();</p>

<p>if(currentTime &gt;= oldTime + FREQUENCY) {
    digitalWrite(LED_PIN, HIGH);
    delay(100);
    digitalWrite(LED_PIN, LOW);
    oldTime = currentTime;
  }
}
```</p>

<p>Ça fonctionne pour notre métronome, bien qu’il reste encore 100 millisecondes
gachées (avec <code>delay(100);</code>). La prochaine fois on verra un moyen de se
débarasser de cette attente inutile.</p>

<p></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ce que je n'ai pas fait cette semaine]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/03/22/ce-que-je-nai-pas-fait-cette-semaine/"/>
    <updated>2015-03-22T15:18:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/03/22/ce-que-je-nai-pas-fait-cette-semaine</id>
    <content type="html"><![CDATA[<p><em>Premier article d’une série récurente que je posterai chaque dimanche, voici
ce que je n’ai pas fait cette semaine.</em></p>

<p>Je n’ai pas installé <strong>la dernière version de l’</strong><a href="http://arduino.cc/en/Main/Software">IDE Arduino</a>.
Je ne compte pas l’utiliser, mais il parait qu’elle intègre des outils en ligne
de commande, et ça c’est cool.</p>

<!-- more -->

<p>Je n’ai pas (encore) lu <strong>le livre de Hilary Mason</strong>
<a href="http://www.oreilly.com/data/free/data-driven.csp">Data Driven</a>.</p>

<p>Je n’ai pas acheté <strong>le livre</strong> <a href="https://leanpub.com/developing-games-with-ruby/">Developing Games With Ruby</a>.
J’hésite. Ça pourrait être fun.</p>

<p>Je ne me suis pas abonné à <strong>la version numérique de
Courrier International.</strong>
Je voulais le faire, mais on ne peut payer ni par carte bancaire, ni par
paypal. Et je n’aime pas l’idée du prélèvement bancaire.</p>

<p>Je n’ai pas travaillé sur mon <a href="https://twitter.com/lkdjiin/status/570258711547023362">super algorithme de génération d’immenses
labyrinthes</a> :</p>

<p>Je n’ai pas donné d’argent à <a href="https://rubytogether.org/">RubyTogether</a>.
Je voulais le faire, je voudrais le faire, je pense qu’il est nécessaire
d’avoir une telle structure pour assurer l’avenir de Ruby et de son écosystème
<del>mais le montant unique de 40$ par mois pour un particulier m’a refroidi.</del>
<ins>Et voilà, je réagis à chaud, je m’emporte et donc je
raconte n’importe quoi. On peut maintenant <a href="https://rubytogether.org/friends">faire un don</a>
sans cotiser mensuellement. Alors rendez-vous la semaine prochaine pour savoir
si j’ai donné ;)</ins></p>

<p>Et vous ? Que n’avez-vous pas fait cette semaine ?</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Un jeu de Simon - Étape 1]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/03/01/un-jeu-de-simon-etape-1/"/>
    <updated>2015-03-01T21:00:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/03/01/un-jeu-de-simon-etape-1</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Lors d’un projet du dimanche avec ma fille, j’ai commencé un
<a href="http://fr.wikipedia.org/wiki/Simon_%28jeu%29">jeu de Simon</a> sur l’Arduino.
Nous avons simplifié les règles au maximum (ma fille n’a pas 3 ans) et obtenu
ce que je vous propose dans cet article.</p>

<p>C’est seulement un point de départ, j’ai bien envie d’implémenter le jeu en
entier et d’en faire un objet réel. Il devrait donc y avoir d’autres articles…</p>

<p><img class="center" src="/images/simon-1.jpg"></p>

<!-- more -->

<h2 id="les-rgles">Les règles</h2>

<p>J’ai réduit les règles du jeu au plus simple : Il y a deux couleurs, rouge et
vert. La machine donne une couleur en allumant une LED et le joueur répond en
appuyant sur un bouton de couleur. Si la réponse est juste le joueur gagne et
une nouvelle partie commence. Si la réponse est fausse les LEDs clignotent
quelque temps pour signaler que le jeu est perdu et une nouvelle partie
commence.</p>

<p>Difficile de faire plus simple, hein ?</p>

<h2 id="les-composants">Les composants</h2>

<p>Nous aurons besoin de :</p>

<ul>
  <li>2 LEDs, une rouge et une verte</li>
  <li>2 boutons momentanés, si possible un rouge et un vert (sinon les gris
moches ça marche aussi)</li>
  <li>2 résistances de 220 Ohms pour les LEDs</li>
  <li>2 résistances de 10 kilo Ohms pour les boutons</li>
  <li>du câble</li>
</ul>

<h2 id="lassemblage">L’assemblage</h2>

<p><img class="center" src="/images/simon-etape1-bb.png"></p>

<h2 id="le-code">Le code</h2>

<p>Rien de spécial à dire pour le code, si ce n’est qu’il a été écrit sous la
pression de ma fille et la patience n’est pas son fort. Ça pourrait expliquer
pourquoi le code n’est pas très joli.</p>

<p>``` c
const byte RED = 0;
const byte GREEN = 1;</p>

<p>byte buttonRed = 8;
byte buttonGreen = 9;
byte ledRed = 2;
byte ledGreen = 3;
byte computerTurn = 1;
byte lastPly;</p>

<p>void setup() {
  pinMode(buttonRed, INPUT);
  pinMode(buttonGreen, INPUT);
  pinMode(ledRed, OUTPUT);
  pinMode(ledGreen, OUTPUT);</p>

<p>randomSeed(analogRead(0));
}</p>

<p>void loop() {
  if(computerTurn) {
    lastPly = random(2);
    allLedsOff();
    if(lastPly == RED) {
      digitalWrite(ledRed, HIGH);
    } else {
      digitalWrite(ledGreen, HIGH);
    }
    delay(300);
    allLedsOff();
    computerTurn = 0;
  } else {
    int stateRed = digitalRead(buttonRed);
    int stateGreen = digitalRead(buttonGreen);
    if(stateRed || stateGreen) {
      if(stateRed) {
        lightTheLed(ledRed);
      } else {
        lightTheLed(ledGreen);
      }
      if(stateRed &amp;&amp; lastPly == RED) {
        delay(2000);
      } else if(stateGreen &amp;&amp; lastPly == GREEN) {
        delay(2000);
      } else if((stateRed &amp;&amp; lastPly == GREEN) || (stateGreen &amp;&amp; lastPly == RED)) {
        blinkLeds();
        delay(2000);
      }
      computerTurn = 1;
    }
    delay(1);
  }
}</p>

<p>void allLedsOff() {
  digitalWrite(ledRed, LOW);
  digitalWrite(ledGreen, LOW);
}</p>

<p>void lightTheLed(byte led) {
  digitalWrite(led, HIGH);
  delay(200);
  digitalWrite(led, LOW);
}</p>

<p>void blinkLeds() {
  for(int i = 0; i &lt; 10; i++) {
    digitalWrite(ledRed, HIGH);
    digitalWrite(ledGreen, HIGH);
    delay(100);
    allLedsOff();
    delay(100);
  }
}
```</p>

<h2 id="la-suite">La suite</h2>

<p>Il reste beaucoup de choses à faire… Ajouter le bleu et le jaune ; ajouter du son ;
enregistrer les séquences de couleur ; le vrai jeu de Simon, quoi.
Et ensuite il faudra en faire un objet autonome, sans Arduino.</p>

<p>Alors à la prochaine.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les maths derrière V=RI]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/02/11/les-maths-derriere-v-equals-ri/"/>
    <updated>2015-02-11T11:22:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/02/11/les-maths-derriere-v-equals-ri</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>\(V = RI\), la formule est simple. V pour le voltage (en Volts), R pour la
résistance (en Ohms) et I pour l’intensité (en Ampères).  Grâce à elle nous
pouvons calculer l’ampérage si nous connaissons le voltage et la résistance:</p>

<p>$$
\begin{align}

  I= \frac{V}{R}
\end{align}
$$</p>

<p>Et nous pouvons aussi calculer la résistance si nous connaissons le voltage et
l’intensité:</p>

<p>$$
\begin{align}

  R= \frac{V}{I}
\end{align}
$$</p>

<p>Pas besoin d’être fort en math pour pouvoir appliquer ces 3 formules. On a
juste à faire une multiplication, ou bien une division. Mais si on veut
comprendre pourquoi les deux dernières formules <em>découlent</em> de la première, il
faut un minimum de bagage en math.</p>

<p><strong>Cet article est pour celles et ceux qui ont séchés les cours de math au
collège</strong> et qui voudraient maintenant comprendre pourquoi \(V = RI\) implique
nécessairement \(I = V / R\). Je vais tâcher de tirer et d’expliquer tous les
fils qui nous amène à déduire la seconde formule à partir de la première.</p>

<p><img class="center" src="/images/math.jpg"></p>

<!-- more -->

<h2 id="le-symbole-de-la-multiplication">Le symbole de la multiplication</h2>

<p>Le plus simple d’abord, \(RI\) est la multiplication de R par I.
Donc \(RI\) est la même chose que \(R \times I\).
Pour simplifier les choses (<em>ironie…</em>) on peut aussi
écrire le signe le la multiplication avec un point.
Les 3 lignes suivantes sont donc équivalentes:</p>

<p>$$
\begin{align}

  RI            <br />
  R \times I    <br />
  R \cdot I
\end{align}
$$</p>

<h2 id="lgalit">L’égalité</h2>

<p>Parlons maintenant du signe <code>=</code>. Il signifie qu’on a une égalité entre ce qui
se trouve à sa gauche et ce qui se trouve à sa droite. En d’autres termes, ce
qui est à gauche du signe <code>=</code> à la même valeur que ce qui est à sa droite.
Donc si V vaut 12 (c’est un exemple), alors R × I vaut
aussi exactement 12. Si je remplace V par 12 dans la formule, on voit bien que
RI vaut 12:</p>

<p>$$
\begin{align}

  12 = RI
\end{align}
$$</p>

<p>Ça ne nous
dit pas combien vaut exactement R ni combien vaut exactement I mais on sait
que la multiplication de ces deux là vaut 12. On a peut-être R = 1 et I = 12, ou
encore R = 3 et I = 4. Tout est possible du moment que \(R \times I = 12\).</p>

<p>Cette dernière égalité ( \(R \times I = 12\) ) m’amène à préciser ceci:
\(V = RI\) est la
même chose que \(RI = V\). Si vous avez du mal à penser avec des lettres,
n’hésitez pas à les remplacer régulièrement par des nombres pour voir de quoi
ça a l’air. Par exemple, si on dit que V = 12, R = 3 et I = 4, on peut écrire:</p>

<p>$$
\begin{align}

  12 = 3 \times 4
\end{align}
$$</p>

<p>Ou encore :</p>

<p>$$
\begin{align}

  3 \times 4 = 12
\end{align}
$$</p>

<p>C’est bien la même chose.</p>

<h2 id="jouons-avec-lgalit">Jouons avec l’égalité</h2>

<p>On peut faire subir aux deux cotés de l’égalité la même opération sans que cela
pose problème.</p>

<p>Par exemple on peut ajouter 1 de chaque coté:</p>

<p>$$
\begin{align}

  V + 1 = RI + 1
\end{align}
$$</p>

<p>Essayons avec des nombres. Si V = 12, R = 3 et I = 4 :</p>

<p>$$
\begin{align}

12 + 1 &amp;= 3 \times 4 + 1 <br />
13 &amp;= 12 + 1 <br />
13 &amp;= 13
\end{align}
$$</p>

<p>Ça marcherait aussi avec une soustraction ou tiens, avec une multiplication:</p>

<p>$$
\begin{align}

V \times 2 &amp;= R \times I \times 2 <br />
12 \times 2 &amp;= 3 \times 4 \times 2 <br />
24 &amp;= 12 \times 2 <br />
24 &amp;= 24
\end{align}
$$</p>

<p>Et bien sûr, ça fonctionne aussi avec la division, tant qu’on divise par
autre chose que zéro:</p>

<p>$$
\begin{align}

V / 2 &amp;= R \times I / 2 <br />
12 / 2 &amp;= 3 \times 4 / 2 <br />
6 &amp;= 12 / 2 <br />
6 &amp;= 6
\end{align}
$$</p>

<h2 id="un-truc-intressant--propos-de-la-division">Un truc intéressant à propos de la division</h2>

<p>Puisqu’on parle de division, voici un truc intéressant à propos de la division.
Quand on divise un nombre (n’importe lequel à part zéro) par lui-même on obtient toujours 1.
Toujours. Par exemple:</p>

<p>$$
\begin{align}

  12 / 12 = 1
\end{align}
$$</p>

<p>Si on généralise : \(A / A = 1\). Donc c’est pareil avec R ou I :</p>

<p>$$
\begin{align}

  R / R &amp;= 1 <br />
  I / I &amp;= 1
\end{align}
$$</p>

<h2 id="division-et-fraction">Division et fraction</h2>

<p>Jusqu’ici j’ai utilisé le signe <code>/</code> pour la division, mais celui-ci n’est pas
toujours très pratique et on le remplace souvent par une fraction. Et oui:
division et fraction c’est la même chose.</p>

<p>$$
\begin{align}

  X / Y= \frac{X}{Y}
\end{align}
$$</p>

<p>Reprenons notre formule de base :</p>

<p>$$
\begin{align}

  V = R \times I
\end{align}
$$</p>

<p>Si on divise les deux cotés par R, ça donne :</p>

<p>$$
\begin{align}

  \frac{V}{R}= \frac{R \times I}{R}
\end{align}
$$</p>

<p>On y est presque, je vous assure ! Il faut encore comprendre une dernière chose :</p>

<p>$$
\begin{align}

  \frac{R \times I}{R}=I
\end{align}
$$</p>

<p>Wait</p>

<p><img class="center" src="/images/wut.jpg"></p>

<p>Rappelez vous qu’une fraction, c’est la même chose qu’une division. Si je
généralise:</p>

<p>$$
\begin{align}

  \frac{X \times Y}{Z}=X \times Y / Z
\end{align}
$$</p>

<p>Il faut aussi savoir qu’il n’y a pas de priorité entre la multiplication et
la division, ainsi \(10 \times 2 / 5 = 4\), tout aussi bien que
\(10 / 5 \times 2 = 4\) ou que \(2 / 5 \times 10 = 4\).</p>

<p>Donc :</p>

<p>$$
\begin{align}

  \frac{R \times I}{R}
\end{align}
$$</p>

<p>Équivaut à :</p>

<p>$$
\begin{align}

  R \times I / R
\end{align}
$$</p>

<p>Ce qui est exactement pareil que :</p>

<p>$$
\begin{align}

  R / R \times I
\end{align}
$$</p>

<p>Et nous avons vu que <code>R / R</code> vaut 1, ce qui donne :</p>

<p>$$
\begin{align}

  1 \times I
\end{align}
$$</p>

<p>Ou plus simplement :</p>

<p>$$
\begin{align}

  I
\end{align}
$$</p>

<h2 id="conclusion">Conclusion</h2>

<p>Notre formule de base nous permet de calculer V à partir de R et de I:</p>

<p>$$
\begin{align}

  V = RI
\end{align}
$$</p>

<p>On joue avec en divisant chaque coté par R:</p>

<p>$$
\begin{align}

  \frac{V}{R} = \frac{RI}{R}
\end{align}
$$</p>

<p>Ce qui donne:</p>

<p>$$
\begin{align}

  \frac{V}{R} = I
\end{align}
$$</p>

<p>Qu’on remet dans le bon sens si on préfère, on peut maintenant calculer I à
partir de V et R:</p>

<p>$$
\begin{align}

  I = \frac{V}{R}
\end{align}
$$</p>

<p>Si nous avons un voltage de 5 Volts et une résistance de 1000 Ohms, combien
aurons nous d’ampères:</p>

<p>$$
\begin{align}

  I = \frac{5}{1000} = 0.005
\end{align}
$$</p>

<p>Vous venez de déduire une formule mathématique à partir d’une autre et de
l’utiliser !
Et de rattraper plusieurs heures de sèche du collège en quelques minutes ;)</p>

<p>À plus tard.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
