<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : arduino | Xavier Nayrac]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/arduino/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2016-01-18T09:34:57+01:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Fabriquer un sablier à thé électronique 2]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/12/12/fabriquer-un-sablier-a-the-electronique-2/"/>
    <updated>2015-12-12T16:51:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/12/12/fabriquer-un-sablier-a-the-electronique-2</id>
    <content type="html"><![CDATA[<p>Après avoir appris à programmer un ATtiny45 avec l’IDE Arduino, il fallait
maintenant s’en passer. Pour cela je suis passé du langage Arduino au
langage C, avec le cross compilateur <code>avr-gcc</code> et l’outil <code>avrdude</code>.</p>

<p>Je vais profiter de vous montrer cela pour comparer la taille d’un même
programme, écrit une fois en langage Arduino et l’autre en C.</p>

<!-- more -->

<p><a href="/blog/2015/10/29/fabriquer-un-sablier-a-the-electronique/">Lire la partie 1</a></p>

<p>Le programme, c’est deux boutons/deux LEDs. Le bouton A s’occupe de la LED A.
Le bouton B s’occupe de la LED B. Quand un bouton est pressé puis relâché, sa
LED respective change d’état. Si elle était éteinte elle s’allume, et vice-versa.
C’était un peu mon <em>hello world!</em></p>

<p>Voilà le programme en langage Arduino:</p>

<p>```c sketch/sketch.ino
void setup() {
  pinMode(3, OUTPUT);
  pinMode(4, OUTPUT);
  digitalWrite(3, HIGH);
  digitalWrite(4, HIGH);
  pinMode(0, INPUT_PULLUP);
  pinMode(1, INPUT_PULLUP);
}</p>

<p>void loop() {
  if(digitalRead(0) == LOW) {
    delay(10);
    while(digitalRead(0) != HIGH) ;
    delay(10);
    digitalWrite(3, bitRead(PORTB, 3) ^ HIGH);
  }
  if(digitalRead(1) == LOW) {
    delay(10);
    while(digitalRead(1) != HIGH) ;
    delay(10);
    digitalWrite(4, bitRead(PORTB, 4) ^ HIGH);
  }
}
```</p>

<p>Le dossier contient juste deux sous dossiers:</p>

<pre><code>$ dirtree
.
├── build
└── sketch
</code></pre>

<p>Je compile avec l’IDE (en ligne de commande mais avec l’IDE quand même):</p>

<pre><code>$ ~/local/bin/arduino-1.6.5/arduino --verify sketch/sketch.ino
--pref build.path=build
Picked up JAVA_TOOL_OPTIONS: 
Loading configuration...
Initializing packages...
Preparing boards...
Verifying...

Le croquis utilise 972 octets (23%) de l'espace de stockage de programmes.
Le maximum est de 4 096 octets.
Les variables globales utilisent 9 octets de mémoire dynamique.
</code></pre>

<p>La taille du programme a déjà était annoncée, mais on peut la vérifier avec
<code>avr-size</code>, 972 octets:</p>

<pre><code>$ avr-size -d build/sketch.cpp.hex 
   text	   data	    bss	    dec	    hex	filename
      0	    972	      0	    972	    3cc	build/sketch.cpp.hex
</code></pre>

<p>Maintenant voici le même programme, cette fois directement en C. Donc sans
toutes les aides et fioritures de l’Arduino:</p>

<p>```c main.c
#include &lt;avr/io.h&gt;
#define F_CPU 1000000UL
#include &lt;util/delay.h&gt;</p>

<p>int main(void)
{
  DDRB |= 1 « 4 | 1 « 3;
  PORTB |= 1 « 4 | 1 « 3;
  DDRB &amp;= ~(1 « 0 | 1 « 1);
  PORTB |= (1 « 0 | 1 « 1);</p>

<p>while(1) {
    if(!(PINB &amp; (1 « 0))) {
      _delay_ms(10);
      while(!(PINB &amp; (1 « 0))) ;
      _delay_ms(10);
      PORTB ^= (1 « 3);
    }
    if(!(PINB &amp; (1 « 1))) {
      _delay_ms(10);
      while(!(PINB &amp; (1 « 1))) ;
      _delay_ms(10);
      PORTB ^= (1 « 4);
    }
  }
}
```</p>

<p>La chaîne de compilation est cette fois un peu plus longue:</p>

<pre><code>$ avr-gcc -O -mmcu=attiny45 -c main.c
$ avr-gcc -mmcu=attiny45 -o main.elf main.o
$ avr-objcopy -O ihex main.elf main.hex
</code></pre>

<p>Même avec une option d’optimisation au minimum, la différence de taille est… sidérale:</p>

<pre><code>$ avr-size -d main.hex 
   text	   data	    bss	    dec	    hex	filename
      0	    158	      0	    158	     9e	main.hex
</code></pre>

<p>Pour transférer le code vers le micro processeur il n’y a plus besoin de l’IDE
Arduino. Je place l’ATtiny45 sur le <a href="/blog/2015/10/29/fabriquer-un-sablier-a-the-electronique/">shield programmateur</a> et j’utilise le
programme avrdude :</p>

<p><code>
avrdude -p attiny45 -P /dev/ttyUSB0 -c arduino -U flash:w:main.hex -b 19200
</code></p>

<p>Rendez vous une prochaine fois pour le code du sablier électronique avec son
Makefile et tout et tout.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Fabriquer un sablier à thé électronique]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/10/29/fabriquer-un-sablier-a-the-electronique/"/>
    <updated>2015-10-29T14:59:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/10/29/fabriquer-un-sablier-a-the-electronique</id>
    <content type="html"><![CDATA[<p>Voici un projet que j’avais en route depuis quelques semaines.  L’objectif était de
fabriquer mon premier «objet» grâce à l’arduino, en l’occurrence un <em>sablier à
thé électronique</em>.</p>

<p><img class="center" src="/images/hourglass.jpg"></p>

<p>Un quoi ? En fait il s’agit tout simplement d’un minuteur. Mais je trouve le
nom <em>sablier à thé électronique</em> bien plus évocateur ;) Quand je me fais du thé
je laisse passer 9 fois sur 10 le temps d’infusion et je me retrouve avec un
breuvage imbuvable. J’avais donc envie d’un minuteur simple avec deux boutons,
un buzzer et une LED. Un des boutons lance un décompte de 3 minutes pour le thé
vert, l’autre c’est 5 minutes pour le thé noir. À la fin ça bip bip et ça
clignote jusqu’à ce qu’on l’arrête. Du vraiment simple, quoi. Sauf que je ne
voulais pas mettre un arduino entier dans ce projet alors qu’un petit micro
contrôleur à 60 centimes pourrait faire l’affaire.</p>

<!-- more -->

<p>J’allais donc devoir apprendre à programmer les micro contrôleurs ATtiny de
chez Atmel. Pourquoi ceux-là ? Parce qu’ils sont proches du micro contrôleur
utilisé par l’arduino (le ATmega 328). Bref je gardais quand même un pied en
terrain connu.</p>

<p>J’ai d’abord créé un prototype de ce <em>sablier sonore</em> avec l’arduino, pour être
sûr que je savais comment faire. Niveau schéma ça pourrait donner quelque chose
comme ça:</p>

<p><img class="center" src="/images/attiny45-step4.png"></p>

<p>Au final je n’utilise qu’une seule LED, mais dans le prototype original il y en
avait deux. Et c’est en utilisant ce premier prototype que je me suis aperçu
qu’une seule LED était suffisante.</p>

<p>L’étape suivante fut de réaliser ce montage, et le code, pour un ATtiny45.
Pourquoi ce micro contrôleur précisément ? Parce que 1) j’en avais un dans un
tiroir, et 2) on trouve une pléthore de tutoriels pour programmer un ATtiny45
en se servant d’un arduino. Si vous n’êtes pas familier du terme,
<strong>programmer</strong> un micro contrôleur c’est, en gros, lui transférer son programme
depuis un ordinateur. Pour que les deux cotés communiquent, on utilise un
<strong>programmateur</strong>. Il y a plusieurs façons de faire ça, je voulais utiliser un
arduino comme base de programmateur pour ne rien avoir à acheter de nouveau.
Vous pouvez trouver un bon tutoriel ici:
<a href="http://www.instructables.com/id/Program-an-ATtiny44458485-with-Arduino/">Program an ATtiny44/45/84/85 with Arduino</a>.</p>

<p>Finalement, on peut se créer le programmateur assez facilement pour l’ATtiny45:</p>

<p><img class="center" src="/images/hello_world_bb.png"></p>

<p>Comme j’allais programmer un certain nombre de micro contrôleurs, j’ai préféré
fabriquer un shield. D’abord un temporaire:</p>

<p><img class="center" src="/images/arduino-temp-shield.jpg"></p>

<p>Puis finalement un définitif:</p>

<p><img class="center" src="/images/arduino-shield-attiny45.jpg"></p>

<p>Trop pressé de le réaliser, je me suis trompé de sens pour le socket, ce qui
explique les câbles qui passent d’un coté à l’autre, puisque je n’ai pas
voulu le dessouder. C’est pas grave et il fonctionne très bien ;)</p>

<p>J’étais donc capable de programmer un ATtiny45 (4K de ROM) en utilisant
l’arduino <strong>ET</strong> l’IDE Arduino. C’était un bon début, mais ça n’était pas
suffisant. D’abord je ne voulais pas utiliser l’IDE Arduino, mais plutôt des
outils en ligne de commande, pour des raisons de reproductibilité et d’automatisation, et ensuite
je soupçonnais que le code de mon <em>sablier sonore</em> pouvait tenir sur un
ATtiny13 qui ne posséde que 1K de ROM et est pratiquement deux fois moins cher
que l’ATtiny45.</p>

<p><a href="/blog/2015/12/12/fabriquer-un-sablier-a-the-electronique-2/">Lire la partie 2</a></p>

<p>À suivre…</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Connaitre la taille d'un programme pour Arduino]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/08/20/connaitre-la-taille-dun-programme-pour-arduino/"/>
    <updated>2015-08-20T16:45:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/08/20/connaitre-la-taille-dun-programme-pour-arduino</id>
    <content type="html"><![CDATA[<p>Si j’ai besoin de connaître la taille et la demande en RAM de mes
programmes Arduino, comment je fais ? Et puis d’abord pourquoi je voudrais
connaître leur taille ?</p>

<p><img class="center" src="/images/640-arduino-avr.jpg"></p>

<!-- more -->

<h2 id="o-se-cache-le-programme">Où se cache le programme</h2>

<p>Le programme au format elf se trouve dans un dossier caché. Vous pouvez
constater que sa taille est assez conséquente. Ce n’est pas du tout sa taille
finale pour l’Arduino.</p>

<p><code>bash
$ \ls -lh .build/uno/firmware.elf 
-rwxr-xr-x 1 xavier xavier 40K août  19 21:01 .build/uno/firmware.elf
</code></p>

<p><em>Un dossier caché est un dossier dont le nom commence par un point. On dit
«caché» car sous Linux et OS X ils sont invisibles par défaut.</em></p>

<h2 id="comment-connatre-les-besoins-en-mmoire-dun-programme-arduino">Comment connaître les besoins en mémoire d’un programme Arduino</h2>

<p>C’est le programme <code>avr-size</code> qui va tout nous dire:</p>

<p>```bash
$ avr-size -dC .build/uno/firmware.elf 
AVR Memory Usage
—————-
Device: Unknown</p>

<p>Program:    2786 bytes
(.text + .data + .bootloader)</p>

<p>Data:         34 bytes
(.data + .bss + .noinit)
```</p>

<p>J’utilise 34 octets de RAM et 2786 octets au total.</p>

<p>Le switch <code>-d</code> fournit les valeurs en décimal. Le switch <code>-C</code> spécifie le
format du rapport de <code>avr-size</code> (<code>$ avr-size --help</code> pour voir les autres).</p>

<h2 id="pourquoi-faire">Pourquoi faire</h2>

<p>Les micro contrôleurs ATMEL ont des tailles de mémoire
différentes (mémoire vive et mémoire programme). Par exemple l’ATtiny13 possède 1 Ko pour le programme et 64 octets
de RAM, tandis que le ATtiny85 fait 8 Ko pour le programme et 512 octets pour
la RAM.</p>

<p>Pour les programmes qui sont destinés à quitter la plateforme Arduino pour
rejoindre un micro contrôleur, connaître la taille mémoire permet de savoir
si il est intéressant de passer du temps et de l’énergie à <em>optimiser</em> ces
programmes.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Arduino : Un métronome tap tempo]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/04/03/arduino-un-metronome-tap-tempo/"/>
    <updated>2015-04-03T18:35:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/04/03/arduino-un-metronome-tap-tempo</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>J’aimerais fabriquer un métronome <em>tap tempo</em> avec l’arduino. C’est un projet à
moyen terme, et
comme souvent, il pourrait être bénéfique de diviser le projet en plusieurs
petites parties. Donc, avant de tenter la programmation du tap tempo, je vais
faire un métronome tout simple avec juste une LED.</p>

<h2 id="les-composants">Les composants</h2>

<p>Coté composants, on a seulement besoin d’une LED et d’une résistance (220 Ohms
ça ira).</p>

<p><img class="center" src="/images/metronome1_bb.png"></p>

<!-- more -->

<h2 id="un-premier-code-naif">Un premier code naif</h2>

<p>Le premier jet est tout simple :</p>

<p>``` cpp
const byte LED_PIN = 2;</p>

<p>void setup() {
  pinMode(LED_PIN, OUTPUT);
}</p>

<p>void loop() {
  digitalWrite(LED_PIN, HIGH);
  delay(100);
  digitalWrite(LED_PIN, LOW);
  delay(600);
}
```</p>

<p>Une fois compilé et envoyé dans l’arduino, la LED clignote toutes les 0,7
secondes. Nous avons un métronome visuel !</p>

<p>C’est simple, non ? Mouais. Trop simple, bien sûr. Ce code est problèmatique
pour la fabrication d’un métronome. Alors afin de comprendre pourquoi, parlons
un peu du tempo.</p>

<h2 id="le-tempo">Le tempo</h2>

<p>Pour le musicien, le tempo est une suite de clics (ou tic, ou tac, ou poum, ou
tchak, ou clac). Ces clics, qui ont la particularité de se succéder à
intervalles réguliers, marquent la <strong>vitesse</strong> de la musique.</p>

<p>Le tempo (donc la vitesse de la musique) est indiqué à l’aide d’un nombre qui
représente le nombre de clics par minute.
Par exemple un tempo de 60 nous indique qu’il doit y avoir 60 clics dans une minute,
ou plus simplement 1 clic par seconde. Autre exemple, un tempo de 120 indique
120 clics par minute, soit 2 clics par seconde, ou encore 1 clic toutes les
0,5 secondes.</p>

<p>Voyons maintenant quelques formules. Pour trouver la fréquence F, en secondes,
il faut diviser 60 par le tempo (noté T) :</p>

<p>$$
\begin{align}

F = 60 / T
\end{align}
$$</p>

<p>Pour obtenir cette fréquence en millisecondes, il faut multiplier le résultat
précédent par 1000 ;</p>

<p>$$
\begin{align}

F = 60 / T \times 1000
\end{align}
$$</p>

<p>Le code arduino ci-dessus envoit un clic toutes les 0,7 secondes, à quel
tempo cela correspond-t-il ? Pour calculer le tempo, on divise 60 par la
fréquence en secondes :</p>

<p>$$
\begin{align}

T = 60 / F
\end{align}
$$</p>

<p>Donc, une fréquence de 0,7 seconde, comme celle de notre code arduino,
correspond à un tempo de \(60 / 0,7\). Soit à peu près 86.</p>

<h2 id="le-problme-de-la-boucle-de-code">Le problème de la boucle de code</h2>

<p>Maintenant on peut regarder le souci de ce code :</p>

<p><code>cpp
void loop() {
  digitalWrite(LED_PIN, HIGH);
  delay(100);
  digitalWrite(LED_PIN, LOW);
  delay(600);
}
</code></p>

<p>Partons de l’hypothèse qu’en plus des deux <code>digitalWrite</code>, mon code doit
aussi :</p>

<ul>
  <li>calculer l’intensité de la LED suivant le beat.</li>
  <li>jouer du son et ausssi calculer son intensité suivant le beat.</li>
  <li>s’occuper de plusieurs LEDs, peut-être avec des motifs.</li>
  <li>écrire le tempo et d’autres informations sur un écran LCD.</li>
  <li>tout ce que vous pourrez imaginer d’autre ;)</li>
</ul>

<p>Imaginons maintenant que l’ensemble de ces actions prennent 30 millisecondes
(0,03 secondes). Dans ce cas le tempo sera de \(60 / 0,73\). Soit à peu près 82.
Donc plus du tout la valeur de 86 qu’on avait trouvé tout à l’heure. <strong>Notre
métronome n’est pas fiable !</strong> Il ne vaut rien, arg.</p>

<p><img class="center" src="/images/facepalm.jpg"></p>

<h2 id="faire-et-ne-pas-attendre">Faire et ne pas attendre</h2>

<p>Pour remédier à ce problème nous demandons à l’arduino d’allumer la LED toutes
les 700 millisecondes et non pas <strong>d’attendre</strong> pendant 700 millisecondes.
Pour cela nous gardons une trace du dernier moment où la LED a été allumée
(dans <code>oldTime</code>) et nous comparons cette trace avec le moment présent
(<code>currentTime</code>) à chaque passage dans la boucle :</p>

<p>``` cpp
const byte LED_PIN = 2;
// In millisecondes.
const long FREQUENCY = 700;</p>

<p>long currentTime;
long oldTime;</p>

<p>void setup() {
  pinMode(LED_PIN, OUTPUT);
  currentTime = 0;
  oldTime = 0;
}</p>

<p>void loop() {
  currentTime = millis();</p>

<p>if(currentTime &gt;= oldTime + FREQUENCY) {
    digitalWrite(LED_PIN, HIGH);
    delay(100);
    digitalWrite(LED_PIN, LOW);
    oldTime = currentTime;
  }
}
```</p>

<p>Ça fonctionne pour notre métronome, bien qu’il reste encore 100 millisecondes
gachées (avec <code>delay(100);</code>). La prochaine fois on verra un moyen de se
débarasser de cette attente inutile.</p>

<p></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ce que je n'ai pas fait cette semaine]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/03/22/ce-que-je-nai-pas-fait-cette-semaine/"/>
    <updated>2015-03-22T15:18:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/03/22/ce-que-je-nai-pas-fait-cette-semaine</id>
    <content type="html"><![CDATA[<p><em>Premier article d’une série récurente que je posterai chaque dimanche, voici
ce que je n’ai pas fait cette semaine.</em></p>

<p>Je n’ai pas installé <strong>la dernière version de l’</strong><a href="http://arduino.cc/en/Main/Software">IDE Arduino</a>.
Je ne compte pas l’utiliser, mais il parait qu’elle intègre des outils en ligne
de commande, et ça c’est cool.</p>

<!-- more -->

<p>Je n’ai pas (encore) lu <strong>le livre de Hilary Mason</strong>
<a href="http://www.oreilly.com/data/free/data-driven.csp">Data Driven</a>.</p>

<p>Je n’ai pas acheté <strong>le livre</strong> <a href="https://leanpub.com/developing-games-with-ruby/">Developing Games With Ruby</a>.
J’hésite. Ça pourrait être fun.</p>

<p>Je ne me suis pas abonné à <strong>la version numérique de
Courrier International.</strong>
Je voulais le faire, mais on ne peut payer ni par carte bancaire, ni par
paypal. Et je n’aime pas l’idée du prélèvement bancaire.</p>

<p>Je n’ai pas travaillé sur mon <a href="https://twitter.com/lkdjiin/status/570258711547023362">super algorithme de génération d’immenses
labyrinthes</a> :</p>

<p>Je n’ai pas donné d’argent à <a href="https://rubytogether.org/">RubyTogether</a>.
Je voulais le faire, je voudrais le faire, je pense qu’il est nécessaire
d’avoir une telle structure pour assurer l’avenir de Ruby et de son écosystème
<del>mais le montant unique de 40$ par mois pour un particulier m’a refroidi.</del>
<ins>Et voilà, je réagis à chaud, je m’emporte et donc je
raconte n’importe quoi. On peut maintenant <a href="https://rubytogether.org/friends">faire un don</a>
sans cotiser mensuellement. Alors rendez-vous la semaine prochaine pour savoir
si j’ai donné ;)</ins></p>

<p>Et vous ? Que n’avez-vous pas fait cette semaine ?</p>

<p></p>
]]></content>
  </entry>
  
</feed>
