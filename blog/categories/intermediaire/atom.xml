<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : intermédiaire | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/intermediaire/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2013-11-16T10:15:06+01:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Les algorithmes génétiques 39: Resolution du sac à dos]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/11/16/les-algorithmes-genetiques-39-resolution-du-sac-a-dos/"/>
    <updated>2013-11-16T10:06:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/11/16/les-algorithmes-genetiques-39-resolution-du-sac-a-dos</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>La dernière fois on a vu une façon simplement
<a href="http://lkdjiin.github.io/blog/2013/11/13/les-algorithmes-genetiques-demystifies-38-evaluation-du-sac-a-dos/">d'évaluer le contenu</a>
du sac à dos.
Aujourd'hui on met en place l'algorithme génétique proprement dit:
sélection, croisement, mutation, etc.</p>

<!-- more -->


<p>J'ai mis le <a href="https://github.com/lkdjiin/knapsack_genetic_algorithm/blob/master/knapsack.rb">code complet de l'algorithme sur Github</a>.
Celui-ci est basé sur ce qu'on a fait jusqu'ici pour
<a href="http://lkdjiin.github.io/blog/2013/09/08/les-algorithmes-genetiques-demystifies-8-le-paradoxe-du-singe-savant/">le paradoxe du singe savant</a>
et pour <a href="http://lkdjiin.github.io/blog/2013/09/24/les-algorithmes-genetiques-demystifies-21-probleme-des-8-dames/">le problème des 8 dames</a>.
Je vais donc commenter les parties qui changent.</p>

<h2>La classe GeneticAlgorithm</h2>

<p>``` ruby
class GeneticAlgorithm
  # &hellip;</p>

<p>  def run</p>

<pre><code>best_ever = nil
@generations.times do |generation|
  Evaluator.new(@capacity, @population).evaluate
  best = @population.best
  best_ever = best if best &gt; best_ever
  display(generation, best)
  next_generation
end
display_best_ever(best_ever)
</code></pre>

<p>  end</p>

<p>  private</p>

<p>  # &hellip;</p>

<p>  def display_best_ever(individual)</p>

<pre><code>puts "----------------------"
puts "Best ever"
puts "----------------------"
puts "score:      #{individual.score}"
puts "chromosome: #{individual.chromosome_as_list}"
</code></pre>

<p>  end</p>

<p>  # &hellip;
end
```</p>

<p>Voyons la méthode <code>run</code>. La variable <code>best_ever</code> va contenir le meilleur
individu, toutes générations confondues. À chaque itération, on compare
ce «meilleur de tout les temps» avec le meilleur individu de la génération:</p>

<pre><code>best_ever = best if best &gt; best_ever
</code></pre>

<p>C'est pour ça qu'on avait besoin d'une méthode <code>&gt;</code> dans la classe <code>Individual</code>
(voir <a href="http://lkdjiin.github.io/blog/2013/11/12/les-algorithmes-genetiques-demystifies-37-le-probleme-du-sac-a-dos/">cet article</a>).</p>

<p>À la fin de la méthode <code>run</code> on utilise la nouvelle méthode <code>display_best_ever</code>
pour afficher notre meilleure solution.</p>

<h2>La classe Mutator</h2>

<p>La seconde classe qui change un peu est la classe <code>Mutator</code>:</p>

<p>``` ruby
class Mutator
  def initialize(chromosome_size, mutation_rate)</p>

<pre><code>@size = chromosome_size
@rate = mutation_rate
</code></pre>

<p>  end</p>

<p>  def mutate(chromosome)</p>

<pre><code>@size.times do |index|
  chromosome[index] = ! chromosome[index] if rand &lt; @rate
end
chromosome
</code></pre>

<p>  end
end
```</p>

<p>Un chromosome étant une liste (un Array) de booléens, la mutation consiste
à <em>inverser</em> un élément, true devient false et inversement:</p>

<pre><code>chromosome[index] = ! chromosome[index] if rand &lt; @rate
</code></pre>

<h2>Le lancement du programme</h2>

<p>Le problème n'a pas l'air trop complexe, je me dis donc que 100 générations
devraient suffire. La population compte 1 000 individus, ce qui est
classique et le taux de mutation est assez élevé (1%):</p>

<p><code>ruby
knapsack_capacity = 400
generations = 100
population = Population.new(Knapsack::ITEMS.size, 1000)
mutation = 0.01
GeneticAlgorithm.new(generations, population, knapsack_capacity, mutation).run
</code></p>

<p>Et voici le moment de vérité:</p>

<pre><code>[~]⇒ ruby knapsack.rb 
Gen: 0 Best score: 922
Gen: 1 Best score: 950
.
.
.
Gen: 57 Best score: 1010
Gen: 58 Best score: 957
Gen: 59 Best score: 1030
.
.
.
Gen: 99 Best score: 957
----------------------
Best ever
----------------------
score:      1030
chromosome: map, compass, water, sandwich, glucose, banana, suntan cream,
waterproof trousers, waterproof overclothes, note-case, sunglasses, socks
</code></pre>

<p>La prochaine fois on va analyser ce résultat et faire en sorte de
l'améliorer.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les algorithmes génétiques démystifiés 38: Évaluation du sac à dos]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/11/13/les-algorithmes-genetiques-demystifies-38-evaluation-du-sac-a-dos/"/>
    <updated>2013-11-13T09:32:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/11/13/les-algorithmes-genetiques-demystifies-38-evaluation-du-sac-a-dos</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Comment évaluer le contenu du sac à dos ? C'est à cette question qu'on
répond aujourd'hui, après avoir vu hier la
<a href="http://lkdjiin.github.io/blog/2013/11/12/les-algorithmes-genetiques-demystifies-37-le-probleme-du-sac-a-dos/">création de la population</a>.</p>

<!-- more -->


<h2>La fonction d'évaluation</h2>

<p>Évaluer le contenu du sac à dos est trivial, on calcule sa valeur en
ajoutant la valeur de tout les objets, et on calcule son poids en ajoutant
le poids de tout les objets. Si le poids total dépasse la capacité du
sac à dos, on va considèrer <em>pour l'instant</em> que la solution est invalide, et
on ne lui permettra pas de se reproduire. Autrement dit, plus la valeur est
importante sans que le poids ne dépasse la capacité, meilleure est
l'individu.</p>

<h2>La classe Evaluator</h2>

<p>Voici le code complet de la classe <code>Evaluator</code>:</p>

<p>``` ruby
class Evaluator
  def initialize(capacity, population)</p>

<pre><code>@capacity = capacity
@population = population
</code></pre>

<p>  end</p>

<p>  def evaluate</p>

<pre><code>@population.each {|individual| score(individual) }
fitness
</code></pre>

<p>  end</p>

<p>  private</p>

<p>  def score(individual)</p>

<pre><code>value = 0
weight = 0
individual.chromosome.each_with_index do |item, index|
  if item
    value += Knapsack::ITEMS[index].value
    weight += Knapsack::ITEMS[index].weight
  end
end
if weight &gt; @capacity
  individual.score = 0
else
  individual.score = value
end
</code></pre>

<p>  end</p>

<p>  def fitness</p>

<pre><code>total = @population.inject(0) {|sum, individual| sum + individual.score }
size = @population.size
@population.each do |individual|
  individual.fitness = individual.score.to_f / total * size
end
</code></pre>

<p>  end
end
```</p>

<h2>Explication du code</h2>

<p>Ce qui nous intéresse se passe dans la méthode <code>score</code>. Tout d'abord on
calcule la valeur totale et le poids total du sac à dos:</p>

<p>``` ruby</p>

<pre><code>individual.chromosome.each_with_index do |item, index|
  if item
    value += Knapsack::ITEMS[index].value
    weight += Knapsack::ITEMS[index].weight
  end
end
</code></pre>

<p>```</p>

<p>Je rappelle qu'un chromosome est ici un Array de booléens, d'où la ligne
<code>if item</code> pour savoir si l'objet est présent ou non.</p>

<p>Une fois valeur et poids calculés, on peut donner un score:</p>

<p>``` ruby</p>

<pre><code>if weight &gt; @capacity
  individual.score = 0
else
  individual.score = value
end
</code></pre>

<p>```</p>

<p>Si le poids du sac à dos dépasse sa capacité, on invalide l'individu en
mettant son score à zéro, ce qui lui interdira par la suite de se reproduire.
Sinon, le score est simplement la valeur totale du sac à dos.</p>

<p>La prochaine fois on mettra en place la sélection, le croisement, la mutation,
etc…</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les algorithmes génétiques démystifiés 37: Le problème du sac à dos]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/11/12/les-algorithmes-genetiques-demystifies-37-le-probleme-du-sac-a-dos/"/>
    <updated>2013-11-12T13:02:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/11/12/les-algorithmes-genetiques-demystifies-37-le-probleme-du-sac-a-dos</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Pour continuer notre exploration des algorithmes génétiques, on va
s'intéresser maintenant au problème du sac à dos:</p>

<p><blockquote><p>En algorithmique, le problème du sac à dos, noté également KP (en anglais,<br/>Knapsack Problem) est un problème d'optimisation combinatoire. Il modélise une<br/>situation analogue au remplissage d'un sac à dos, ne pouvant supporter plus<br/>d'un certain poids, avec tout ou partie d'un ensemble donné d'objets ayant<br/>chacun un poids et une valeur. Les objets mis dans le sac à dos doivent<br/>maximiser la valeur totale, sans dépasser le poids maximum.</p><footer><strong>Wikipédia <a href="http://fr.wikipedia.org/wiki/Probl%C3%A8me_du_sac_%C3%A0_dos">http://fr.wikipedia.org/wiki/Probl%C3%A8me_du_sac_%C3%A0_dos</a></strong></footer></blockquote></p>

<!-- more -->


<p>Un des intéret de ce problème est que certaines solutions <em>invalides</em> sont
plus proches de la meilleure solution que nombres de solutions <em>valides</em>.</p>

<p>De même, c'est un problème <em>théorique</em> qui peut être vu comme une
simplification de problèmes <em>pratiques</em>. Par exemple: «Mon bateau peut
transporter 100 containers, pour un poids de X tonnes. Je gagne plus ou
moins d'argent selon les containers transportés. Quels containers je dois
embarquer parmi un choix de 300 containers ?»</p>

<p>La liste des objets que je vais utiliser se trouve sur le
<a href="http://rosettacode.org/wiki/Knapsack_problem/0-1">projet RosettaCode</a>.</p>

<p>On commence tout de suite avec la création de la population:</p>

<p>``` ruby
KnapsackItem = Struct.new(:name, :weight, :value)</p>

<p>module Knapsack
  ITEMS = [</p>

<pre><code>KnapsackItem.new('map', 9, 150),
KnapsackItem.new('compass', 13, 35),
KnapsackItem.new('water', 153, 200),
KnapsackItem.new('sandwich', 50, 160),
KnapsackItem.new('glucose', 15, 60),
KnapsackItem.new('tin', 68, 45),
KnapsackItem.new('banana', 27, 60),
KnapsackItem.new('apple', 39, 40),
KnapsackItem.new('cheese', 23, 30),
KnapsackItem.new('beer', 52, 10),
KnapsackItem.new('suntan cream', 11, 70),
KnapsackItem.new('camera', 32, 30),
KnapsackItem.new('t-shirt', 24, 15),
KnapsackItem.new('trousers', 48, 10),
KnapsackItem.new('umbrella', 73, 40),
KnapsackItem.new('waterproof trousers', 42, 70),
KnapsackItem.new('waterproof overclothes', 43, 75),
KnapsackItem.new('note-case', 22, 80),
KnapsackItem.new('sunglasses', 7, 20),
KnapsackItem.new('towel', 18, 12),
KnapsackItem.new('socks', 4, 50),
KnapsackItem.new('book', 30, 10),
</code></pre>

<p>  ]
end
```</p>

<p>Pour ceux qui ne connaissent pas Ruby, <code>Struct</code> permet de définir rapidement
une classe simpliste, une espèce de POxO (Plain Old &ldquo;insérez votre langage&rdquo;
Object). La classe <code>KnapsackItem</code> aura donc 3 accesseurs: <code>name</code>, <code>weight</code> et
<code>value</code>. On pourra accéder à la liste des objets avec <code>Knapsack::ITEMS</code>.</p>

<p>Maintenant la classe <code>Individual</code>:</p>

<p>``` ruby
class Individual
  def self.random(chromosome_size)</p>

<pre><code>new(nil, chromosome_size)
</code></pre>

<p>  end</p>

<p>  def self.from_chromosome(chromosome)</p>

<pre><code>new(chromosome)
</code></pre>

<p>  end</p>

<p>  attr_accessor :score, :fitness
  attr_reader :chromosome</p>

<p>  def initialize(chromosome = nil, chromosome_size = nil)</p>

<pre><code>if chromosome
  @chromosome = chromosome
else
  @chromosome = []
  chromosome_size.times { @chromosome &lt;&lt; (rand(0..1) == 1) }
end
</code></pre>

<p>  end
  private_class_method :new</p>

<p>  def chromosome_as_list</p>

<pre><code>list = []
@chromosome.each_with_index do |gene, index|
  list &lt;&lt; Knapsack::ITEMS[index].name if gene
end
list.join(', ')
</code></pre>

<p>  end</p>

<p>  def >(other)</p>

<pre><code>return true if other.nil?
score &gt; other.score
</code></pre>

<p>  end
end
```</p>

<p>Un chromosome est défini comme un Array de booléens:</p>

<p>``` ruby</p>

<pre><code>  chromosome_size.times { @chromosome &lt;&lt; (rand(0..1) == 1) }
</code></pre>

<p>```</p>

<p>Chaque case de l'Array nous indique si un objet est sélectionné (true) ou
non (false).</p>

<p>J'ai aussi ajouté 2 nouvelles méthodes à cette classe. Tout d'abord
<code>chromosome_as_list</code> produit une chaîne de caractères avec la liste
des objets sélectionnés dans le chromosome. Puis la méthode <code>&gt;</code> nous
sera utile pour comparer deux chromosomes.</p>

<p>Reste la classe <code>Population</code>, qui est identique à ce que nous avons
déjà écrit avec d'autres algorithmes génétiques:</p>

<p>``` ruby
class Population &lt; Array
  def initialize(chromosome_size, population_size)</p>

<pre><code>population_size.times { self &lt;&lt; Individual.random(chromosome_size) }
</code></pre>

<p>  end</p>

<p>  def best</p>

<pre><code>self.sort_by{|individual| individual.score}.last
</code></pre>

<p>  end
end
```</p>

<p>La prochaine fois on verra une première version de la méthode d'évaluation.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Une regex pour savoir si un nombre est premier]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/11/05/une-regex-pour-savoir-si-un-nombre-est-premier/"/>
    <updated>2013-11-05T16:55:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/11/05/une-regex-pour-savoir-si-un-nombre-est-premier</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Aujourd'hui je traduis (approximativement) un article de 2007 qui m'a fasciné:
<a href="http://www.noulakaz.net/weblog/2007/03/18/a-regular-expression-to-check-for-prime-numbers/">A regular expression to check for prime numbers</a>.</p>

<!-- more -->


<p>Les regexs sont très puissantes. C'est un truc que je lis une ou deux fois par
jour sur le web.</p>

<p>Pendant que j'étais sur le net aujourd'hui, je suis tombé sur
<a href="http://montreal.pm.org/tech/neil_kandalgaonkar.shtml">cette page</a>
qui décrit minutieusement la regex <code>/^1?$|^(11+?)\1+$/</code> en Perl pour voir
si un nombre est premier ou non !</p>

<p>Pour être franc, j'étais sceptique. La regex semble être magique ! Et je
voulais la comprendre mieux. Je l'ai réécrite en Ruby, pour la tester:</p>

<p>``` irb
[~]⇒ irb</p>

<blockquote><blockquote><p>def prime?(n)
  (&ldquo;1&rdquo; * n) !~ /^1?$|^(11+?)\1+$/
end
=>
prime? 10
=> false
prime? 11
=> true
prime? 12
=> false
prime? 13
=> true
prime? 99
=> false
prime? 100
=> false
prime? 101
=> true
```</p></blockquote></blockquote>

<p>Cool ! Ça marche aussi en Ruby ! Ce qui veut dire qu'il n'y a aucune magie
due à Perl. La regex fonctionne vraiment. Mais comment ? Essayons de la
décortiquer.</p>

<h2>Est-ce-que 7 est un nombre premier ?</h2>

<p>Pour le savoir, la méthode génère &ldquo;1111111&rdquo; et regarde si cette chaîne
<strong>ne correspond pas</strong> avec <code>/^1?$|^(11+?)\1+$/</code>. Si il n'y a pas
correspondance, alors le nombre est premier.</p>

<p>Notez que la regex a deux parties (séparées par une barre verticale <code>|</code>).</p>

<p>La première partie <code>/^1?$/</code> est triviale, et cherche une correspondance
avec un début de ligne (<code>^</code>), un 1 optionel (<code>1?</code>) et une fin de ligne
(<code>$</code>), ce qui implique une chaîne vide ou &ldquo;1&rdquo;. Donc l'appel de cette
méthode quand n vaut 0 ou 1 renverra false, le bon résultat.</p>

<p>La seconde partie est plus… magique…</p>

<p><code>/^(11+?)\1+$/</code> cherche une correspondance avec un début de ligne (<code>^</code>)
puis <code>11+?</code> puis <code>\1+</code> et finalement une fin de ligne (<code>$</code>).
Je suppose que vous savez que <code>\1</code> est une variable attachée à ce qui a été
mis en correspondance précédement (dans notre cas avec <code>11+?</code>).</p>

<p>Allons y lentement…</p>

<p><code>(11+?)</code> fait deux choses:</p>

<ol>
<li>Il cherche une correspondance avec un &ldquo;1&rdquo; suivi par un ou plusieurs autres
&ldquo;1&rdquo; <strong>de façon minimale</strong>. Ce qui signifie qu'on aura une correspondance
avec &ldquo;11&rdquo; la première fois (notez que si il n'y avait pas de <code>?</code> dans
<code>(11+?)</code> c'est la chaîne entière qui serait mise en correspondance).</li>
<li>La chaîne obtenue (&ldquo;11&rdquo; la première fois) est attachée à la variable <code>\1</code>.</li>
</ol>


<p><code>\1+</code> cherche alors une correspondance avec ce qu'on a obtenu avant (&ldquo;11&rdquo;
la première fois) <strong>de manière répétitive, une ou plusieurs fois</strong>.
Si une correspondance est trouvée, alors le nombre n'est pas premier.</p>

<p>Si vous suivez jusqu'ici, vous avez peut-être réalisé que cela éliminait tout
les nombres pairs, excepté 2 (par exemple, 8 est &ldquo;11111111&rdquo; and donc <code>(11+?)</code>
va correspondre avec &ldquo;11&rdquo; et <code>\1+</code> va correspondre avec &ldquo;111111&rdquo;).</p>

<p>Pour les nombres impairs (7 dans notre cas), le <code>(11+?)</code> correspond à &ldquo;11&rdquo;
la première fois mais <code>\1+$</code> ne peut pas être vrai (notez le <code>$</code>) puisqu'il
reste cinq &ldquo;1&rdquo;. Le moteur de regexp va <strong>revenir en arrière</strong> et <code>(11+?)</code>
va alors correspondre avec &ldquo;111&rdquo; et là aussi, <code>\1+$</code> sera faux puisqu'il
reste quatre &ldquo;1&rdquo; (et à ce moment là, <code>\1+$</code> ne peut correspondre qu'avec un
nombre de &ldquo;1&rdquo; qui est multiple de 3, suivi par une fin de ligne), etc…
D'où le fait que &ldquo;1111111&rdquo; ne correspondra jamais avec la regex, ce qui
implique que 7 est un nombre premier.</p>

<p>[&hellip;] Voyons ce qu'il se passe avec 9, qui n'est pas un nombre premier:
&ldquo;1&rdquo; * 9 devrait correspondre avec la regex.</p>

<p>&ldquo;1&rdquo; * 9 = &ldquo;111111111&rdquo;. <code>(11+?)</code> correspond initialement à &ldquo;11&rdquo;. <code>\1+$</code> ne
peut être mis en correspondance puisqu'il reste 7 &ldquo;1&rdquo;. Quand le moteur de
regex repart en arrière, <code>(11+?)</code> correspond alors avec &ldquo;111&rdquo;. Et cette
fois <code>\1+$</code> correspond aux 6 &ldquo;1&rdquo; restants ! D'où 9 n'est pas premier.</p>

<p>Simple et beau en même temps.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Écrire une fonction Vim avec Ruby]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/11/04/ecrire-une-fonction-vim-avec-ruby/"/>
    <updated>2013-11-04T17:01:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/11/04/ecrire-une-fonction-vim-avec-ruby</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Parfois, pas besoin de faire appel à un plugin, une simple petite fonction
suffit pour ce qu'on veut faire. Mais il faut avouer que le Vim Script est
un langage qui est loin de faire l'unanimité. Si on pouvait faire appel
à Ruby (ou Python, etc) pour écrire en partie nos fonctions Vim, ce serait
cool, non ?</p>

<!-- more -->


<h2>Un cas d'utilisation simple</h2>

<p>Prenons un cas habituel: supprimer les espaces en fin de ligne dans tout un
fichier. Pour cela il nous suffit d'écrire directement dans Vim:</p>

<p><code>vim
:%s/\s\+$//
</code></p>

<p>Mouais… Ça fonctionne, c'est sûr. Mais j'ai deux petits problèmes:</p>

<ol>
<li>Je ne veux pas taper ça à chaque fois, parce qu'il faut que je me
concentre un minimum pour bien écrire une regex, même si là y a pas
de quoi fouetter un chat. En même temps, ça ne vaut pas le coup
d'écrire un plugin juste pour ça.</li>
<li>Y'a rien à faire, je ne me rappelle jamais comment fonctionnent les
regex Vim, quels sont les méta-caractères et tout et tout. 9 fois
sur 10 j'oublierais par exemple d'échapper le <code>+</code>.</li>
</ol>


<h2>Une fonction Vim</h2>

<p>Si ça ne vaut pas un plugin, ça vaut bien une petite fonction à mettre,
par exemple, dans son <code>.vimrc</code>:</p>

<p><code>vim
function RemoveTrailingSpaces()
  %s/\s\+$//
endfunction
</code></p>

<p>Maintenant, on peut appeler notre fonction ainsi:</p>

<p><code>vim
:call RemoveTrailingSpaces()
</code></p>

<p>Ou bien la mapper sur une touche, si on l'utilise souvent:</p>

<p><code>vim
map &lt;Leader&gt;r :call RemoveTrailingSpaces()&lt;Enter&gt;
</code></p>

<p>Premier problème réglé, au suivant.</p>

<h2>Utiliser Ruby dans une fonction Vim</h2>

<p>Il faut bien sûr que votre Vim ait été compilé avec le support de Ruby.
Pour le savoir vous pouvez taper la ligne suivante dans votre console,
si &ldquo;+ruby&rdquo; s'affiche, c'est bon:</p>

<p><code>bash
[~]⇒ vim --version | grep --color -i \+ruby
+printer +profile +python -python3 +quickfix +reltime +rightleft +ruby
</code></p>

<p>Voilà ce que donnerait notre fonction en utilisant Ruby:</p>

<p><code>vim
function RemoveTrailingSpaces()
  rubydo gsub /\s+$/, ''
endfunction
</code></p>

<p>C'est tout, <code>rubydo</code> suivi de l'instruction en Ruby !  Et vous, vous auriez des
petites astuces de ce genre à partager ?</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
