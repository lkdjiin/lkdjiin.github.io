<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : intermédiaire | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/intermediaire/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2014-05-16T21:09:48+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Un algorithme génétique en Julia - partie 4]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/05/16/un-algorithme-genetique-en-julia-partie-4/"/>
    <updated>2014-05-16T21:00:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/05/16/un-algorithme-genetique-en-julia-partie-4</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Voici le fichier actuel:</p>

<p>``` julia main.jl
create_chromosome(size) = rand(0:1, size)</p>

<p>function create_population(size, chromosome_size)
  [ create_chromosome(chromosome_size) for _ in 1:size ]
end</p>

<p>score(population) = map(sum, population)</p>

<p>function fight(scores, index1, index2)
  scores[index1] > scores[index2] ? index1 : index2
end
```</p>

<p>Aujourd'hui on ajoute la fonction <code>tournament</code>.</p>

<!-- more -->


<p>La voilà:</p>

<p>``` julia
function tournament(scores)
  population_size = length(scores)
  selection_size = population_size * 2
  [ fight(scores, rand(1:population_size), rand(1:population_size))</p>

<pre><code>for _ in 1:selection_size ]
</code></pre>

<p>end
```</p>

<p>On voit que pour connaître la taille d'un tableau, on utilise la fonction
<code>length</code> et que je me sers encore d'une compréhension de liste pour produire
un tableau qui contiendra les index (sur la population) de mes reproducteurs.</p>

<pre><code>julia&gt; include("main.jl")
tournament (generic function with 1 method)

julia&gt; pop = create_population(8, 20)
8-element Array{Array{Int32,1},1}:
 [0,0,0,0,1,1,0,0,0,0,0,1,0,1,1,0,0,1,1,0]
 [1,0,1,1,1,0,1,1,0,0,1,1,1,0,1,1,1,1,0,0]
 [1,0,1,1,0,1,0,0,1,0,0,1,0,0,0,0,1,1,0,1]
 [1,1,1,0,1,0,1,0,1,0,0,1,0,1,1,1,0,0,0,1]
 [1,1,1,1,0,1,0,0,0,1,0,0,1,0,1,0,1,1,0,1]
 [1,1,1,1,1,1,1,0,0,1,0,0,0,1,1,1,0,1,1,0]
 [0,1,1,1,1,1,1,0,1,1,1,1,0,1,0,0,0,1,1,0]
 [0,0,1,1,1,0,1,0,0,1,1,1,0,0,0,1,0,1,0,0]

julia&gt; scores = score(pop)
8-element Array{Int32,1}:
  7
 13
  9
 11
 11
 13
 13
  9

julia&gt; tournament(scores)
16-element Array{Int32,1}:
 5
 6
 6
 4
 4
 6
 7
 2
 6
 6
 3
 7
 2
 2
 6
 3
</code></pre>

<p>À plus tard pour la suite…</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Un algorithme génétique en Julia - partie 3]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/05/15/un-algorithme-genetique-en-julia-partie-3/"/>
    <updated>2014-05-15T21:28:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/05/15/un-algorithme-genetique-en-julia-partie-3</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Aujourd'hui j'essaye de faire la sélection en vue de la reprodution ;)
Si vous aviez suivi ma série d'articles
<a href="http://lkdjiin.github.io/blog/categories/algorithme-genetique/">les algorithmes génétiques démystifiés</a> vous savez de quoi je parle…</p>

<!-- more -->


<p>Voici d'abord les fonctions que j'ai jusqu'à présent :</p>

<p>``` julia main.jl
create_chromosome(size) = rand(0:1, size)</p>

<p>function create_population(size, chromosome_size)
  [ create_chromosome(chromosome_size) for _ in 1:size ]
end</p>

<p>score(population) = map(sum, population)
```</p>

<p>Alors j'ai remis des <code>_</code>, parce que sans j'y arrivais vraiment pas ;)
J'ai aussi ajouté l'argument <code>size</code> à la fonction de création d'un
chromosome pour éviter les nombres magiques.</p>

<p>Je veux opérer une sélection très simple : un tournoi. Pour ça, je
commence avec une fonction <code>fight</code> qui va renvoyer le meilleur chromosome
parmi deux:</p>

<p><code>julia
function fight(scores, index1, index2)
  scores[index1] &gt; scores[index2] ? index1 : index2
end
</code></p>

<p>En fait je ne passe pas de chromosome à cette fonction mais le tableau des
scores de la population, obtenu avec <code>score</code> et deux indexs.</p>

<pre><code>julia&gt; include("main.jl")

julia&gt; pop = create_population(8, 20)
8-element Array{Array{Int32,1},1}:
 [1,0,1,1,1,1,1,0,1,0,1,1,1,0,1,0,1,1,1,1]
 [1,1,0,0,0,1,0,1,0,1,0,0,0,0,0,1,0,1,1,1]
 [0,0,1,0,1,0,0,1,0,1,0,0,1,1,1,0,0,1,0,1]
 [1,1,0,1,1,1,0,1,1,0,0,1,1,1,0,1,0,1,1,1]
 [0,1,0,0,1,1,1,1,0,1,0,1,1,0,0,1,0,0,0,1]
 [1,1,0,0,0,1,0,0,1,0,1,1,1,0,1,1,1,0,1,0]
 [1,1,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,1]
 [0,0,0,1,0,1,0,0,0,1,1,1,0,1,0,1,1,1,1,1]

julia&gt; scores = score(pop)
8-element Array{Int32,1}:
 15
  9
  9
 14
 10
 11
 10
 11
</code></pre>

<p>Et la fonction <code>fight</code> renvoit l'index du meilleur des deux chromosomes
du <em>combat</em>:</p>

<pre><code>julia&gt; fight(scores, 1, 2)
1

julia&gt; fight(scores, 7, 8)
8
</code></pre>

<p>La prochaine fois je pourrais organiser le tournoi proprement dit.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Un algorithme génétique en Julia - partie 2]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/05/14/un-algorithme-genetique-en-julia-partie-2/"/>
    <updated>2014-05-14T21:04:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/05/14/un-algorithme-genetique-en-julia-partie-2</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Je continue l'algorithme génétique en Julia que j'ai commencé hier, en
cherchant la manière de calculer le score d'un chromosome.</p>

<!-- more -->


<p>Tout d'abord, je met les fonctions créées hier dans un fichier <code>main.jl</code>.
J'en profite pour les renommer. La convention en Julia veut qu'on accolle
les mots, sans séparation. Bien que je trouve ça curieux et illisible, je
vais m'y plier, après tout j'apprends…</p>

<p>``` julia main.jl
createchromosome() = rand(0:1, 10)</p>

<p>createpopulation(size) = [ createchromosome() for _ in 1:size ]
```</p>

<p>Une fois l'interpréteur Julia lancé, je charge les définitions de fonctions
du fichier <code>main.jl</code>:</p>

<pre><code>julia&gt; include("main.jl")
</code></pre>

<p>Puis je crée un chromosome:</p>

<pre><code>julia&gt; chromosome = createchromosome()
10-element Array{Int32,1}:
 1
 0
 0
 1
 1
 0
 0
 0
 1
 1
</code></pre>

<p>L'algorithme génétique que je veux mettre en place est le plus simple qui
existe. Je cherche à maximiser les chromosomes, c'est à dire que je veux
obtenir un chromosome qui ne comporte que des 1. Pour calculer son score,
il suffit donc de faire la somme de ses gènes. Très facile, puisque Julia
fournit la fonction <code>sum</code>:</p>

<pre><code>julia&gt; sum(chromosome)
5
</code></pre>

<p>Maintenant je dois trouver comment calculer le score de chaque chromosome.
Je crée donc une population:</p>

<pre><code>julia&gt; population = createpopulation(8)
8-element Array{Array{Int32,1},1}:
 [0,0,1,1,1,0,0,0,0,1]
 [1,0,0,0,1,0,1,1,0,0]
 [0,0,1,1,0,0,0,1,0,1]
 [1,0,0,1,1,0,0,0,0,0]
 [1,0,1,0,1,0,1,0,0,1]
 [0,1,1,1,1,1,0,1,0,0]
 [0,1,1,0,1,0,1,0,1,1]
 [0,1,1,1,1,1,0,1,0,0]
</code></pre>

<p>Et j'utilise <code>map</code>, qui va <em>mapper</em> la fonction <code>sum</code> sur chaque élément
de la population:</p>

<pre><code>julia&gt; map(sum, population)
8-element Array{Int32,1}:
 4
 4
 4
 3
 5
 6
 6
 6
</code></pre>

<p>Voilà, si on veut, on peut aussi créer une fonction <code>score</code>:</p>

<pre><code>julia&gt; score(population) = map(sum, population)

julia&gt; score(population)
8-element Array{Int32,1}:
 4
 4
 4
 3
 5
 6
 6
 6
</code></pre>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Un algorithme génétique en Julia - partie 1]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/05/13/un-algorithme-genetique-en-julia-partie-1/"/>
    <updated>2014-05-13T21:09:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/05/13/un-algorithme-genetique-en-julia-partie-1</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Pour continuer d'apprendre le langage Julia, je vais coder un algorithme
génétique simple.</p>

<!-- more -->


<p>Tout d'abord un chromosome, qui va contenir 10 valeurs, chaque valeur pouvant
être soit zéro, soit un:</p>

<pre><code>julia&gt; chromosome() = rand(0:1, 10)
</code></pre>

<p>La fonction <code>rand</code> prend un <em>range</em> en premier paramêtre.</p>

<p>On teste cette fonction:</p>

<pre><code>julia&gt; chromosome()
10-element Array{Int32,1}:
 0
 1
 1
 1
 1
 1
 1
 0
 1
 1
</code></pre>

<p>Maintenant je veux une population:</p>

<pre><code>julia&gt; population(size) = [ chromosome() for _ in 1:size ]
</code></pre>

<p>Il s'agit d'une <em>compréhension de liste</em>. Pour chaque valeur (symbolisée
par le <code>_</code>) du <em>range</em> de 1 à <code>size</code>, on applique la fonction <code>chromosome</code>.
Je peux donc avoir une population:</p>

<pre><code>julia&gt; population(8)
8-element Array{Array{Int32,1},1}:
 [1,0,1,0,1,0,0,1,1,0]
 [1,1,0,1,0,1,0,1,0,0]
 [1,0,1,1,0,1,1,1,1,1]
 [0,0,1,0,0,1,0,0,1,1]
 [1,0,0,1,0,1,1,1,1,0]
 [0,1,0,0,1,1,1,0,1,1]
 [0,0,0,1,0,1,0,1,1,1]
 [0,1,0,0,0,1,0,1,1,0]
</code></pre>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les fonctions en Julia - partie 2]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/05/12/les-fonctions-en-julia-partie-2/"/>
    <updated>2014-05-12T21:05:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/05/12/les-fonctions-en-julia-partie-2</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Suite du tour d'horizon des fonctions en Julia. Je m'intéresse aujourd'hui
aux arguments par défaut et aux arguments nommés (souvent appellés
<em>keyword arguments</em>).</p>

<!-- more -->


<p>La fonction suivante possède un argument <em>normal</em>, <code>a</code>, et un argument par
défaut, <code>b</code>:</p>

<pre><code>julia&gt; function add(a, b = 10)
           a + b
       end
</code></pre>

<p>Lorsqu'on l'appelle avec deux arguments, elle les additionne:</p>

<pre><code>julia&gt; add(1, 2)
3
</code></pre>

<p>Lorsqu'on l'appelle avec un seul argument, la valeur par défaut du second
argument est utilisé:</p>

<pre><code>julia&gt; add(1)
11
</code></pre>

<p>Tout ça est très classique, sans surprise. Voyons maintenant les arguments
nommés:</p>

<pre><code>julia&gt; function add(a, b = 10 ; c = 0)
           a + b + c
       end
</code></pre>

<p>J'ai ici défini la fonction <code>add</code> avec un argument normal, <code>a</code>, un argument par
défaut, <code>b</code>, et un argument nommé, <code>c</code>. On doit séparer les arguments
nommés par un point-virgule.</p>

<p>Avec une seule valeur, <code>b</code> vaut 10 et <code>c</code> vaut 0:</p>

<pre><code>julia&gt; add(1)
11
</code></pre>

<p>Avec deux valeurs, <code>b</code> vaut 2 et <code>c</code> vaut 0:</p>

<pre><code>julia&gt; add(1, 2)
3
</code></pre>

<p>Avec trois valeurs, je suis obligé de <em>nommer</em> <code>c</code>:</p>

<pre><code>julia&gt; add(1, 2, c = 10)
13
</code></pre>

<p>Lorsqu'on a uniquement des arguments nommés, la syntaxe peut paraître
étrange, il ne faut pas oublier le point-virgule:</p>

<pre><code>julia&gt; function foo(; bar = "bar", baz = "baz")
           "$bar $baz"
       end

julia&gt; foo()
"bar baz"

julia&gt; foo(bar = "hello", baz = "world")
"hello world"
</code></pre>

<p>Pour finir, on va mettre en exergue une différence de <em>portée</em> entre les
arguments par défaut et les arguments nommés. Soit <code>b</code> qui vaut 3:</p>

<pre><code>julia&gt; b = 3
3
</code></pre>

<p>Dans la fonction <code>foo</code> suivante je n'ai que des arguments par défaut.
L'argument <code>a</code> a comme valeur par défaut le contenu de <code>b</code>. Il s'agit du
contenu du <code>b</code> précédent, pas celui de l'argument:</p>

<pre><code>julia&gt; foo(a = b, b = 9) = a + b

julia&gt; foo()
12
</code></pre>

<p>Maintenant, même chose avec des arguments nommés:</p>

<pre><code>julia&gt; foo(; a = b, b = 9) = a + b

julia&gt; foo()
ERROR: b not defined
</code></pre>

<p>Oups ! Les arguments nommés n'ont pas accès au monde extérieur.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
