<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : intermédiaire | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/intermediaire/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2014-05-09T22:05:28+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Le langage Julia]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/05/09/le-langage-julia/"/>
    <updated>2014-05-09T21:27:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/05/09/le-langage-julia</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Aujourd'hui j'ai commencé à jouer un peu (2 heures à peine) avec le langage
<a href="http://julialang.org/">Julia</a>.
Ça faisait longtemps que j'en avais envie et j'ai été enthousiasmé.</p>

<!-- more -->


<p>Je cherche un langage fonctionnel qui, entre autres,:</p>

<ul>
<li>ne soit pas <em>purement</em> fonctionnel.</li>
<li>soit rapide.</li>
<li>ai une syntaxe assez simple.</li>
</ul>


<p>J'ai peut-être trouvé ça avec Julia. Cet après-midi j'ai installé la
version binaire sur OS X sans problème. En ce moment je suis en train de
la compiler sur Debian (c'est très long…).</p>

<p>J'en suis encore à faire le tour de la syntaxe en suivant
<a href="http://learnxinyminutes.com/docs/julia/">cette introduction</a>. J'en parlerais
plus quand j'aurais un peu avancé ;)</p>

<p>Deux/trois trucs que j'ai retenu:</p>

<p>L'operateur de division est logiquement:</p>

<p><code>julia
5 / 2 # =&gt; 2.5
</code></p>

<p>Mais plus surprenant (pour moi en tous cas):</p>

<p><code>julia
2 \ 5 # =&gt; 2.5
</code></p>

<p>J'ai hâte de savoir si il y a une utilité à ça ;)</p>

<p>J'ai eu aussi plaisir à retrouver une arithmétique binaire, par exemple
la multiplication par 2:</p>

<p><code>julia
8 &lt;&lt; 1 # =&gt; 16
</code></p>

<p>Dernier truc, et je m'arrête là, j'aime quand les indices commencent à
1, et non pas à 0:</p>

<p><code>julia
"Bonjour"[1] # =&gt; 'B'
</code></p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Programmation concurrente pour Ruby avec eldritch - partie 2]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/05/07/programmation-concurrente-pour-ruby-avec-eldritch-partie-2/"/>
    <updated>2014-05-07T19:18:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/05/07/programmation-concurrente-pour-ruby-avec-eldritch-partie-2</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Suite du test de la gem <a href="https://github.com/beraboris/eldritch">eldritch</a>
qui facilite la programmation concurrente en Ruby.</p>

<!-- more -->


<p>Prenons le programme de référence suivant:</p>

<p>``` ruby test.rb
def long_task
  sleep(1)
  Time.now
end</p>

<p>10.times do |i|
  puts &ldquo;#{i} : #{long_task}&rdquo;
end
```</p>

<p>La méthode <code>long_task</code> va <em>dormir</em> pendant une seconde puis renvoyer la
date courante. Si on l'appelle 10 fois de suite, voici la sortie:</p>

<pre><code>$ time ruby test.rb
0 : 2014-05-07 18:15:52 +0200
1 : 2014-05-07 18:15:53 +0200
2 : 2014-05-07 18:15:54 +0200
3 : 2014-05-07 18:15:55 +0200
4 : 2014-05-07 18:15:56 +0200
5 : 2014-05-07 18:15:57 +0200
6 : 2014-05-07 18:15:58 +0200
7 : 2014-05-07 18:15:59 +0200
8 : 2014-05-07 18:16:00 +0200
9 : 2014-05-07 18:16:01 +0200

real    0m10.809s
</code></pre>

<p>Un appel par seconde, normal.</p>

<p>Maintenant on va se servir de <strong>eldritch</strong> pour que les 10 appels à
<code>long_task</code> soient concurrents:</p>

<p>``` ruby test.rb
require &lsquo;eldritch&rsquo;</p>

<p>def long_task
  sleep(1)
  Time.now
end</p>

<p>together do
  10.times do |i|</p>

<pre><code>async do
  puts "#{i} : #{long_task}"
end
</code></pre>

<p>  end
end
```</p>

<p>Le bloc <code>together</code> permet au programme d'attendre que chacune des <em>tâches</em>
soient terminées avant d'aller plus loin. Voici ce que ça donne:</p>

<pre><code>$ time ruby test.rb
0 : 2014-05-07 18:16:52 +02002 : 2014-05-07 18:16:52 +0200

3 : 2014-05-07 18:16:52 +0200
4 : 2014-05-07 18:16:52 +0200
5 : 2014-05-07 18:16:52 +0200
6 : 2014-05-07 18:16:52 +0200
7 : 2014-05-07 18:16:52 +0200
8 : 2014-05-07 18:16:52 +0200
9 : 2014-05-07 18:16:52 +0200
1 : 2014-05-07 18:16:52 +0200

real    0m1.890s
</code></pre>

<p>Que nous apprend cette sortie ? Chacune des dix tâches a été démarrée à la
même seconde (pas en même temps exactement bien sûr). On voit bien aussi
que l'ordre de terminaison des 10 tâches est aléatoires, ce qui est normal
en programmation concurrente. Le programme s'est terminé 10 fois plus vite,
c'est normal puisque <code>long_task</code> passe son temps à ne rien faire ;)</p>

<p>À quoi sert exactement ce bloc <code>together</code> ? Voyons ce qu'il se passe si on le
retire:</p>

<p>``` ruby test.rb
require &lsquo;eldritch&rsquo;</p>

<p>def long_task
  sleep(1)
  Time.now
end</p>

<p>10.times do |i|
  async do</p>

<pre><code>puts "#{i} : #{long_task}"
</code></pre>

<p>  end
end
```</p>

<pre><code>$ time ruby test.rb

real    0m0.846s
</code></pre>

<p>Oups ! Le programme s'est terminé <em>avant</em> la fin des tâches, elles sont
perdues !</p>

<p>Une autre façon de faire est de créer <em>explicitement</em> une tâche, avec
<code>task = async do ...</code> et d'utiliser <code>task.value</code> qui attend que la tâche
soit complètée:</p>

<p>``` ruby test.rb
require &lsquo;eldritch&rsquo;</p>

<p>long_task = async do
  sleep(1)
  Time.now
end</p>

<p>10.times do |i|
  puts &ldquo;#{i} : #{long_task.value}&rdquo;
end
```</p>

<pre><code>$ time ruby eldritch2.rb
0 : 2014-05-07 18:38:20 +0200
1 : 2014-05-07 18:38:20 +0200
2 : 2014-05-07 18:38:20 +0200
3 : 2014-05-07 18:38:20 +0200
4 : 2014-05-07 18:38:20 +0200
5 : 2014-05-07 18:38:20 +0200
6 : 2014-05-07 18:38:20 +0200
7 : 2014-05-07 18:38:20 +0200
8 : 2014-05-07 18:38:20 +0200
9 : 2014-05-07 18:38:20 +0200

real    0m1.861s
</code></pre>

<p>Tout les tests que j'ai fait avec cette méthode montrent que l'ordre des
tâches est respecté, de 0 à 9. Est-ce que c'est vraiment le cas ou bien
est-ce une coincidence ? Je n'ai pas encore de réponses…</p>

<p>Quoiqu'il en soit, je suis pressé d'essayer <strong>eldritch</strong> avec les algorithmes génétiques, ce
qui par la même occasion me permettra d'en reparler (des algos) dans ce blog.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Programmation concurrente pour Ruby avec eldritch]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/05/06/programmation-concurrente-pour-ruby-avec-eldritch/"/>
    <updated>2014-05-06T21:38:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/05/06/programmation-concurrente-pour-ruby-avec-eldritch</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Ce matin j'ai découvert la gem <a href="https://github.com/beraboris/eldritch">eldritch</a>,
pour faire de la programmation concurrente. Son API m'a paru vraiment
simple et élégante. Ce soir j'ai seulement 5 minutes pour faire un premier
test, alors on y va sans fioritures.</p>

<!-- more -->


<p>Tout d'abord, je vais utiliser Rubinius, puisqu'un ruby MRI ne permet pas
l'utilisation de plusieurs coeurs.</p>

<pre><code>$ rvm use rbx-2.0.0
Using /home/xavier/.rvm/gems/rbx-2.0.0
</code></pre>

<p>Ensuite, installation de la gem:</p>

<pre><code>gem install eldritch
</code></pre>

<p>Il me faut un programme simple pour tester rapidement. Le voici:</p>

<p>``` ruby eldritch.rb
def long_method1
  sleep(2)
  &ldquo;1&rdquo;
end</p>

<p>def long_method2
  sleep(2)
  &ldquo;2&rdquo;
end</p>

<p>puts long_method1
puts long_method2
```</p>

<p>Je simule deux méthodes assez longues grâce à <code>sleep(2)</code>, qui <em>endort</em> le
programme pendant 2 secondes. Le temps d'exécution est conforme à mes
attentes:</p>

<pre><code>$ time ruby eldritch.rb
1
2

real    0m4.821s
</code></pre>

<p>Maintenant on va utiliser la gem eldritch et son concept de <strong>tâche</strong> pour
réécrire le programme:</p>

<p>``` ruby eldritch.rb
require &lsquo;eldritch&rsquo;</p>

<p>long_task1 = async do
  sleep(2)
  &ldquo;1&rdquo;
end</p>

<p>long_task2 = async do
  sleep(2)
  &ldquo;2&rdquo;
end</p>

<p>puts long_task1.value
puts long_task2.value
```</p>

<p>Et voici le résultat:</p>

<pre><code>$ time ruby eldritch.rb
1
2

real    0m2.869s
</code></pre>

<p><strong>Tada !</strong> Mes deux <em>tâches</em> ont tournées en parallèle.</p>

<p>Ça me plait ce concept de tâche. Mais ce n'était qu'un premier test
rapide, eldritch nous réserve encore de bonne surprises. J'espère pouvoir
tester le reste demain.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Le LOAD_PATH dans Ruby]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/05/05/le-load-path-dans-ruby/"/>
    <updated>2014-05-05T21:02:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/05/05/le-load-path-dans-ruby</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>En Ruby, la variable <code>$LOAD_PATH</code> contient tous les chemins vers les
bibliothèques chargées.</p>

<p>``` irb</p>

<blockquote><blockquote><p>$LOAD_PATH
[</p>

<pre><code>[0] "/home/xavier/.rvm/gems/ruby-2.1.0/gems/awesome_print-1.2.0/lib",
[1] "/home/xavier/.rvm/rubies/ruby-2.1.0/lib/ruby/site_ruby/2.1.0",
[2] "/home/xavier/.rvm/rubies/ruby-2.1.0/lib/ruby/site_ruby/2.1.0/i686-linux",
[3] "/home/xavier/.rvm/rubies/ruby-2.1.0/lib/ruby/site_ruby",
[4] "/home/xavier/.rvm/rubies/ruby-2.1.0/lib/ruby/vendor_ruby/2.1.0",
[5] "/home/xavier/.rvm/rubies/ruby-2.1.0/lib/ruby/vendor_ruby/2.1.0/i686-linux",
[6] "/home/xavier/.rvm/rubies/ruby-2.1.0/lib/ruby/vendor_ruby",
[7] "/home/xavier/.rvm/rubies/ruby-2.1.0/lib/ruby/2.1.0",
[8] "/home/xavier/.rvm/rubies/ruby-2.1.0/lib/ruby/2.1.0/i686-linux"
</code></pre>

<p>]
```</p></blockquote></blockquote>

<!-- more -->


<p>Si je charge Rspec, par exemple, son chemin va être ajouté dans la variable
<code>$LOAD_PATH</code>, ainsi que toutes les bibliothèques dont dépend Rspec:</p>

<p>``` irb</p>

<blockquote><blockquote><p>require &lsquo;rspec&rsquo;
true
$LOAD_PATH
[</p>

<pre><code>[ 0] "/home/xavier/.rvm/gems/ruby-2.1.0/gems/awesome_print-1.2.0/lib",
[ 1] "/home/xavier/.rvm/gems/ruby-2.1.0/gems/rspec-2.14.1/lib",
[ 2] "/home/xavier/.rvm/gems/ruby-2.1.0/gems/rspec-core-2.14.8/lib",
[ 3] "/home/xavier/.rvm/rubies/ruby-2.1.0/lib/ruby/site_ruby/2.1.0",
[ 4] "/home/xavier/.rvm/rubies/ruby-2.1.0/lib/ruby/site_ruby/2.1.0/i686-linux",
[ 5] "/home/xavier/.rvm/rubies/ruby-2.1.0/lib/ruby/site_ruby",
[ 6] "/home/xavier/.rvm/rubies/ruby-2.1.0/lib/ruby/vendor_ruby/2.1.0",
[ 7] "/home/xavier/.rvm/rubies/ruby-2.1.0/lib/ruby/vendor_ruby/2.1.0/i686-linux",
[ 8] "/home/xavier/.rvm/rubies/ruby-2.1.0/lib/ruby/vendor_ruby",
[ 9] "/home/xavier/.rvm/rubies/ruby-2.1.0/lib/ruby/2.1.0",
[10] "/home/xavier/.rvm/rubies/ruby-2.1.0/lib/ruby/2.1.0/i686-linux"
</code></pre>

<p>]
```</p></blockquote></blockquote>

<p>Il y a encore quelques jours, je faisais systématiquement cela au début de
toutes mes gems:</p>

<p><code>ruby
$LOAD_PATH.unshift File.dirname(__FILE__)
</code></p>

<p>Ceci pour que ma gem ajoute son propre chemin dans le <code>LOAD_PATH</code>.
Et bien je viens d'apprendre que non, c'est inutile ! L'utilitaire <code>gem</code>
fait très bien cela tout seul.</p>

<p>Aujourd'hui j'ai (encore) appris quelque chose ;)</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby - Et si on écrivait un ORM ? - partie 13]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/05/04/ruby-et-si-on-ecrivait-un-orm-partie-13/"/>
    <updated>2014-05-04T21:09:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/05/04/ruby-et-si-on-ecrivait-un-orm-partie-13</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Aujourd'hui on termine de structurer quelque peu le projet. Voici ce que je
veux obtenir:</p>

<pre><code>$ tree -a
.
├── lib/
│   ├── base.rb
│   ├── database.rb
│   └── recorder.rb
├── .rspec
├── sorm.rb
├── spec/
│   ├── base_spec.rb
│   └── database_spec.rb
└── test.db
</code></pre>

<!-- more -->


<p>Le fichier <code>sorm.rb</code> à la racine du projet va contenir nos require:</p>

<p><code>ruby sorm.rb
require 'sqlite3'
require './lib/database'
require './lib/base'
require './lib/recorder'
</code></p>

<p>Quant aux 3 fichiers sous <code>lib/</code> ils contiennent chacun une classe
de notre ancien fichier <code>sorm.rb</code>, qui était un fourre-tout.
Voici ces fichiers:</p>

<p>``` ruby lib/base.rb
module SORM
  class Base</p>

<pre><code>def self.save(parameters)
  Recorder.new(self.to_s.downcase, parameters).save
  self.new(parameters)
end

def initialize(attributes)
  attributes.each do |name, value|
    instance_variable_set("@#{name}", value)
    singleton_class.class_eval{attr_reader name.to_sym}
  end
end
</code></pre>

<p>  end
end
```</p>

<p>``` ruby lib/database.rb
module SORM
  class Database</p>

<pre><code>@@connection = false

def self.connect(database_filename)
  @@connection = SQLite3::Database.open(database_filename)
end

def self.disconnect
  @@connection = false
end

def self.connected?
  !!@@connection
end

def self.execute(sql)
  @@connection.execute(sql)
end
</code></pre>

<p>  end
end
```</p>

<p>``` ruby lib/recorder.rb
module SORM
  class Recorder</p>

<pre><code>def initialize(table, parameters)
  @table = table
  @parameters = parameters
end

def save
  Database.execute(query)
end

def query
  "INSERT INTO #@table (#{columns}) VALUES(#{values});"
end

def columns
  @parameters.keys.join(',')
end

def values
  @parameters.values.map do |item|
    item.class == String ? "'#{item}'" : item
  end.join(',')
end
</code></pre>

<p>  end
end
```</p>

<p>On va enfin pouvoir ajouter de nouvelles fonctionnalités à notre ORM !
C'est pas trop tôt, je commençais à m'ennuyer ;)</p>

<p>Je tâcherais aussi de mettre le projet sur Github prochainement pour
qu'il soit plus facile à suivre.</p>

<p><em>To be continued</em></p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
