<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : intermédiaire | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/intermediaire/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2014-05-05T21:20:56+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Le LOAD_PATH dans Ruby]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/05/05/le-load-path-dans-ruby/"/>
    <updated>2014-05-05T21:02:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/05/05/le-load-path-dans-ruby</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>En Ruby, la variable <code>$LOAD_PATH</code> contient tous les chemins vers les
bibliothèques chargées.</p>

<p>``` irb</p>

<blockquote><blockquote><p>$LOAD_PATH
[</p>

<pre><code>[0] "/home/xavier/.rvm/gems/ruby-2.1.0/gems/awesome_print-1.2.0/lib",
[1] "/home/xavier/.rvm/rubies/ruby-2.1.0/lib/ruby/site_ruby/2.1.0",
[2] "/home/xavier/.rvm/rubies/ruby-2.1.0/lib/ruby/site_ruby/2.1.0/i686-linux",
[3] "/home/xavier/.rvm/rubies/ruby-2.1.0/lib/ruby/site_ruby",
[4] "/home/xavier/.rvm/rubies/ruby-2.1.0/lib/ruby/vendor_ruby/2.1.0",
[5] "/home/xavier/.rvm/rubies/ruby-2.1.0/lib/ruby/vendor_ruby/2.1.0/i686-linux",
[6] "/home/xavier/.rvm/rubies/ruby-2.1.0/lib/ruby/vendor_ruby",
[7] "/home/xavier/.rvm/rubies/ruby-2.1.0/lib/ruby/2.1.0",
[8] "/home/xavier/.rvm/rubies/ruby-2.1.0/lib/ruby/2.1.0/i686-linux"
</code></pre>

<p>]
```</p></blockquote></blockquote>

<!-- more -->


<p>Si je charge Rspec, par exemple, son chemin va être ajouté dans la variable
<code>$LOAD_PATH</code>, ainsi que toutes les bibliothèques dont dépend Rspec:</p>

<p>``` irb</p>

<blockquote><blockquote><p>require &lsquo;rspec&rsquo;
true
$LOAD_PATH
[</p>

<pre><code>[ 0] "/home/xavier/.rvm/gems/ruby-2.1.0/gems/awesome_print-1.2.0/lib",
[ 1] "/home/xavier/.rvm/gems/ruby-2.1.0/gems/rspec-2.14.1/lib",
[ 2] "/home/xavier/.rvm/gems/ruby-2.1.0/gems/rspec-core-2.14.8/lib",
[ 3] "/home/xavier/.rvm/rubies/ruby-2.1.0/lib/ruby/site_ruby/2.1.0",
[ 4] "/home/xavier/.rvm/rubies/ruby-2.1.0/lib/ruby/site_ruby/2.1.0/i686-linux",
[ 5] "/home/xavier/.rvm/rubies/ruby-2.1.0/lib/ruby/site_ruby",
[ 6] "/home/xavier/.rvm/rubies/ruby-2.1.0/lib/ruby/vendor_ruby/2.1.0",
[ 7] "/home/xavier/.rvm/rubies/ruby-2.1.0/lib/ruby/vendor_ruby/2.1.0/i686-linux",
[ 8] "/home/xavier/.rvm/rubies/ruby-2.1.0/lib/ruby/vendor_ruby",
[ 9] "/home/xavier/.rvm/rubies/ruby-2.1.0/lib/ruby/2.1.0",
[10] "/home/xavier/.rvm/rubies/ruby-2.1.0/lib/ruby/2.1.0/i686-linux"
</code></pre>

<p>]
```</p></blockquote></blockquote>

<p>Il y a encore quelques jours, je faisais systématiquement cela au début de
toutes mes gems:</p>

<p><code>ruby
$LOAD_PATH.unshift File.dirname(__FILE__)
</code></p>

<p>Ceci pour que ma gem ajoute son propre chemin dans le <code>LOAD_PATH</code>.
Et bien je viens d'apprendre que non, c'est inutile ! L'utilitaire <code>gem</code>
fait très bien cela tout seul.</p>

<p>Aujourd'hui j'ai (encore) appris quelque chose ;)</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby - Et si on écrivait un ORM ? - partie 13]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/05/04/ruby-et-si-on-ecrivait-un-orm-partie-13/"/>
    <updated>2014-05-04T21:09:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/05/04/ruby-et-si-on-ecrivait-un-orm-partie-13</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Aujourd'hui on termine de structurer quelque peu le projet. Voici ce que je
veux obtenir:</p>

<pre><code>$ tree -a
.
├── lib/
│   ├── base.rb
│   ├── database.rb
│   └── recorder.rb
├── .rspec
├── sorm.rb
├── spec/
│   ├── base_spec.rb
│   └── database_spec.rb
└── test.db
</code></pre>

<!-- more -->


<p>Le fichier <code>sorm.rb</code> à la racine du projet va contenir nos require:</p>

<p><code>ruby sorm.rb
require 'sqlite3'
require './lib/database'
require './lib/base'
require './lib/recorder'
</code></p>

<p>Quant aux 3 fichiers sous <code>lib/</code> ils contiennent chacun une classe
de notre ancien fichier <code>sorm.rb</code>, qui était un fourre-tout.
Voici ces fichiers:</p>

<p>``` ruby lib/base.rb
module SORM
  class Base</p>

<pre><code>def self.save(parameters)
  Recorder.new(self.to_s.downcase, parameters).save
  self.new(parameters)
end

def initialize(attributes)
  attributes.each do |name, value|
    instance_variable_set("@#{name}", value)
    singleton_class.class_eval{attr_reader name.to_sym}
  end
end
</code></pre>

<p>  end
end
```</p>

<p>``` ruby lib/database.rb
module SORM
  class Database</p>

<pre><code>@@connection = false

def self.connect(database_filename)
  @@connection = SQLite3::Database.open(database_filename)
end

def self.disconnect
  @@connection = false
end

def self.connected?
  !!@@connection
end

def self.execute(sql)
  @@connection.execute(sql)
end
</code></pre>

<p>  end
end
```</p>

<p>``` ruby lib/recorder.rb
module SORM
  class Recorder</p>

<pre><code>def initialize(table, parameters)
  @table = table
  @parameters = parameters
end

def save
  Database.execute(query)
end

def query
  "INSERT INTO #@table (#{columns}) VALUES(#{values});"
end

def columns
  @parameters.keys.join(',')
end

def values
  @parameters.values.map do |item|
    item.class == String ? "'#{item}'" : item
  end.join(',')
end
</code></pre>

<p>  end
end
```</p>

<p>On va enfin pouvoir ajouter de nouvelles fonctionnalités à notre ORM !
C'est pas trop tôt, je commençais à m'ennuyer ;)</p>

<p>Je tâcherais aussi de mettre le projet sur Github prochainement pour
qu'il soit plus facile à suivre.</p>

<p><em>To be continued</em></p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Trois-centième article aujourd'hui !]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/05/03/trois-centieme-article-aujourdhui-slash/"/>
    <updated>2014-05-03T21:56:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/05/03/trois-centieme-article-aujourdhui-slash</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Aujourd'hui c'est le 300ème article de ce blog ! Voilà 300 jours que je
pond un article au quotidien. J'en reviens pas !</p>

<!-- more -->


<p>Encore 65 et j'aurais réussi le défi que je m'étais fixé il y a 300 jours:
écrire un article par jour pendant un an.</p>

<p>Bref, le contenu du jour sera : le fichier <code>.yardopts</code>. Qu'est-ce que c'est
encore que ça ?</p>

<p>Pour générer une documentation de vos gems Ruby avec
<a href="http://yardoc.org/">Yard</a> vous écrivez peut-être comme moi une tâche Rake dans ce genre:</p>

<p><code>ruby
desc 'Create documentation'
task :doc do
  exec 'yardoc --title "Titre de la doc"'
end
</code></p>

<p>Là j'ai mis une seule option, mais on en a souvent d'autres, plus des fichiers
à inclure (comme la licence, le changelog, etc).</p>

<p>Et bien j'ai appris aujourd'hui que ces options pouvaient être mises dans
un fichier <code>.yardopts</code>. En reprenant l'exemple précédant, cela deviendrait:</p>

<p><code>raw .yardopts
--title "Titre de la doc"
</code></p>

<p><code>ruby
desc 'Create documentation'
task :doc do
  exec 'yardoc'
end
</code></p>

<p>Non seulement ça évite de surcharger la tâche rake avec des informations
inutiles, mais surtout, ça permet à des service externes comme
<a href="http://www.rubydoc.info/">RubyDoc</a> de savoir exactement ce que vous voulez.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby - Et si on écrivait un ORM ? - partie 12]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/05/02/ruby-et-si-on-ecrivait-un-orm-partie-12/"/>
    <updated>2014-05-02T20:59:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/05/02/ruby-et-si-on-ecrivait-un-orm-partie-12</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Douzième partie déjà de cette série sur la construction d'un ORM en Ruby…</p>

<!-- more -->


<p>On doit ajouter une méthode <code>disconnect</code> à notre classe <code>Database</code>, voici
d'abord le test:</p>

<p>``` ruby spec/database_spec.rb
require &lsquo;./sorm&rsquo;</p>

<p>describe SORM::Database do</p>

<p>  it &lsquo;is not connected by default&rsquo; do</p>

<pre><code>expect(SORM::Database.connected?).to be false
</code></pre>

<p>  end</p>

<p>  describe &lsquo;after connection&rsquo; do</p>

<pre><code>before { SORM::Database.connect('test.db') }
after  { SORM::Database.disconnect }

it 'is connected' do
  expect(SORM::Database.connected?).to be true
end

it 'is disconnected after disconnection' do
  SORM::Database.disconnect
  expect(SORM::Database.connected?).to be false
end
</code></pre>

<p>  end
end
```</p>

<p>Et maintenant l'implémentation:</p>

<p>``` ruby
  class Database</p>

<pre><code>@@connection = false

def self.connect(database_filename)
  @@connection = SQLite3::Database.open(database_filename)
end

def self.disconnect
  @@connection = false
end

def self.connected?
  !!@@connection
end

def self.execute(sql)
  @@connection.execute(sql)
end
</code></pre>

<p>  end
```</p>

<p>Rien à dire d'intéressant là-dessus. Je vais aussi configurer Rspec pour
qu'il joue les tests dans un ordre alétoire, et tant que j'y suis j'ajoute
un peu de couleur à la sortie:</p>

<p><code>raw .rspec
--color
--order=random
</code></p>

<p>Et voici l'instant de vérité:</p>

<pre><code>$ rspec
........
Finished in 0.03996 seconds
8 examples, 0 failures
Randomized with seed 55135
</code></pre>

<p>Parfait, on a splitté les tests, on les a mis dans un dossier <code>spec/</code>,
on les a amélioré. C'est tout bon. Maintenant on devrait pouvoir faire
facilement un truc similaire avec le fichier <code>sorm.rb</code>.</p>

<p><em>To be continued</em></p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby - Et si on écrivait un ORM ? - partie 11]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/04/30/ruby-et-si-on-ecrivait-un-orm-partie-11/"/>
    <updated>2014-04-30T21:39:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/04/30/ruby-et-si-on-ecrivait-un-orm-partie-11</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>On a dit qu'il était temps de <em>splitter</em> les fichiers, aussi bien pour
les tests que pour le code d'implémentation.</p>

<!-- more -->


<p>On commence par créer un dossier spec avec à l'intérieur le fichier
<code>database_spec.rb</code>:</p>

<p>``` ruby spec/database_spec.rb
require &lsquo;./sorm&rsquo;</p>

<p>describe SORM::Database do
  describe &lsquo;connection&rsquo; do</p>

<pre><code>it 'is not connected' do
  expect(SORM::Database.connected?).to be false
end

describe 'after connection' do
  it 'is connected' do
    SORM::Database.connect('test.db')
    expect(SORM::Database.connected?).to be true
  end
end
</code></pre>

<p>  end
end
```</p>

<p>Puis on vérifie que tout va bien:</p>

<pre><code>$ rspec spec/database_spec.rb 
..
Finished in 0.00267 seconds
2 examples, 0 failures
</code></pre>

<p>Au tour de la classe <code>Base</code> d'avoir son propre fichier de tests. Je vous
épargne le contenu des méthodes <code>it</code>, il n'a pas changé:</p>

<p>``` ruby spec/base_spec.rb
require &lsquo;./sorm&rsquo;</p>

<p>describe SORM::Base do
  class Article &lt; SORM::Base ; end</p>

<p>  describe &lsquo;.execute&rsquo; do</p>

<pre><code>before do
  SORM::Database.execute("INSERT INTO article VALUES(1, 'Foo');")
  SORM::Database.execute("INSERT INTO article VALUES(2, 'Bar');")
end

after do
  SORM::Database.execute("DELETE FROM article;")
end

it 'returns the correct number of rows' do
  #
end

it 'returns correct values' do
  #
end
</code></pre>

<p>  end</p>

<p>  describe &lsquo;object creation&rsquo; do</p>

<pre><code>after { SORM::Database.execute("DELETE FROM article;") }

it 'creates a record' do
  #
end

it 'returns an object with correct class' do
  #
end

it 'returns an object with correct attributes' do
  #
end
</code></pre>

<p>  end
end
```</p>

<p>Place à la vérification:</p>

<pre><code>$ rspec spec/base_spec.rb 
An error occurred in an after hook
  NoMethodError: undefined method `execute' for false:FalseClass
[...]
5 examples, 5 failures
</code></pre>

<p>Bah oui, ça ne devrait pas nous surprendre. Notre ancien fichier de
test <em>global</em> était mal conçu. On n'est plus connecté à la base de
données. Et là se pose la question de savoir si on doit se connecter
avant chaque test, dans un <code>before :each</code> ou bien une fois pour toute
au début du fichier, dans un <code>before :all</code> ? La seconde solution me parait
la plus adaptée, mais on pourra toujours en changer par la suite si besoin
est:</p>

<p>``` ruby
describe SORM::Base do
  class Article &lt; SORM::Base ; end</p>

<p>  before :all do</p>

<pre><code>SORM::Database.connect('test.db')
</code></pre>

<p>  end</p>

<p>[&hellip;]
```</p>

<p>Or relance les tests:</p>

<pre><code>$ rspec spec/base_spec.rb 
.....
Finished in 0.10185 seconds
5 examples, 0 failures
</code></pre>

<p>Ok, cool. Reste encore à lancer les tests <strong>au complet</strong> avant de crier
victoire:</p>

<pre><code>$ rspec
.....F.

Failures:

  1) SORM::Database connection is not connected
     Failure/Error: expect(SORM::Database.connected?).to be false

       expected #&lt;FalseClass:0&gt; =&gt; false
            got #&lt;TrueClass:2&gt; =&gt; true

       Compared using equal?, which compares object identity,
       but expected and actual are not the same object. Use
       `expect(actual).to eq(expected)` if you don't care about
       object identity in this example.
     # ./spec/database_spec.rb:6:in `block (3 levels) in &lt;top (required)&gt;'

Finished in 0.03452 seconds
7 examples, 1 failure

Failed examples:

rspec ./spec/database_spec.rb:5 # SORM::Database connection is not connected
</code></pre>

<p>Et oui, on ne maitrise plus l'ordre des tests ! <code>base_spec.rb</code>, premier
dans l'ordre alphabétique a été joué avant, et donc <code>database_spec.rb</code> se
retrouve avec une base de données connectée.</p>

<p>On ajoutera donc la prochaine fois une méthode <code>disconnect</code>. Et ça me
fait penser aussi qu'il faudra configurer Rspec pour jouer les tests dans
un ordre aléatoire.</p>

<p><em>To be continued</em></p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
