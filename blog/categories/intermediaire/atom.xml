<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : intermédiaire | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/intermediaire/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2014-07-03T21:48:48+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Exercise Ruby - Reduce ranges - d'autres solutions]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/07/02/exercise-ruby-reduce-ranges-dautres-solutions/"/>
    <updated>2014-07-02T21:03:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/07/02/exercise-ruby-reduce-ranges-dautres-solutions</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Hier j'ai proposé <a href="http://lkdjiin.github.io/blog/2014/07/01/exercise-ruby-reduce-ranges-une-solution/">une solution</a> à cet exercise de <a href="http://lkdjiin.github.io/blog/2014/06/30/exercice-ruby-reduce-ranges/">Range reduce</a>.
Bien qu'élégante (du moins pour moi), elle prenait vraiment trop de temps par
rapport à l'originale. En voici d'autres. Meilleures ?</p>

<!-- more -->


<p>Pour rappel, voici l'originale:</p>

<p>``` ruby
def original(array)
  arr = array.dup
  arr.each_with_index do |el, index|</p>

<pre><code>range_index = index + 1
prev = el
while arr[range_index] == prev + 1 do
  prev = arr[range_index]
  range_index += 1
end
arr[index..range_index-1] = (arr[index]..arr[range_index-1]) unless index == range_index - 1
</code></pre>

<p>  end
end
```</p>

<p>Et voici ma solution d'hier:</p>

<p>``` ruby
def range_reduce(array)
  previous = array.first
  array.slice_before do |element|</p>

<pre><code>previous, previous2 = element, previous
previous2.succ != element
</code></pre>

<p>  end.map do |element|</p>

<pre><code>element.size == 1 ? element.first : element.first..element.last
</code></pre>

<p>  end
end
```</p>

<p>Maintenant, voici celle que j'ai eu en tête toute la journée:</p>

<p>``` ruby
def range_reduce_1(array)
  temp = []
  result = []</p>

<p>  array.each do |element|</p>

<pre><code>if temp.empty?
  temp &lt;&lt; element
else
  if temp.last + 1 == element
    temp &lt;&lt; element
  else
    if temp.size == 1
      result &lt;&lt; temp.first
    else
      result &lt;&lt; (temp.first..temp.last)
    end
    temp = [element]
  end
end
</code></pre>

<p>  end</p>

<p>  if temp.size == 1</p>

<pre><code>result &lt;&lt; temp.first
</code></pre>

<p>  else</p>

<pre><code>result &lt;&lt; (temp.first..temp.last)
</code></pre>

<p>  end</p>

<p>  result
end
```</p>

<p>C'est moche, hein ? Mais ne riez quand même pas trop, attendez de voir les
benchmarks ;)</p>

<p>Je me suis dis que j'allais aussi tester une solution <em>propre</em>, avec un
pattern que j'aime beaucoup:</p>

<p>``` ruby
class ArrayReduce</p>

<p>  def self.ranges(array)</p>

<pre><code>new(array).ranges
</code></pre>

<p>  end</p>

<p>  def initialize(array)</p>

<pre><code>@array = array
@result = [ [@array.first] ]
</code></pre>

<p>  end</p>

<p>  def ranges</p>

<pre><code>@array[1..-1].each do |element|
  suite?(element) ? @result.last &lt;&lt; element : @result &lt;&lt; [element]
end

@result.map do |element|
  element.size == 1 ? element.first : element.first..element.last
end
</code></pre>

<p>  end</p>

<p>  private</p>

<p>  def suite?(element)</p>

<pre><code>@result.last.last == element.pred
</code></pre>

<p>  end</p>

<p>end
```</p>

<p>Et voici la solution qu'a posté un lecteur, Calyhre. J'ai pris la liberté de
la transformer en méthode, comme j'ai fait pour la solution originale qui
<em>monkey patch</em> la classe Array (<a href="https://gist.github.com/Calyhre/280ee41136ad2a62e6c3">solution originale de Calyhre</a>):</p>

<p>``` ruby
def calyhre(array)
  temp = results = []
  array.each do |e|</p>

<pre><code>temp &lt;&lt; e and next if temp.last == e - 1
results &lt;&lt; ( temp[1].nil? ? temp[0] : (temp.first..temp.last) ) unless temp.empty?
temp = [e]
</code></pre>

<p>  end
  results &lt;&lt; ( temp[1].nil? ? temp[0] : (temp.first..temp.last) )
end
```</p>

<p>Du coup, pour être équitable, il faudrait un autre benchmark pour les
<em>monkey patches</em> ! Peut-être plus tard.</p>

<p>Voici donc les résultats avec Ruby 2.1:</p>

<pre><code>$ 21:16 [~/devel/ruby/tests] (ruby-2.1.0) 
$ ruby range_reduce.rb 
Rehearsal --------------------------------------------------
original         0.690000   0.000000   0.690000 (  0.694524)
range_reduce     2.310000   0.000000   2.310000 (  2.305131)
range_reduce_1   0.650000   0.000000   0.650000 (  0.648863)
ArrayReduce      1.080000   0.000000   1.080000 (  1.088213)
Calyhre          0.680000   0.000000   0.680000 (  0.676048)
----------------------------------------- total: 5.410000sec

                     user     system      total        real
original         0.690000   0.000000   0.690000 (  0.692163)
range_reduce     2.250000   0.000000   2.250000 (  2.253139)
range_reduce_1   0.630000   0.000000   0.630000 (  0.636611)
ArrayReduce      1.050000   0.010000   1.060000 (  1.077018)
Calyhre          0.660000   0.000000   0.660000 (  0.662596)
</code></pre>

<p>Puis avec Rubinius 2.0:</p>

<pre><code>$ 21:19 [~/devel/ruby/tests] (rbx-2.0.0) 
$ ruby range_reduce.rb 
Rehearsal --------------------------------------------------
original         1.984124   0.004000   1.988124 (  1.994156)
range_reduce     3.220201   0.012001   3.232202 (  3.248281)
range_reduce_1   0.620038   0.000000   0.620038 (  0.775944)
ArrayReduce      1.156072   0.000000   1.156072 (  1.195206)
Calyhre          0.788049   0.000000   0.788049 (  1.007030)
----------------------------------------- total: 7.784485sec

                     user     system      total        real
original         1.008063   0.000000   1.008063 (  1.152041)
range_reduce     2.504157   0.020001   2.524158 (  2.525078)
range_reduce_1   0.320020   0.000000   0.320020 (  0.319301)
ArrayReduce      0.652041   0.000000   0.652041 (  0.653359)
Calyhre          0.352022   0.000000   0.352022 (  0.349252)
</code></pre>

<p>Ma méthode bien moche fonctionne plutôt bien ici :)</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Exercise Ruby : Reduce ranges - une solution]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/07/01/exercise-ruby-reduce-ranges-une-solution/"/>
    <updated>2014-07-01T21:07:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/07/01/exercise-ruby-reduce-ranges-une-solution</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Je rappelle le sujet/énoncé : en partant de ce tableau:</p>

<pre><code>[1, 2, 3, 7, 9, 17, 18, 19, 20]
</code></pre>

<p>on doit obtenir celui-ci:</p>

<pre><code>[1..3, 7, 9, 17..20]
</code></pre>

<p>En y réflechissant un peu, je me suis demandé si le module <code>Enumerable</code>
offrait une méthode qui nous aiderait. Bingo ! J'ai trouvé la méthode
<code>slice_before</code>, que je n'avais jamais utilisé jusqu'ici. Voici donc ma
solution:</p>

<!-- more -->


<p>``` ruby
def range_reduce(array)
  previous = array.first
  array.slice_before do |element|</p>

<pre><code>previous, previous2 = element, previous
previous2.succ != element
</code></pre>

<p>  end.map do |element|</p>

<pre><code>element.size == 1 ? element.first : element.first..element.last
</code></pre>

<p>  end
end
```</p>

<p>Quand je la compare à la solution originale de l'auteur de la gem:</p>

<p>``` ruby
def original(array)
  arr = array.dup
  arr.each_with_index do |el, index|</p>

<pre><code>range_index = index + 1
prev = el
while arr[range_index] == prev + 1 do
  prev = arr[range_index]
  range_index += 1
end
arr[index..range_index-1] = (arr[index]..arr[range_index-1]) unless index == range_index - 1
</code></pre>

<p>  end
end
```</p>

<p>Je me dis que je préfère la mienne, que je la trouve plus claire. Et j'étais
à deux doigts de balancer ma belle solution dans une <em>Pull Request</em> à l'auteur,
quand je me suis dis que je ferais bien de faire un benchmark quand même.
Et là, <em>patatra</em>:</p>

<p>``` ruby
require &lsquo;benchmark&rsquo;</p>

<p>array1 = [1, 2, 3, 7, 9, 17, 18, 19, 20]</p>

<p>Benchmark.bmbm do |x|
  x.report(&ldquo;mine&rdquo;) { 100_000.times { range_reduce(array1) } }
  x.report(&ldquo;original&rdquo;) { 100_000.times { original(array1) } }
end
```</p>

<pre><code>Rehearsal --------------------------------------------
mine       2.270000   0.000000   2.270000 (  2.270935)
original   0.710000   0.000000   0.710000 (  0.709436)
----------------------------------- total: 2.980000sec

               user     system      total        real
mine       2.320000   0.000000   2.320000 (  2.321878)
original   0.690000   0.000000   0.690000 (  0.692148)
</code></pre>

<p>Le score est sans appel ! Ma belle méthode sucre les fraises :(</p>

<p>Du coup j'ai bien envie de voir si je peux faire mieux que la méthode
originale ;) Soit en tentant d'améliorer ma méthode, soit en déroulant
un algorithme «à la C». On verra peut-être demain.</p>

<p>En attendant, vos solutions m'intéresse, n'hésitez pas à les envoyer dans
un commentaire.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Exercice Ruby : Reduce Ranges]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/06/30/exercice-ruby-reduce-ranges/"/>
    <updated>2014-06-30T21:09:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/06/30/exercice-ruby-reduce-ranges</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Je suis tombé récemment sur une nouvelle gem, <a href="https://github.com/jacobaweiss/reduce_ranges">ReduceRanges</a>.</p>

<p>Le sujet de cette gem est de transformer ceci:</p>

<pre><code>[1, 2, 3, 7, 9, 17, 18, 19, 20]
</code></pre>

<p>en cela:</p>

<pre><code>[1..3, 7, 9, 17..20]
</code></pre>

<!-- more -->


<p>Au delà de l'intéret d'une telle gem (je n'ai pas vraiment de <em>use cases</em> à
proposer, si vous en connaissez, laissez moi donc un commentaire) j'ai trouvé
l'exercice intéressant.</p>

<p>Demain je vous proposerais ma solution. Si vous voulez jouer, ne regardez pas
le code de la gem et proposez moi le votre ici, où dans l'article de demain.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Un space invaders avec Opal.rb - partie 16]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/06/27/un-space-invaders-avec-opal-dot-rb-partie-16/"/>
    <updated>2014-06-27T21:23:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/06/27/un-space-invaders-avec-opal-dot-rb-partie-16</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Hier on a vu comment lancer une appli rack pour le développement. Seulement
je n'ai pas envie de choisir entre les deux méthodes. Je veux les deux !
Le serveur rack pour le développement, et le build classique du fichier
javascript pour la mise en production.</p>

<p>On va se bricoler deux tâches <code>rake</code> en quelques minutes pour obtenir ça.</p>

<!-- more -->


<p>Alors j'avertis tout de suite : le script n'est pas parfait. C'est malgré une
bonne base pour commencer.</p>

<p>Voici le nouveau <code>Rakefile</code>, dans lequel j'ai ajouté une tâche <code>development</code>
et une tâche <code>production</code>:</p>

<p>``` ruby Rakefile
require &lsquo;opal&rsquo;
require &lsquo;opal-jquery&rsquo;</p>

<p>desc &ldquo;Build our app to build.js&rdquo;
task :build do
  env = Opal::Environment.new
  env.append_path &ldquo;app&rdquo;</p>

<p>  File.open(&ldquo;build.js&rdquo;, &ldquo;w+&rdquo;) do |out|</p>

<pre><code>out &lt;&lt; env["application"].to_s
</code></pre>

<p>  end
end</p>

<p>desc &lsquo;Build app for production&rsquo;
task :production => :build do
  cp &lsquo;app/templates/index_production.html&rsquo;, &lsquo;index.html&rsquo;
end</p>

<p>desc &lsquo;Run development server&rsquo;
task :development do
  cp &lsquo;app/templates/index_development.html&rsquo;, &lsquo;index.html&rsquo;
  <code>bundle exec rackup</code>
end
```</p>

<p>Pour que le fichier <code>index.html</code> reflète le bon environnement, j'ai
ajouté un dossier <code>templates</code>, avec une version de chaque:</p>

<pre><code>$ tree app
app
├── application.rb
├── enemies.rb
├── enemy.rb
├── fire.rb
├── game.rb
├── player.rb
├── space_canvas.rb
└── templates
    ├── index_development.html
    └── index_production.html
</code></pre>

<p>Pour info, voici le contenu des templates:</p>

<p>``` html app/templates/index_development.html
&lt;!DOCTYPE html>
<html>
  <head></p>

<pre><code>&lt;meta charset="utf-8" /&gt;
&lt;script src="http://code.jquery.com/jquery-1.11.0.min.js"&gt;&lt;/script&gt;
</code></pre>

<p>  </head>
  <body></p>

<pre><code>&lt;canvas width="700" height="600" id="canvas"&gt;&lt;/canvas&gt;
&lt;script src="assets/application.js"&gt;&lt;/script&gt;
</code></pre>

<p>  </body>
</html>
```</p>

<p>``` html app/templates/index_production.html
&lt;!DOCTYPE html>
<html>
  <head></p>

<pre><code>&lt;meta charset="utf-8" /&gt;
&lt;script src="http://code.jquery.com/jquery-1.11.0.min.js"&gt;&lt;/script&gt;
</code></pre>

<p>  </head>
  <body></p>

<pre><code>&lt;canvas width="700" height="600" id="canvas"&gt;&lt;/canvas&gt;
&lt;script src="build.js"&gt;&lt;/script&gt;
</code></pre>

<p>  </body>
</html>
```</p>

<p>Alors oui, les templates sont redondants. Et si on doit modifier le contenu
de <code>index.html</code>, il faudra faire la modification sur les deux templates.
J'avais prévenu que ça n'était pas parfait ;) Par contre, pour cette appli
c'est bien suffisant.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Un space invaders avec Opal.rb - partie 15]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/06/26/un-space-invaders-avec-opal-dot-rb-partie-15/"/>
    <updated>2014-06-26T21:09:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/06/26/un-space-invaders-avec-opal-dot-rb-partie-15</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Vous en avez peut-être marre de tapez <code>rake build</code> à chaque petite
modification de votre code ? Moi, oui. En utilisant Sprockets, on peut
rendre le build automatique. Cool.</p>

<!-- more -->


<p>La marche à suivre est décrite dans la <a href="http://opalrb.org/docs/using_sprockets/">documentation d'Opal</a>.
Basiquement, on ajoute un fichier <code>config.ru</code> à la racine:</p>

<p>``` ruby config.ru
require &lsquo;bundler&rsquo;
Bundler.require</p>

<p>run Opal::Server.new { |s|
  s.append_path &lsquo;app&rsquo;
  s.main = &lsquo;application&rsquo;
  s.index_path = &lsquo;index.html&rsquo;
}
```</p>

<p>Et on change la localisation du script dans <code>index.html</code>:</p>

<p>``` html index.html
&lt;!DOCTYPE html>
<html>
  <head></p>

<pre><code>&lt;meta charset="utf-8" /&gt;
&lt;script src="http://code.jquery.com/jquery-1.11.0.min.js"&gt;&lt;/script&gt;
</code></pre>

<p>  </head>
  <body></p>

<pre><code>&lt;canvas width="700" height="600" id="canvas"&gt;&lt;/canvas&gt;
&lt;script src="assets/application.js"&gt;&lt;/script&gt;
</code></pre>

<p>  </body>
</html>
```</p>

<p>Après quoi on lance l'application rack:</p>

<pre><code>$ bundle exec rackup
</code></pre>

<p>Et votre appli est accessible à l'adresse <code>localhost:9292</code>.</p>

<p>Maintenant tout changement de code demande seulement un raffraichіssement
dans le navigateur.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
