<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : intermédiaire | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/intermediaire/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2014-05-06T21:43:07+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Programmation concurrente pour Ruby avec eldritch]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/05/06/programmation-concurrente-pour-ruby-avec-eldritch/"/>
    <updated>2014-05-06T21:38:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/05/06/programmation-concurrente-pour-ruby-avec-eldritch</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Ce matin j'ai découvert la gem <a href="https://github.com/beraboris/eldritch">eldritch</a>,
pour faire de la programmation concurrente. Son API m'a paru vraiment
simple et élégante. Ce soir j'ai seulement 5 minutes pour faire un premier
test, alors on y va sans fioritures.</p>

<!-- more -->


<p>Tout d'abord, je vais utiliser Rubinius, puisqu'un ruby MRI ne permet pas
l'utilisation de plusieurs coeurs.</p>

<pre><code>$ rvm use rbx-2.0.0
Using /home/xavier/.rvm/gems/rbx-2.0.0
</code></pre>

<p>Ensuite, installation de la gem:</p>

<pre><code>gem install eldritch
</code></pre>

<p>Il me faut un programme simple pour tester rapidement. Le voici:</p>

<p>``` ruby eldritch.rb
def long_method1
  sleep(2)
  &ldquo;1&rdquo;
end</p>

<p>def long_method2
  sleep(2)
  &ldquo;2&rdquo;
end</p>

<p>puts long_method1
puts long_method2
```</p>

<p>Je simule deux méthodes assez longues grâce à <code>sleep(2)</code>, qui <em>endort</em> le
programme pendant 2 secondes. Le temps d'exécution est conforme à mes
attentes:</p>

<pre><code>$ time ruby eldritch.rb
1
2

real    0m4.821s
</code></pre>

<p>Maintenant on va utiliser la gem eldritch et son concept de <strong>tâche</strong> pour
réécrire le programme:</p>

<p>``` ruby eldritch.rb
require &lsquo;eldritch&rsquo;</p>

<p>long_task1 = async do
  sleep(2)
  &ldquo;1&rdquo;
end</p>

<p>long_task2 = async do
  sleep(2)
  &ldquo;2&rdquo;
end</p>

<p>puts long_task1.value
puts long_task2.value
```</p>

<p>Et voici le résultat:</p>

<pre><code>$ time ruby eldritch.rb
1
2

real    0m2.869s
</code></pre>

<p><strong>Tada !</strong> Mes deux <em>tâches</em> ont tournées en parallèle.</p>

<p>Ça me plait ce concept de tâche. Mais ce n'était qu'un premier test
rapide, eldritch nous réserve encore de bonne surprises. J'espère pouvoir
tester le reste demain.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Le LOAD_PATH dans Ruby]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/05/05/le-load-path-dans-ruby/"/>
    <updated>2014-05-05T21:02:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/05/05/le-load-path-dans-ruby</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>En Ruby, la variable <code>$LOAD_PATH</code> contient tous les chemins vers les
bibliothèques chargées.</p>

<p>``` irb</p>

<blockquote><blockquote><p>$LOAD_PATH
[</p>

<pre><code>[0] "/home/xavier/.rvm/gems/ruby-2.1.0/gems/awesome_print-1.2.0/lib",
[1] "/home/xavier/.rvm/rubies/ruby-2.1.0/lib/ruby/site_ruby/2.1.0",
[2] "/home/xavier/.rvm/rubies/ruby-2.1.0/lib/ruby/site_ruby/2.1.0/i686-linux",
[3] "/home/xavier/.rvm/rubies/ruby-2.1.0/lib/ruby/site_ruby",
[4] "/home/xavier/.rvm/rubies/ruby-2.1.0/lib/ruby/vendor_ruby/2.1.0",
[5] "/home/xavier/.rvm/rubies/ruby-2.1.0/lib/ruby/vendor_ruby/2.1.0/i686-linux",
[6] "/home/xavier/.rvm/rubies/ruby-2.1.0/lib/ruby/vendor_ruby",
[7] "/home/xavier/.rvm/rubies/ruby-2.1.0/lib/ruby/2.1.0",
[8] "/home/xavier/.rvm/rubies/ruby-2.1.0/lib/ruby/2.1.0/i686-linux"
</code></pre>

<p>]
```</p></blockquote></blockquote>

<!-- more -->


<p>Si je charge Rspec, par exemple, son chemin va être ajouté dans la variable
<code>$LOAD_PATH</code>, ainsi que toutes les bibliothèques dont dépend Rspec:</p>

<p>``` irb</p>

<blockquote><blockquote><p>require &lsquo;rspec&rsquo;
true
$LOAD_PATH
[</p>

<pre><code>[ 0] "/home/xavier/.rvm/gems/ruby-2.1.0/gems/awesome_print-1.2.0/lib",
[ 1] "/home/xavier/.rvm/gems/ruby-2.1.0/gems/rspec-2.14.1/lib",
[ 2] "/home/xavier/.rvm/gems/ruby-2.1.0/gems/rspec-core-2.14.8/lib",
[ 3] "/home/xavier/.rvm/rubies/ruby-2.1.0/lib/ruby/site_ruby/2.1.0",
[ 4] "/home/xavier/.rvm/rubies/ruby-2.1.0/lib/ruby/site_ruby/2.1.0/i686-linux",
[ 5] "/home/xavier/.rvm/rubies/ruby-2.1.0/lib/ruby/site_ruby",
[ 6] "/home/xavier/.rvm/rubies/ruby-2.1.0/lib/ruby/vendor_ruby/2.1.0",
[ 7] "/home/xavier/.rvm/rubies/ruby-2.1.0/lib/ruby/vendor_ruby/2.1.0/i686-linux",
[ 8] "/home/xavier/.rvm/rubies/ruby-2.1.0/lib/ruby/vendor_ruby",
[ 9] "/home/xavier/.rvm/rubies/ruby-2.1.0/lib/ruby/2.1.0",
[10] "/home/xavier/.rvm/rubies/ruby-2.1.0/lib/ruby/2.1.0/i686-linux"
</code></pre>

<p>]
```</p></blockquote></blockquote>

<p>Il y a encore quelques jours, je faisais systématiquement cela au début de
toutes mes gems:</p>

<p><code>ruby
$LOAD_PATH.unshift File.dirname(__FILE__)
</code></p>

<p>Ceci pour que ma gem ajoute son propre chemin dans le <code>LOAD_PATH</code>.
Et bien je viens d'apprendre que non, c'est inutile ! L'utilitaire <code>gem</code>
fait très bien cela tout seul.</p>

<p>Aujourd'hui j'ai (encore) appris quelque chose ;)</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby - Et si on écrivait un ORM ? - partie 13]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/05/04/ruby-et-si-on-ecrivait-un-orm-partie-13/"/>
    <updated>2014-05-04T21:09:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/05/04/ruby-et-si-on-ecrivait-un-orm-partie-13</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Aujourd'hui on termine de structurer quelque peu le projet. Voici ce que je
veux obtenir:</p>

<pre><code>$ tree -a
.
├── lib/
│   ├── base.rb
│   ├── database.rb
│   └── recorder.rb
├── .rspec
├── sorm.rb
├── spec/
│   ├── base_spec.rb
│   └── database_spec.rb
└── test.db
</code></pre>

<!-- more -->


<p>Le fichier <code>sorm.rb</code> à la racine du projet va contenir nos require:</p>

<p><code>ruby sorm.rb
require 'sqlite3'
require './lib/database'
require './lib/base'
require './lib/recorder'
</code></p>

<p>Quant aux 3 fichiers sous <code>lib/</code> ils contiennent chacun une classe
de notre ancien fichier <code>sorm.rb</code>, qui était un fourre-tout.
Voici ces fichiers:</p>

<p>``` ruby lib/base.rb
module SORM
  class Base</p>

<pre><code>def self.save(parameters)
  Recorder.new(self.to_s.downcase, parameters).save
  self.new(parameters)
end

def initialize(attributes)
  attributes.each do |name, value|
    instance_variable_set("@#{name}", value)
    singleton_class.class_eval{attr_reader name.to_sym}
  end
end
</code></pre>

<p>  end
end
```</p>

<p>``` ruby lib/database.rb
module SORM
  class Database</p>

<pre><code>@@connection = false

def self.connect(database_filename)
  @@connection = SQLite3::Database.open(database_filename)
end

def self.disconnect
  @@connection = false
end

def self.connected?
  !!@@connection
end

def self.execute(sql)
  @@connection.execute(sql)
end
</code></pre>

<p>  end
end
```</p>

<p>``` ruby lib/recorder.rb
module SORM
  class Recorder</p>

<pre><code>def initialize(table, parameters)
  @table = table
  @parameters = parameters
end

def save
  Database.execute(query)
end

def query
  "INSERT INTO #@table (#{columns}) VALUES(#{values});"
end

def columns
  @parameters.keys.join(',')
end

def values
  @parameters.values.map do |item|
    item.class == String ? "'#{item}'" : item
  end.join(',')
end
</code></pre>

<p>  end
end
```</p>

<p>On va enfin pouvoir ajouter de nouvelles fonctionnalités à notre ORM !
C'est pas trop tôt, je commençais à m'ennuyer ;)</p>

<p>Je tâcherais aussi de mettre le projet sur Github prochainement pour
qu'il soit plus facile à suivre.</p>

<p><em>To be continued</em></p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Trois-centième article aujourd'hui !]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/05/03/trois-centieme-article-aujourdhui-slash/"/>
    <updated>2014-05-03T21:56:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/05/03/trois-centieme-article-aujourdhui-slash</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Aujourd'hui c'est le 300ème article de ce blog ! Voilà 300 jours que je
pond un article au quotidien. J'en reviens pas !</p>

<!-- more -->


<p>Encore 65 et j'aurais réussi le défi que je m'étais fixé il y a 300 jours:
écrire un article par jour pendant un an.</p>

<p>Bref, le contenu du jour sera : le fichier <code>.yardopts</code>. Qu'est-ce que c'est
encore que ça ?</p>

<p>Pour générer une documentation de vos gems Ruby avec
<a href="http://yardoc.org/">Yard</a> vous écrivez peut-être comme moi une tâche Rake dans ce genre:</p>

<p><code>ruby
desc 'Create documentation'
task :doc do
  exec 'yardoc --title "Titre de la doc"'
end
</code></p>

<p>Là j'ai mis une seule option, mais on en a souvent d'autres, plus des fichiers
à inclure (comme la licence, le changelog, etc).</p>

<p>Et bien j'ai appris aujourd'hui que ces options pouvaient être mises dans
un fichier <code>.yardopts</code>. En reprenant l'exemple précédant, cela deviendrait:</p>

<p><code>raw .yardopts
--title "Titre de la doc"
</code></p>

<p><code>ruby
desc 'Create documentation'
task :doc do
  exec 'yardoc'
end
</code></p>

<p>Non seulement ça évite de surcharger la tâche rake avec des informations
inutiles, mais surtout, ça permet à des service externes comme
<a href="http://www.rubydoc.info/">RubyDoc</a> de savoir exactement ce que vous voulez.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby - Et si on écrivait un ORM ? - partie 12]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/05/02/ruby-et-si-on-ecrivait-un-orm-partie-12/"/>
    <updated>2014-05-02T20:59:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/05/02/ruby-et-si-on-ecrivait-un-orm-partie-12</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Douzième partie déjà de cette série sur la construction d'un ORM en Ruby…</p>

<!-- more -->


<p>On doit ajouter une méthode <code>disconnect</code> à notre classe <code>Database</code>, voici
d'abord le test:</p>

<p>``` ruby spec/database_spec.rb
require &lsquo;./sorm&rsquo;</p>

<p>describe SORM::Database do</p>

<p>  it &lsquo;is not connected by default&rsquo; do</p>

<pre><code>expect(SORM::Database.connected?).to be false
</code></pre>

<p>  end</p>

<p>  describe &lsquo;after connection&rsquo; do</p>

<pre><code>before { SORM::Database.connect('test.db') }
after  { SORM::Database.disconnect }

it 'is connected' do
  expect(SORM::Database.connected?).to be true
end

it 'is disconnected after disconnection' do
  SORM::Database.disconnect
  expect(SORM::Database.connected?).to be false
end
</code></pre>

<p>  end
end
```</p>

<p>Et maintenant l'implémentation:</p>

<p>``` ruby
  class Database</p>

<pre><code>@@connection = false

def self.connect(database_filename)
  @@connection = SQLite3::Database.open(database_filename)
end

def self.disconnect
  @@connection = false
end

def self.connected?
  !!@@connection
end

def self.execute(sql)
  @@connection.execute(sql)
end
</code></pre>

<p>  end
```</p>

<p>Rien à dire d'intéressant là-dessus. Je vais aussi configurer Rspec pour
qu'il joue les tests dans un ordre alétoire, et tant que j'y suis j'ajoute
un peu de couleur à la sortie:</p>

<p><code>raw .rspec
--color
--order=random
</code></p>

<p>Et voici l'instant de vérité:</p>

<pre><code>$ rspec
........
Finished in 0.03996 seconds
8 examples, 0 failures
Randomized with seed 55135
</code></pre>

<p>Parfait, on a splitté les tests, on les a mis dans un dossier <code>spec/</code>,
on les a amélioré. C'est tout bon. Maintenant on devrait pouvoir faire
facilement un truc similaire avec le fichier <code>sorm.rb</code>.</p>

<p><em>To be continued</em></p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
