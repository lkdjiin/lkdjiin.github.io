<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : intermédiaire | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/intermediaire/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2014-12-17T16:45:47+01:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Les tours de Hanoi - partie 3]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/07/07/les-tours-de-hanoi-partie-3/"/>
    <updated>2014-07-07T21:13:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/07/07/les-tours-de-hanoi-partie-3</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>On commence à coder l'algorithme génétique pour solutionner les tours de
Hanoi.</p>

<pre><code>$ tree
.
├── ga.rb
├── lib
│   ├── hanoi
│   │   ├── board.rb
│   │   ├── game.rb
│   │   └── rules.rb
│   └── hanoi.rb
└── spec
    ├── board_spec.rb
    ├── game_spec.rb
    ├── integration
    │   └── game_spec.rb
    └── spec_helper.rb
</code></pre>

<!-- more -->


<p>``` ruby ga.rb
require &lsquo;./lib/hanoi/board&rsquo;
require &lsquo;./lib/hanoi/game&rsquo;
require &lsquo;./lib/hanoi/rules&rsquo;</p>

<p>class Chromosome
  attr_reader :genes
  def initialize(number_of_pieces)</p>

<pre><code>@genes = Array.new(2 ** number_of_pieces - 1) { rand(6) }
</code></pre>

<p>  end
end</p>

<p>class Population
  def initialize(size, number_of_pieces)</p>

<pre><code>@population = Array.new(size) { Chromosome.new(number_of_pieces) }
</code></pre>

<p>  end</p>

<p>  def each(&amp;block)</p>

<pre><code>@population.each(&amp;block)
</code></pre>

<p>  end
end</p>

<p>class GA</p>

<p>  def initialize</p>

<pre><code>@population = Population.new(20, 3)
</code></pre>

<p>  end</p>

<p>  def evaluate</p>

<pre><code>@population.each do |chromosome|
  board = ::Hanoi::Board.new(3)
  game = ::Hanoi::Game.new(board)
  chromosome.genes.each do |gene|
    case gene
    when 0 then game.move from: 1, to: 2
    when 1 then game.move from: 1, to: 3
    when 2 then game.move from: 2, to: 1
    when 3 then game.move from: 2, to: 3
    when 4 then game.move from: 3, to: 1
    when 5 then game.move from: 3, to: 2
    end
  end
  p board.eval
end
</code></pre>

<p>  end
end</p>

<p>ga = GA.new
ga.evaluate
```</p>

<p>Voilà de quoi commencer, des chromosomes, une population et l'évaluation
de chaque chromosome.</p>

<p>Ça fonctionne:</p>

<pre><code>$ ruby ga.rb 
0
5
4
2
2
4
5
5
4
4
4
1
5
4
1
0
0
2
0
4
</code></pre>

<p>Mais la fonction <code>GA#evaluate</code> me dérange. D'abord elle est trop longue, mais
rien qui ne puisse s'arranger avec un refactoring. Ce qui me dérange surtout
c'est qu'elle délègue la <em>vraie</em> évaluation à <code>Board</code>. Or, l'évaluation
dévrait faire partie intégrante de l'algorithme génétique, et pas de la
mécanique du jeu. C'est donc un point à améliorer avant d'aller plus loin.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les tours de hanoi - partie 2]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/07/06/les-tours-de-hanoi-partie-2/"/>
    <updated>2014-07-06T13:02:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/07/06/les-tours-de-hanoi-partie-2</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Je termine l'implémentation de la mécanique du jeu, pour pouvoir passer ensuite
à la construction de l'algorithme génétique.</p>

<pre><code>$ tree
.
├── lib
│   ├── hanoi
│   │   ├── board.rb
│   │   ├── game.rb
│   │   └── rules.rb
│   └── hanoi.rb
└── spec
    ├── board_spec.rb
    ├── game_spec.rb
    ├── integration
    │   └── game_spec.rb
    └── spec_helper.rb
</code></pre>

<!-- more -->


<p>J'ai mis <a href="https://github.com/lkdjiin/hanoi">le code</a> sur Github pour que vous puissiez le voir dans son
ensemble.</p>

<p>La classe <code>Board</code> gagne une méthode <code>move</code>, sans intelligence aucune:</p>

<p>``` ruby
module Hanoi</p>

<p>  class Board</p>

<pre><code>def initialize(number_of_pieces)
  @pegs = [ (1..number_of_pieces).to_a.reverse, [], [] ]
end

def position
  @pegs
end

def position=(pegs)
  @pegs = pegs
end

def eval
  @pegs[1].reduce(0, :+) + 2 * @pegs[2].reduce(0, :+)
end

def move(from, to)
  piece = @pegs[from - 1].pop
  @pegs[to - 1].push(piece)
end
</code></pre>

<p>  end</p>

<p>end
```</p>

<p>La mécanique du jeu est assurée par la classe <code>Game</code>, qui délègue à <code>Board</code> et
se repose sur un module <code>Rules</code> pour les décisions:</p>

<p>``` ruby
module Hanoi</p>

<p>  class Game</p>

<pre><code>def initialize(board)
  @board = board
end

def move(from: 1, to: 1)
  @board.move(from, to) if Rules.valid?(@board, from, to)
end

def win?
  Rules.win?(@board)
end

def position
  @board.position
end
</code></pre>

<p>  end</p>

<p>end
```</p>

<p>``` ruby
module Hanoi::Rules</p>

<p>  def self.valid?(board, from, to)</p>

<pre><code>return false if board.position[from - 1].empty?
return true if board.position[to - 1].empty?
if board.position[from - 1][0] &lt; board.position[to - 1][0]
  true
else
  false
end
</code></pre>

<p>  end</p>

<p>  def self.win?(board)</p>

<pre><code>if board.position[0].empty? &amp;&amp; board.position[1].empty?
  true
else
  false
end
</code></pre>

<p>  end</p>

<p>end
```</p>

<p>Voilà, notre futur algorithme génétique a maintenant les moyens d'évaluer
une suite de mouvements, reste plus qu'à le coder ;)</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les tours de Hanoi - partie 1]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/07/05/les-tours-de-hanoi-partie-1/"/>
    <updated>2014-07-05T15:25:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/07/05/les-tours-de-hanoi-partie-1</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Je vais commencer par implémenter une classe <code>Board</code>, dont la tâche est
de retenir l'état du plateau de jeu, c'est à dire la position des pièces.
J'ai envie de faire des tests avec Rspec, donc voici les premiers fichiers:</p>

<pre><code>$ tree
.
├── board.rb
└── spec
    └── board_spec.rb
</code></pre>

<!-- more -->


<p>Voici les tests de <code>Board</code>, qui décrivent ce que j'attend de cette classe:</p>

<p>``` ruby spec/board_spec.rb
require &lsquo;./board&rsquo;</p>

<p>describe Board do</p>

<p>  before { @board = Board.new(3) }</p>

<p>  it &lsquo;has a position&rsquo; do</p>

<pre><code>expect(@board.position).to eq [ [3, 2, 1], [], [] ]
</code></pre>

<p>  end</p>

<p>  it &lsquo;accepts a position&rsquo; do</p>

<pre><code>@board.position = [ [], [3], [2, 1] ]
expect(@board.position).to eq [ [], [3], [2, 1] ]
</code></pre>

<p>  end</p>

<p>  describe &lsquo;position evalution&rsquo; do</p>

<pre><code>specify { expect(@board.eval).to eq 0 }

specify do
  @board.position = [ [], [3], [2, 1] ]
  expect(@board.eval).to eq 9
end

specify do
  @board.position = [ [], [], [3, 2, 1] ]
  expect(@board.eval).to eq 12
end
</code></pre>

<p>  end</p>

<p>end
```</p>

<p>On doit pouvoir l'initialiser avec un nombre de pièces:</p>

<pre><code>before { @board = Board.new(3) }
</code></pre>

<p>À l'initialisation, les pièces sont en position de départ:</p>

<pre><code>it 'has a position' do
  expect(@board.position).to eq [ [3, 2, 1], [], [] ]
end
</code></pre>

<p>On peut modifier la position à volonté:</p>

<pre><code>it 'accepts a position' do
  @board.position = [ [], [3], [2, 1] ]
  expect(@board.position).to eq [ [], [3], [2, 1] ]
end
</code></pre>

<p>Enfin, la position actuelle peut être évaluée:</p>

<pre><code>describe 'position evalution' do

  specify { expect(@board.eval).to eq 0 }

  specify do
    @board.position = [ [], [3], [2, 1] ]
    expect(@board.eval).to eq 9
  end

  specify do
    @board.position = [ [], [], [3, 2, 1] ]
    expect(@board.eval).to eq 12
  end

end
</code></pre>

<p>Pour finir, l'implémentation minimum:</p>

<p>``` ruby board.rb
class Board</p>

<p>  def initialize(number_of_pieces)</p>

<pre><code>@pegs = [ (1..number_of_pieces).to_a.reverse, [], [] ]
</code></pre>

<p>  end</p>

<p>  def position</p>

<pre><code>@pegs
</code></pre>

<p>  end</p>

<p>  def position=(pegs)</p>

<pre><code>@pegs = pegs
</code></pre>

<p>  end</p>

<p>  def eval</p>

<pre><code>@pegs[1].reduce(0, :+) + 2 * @pegs[2].reduce(0, :+)
</code></pre>

<p>  end</p>

<p>end
```</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Un algorithme génétique pour les tours de Hanoi avec Opal.rb]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/07/04/un-algorithme-genetique-pour-les-tours-de-hanoi-avec-opal-dot-rb/"/>
    <updated>2014-07-04T21:07:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/07/04/un-algorithme-genetique-pour-les-tours-de-hanoi-avec-opal-dot-rb</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Pour débuter la résolution du jeu des tours de Hanoi à l'aide d'un algorithme
génétique, j'ai envie de commencer par réfléchir à la représentation des
chromosomes, aux règles de mouvement, à la fonction d'évaluation, sans
forcément commencer à coder.</p>

<!-- more -->


<p>Les règles sont sur <a href="http://fr.wikipedia.org/wiki/Tours_de_Hano%C3%AF">wikipédia</a>.</p>

<p>J'apprend un truc qui va me servir, il faut 2<sup>n</sup> &ndash; 1 coups au minimum pour
solutionner le problème (n est le nombre de disques). Du coup, mes chromosomes
devront posséder 2<sup>n</sup> &ndash; 1 gènes. Ce qui ira sans trop de soucis jusqu'à une
dizaines de disques, mais au delà c'est pas gagné.</p>

<p>Pour faire simple, un gène va représenter un mouvement à l'aide d'un nombre:</p>

<pre><code>0 -&gt; du 1er poteau au 2ème poteau
1 -&gt; du 1er poteau au 3ème poteau
2 -&gt; du 2ème poteau au 1er poteau
3 -&gt; du 2ème poteau au 3ème poteau
4 -&gt; du 3ème poteau au 1er poteau
5 -&gt; du 3ème poteau au 2ème poteau
</code></pre>

<p>Que faire quand un mouvement est illégal ? Le plus simple est de l'ignorer,
c'est donc ce que je vais faire.</p>

<p>La fonction d'évaluation, maintenant ? J'ai envie de donner un <em>poids</em> à
chaque disque suivant le poteau où il se trouve. Sur le premier poteau, un
disque vaut 0 point. Sur le second poteau, il vaut 1 point, et sur le
troisième, il vaut 2 points.</p>

<p>Par exemple, si je commence avec seulement 3 disques, la position suivante
vaut 0 point:</p>

<pre><code>  x|x      |       |   
 xx|xx     |       |   
xxx|xxx    |       |    
</code></pre>

<p>Alors que la suivante vaut 6 points:</p>

<pre><code>   |       |      x|x   
   |       |     xx|xx 
   |       |    xxx|xxx
</code></pre>

<p>C'est pas suffisant pour différencier certaines solutions, donc on appliquera
un multiplicateur suivant la taille du disque, 1 pour le plus petit, 2 pour
le suivant et 3 pour le plus grand. Je vous laisse faire les calculs, ça me
prend trop de temps de faire les petits dessins ;)</p>

<p>Allez, la prochaine fois on code…</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Exercise Ruby - Reduce ranges - d'autres solutions]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/07/02/exercise-ruby-reduce-ranges-dautres-solutions/"/>
    <updated>2014-07-02T21:03:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/07/02/exercise-ruby-reduce-ranges-dautres-solutions</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Hier j'ai proposé <a href="http://lkdjiin.github.io/blog/2014/07/01/exercise-ruby-reduce-ranges-une-solution/">une solution</a> à cet exercise de <a href="http://lkdjiin.github.io/blog/2014/06/30/exercice-ruby-reduce-ranges/">Range reduce</a>.
Bien qu'élégante (du moins pour moi), elle prenait vraiment trop de temps par
rapport à l'originale. En voici d'autres. Meilleures ?</p>

<!-- more -->


<p>Pour rappel, voici l'originale:</p>

<p>``` ruby
def original(array)
  arr = array.dup
  arr.each_with_index do |el, index|</p>

<pre><code>range_index = index + 1
prev = el
while arr[range_index] == prev + 1 do
  prev = arr[range_index]
  range_index += 1
end
arr[index..range_index-1] = (arr[index]..arr[range_index-1]) unless index == range_index - 1
</code></pre>

<p>  end
end
```</p>

<p>Et voici ma solution d'hier:</p>

<p>``` ruby
def range_reduce(array)
  previous = array.first
  array.slice_before do |element|</p>

<pre><code>previous, previous2 = element, previous
previous2.succ != element
</code></pre>

<p>  end.map do |element|</p>

<pre><code>element.size == 1 ? element.first : element.first..element.last
</code></pre>

<p>  end
end
```</p>

<p>Maintenant, voici celle que j'ai eu en tête toute la journée:</p>

<p>``` ruby
def range_reduce_1(array)
  temp = []
  result = []</p>

<p>  array.each do |element|</p>

<pre><code>if temp.empty?
  temp &lt;&lt; element
else
  if temp.last + 1 == element
    temp &lt;&lt; element
  else
    if temp.size == 1
      result &lt;&lt; temp.first
    else
      result &lt;&lt; (temp.first..temp.last)
    end
    temp = [element]
  end
end
</code></pre>

<p>  end</p>

<p>  if temp.size == 1</p>

<pre><code>result &lt;&lt; temp.first
</code></pre>

<p>  else</p>

<pre><code>result &lt;&lt; (temp.first..temp.last)
</code></pre>

<p>  end</p>

<p>  result
end
```</p>

<p>C'est moche, hein ? Mais ne riez quand même pas trop, attendez de voir les
benchmarks ;)</p>

<p>Je me suis dis que j'allais aussi tester une solution <em>propre</em>, avec un
pattern que j'aime beaucoup:</p>

<p>``` ruby
class ArrayReduce</p>

<p>  def self.ranges(array)</p>

<pre><code>new(array).ranges
</code></pre>

<p>  end</p>

<p>  def initialize(array)</p>

<pre><code>@array = array
@result = [ [@array.first] ]
</code></pre>

<p>  end</p>

<p>  def ranges</p>

<pre><code>@array[1..-1].each do |element|
  suite?(element) ? @result.last &lt;&lt; element : @result &lt;&lt; [element]
end

@result.map do |element|
  element.size == 1 ? element.first : element.first..element.last
end
</code></pre>

<p>  end</p>

<p>  private</p>

<p>  def suite?(element)</p>

<pre><code>@result.last.last == element.pred
</code></pre>

<p>  end</p>

<p>end
```</p>

<p>Et voici la solution qu'a posté un lecteur, Calyhre. J'ai pris la liberté de
la transformer en méthode, comme j'ai fait pour la solution originale qui
<em>monkey patch</em> la classe Array (<a href="https://gist.github.com/Calyhre/280ee41136ad2a62e6c3">solution originale de Calyhre</a>):</p>

<p>``` ruby
def calyhre(array)
  temp = results = []
  array.each do |e|</p>

<pre><code>temp &lt;&lt; e and next if temp.last == e - 1
results &lt;&lt; ( temp[1].nil? ? temp[0] : (temp.first..temp.last) ) unless temp.empty?
temp = [e]
</code></pre>

<p>  end
  results &lt;&lt; ( temp[1].nil? ? temp[0] : (temp.first..temp.last) )
end
```</p>

<p>Du coup, pour être équitable, il faudrait un autre benchmark pour les
<em>monkey patches</em> ! Peut-être plus tard.</p>

<p>Voici donc les résultats avec Ruby 2.1:</p>

<pre><code>$ 21:16 [~/devel/ruby/tests] (ruby-2.1.0) 
$ ruby range_reduce.rb 
Rehearsal --------------------------------------------------
original         0.690000   0.000000   0.690000 (  0.694524)
range_reduce     2.310000   0.000000   2.310000 (  2.305131)
range_reduce_1   0.650000   0.000000   0.650000 (  0.648863)
ArrayReduce      1.080000   0.000000   1.080000 (  1.088213)
Calyhre          0.680000   0.000000   0.680000 (  0.676048)
----------------------------------------- total: 5.410000sec

                     user     system      total        real
original         0.690000   0.000000   0.690000 (  0.692163)
range_reduce     2.250000   0.000000   2.250000 (  2.253139)
range_reduce_1   0.630000   0.000000   0.630000 (  0.636611)
ArrayReduce      1.050000   0.010000   1.060000 (  1.077018)
Calyhre          0.660000   0.000000   0.660000 (  0.662596)
</code></pre>

<p>Puis avec Rubinius 2.0:</p>

<pre><code>$ 21:19 [~/devel/ruby/tests] (rbx-2.0.0) 
$ ruby range_reduce.rb 
Rehearsal --------------------------------------------------
original         1.984124   0.004000   1.988124 (  1.994156)
range_reduce     3.220201   0.012001   3.232202 (  3.248281)
range_reduce_1   0.620038   0.000000   0.620038 (  0.775944)
ArrayReduce      1.156072   0.000000   1.156072 (  1.195206)
Calyhre          0.788049   0.000000   0.788049 (  1.007030)
----------------------------------------- total: 7.784485sec

                     user     system      total        real
original         1.008063   0.000000   1.008063 (  1.152041)
range_reduce     2.504157   0.020001   2.524158 (  2.525078)
range_reduce_1   0.320020   0.000000   0.320020 (  0.319301)
ArrayReduce      0.652041   0.000000   0.652041 (  0.653359)
Calyhre          0.352022   0.000000   0.352022 (  0.349252)
</code></pre>

<p>Ma méthode bien moche fonctionne plutôt bien ici :)</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
