<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : intermédiaire | Xavier Nayrac]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/intermediaire/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2015-05-15T13:58:52+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Le hack FizzBuzz en Ruby]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/04/30/le-hack-fizzbuzz-en-ruby/"/>
    <updated>2015-04-30T17:07:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/04/30/le-hack-fizzbuzz-en-ruby</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Voici ce qui trainait sur le net aujourd’hui, un jeu de
<a href="http://en.wikipedia.org/wiki/Fizz_buzz">FizzBuzz</a> en une ligne de Ruby:</p>

<p><code>ruby
1.upto(100){|n|puts'FizzBuzz '[o=n**4%-15,o+13]||n}
</code></p>

<p>Ce qui donne:</p>

<p><code>bash
ruby -e "1.upto(100){|n|puts'FizzBuzz '[o=n**4%-15,o+13]||n}"
1
2
Fizz
4
Buzz 
Fizz
7
8
Fizz
Buzz 
11
.
.
.
94
Buzz 
Fizz
97
98
Fizz
Buzz 
</code></p>

<p>Pour celles et ceux qui ne pigent pas cette ligne de code Ruby, on va la
déconstruire petit à petit.</p>

<!-- more -->

<p>Nous avons affaire à une boucle (j’ai remplacé les <code>{}</code> par <code>do end</code>):</p>

<p><code>ruby
1.upto(100) do |n|
  puts'FizzBuzz '[o=n**4%-15,o+13]||n
end
</code></p>

<p><code>a.upto(b)</code> itère de <code>a</code> jusqu’à <code>b</code>:</p>

<p><code>irb
$ irb
&gt;&gt; 10.upto(12) do |iteration|
?&gt;   puts iteration
&gt;&gt; end
10
11
12
</code></p>

<p>Regardons de plus près l’intérieur de la boucle, là où c’est intéressant.
Ruby permet d’appeler les
méthodes sans utiliser de parenthèses. Ici je les ai simplement rajouter pour
tenter de clarifier le code:</p>

<p><code>ruby
1.upto(100) do |n|
  puts( 'FizzBuzz '[o=n**4%-15,o+13]||n )
end
</code></p>

<p>Maintenant qu’on est bien sûr qu’il s’agit de la méthode <code>puts</code> avec un
argument bizarre dedans, je sépare les différents éléments de la <em>grammaire de
Ruby</em> par des espaces. Toujours pour essayer d’y voir plus clair:</p>

<p><code>ruby
1.upto(100) do |n|
  puts( 'FizzBuzz '[o = n ** 4 % -15, o + 13] || n )
end
</code></p>

<p>Arrêtons nous un peu sur les sous-ensembles de chaîne <code>[a, b]</code>.
Le premier chiffre est la position de départ, le second est le nombre de
caractères:</p>

<p><code>irb
$ irb
&gt;&gt; "abcdef"[0, 2]
"ab"
&gt;&gt; "abcdef"[3, 2]
"de"
</code></p>

<p>Ruby permet de donner une position de départ pas rapport à la fin:</p>

<p><code>irb
&gt;&gt; "abcdef"[-4, 2]
"cd"
</code></p>

<p>Pour la suite, notez bien que si on va chercher des caractères <strong>avant</strong> le début ou <strong>après</strong> la fin de la chaîne, on se retrouve avec <code>nil</code>. Ça n’est pas une erreur, c’est le comportement attendu:</p>

<p><code>irb
&gt;&gt; "abcdef"[-123, 2]
nil
&gt;&gt; "abcdef"[999, 2]
nil
</code></p>

<p>Maintenant essayons de décrypter la formule mathématique.
Utilisons une variable temporaire pour l’isoler:</p>

<p><code>ruby
1.upto(100) do |n|
  o = n ** 4 % -15
  puts( 'FizzBuzz '[o, o + 13] || n )
end
</code></p>

<p>En Ruby, <code>**</code> est l’opérateur de puissance:</p>

<p><code>irb
$ irb
&gt;&gt; 10 ** 2
100
&gt;&gt; 10 ** 3
1000
&gt;&gt; 10 ** 4
10000
</code></p>

<p>Quant à <code>%</code>, c’est l’opérateur de la division modulaire, souvent appelé
<em>modulo</em>. Si vous avez plein de temps devant vous il y a la page wikipédia sur
<a href="http://fr.wikipedia.org/wiki/Arithm%C3%A9tique_modulaire">l’arithmétique modulaire</a>.
Sinon voici une explication rapide du modulo: <strong>c’est le reste de la division
entière</strong>. Donc <code>9 % 4 == 1</code>.</p>

<p>Sauf qu’ici on utilise le modulo avec un nombre négatif. Et là les maths se
compliquent un peu, et surtout différents langages de programmation auront différents
comportements.</p>

<p>Essayons plutôt de <em>sentir</em> la formule en l’appliquant aux nombres de 1 à 16:</p>

<p><code>irb
$ irb
&gt;&gt; (1..16).each do |n|
?&gt;   o = n ** 4 % -15
&gt;&gt;   puts "#{n} =&gt; #{o}"
&gt;&gt; end
1 =&gt; -14
2 =&gt; -14
3 =&gt; -9
4 =&gt; -14
5 =&gt; -5
6 =&gt; -9
7 =&gt; -14
8 =&gt; -14
9 =&gt; -9
10 =&gt; -5
11 =&gt; -14
12 =&gt; -9
13 =&gt; -14
14 =&gt; -14
15 =&gt; 0
16 =&gt; -14
</code></p>

<p>J’imagine qu’à ce moment précis, vous êtes plusieurs à crier <strong>«Ha ha !»</strong>.</p>

<p>Cette formule, en Ruby, a donc 4 solutions possibles:</p>

<ul>
  <li>Quand <em>n</em> est un multiple de 3, la solution est <strong>-9</strong>.</li>
  <li>Quand <em>n</em> est un multiple de 5, la solution est <strong>-5</strong>.</li>
  <li>Quand <em>n</em> est un multiple de 15 (c’est à dire à la fois multiple de 3 et de
9), la solution est <strong>0</strong>.</li>
  <li>Dans les autres cas, la solution est <strong>-14</strong>.</li>
</ul>

<p>Voyons ce qu’il se passe avec <code>'FizzBuzz '</code> quand <code>o</code> vaut respectivement -9, -5, 0 puis -14:</p>

<p><code>irb
$ irb
&gt;&gt; 'FizzBuzz '[-9, -9 + 13]
"Fizz"
&gt;&gt; 'FizzBuzz '[-5, -5 + 13]
"Buzz "
&gt;&gt; 'FizzBuzz '[0, 13]
"FizzBuzz "
&gt;&gt; 'FizzBuzz '[-14, -14 + 13]
nil
</code></p>

<p>Peut-être vous demandez vous pourquoi il y a un espace après FizzBuzz ?
En pratique, voici la raison:</p>

<p><code>irb
&gt;&gt; 'FizzBuzz'[-9, -9 + 13]
nil
&gt;&gt; 'FizzBuzz'[-5, -5 + 13]
"zBuzz"
</code></p>

<p>En théorie, je vous laisse faire les calculs ;)</p>

<p>Pour finir, il reste à expliquer le <code>||</code>, un exemple vaut mieux qu’un long
discours:</p>

<p><code>irb
&gt;&gt; "foo" || 13
"foo"
&gt;&gt; nil || 13
13
</code></p>

<p>Voilà, si vous voulez ajouter d’autres explications, les commentaires sont fait
pour ça ;)</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Une machine de Turing en Ruby - La routine de copie]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/02/04/une-machine-de-turing-en-ruby-la-routine-de-copie/"/>
    <updated>2015-02-04T10:22:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/02/04/une-machine-de-turing-en-ruby-la-routine-de-copie</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>La routine de copie est une brique élémentaire d’un programme pour une machine
de Turing. Par exemple, si les données de la bande sont <code>111</code>, la routine de
copie va doubler ces trois symboles en insérant un zéro au milieu: <code>1110111</code>.</p>

<p><img class="center" src="/images/copie-clone.jpg"></p>

<!-- more -->

<p>Je ne vais pas expliquer la routine de copie
— <a href="http://en.wikipedia.org/wiki/Turing_machine_examples#A_copy_subroutine">cet article de Wikipédia</a>
le fait très bien — mais plutôt montrer comment j’ai du adapter
<a href="https://github.com/lkdjiin/turing_machine">ma machine de Turing</a>
pour pouvoir faire tourner cette routine.</p>

<p>Voici le jeu d’instructions de la routine de copie:</p>

<p><code>raw copy_with_data
0 A  =&gt; 1 L B
0 B  =&gt; 1 N s1
0 s1 =&gt; N N HALT
1 s1 =&gt; 0 R s2
0 s2 =&gt; 0 R s3
1 s2 =&gt; 1 R s2
0 s3 =&gt; 1 L s4
1 s3 =&gt; 1 R s3
0 s4 =&gt; 0 L s5
1 s4 =&gt; 1 L s4
0 s5 =&gt; 1 R s1
1 s5 =&gt; 1 L s5
</code></p>

<p>C’est en deux parties, les deux premières lignes écrivent des données sur la
bande (le nombre <code>11</code>) et les neuf dernières lignes sont effectivement la
routine de copie. Une des limitations actuelles de ma machine de Turing est de
ne pas pouvoir initialiser la bande avec des données spécifiques, il faut donc
le faire depuis le programme, comme ici les deux premières lignes.</p>

<p>Les nouveautés dans ce jeu d’instructions sont les caractères <code>N</code>, qu’on peut
trouver dans les symboles à écrire et dans le mouvement de la tête de lecture,
par exemple dans la 3ème ligne:</p>

<pre><code>0 s1 =&gt; N N HALT
</code></pre>

<p>Cela signifie pas d’écriture et pas de mouvement (<strong>N</strong>o write, <strong>N</strong>o move).</p>

<p>Le parser étant déjà capable d’attraper n’importe quel mot/symbole, il suffit de
faire évoluer la méthode de mise à jour de la bande ainsi (c’est un peu lourd
comme écriture mais ça reste clair et pragmatique):</p>

<p>``` ruby lib/turing_machine/instance.rb
module TuringMachine</p>

<p>class Instance</p>

<p>[…]</p>

<pre><code>def update_tape(current_action)
  @tape.head = current_action[:write] unless current_action[:write] == 'N'
  @tape.shift_left if current_action[:move] == 'L'
  @tape.shift_right if current_action[:move] == 'R'
end
</code></pre>

<p>[…]
```</p>

<p>Et maintenant la routine de copie fonctionne !</p>

<pre><code>$ turing_machine instruction_sets/copy_with_data
  1 0000000000000000000000000000000000000000 A -&gt; 1LB
                       ^
  2 0000000000000000000100000000000000000000 B -&gt; 1Ns1
                      ^
  3 0000000000000000001100000000000000000000 s1 -&gt; 0Rs2
                      ^
  4 0000000000000000000100000000000000000000 s2 -&gt; 1Rs2
                       ^
  5 0000000000000000000100000000000000000000 s2 -&gt; 0Rs3
                        ^
  6 0000000000000000000100000000000000000000 s3 -&gt; 1Ls4
                         ^
  7 0000000000000000000101000000000000000000 s4 -&gt; 0Ls5
                        ^
  8 0000000000000000000101000000000000000000 s5 -&gt; 1Ls5
                       ^
  9 0000000000000000000101000000000000000000 s5 -&gt; 1Rs1
                      ^
 10 0000000000000000001101000000000000000000 s1 -&gt; 0Rs2
                       ^
 11 0000000000000000001001000000000000000000 s2 -&gt; 0Rs3
                        ^
 12 0000000000000000001001000000000000000000 s3 -&gt; 1Rs3
                         ^
 13 0000000000000000001001000000000000000000 s3 -&gt; 1Ls4
                          ^
 14 0000000000000000001001100000000000000000 s4 -&gt; 1Ls4
                         ^
 15 0000000000000000001001100000000000000000 s4 -&gt; 0Ls5
                        ^
 16 0000000000000000001001100000000000000000 s5 -&gt; 1Rs1
                       ^
 17 0000000000000000001101100000000000000000 s1 -&gt; NNHALT
                        ^
 18 0000000000000000001101100000000000000000 HALT
</code></pre>

<p>Le code est <a href="https://github.com/lkdjiin/turing_machine">sur Github</a>, à plus tard.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Une machine de Turing en Ruby]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/02/01/une-machine-de-turing-en-ruby/"/>
    <updated>2015-02-01T10:11:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/02/01/une-machine-de-turing-en-ruby</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Avec le film <em>Imitation Game</em> sorti récemment, Alan Turing, qu’on peut considérer
comme un père fondateur de l’informatique, fait l’actualité.
Je vous propose, dans cet article, de réaliser une machine de Turing en Ruby.</p>

<p><img class="center" src="/images/alan-turing2.jpg"></p>

<!-- more -->

<h2 id="dfinition-de-la-machine-de-turing">Définition de la machine de Turing</h2>

<p>Ma définition personnelle sera la suivante:</p>

<p><strong>Une machine de Turing est une machine imaginaire et hyper-minimale, pouvant
faire tourner un algorithme.</strong></p>

<p>Si vous ressentez le besoin d’une définition plus formelle, les articles de
Wikipédia, en <a href="http://en.wikipedia.org/wiki/Turing_machine">anglais</a>
et en <a href="http://fr.wikipedia.org/wiki/Machine_de_Turing">français</a>
sont très bien fourni. Il y a aussi une présentation sympathique de la machine de
Turing dans une petite <a href="http://videotheque.cnrs.fr/doc=3001">vidéo en français</a>
de 7 minutes, par le CNRS.</p>

<p>Dans la suite de l’article, je prends comme hypothèse que vous savez ce qu’est
une machine de Turing. Si ça n’est pas le cas, ou si vous avez besoin de vous
rafraichir la mémoire, n’hésitez pas à visiter les liens précédents.</p>

<h2 id="on-fait-une-gem-">On fait une gem ?</h2>

<p>À terme, j’aimerais un programme qui puisse faire tourner n’importe quel jeu
d’instructions. Mais pour un premier jet, concret, rapidement réalisable, et
malgré tout intéressant,
on va faire tourner un <a href="http://en.wikipedia.org/wiki/Busy_beaver">busy beaver</a>
à 3 états.</p>

<p>Deux trucs à noter:</p>

<ol>
  <li><em>Busy beaver à 3 états</em> ça peut faire peur. Je vous assure qu’il n’y a pas
de quoi. C’est un algorithme relativement simple.</li>
  <li><em>Busy beaver</em> se traduit par <em>castor affairé</em>, c’est bien la preuve qu’il n’y
a pas de quoi avoir peur.</li>
</ol>

<p>Comme je veux une structure bien claire dès le départ, et pas un script vite
fait qu’on aura toutes les peines du monde à étendre, je vais faire une gem:</p>

<pre><code>$ bundle gem turing_machine -btV
      create  turing_machine/Gemfile
      create  turing_machine/Rakefile
      create  turing_machine/LICENSE.txt
      create  turing_machine/README.md
      create  turing_machine/.gitignore
      create  turing_machine/turing_machine.gemspec
      create  turing_machine/lib/turing_machine.rb
      create  turing_machine/lib/turing_machine/version.rb
      create  turing_machine/bin/turing_machine
      create  turing_machine/.rspec
      create  turing_machine/spec/spec_helper.rb
      create  turing_machine/spec/turing_machine_spec.rb
      create  turing_machine/.travis.yml
Initializing git repo in /home/xavier/devel/ruby/turing_machine
</code></pre>

<p>Vous pouvez trouver le code sur Github : <a href="https://github.com/lkdjiin/turing_machine">lkdjiin/turing_machine</a>.</p>

<h2 id="objectif-de-la-premire-version">Objectif de la première version</h2>

<p>Mon objectif est d’obtenir cette sortie quand je lance le programme
<code>turing_machine</code>:</p>

<pre><code>$ turing_machine 
  1 0000000000 A -&gt; 1RB
        ^
  2 0000100000 B -&gt; 1LA
         ^
  3 0000110000 A -&gt; 1LC
        ^
  4 0000110000 C -&gt; 1LB
       ^
  5 0001110000 B -&gt; 1LA
      ^
  6 0011110000 A -&gt; 1RB
     ^
  7 0111110000 B -&gt; 1RB
      ^
  8 0111110000 B -&gt; 1RB
       ^
  9 0111110000 B -&gt; 1RB
        ^
 10 0111110000 B -&gt; 1RB
         ^
 11 0111110000 B -&gt; 1LA
          ^
 12 0111111000 A -&gt; 1LC
         ^
 13 0111111000 C -&gt; 1RHALT
        ^
 14 0111111000 HALT
         ^
</code></pre>

<p>Explication d’une ligne de la sortie:</p>

<pre><code>  5 0001110000 B -&gt; 1LA
      ^ - Le `5` est le numéro de la séquence. - La suite de `0` et de `1` est le ruban. - Le `^` est la position de la tête de lecture. - Le `B` est l'état courant. - La fin, ici `1LA`, est la prochaine instruction à exécuter.
</code></pre>

<p>Une instruction est composé a) du symbole à écrire, b) du mouvement de la
tête de lecture et, c) du nouvel état. Par exemple <code>1LA</code> signifie: écrire <code>1</code>,
bouger la tête de lecture à gauche (<code>L</code>) et passer dans l’état <code>A</code>.</p>

<h2 id="une-classe-pour-le-ruban-et-la-tte-de-lecture">Une classe pour le ruban et la tête de lecture</h2>

<p>On commence par une classe <code>Tape</code> (ruban), que je combine avec <code>head</code> (tête de
lecture) pour aller plus vite.</p>

<p>``` ruby
class Tape</p>

<p>def initialize
    @symbols = Array.new(10) { ‘0’ }
    @index = 4
  end</p>

<p>attr_reader :index</p>

<p>def head
    @symbols[@index]
  end</p>

<p>def head=(symbol)
    @symbols[@index] = symbol
  end</p>

<p>def shift_left
    @index -= 1
  end</p>

<p>def shift_right
    @index += 1
  end</p>

<p>def to_s
    @symbols.join
  end
end
```</p>

<p>Il faut noter qu’une machine de Turing possède un ruban avec un nombre infini
de cellules. Ici ça n’est pas le cas puisqu’il n’y en a que 10. C’est un
raccourci qui permet d’aller plus vite, de garder le code simple, et 10 cellules
sont largement suffisantes pour le <em>busy beaver à 3 états</em>.</p>

<p><img class="center" src="/images/castor2.png"></p>

<h2 id="une-classe-pour-le-registre-dtat">Une classe pour le registre d’état</h2>

<p>Avoir une classe dédiée à conserver l’état peut sembler
<a href="http://fr.wikipedia.org/wiki/Overkill">overkill</a>. Et pour être honnête, je dois
dire que ça l’est certainement. Une simple variable aurait été suffisante pour
cette première version. Mais bon, je suis sûr que cette classe sera bientôt
utile ;)</p>

<p>``` ruby
class StateRegister</p>

<p>def initialize(state)
    @state = state
  end</p>

<p>def current
    @state
  end</p>

<p>def change(new_state)
    @state = new_state
  end</p>

<p>def to_s
    @state.to_s
  end
end
```</p>

<h2 id="une-classe-pour-la-table-dinstructions">Une classe pour la table d’instructions</h2>

<p>Ici aussi, j’aurais pu (du ?) faire appel au
<a href="http://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it">YAGNI</a>.
Un simple hash pourrait faire l’affaire pour l’instant.</p>

<p>``` ruby
class Instruction</p>

<p>def initialize(table)
    @table = table
  end</p>

<p>def for(symbol, state)
    @table[[symbol, state]]
  end</p>

<p>end
```</p>

<h2 id="une-instance-dune-machine-de-turing">Une instance d’une machine de Turing</h2>

<p>Les trois petites classes ci-dessus vont se combiner à l’intérieur de la
classe <code>Instance</code> suivante, pour simuler une machine de Turing. Même si elle
est un peu plus complexe que les précédentes, cette classe reste malgré tout
très simple.</p>

<p>``` ruby
class Instance</p>

<p>def initialize(instructions, initial_state)
    @instruction = Instruction.new(instructions)
    @state = StateRegister.new(initial_state)
    @tape = Tape.new
    @sequence = 1
  end</p>

<p>def to_s
    “#{‘%3d’ % @sequence} #{@tape} #{@state}#{instr_to_s}\n    “ +
    ‘ ‘ * @tape.index + ‘^’
  end</p>

<p>def proceed
    current = action
    update_sequence
    update_tape(current)
    update_state(current)
  end</p>

<p>def halted?
    @state.current == ‘HALT’
  end</p>

<p>private</p>

<p>def update_sequence
    @sequence += 1
  end</p>

<p>def update_tape(current_action)
    @tape.head = current_action[:write]
    current_action[:move] == ‘L’ ? @tape.shift_left : @tape.shift_right
  end</p>

<p>def update_state(current_action)
    @state.change(current_action[:next_state])
  end</p>

<p>def action
    @instruction.for(@tape.head, @state.current)
  end</p>

<p>def instr_to_s
    if halted?
      ‘’
    else
      “ -&gt; “ + action[:write] + action[:move] + action[:next_state]
    end
  end
end
```</p>

<h2 id="le-binaire">Le binaire</h2>

<p>Enfin quand je dis le binaire c’est un abus de langage puisque ça reste un
fichier texte ;) Quoiqu’il en soit voici le programme <code>turing_machine</code> qui
implémente le <em>busy beaver à 3 états</em>.</p>

<p>``` ruby bin/turing_machine
#!/usr/bin/env ruby</p>

<p>require ‘turing_machine’</p>

<p>include TuringMachine</p>

<p>instructions = {
  [‘0’, ‘A’] =&gt; {write: ‘1’, move: ‘R’, next_state: ‘B’},
  [‘1’, ‘A’] =&gt; {write: ‘1’, move: ‘L’, next_state: ‘C’},
  [‘0’, ‘B’] =&gt; {write: ‘1’, move: ‘L’, next_state: ‘A’},
  [‘1’, ‘B’] =&gt; {write: ‘1’, move: ‘R’, next_state: ‘B’},
  [‘0’, ‘C’] =&gt; {write: ‘1’, move: ‘L’, next_state: ‘B’},
  [‘1’, ‘C’] =&gt; {write: ‘1’, move: ‘R’, next_state: ‘HALT’},
}</p>

<p>initial_state = ‘A’</p>

<p>instance = Instance.new(instructions, initial_state)</p>

<p>loop do
  puts instance.to_s
  break if instance.halted?
  instance.proceed
end
```</p>

<p>Cette version (<a href="https://github.com/lkdjiin/turing_machine">voir le code complet</a>) est juste une mise en train. Il faudrait maintenant disposer
d’un ruban infini et pouvoir entrer n’importe quel jeu d’instructions.</p>

<p>À plus tard.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les tours de Hanoi - partie 3]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/07/07/les-tours-de-hanoi-partie-3/"/>
    <updated>2014-07-07T21:13:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/07/07/les-tours-de-hanoi-partie-3</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>On commence à coder l’algorithme génétique pour solutionner les tours de
Hanoi.</p>

<pre><code>$ tree
.
├── ga.rb
├── lib
│   ├── hanoi
│   │   ├── board.rb
│   │   ├── game.rb
│   │   └── rules.rb
│   └── hanoi.rb
└── spec
    ├── board_spec.rb
    ├── game_spec.rb
    ├── integration
    │   └── game_spec.rb
    └── spec_helper.rb
</code></pre>

<!-- more -->

<p>``` ruby ga.rb
require ‘./lib/hanoi/board’
require ‘./lib/hanoi/game’
require ‘./lib/hanoi/rules’</p>

<p>class Chromosome
  attr_reader :genes
  def initialize(number_of_pieces)
    @genes = Array.new(2 ** number_of_pieces - 1) { rand(6) }
  end
end</p>

<p>class Population
  def initialize(size, number_of_pieces)
    @population = Array.new(size) { Chromosome.new(number_of_pieces) }
  end</p>

<p>def each(&amp;block)
    @population.each(&amp;block)
  end
end</p>

<p>class GA</p>

<p>def initialize
    @population = Population.new(20, 3)
  end</p>

<p>def evaluate
    @population.each do |chromosome|
      board = ::Hanoi::Board.new(3)
      game = ::Hanoi::Game.new(board)
      chromosome.genes.each do |gene|
        case gene
        when 0 then game.move from: 1, to: 2
        when 1 then game.move from: 1, to: 3
        when 2 then game.move from: 2, to: 1
        when 3 then game.move from: 2, to: 3
        when 4 then game.move from: 3, to: 1
        when 5 then game.move from: 3, to: 2
        end
      end
      p board.eval
    end
  end
end</p>

<p>ga = GA.new
ga.evaluate
```</p>

<p>Voilà de quoi commencer, des chromosomes, une population et l’évaluation
de chaque chromosome.</p>

<p>Ça fonctionne:</p>

<pre><code>$ ruby ga.rb 
0
5
4
2
2
4
5
5
4
4
4
1
5
4
1
0
0
2
0
4
</code></pre>

<p>Mais la fonction <code>GA#evaluate</code> me dérange. D’abord elle est trop longue, mais
rien qui ne puisse s’arranger avec un refactoring. Ce qui me dérange surtout
c’est qu’elle délègue la <em>vraie</em> évaluation à <code>Board</code>. Or, l’évaluation
dévrait faire partie intégrante de l’algorithme génétique, et pas de la
mécanique du jeu. C’est donc un point à améliorer avant d’aller plus loin.</p>

<script id="fb33k8u">(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les tours de hanoi - partie 2]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/07/06/les-tours-de-hanoi-partie-2/"/>
    <updated>2014-07-06T13:02:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/07/06/les-tours-de-hanoi-partie-2</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Je termine l’implémentation de la mécanique du jeu, pour pouvoir passer ensuite
à la construction de l’algorithme génétique.</p>

<pre><code>$ tree
.
├── lib
│   ├── hanoi
│   │   ├── board.rb
│   │   ├── game.rb
│   │   └── rules.rb
│   └── hanoi.rb
└── spec
    ├── board_spec.rb
    ├── game_spec.rb
    ├── integration
    │   └── game_spec.rb
    └── spec_helper.rb
</code></pre>

<!-- more -->

<p>J’ai mis <a href="https://github.com/lkdjiin/hanoi">le code</a> sur Github pour que vous puissiez le voir dans son
ensemble.</p>

<p>La classe <code>Board</code> gagne une méthode <code>move</code>, sans intelligence aucune:</p>

<p>``` ruby
module Hanoi</p>

<p>class Board</p>

<pre><code>def initialize(number_of_pieces)
  @pegs = [ (1..number_of_pieces).to_a.reverse, [], [] ]
end

def position
  @pegs
end

def position=(pegs)
  @pegs = pegs
end

def eval
  @pegs[1].reduce(0, :+) + 2 * @pegs[2].reduce(0, :+)
end

def move(from, to)
  piece = @pegs[from - 1].pop
  @pegs[to - 1].push(piece)
end   end
</code></pre>

<p>end
```</p>

<p>La mécanique du jeu est assurée par la classe <code>Game</code>, qui délègue à <code>Board</code> et
se repose sur un module <code>Rules</code> pour les décisions:</p>

<p>``` ruby
module Hanoi</p>

<p>class Game</p>

<pre><code>def initialize(board)
  @board = board
end

def move(from: 1, to: 1)
  @board.move(from, to) if Rules.valid?(@board, from, to)
end

def win?
  Rules.win?(@board)
end

def position
  @board.position
end   end
</code></pre>

<p>end
```</p>

<p>``` ruby
module Hanoi::Rules</p>

<p>def self.valid?(board, from, to)
    return false if board.position[from - 1].empty?
    return true if board.position[to - 1].empty?
    if board.position[from - 1][0] &lt; board.position[to - 1][0]
      true
    else
      false
    end
  end</p>

<p>def self.win?(board)
    if board.position[0].empty? &amp;&amp; board.position[1].empty?
      true
    else
      false
    end
  end</p>

<p>end
```</p>

<p>Voilà, notre futur algorithme génétique a maintenant les moyens d’évaluer
une suite de mouvements, reste plus qu’à le coder ;)</p>

<script id="fb33k8u">(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
