<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : intermédiaire | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/intermediaire/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2014-05-10T21:21:07+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Le langage Julia - 2]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/05/10/le-langage-julia-2/"/>
    <updated>2014-05-10T21:07:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/05/10/le-langage-julia-2</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>J'ai continué aujourd'hui a tester le langage
<a href="http://julialang.org/">Julia</a>.
Et en faisant quelques recherches, je me suis aperçu qu'il était très
souvent présenté comme un langage pour le calcul scientifique (voir par
exemple <a href="http://fr.wikipedia.org/wiki/Julia_%28langage_de_programmation%29">la page consacrée à Julia</a> sur Wikipédia). Ça m'énerve un peu.</p>

<!-- more -->


<p>Car sur le blog de Julia, on peut lire dans l'article d'introduction
<a href="http://julialang.org/blog/2012/02/why-we-created-julia/">Why we created Julia</a>:</p>

<p><blockquote><p>We want a language that’s open source, with a liberal license. We want the speed of C with the dynamism of Ruby. We want a language that’s homoiconic, with true macros like Lisp, but with obvious, familiar mathematical notation like Matlab. We want something as usable for general programming as Python, as easy for statistics as R, as natural for string processing as Perl, as powerful for linear algebra as Matlab, as good at gluing programs together as the shell. Something that is dirt simple to learn, yet keeps the most serious hackers happy. We want it interactive and we want it compiled.</p></blockquote></p>

<p>C'est donc loin d'être un langage utile seulement pour le calcul scientifique.
Enfin, je verrais bien qui dit vrai une fois que je le maitriserai assez…</p>

<p>Si vous avez déjà testé/utilisé Julia, qu'en avez vous pensez ?</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Le langage Julia]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/05/09/le-langage-julia/"/>
    <updated>2014-05-09T21:27:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/05/09/le-langage-julia</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Aujourd'hui j'ai commencé à jouer un peu (2 heures à peine) avec le langage
<a href="http://julialang.org/">Julia</a>.
Ça faisait longtemps que j'en avais envie et j'ai été enthousiasmé.</p>

<!-- more -->


<p>Je cherche un langage fonctionnel qui, entre autres,:</p>

<ul>
<li>ne soit pas <em>purement</em> fonctionnel.</li>
<li>soit rapide.</li>
<li>ai une syntaxe assez simple.</li>
</ul>


<p>J'ai peut-être trouvé ça avec Julia. Cet après-midi j'ai installé la
version binaire sur OS X sans problème. En ce moment je suis en train de
la compiler sur Debian (c'est très long…).</p>

<p>J'en suis encore à faire le tour de la syntaxe en suivant
<a href="http://learnxinyminutes.com/docs/julia/">cette introduction</a>. J'en parlerais
plus quand j'aurais un peu avancé ;)</p>

<p>Deux/trois trucs que j'ai retenu:</p>

<p>L'operateur de division est logiquement:</p>

<p><code>julia
5 / 2 # =&gt; 2.5
</code></p>

<p>Mais plus surprenant (pour moi en tous cas):</p>

<p><code>julia
2 \ 5 # =&gt; 2.5
</code></p>

<p>J'ai hâte de savoir si il y a une utilité à ça ;)</p>

<p>J'ai eu aussi plaisir à retrouver une arithmétique binaire, par exemple
la multiplication par 2:</p>

<p><code>julia
8 &lt;&lt; 1 # =&gt; 16
</code></p>

<p>Dernier truc, et je m'arrête là, j'aime quand les indices commencent à
1, et non pas à 0:</p>

<p><code>julia
"Bonjour"[1] # =&gt; 'B'
</code></p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Programmation concurrente pour Ruby avec eldritch - partie 2]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/05/07/programmation-concurrente-pour-ruby-avec-eldritch-partie-2/"/>
    <updated>2014-05-07T19:18:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/05/07/programmation-concurrente-pour-ruby-avec-eldritch-partie-2</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Suite du test de la gem <a href="https://github.com/beraboris/eldritch">eldritch</a>
qui facilite la programmation concurrente en Ruby.</p>

<!-- more -->


<p>Prenons le programme de référence suivant:</p>

<p>``` ruby test.rb
def long_task
  sleep(1)
  Time.now
end</p>

<p>10.times do |i|
  puts &ldquo;#{i} : #{long_task}&rdquo;
end
```</p>

<p>La méthode <code>long_task</code> va <em>dormir</em> pendant une seconde puis renvoyer la
date courante. Si on l'appelle 10 fois de suite, voici la sortie:</p>

<pre><code>$ time ruby test.rb
0 : 2014-05-07 18:15:52 +0200
1 : 2014-05-07 18:15:53 +0200
2 : 2014-05-07 18:15:54 +0200
3 : 2014-05-07 18:15:55 +0200
4 : 2014-05-07 18:15:56 +0200
5 : 2014-05-07 18:15:57 +0200
6 : 2014-05-07 18:15:58 +0200
7 : 2014-05-07 18:15:59 +0200
8 : 2014-05-07 18:16:00 +0200
9 : 2014-05-07 18:16:01 +0200

real    0m10.809s
</code></pre>

<p>Un appel par seconde, normal.</p>

<p>Maintenant on va se servir de <strong>eldritch</strong> pour que les 10 appels à
<code>long_task</code> soient concurrents:</p>

<p>``` ruby test.rb
require &lsquo;eldritch&rsquo;</p>

<p>def long_task
  sleep(1)
  Time.now
end</p>

<p>together do
  10.times do |i|</p>

<pre><code>async do
  puts "#{i} : #{long_task}"
end
</code></pre>

<p>  end
end
```</p>

<p>Le bloc <code>together</code> permet au programme d'attendre que chacune des <em>tâches</em>
soient terminées avant d'aller plus loin. Voici ce que ça donne:</p>

<pre><code>$ time ruby test.rb
0 : 2014-05-07 18:16:52 +02002 : 2014-05-07 18:16:52 +0200

3 : 2014-05-07 18:16:52 +0200
4 : 2014-05-07 18:16:52 +0200
5 : 2014-05-07 18:16:52 +0200
6 : 2014-05-07 18:16:52 +0200
7 : 2014-05-07 18:16:52 +0200
8 : 2014-05-07 18:16:52 +0200
9 : 2014-05-07 18:16:52 +0200
1 : 2014-05-07 18:16:52 +0200

real    0m1.890s
</code></pre>

<p>Que nous apprend cette sortie ? Chacune des dix tâches a été démarrée à la
même seconde (pas en même temps exactement bien sûr). On voit bien aussi
que l'ordre de terminaison des 10 tâches est aléatoires, ce qui est normal
en programmation concurrente. Le programme s'est terminé 10 fois plus vite,
c'est normal puisque <code>long_task</code> passe son temps à ne rien faire ;)</p>

<p>À quoi sert exactement ce bloc <code>together</code> ? Voyons ce qu'il se passe si on le
retire:</p>

<p>``` ruby test.rb
require &lsquo;eldritch&rsquo;</p>

<p>def long_task
  sleep(1)
  Time.now
end</p>

<p>10.times do |i|
  async do</p>

<pre><code>puts "#{i} : #{long_task}"
</code></pre>

<p>  end
end
```</p>

<pre><code>$ time ruby test.rb

real    0m0.846s
</code></pre>

<p>Oups ! Le programme s'est terminé <em>avant</em> la fin des tâches, elles sont
perdues !</p>

<p>Une autre façon de faire est de créer <em>explicitement</em> une tâche, avec
<code>task = async do ...</code> et d'utiliser <code>task.value</code> qui attend que la tâche
soit complètée:</p>

<p>``` ruby test.rb
require &lsquo;eldritch&rsquo;</p>

<p>long_task = async do
  sleep(1)
  Time.now
end</p>

<p>10.times do |i|
  puts &ldquo;#{i} : #{long_task.value}&rdquo;
end
```</p>

<pre><code>$ time ruby eldritch2.rb
0 : 2014-05-07 18:38:20 +0200
1 : 2014-05-07 18:38:20 +0200
2 : 2014-05-07 18:38:20 +0200
3 : 2014-05-07 18:38:20 +0200
4 : 2014-05-07 18:38:20 +0200
5 : 2014-05-07 18:38:20 +0200
6 : 2014-05-07 18:38:20 +0200
7 : 2014-05-07 18:38:20 +0200
8 : 2014-05-07 18:38:20 +0200
9 : 2014-05-07 18:38:20 +0200

real    0m1.861s
</code></pre>

<p>Tout les tests que j'ai fait avec cette méthode montrent que l'ordre des
tâches est respecté, de 0 à 9. Est-ce que c'est vraiment le cas ou bien
est-ce une coincidence ? Je n'ai pas encore de réponses…</p>

<p>Quoiqu'il en soit, je suis pressé d'essayer <strong>eldritch</strong> avec les algorithmes génétiques, ce
qui par la même occasion me permettra d'en reparler (des algos) dans ce blog.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Programmation concurrente pour Ruby avec eldritch]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/05/06/programmation-concurrente-pour-ruby-avec-eldritch/"/>
    <updated>2014-05-06T21:38:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/05/06/programmation-concurrente-pour-ruby-avec-eldritch</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Ce matin j'ai découvert la gem <a href="https://github.com/beraboris/eldritch">eldritch</a>,
pour faire de la programmation concurrente. Son API m'a paru vraiment
simple et élégante. Ce soir j'ai seulement 5 minutes pour faire un premier
test, alors on y va sans fioritures.</p>

<!-- more -->


<p>Tout d'abord, je vais utiliser Rubinius, puisqu'un ruby MRI ne permet pas
l'utilisation de plusieurs coeurs.</p>

<pre><code>$ rvm use rbx-2.0.0
Using /home/xavier/.rvm/gems/rbx-2.0.0
</code></pre>

<p>Ensuite, installation de la gem:</p>

<pre><code>gem install eldritch
</code></pre>

<p>Il me faut un programme simple pour tester rapidement. Le voici:</p>

<p>``` ruby eldritch.rb
def long_method1
  sleep(2)
  &ldquo;1&rdquo;
end</p>

<p>def long_method2
  sleep(2)
  &ldquo;2&rdquo;
end</p>

<p>puts long_method1
puts long_method2
```</p>

<p>Je simule deux méthodes assez longues grâce à <code>sleep(2)</code>, qui <em>endort</em> le
programme pendant 2 secondes. Le temps d'exécution est conforme à mes
attentes:</p>

<pre><code>$ time ruby eldritch.rb
1
2

real    0m4.821s
</code></pre>

<p>Maintenant on va utiliser la gem eldritch et son concept de <strong>tâche</strong> pour
réécrire le programme:</p>

<p>``` ruby eldritch.rb
require &lsquo;eldritch&rsquo;</p>

<p>long_task1 = async do
  sleep(2)
  &ldquo;1&rdquo;
end</p>

<p>long_task2 = async do
  sleep(2)
  &ldquo;2&rdquo;
end</p>

<p>puts long_task1.value
puts long_task2.value
```</p>

<p>Et voici le résultat:</p>

<pre><code>$ time ruby eldritch.rb
1
2

real    0m2.869s
</code></pre>

<p><strong>Tada !</strong> Mes deux <em>tâches</em> ont tournées en parallèle.</p>

<p>Ça me plait ce concept de tâche. Mais ce n'était qu'un premier test
rapide, eldritch nous réserve encore de bonne surprises. J'espère pouvoir
tester le reste demain.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Le LOAD_PATH dans Ruby]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/05/05/le-load-path-dans-ruby/"/>
    <updated>2014-05-05T21:02:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/05/05/le-load-path-dans-ruby</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>En Ruby, la variable <code>$LOAD_PATH</code> contient tous les chemins vers les
bibliothèques chargées.</p>

<p>``` irb</p>

<blockquote><blockquote><p>$LOAD_PATH
[</p>

<pre><code>[0] "/home/xavier/.rvm/gems/ruby-2.1.0/gems/awesome_print-1.2.0/lib",
[1] "/home/xavier/.rvm/rubies/ruby-2.1.0/lib/ruby/site_ruby/2.1.0",
[2] "/home/xavier/.rvm/rubies/ruby-2.1.0/lib/ruby/site_ruby/2.1.0/i686-linux",
[3] "/home/xavier/.rvm/rubies/ruby-2.1.0/lib/ruby/site_ruby",
[4] "/home/xavier/.rvm/rubies/ruby-2.1.0/lib/ruby/vendor_ruby/2.1.0",
[5] "/home/xavier/.rvm/rubies/ruby-2.1.0/lib/ruby/vendor_ruby/2.1.0/i686-linux",
[6] "/home/xavier/.rvm/rubies/ruby-2.1.0/lib/ruby/vendor_ruby",
[7] "/home/xavier/.rvm/rubies/ruby-2.1.0/lib/ruby/2.1.0",
[8] "/home/xavier/.rvm/rubies/ruby-2.1.0/lib/ruby/2.1.0/i686-linux"
</code></pre>

<p>]
```</p></blockquote></blockquote>

<!-- more -->


<p>Si je charge Rspec, par exemple, son chemin va être ajouté dans la variable
<code>$LOAD_PATH</code>, ainsi que toutes les bibliothèques dont dépend Rspec:</p>

<p>``` irb</p>

<blockquote><blockquote><p>require &lsquo;rspec&rsquo;
true
$LOAD_PATH
[</p>

<pre><code>[ 0] "/home/xavier/.rvm/gems/ruby-2.1.0/gems/awesome_print-1.2.0/lib",
[ 1] "/home/xavier/.rvm/gems/ruby-2.1.0/gems/rspec-2.14.1/lib",
[ 2] "/home/xavier/.rvm/gems/ruby-2.1.0/gems/rspec-core-2.14.8/lib",
[ 3] "/home/xavier/.rvm/rubies/ruby-2.1.0/lib/ruby/site_ruby/2.1.0",
[ 4] "/home/xavier/.rvm/rubies/ruby-2.1.0/lib/ruby/site_ruby/2.1.0/i686-linux",
[ 5] "/home/xavier/.rvm/rubies/ruby-2.1.0/lib/ruby/site_ruby",
[ 6] "/home/xavier/.rvm/rubies/ruby-2.1.0/lib/ruby/vendor_ruby/2.1.0",
[ 7] "/home/xavier/.rvm/rubies/ruby-2.1.0/lib/ruby/vendor_ruby/2.1.0/i686-linux",
[ 8] "/home/xavier/.rvm/rubies/ruby-2.1.0/lib/ruby/vendor_ruby",
[ 9] "/home/xavier/.rvm/rubies/ruby-2.1.0/lib/ruby/2.1.0",
[10] "/home/xavier/.rvm/rubies/ruby-2.1.0/lib/ruby/2.1.0/i686-linux"
</code></pre>

<p>]
```</p></blockquote></blockquote>

<p>Il y a encore quelques jours, je faisais systématiquement cela au début de
toutes mes gems:</p>

<p><code>ruby
$LOAD_PATH.unshift File.dirname(__FILE__)
</code></p>

<p>Ceci pour que ma gem ajoute son propre chemin dans le <code>LOAD_PATH</code>.
Et bien je viens d'apprendre que non, c'est inutile ! L'utilitaire <code>gem</code>
fait très bien cela tout seul.</p>

<p>Aujourd'hui j'ai (encore) appris quelque chose ;)</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
