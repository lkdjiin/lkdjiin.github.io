<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : intermédiaire | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/intermediaire/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2014-01-19T12:41:34+01:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Compiler votre Vim sous Linux]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/01/19/compiler-votre-vim-sous-linux/"/>
    <updated>2014-01-19T12:32:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/01/19/compiler-votre-vim-sous-linux</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Aujourd'hui on voit comment compiler la dernière version de
Vim sur Linux (Debian, mais Ubuntu devrait marcher aussi).</p>

<!-- more -->


<h2>Pourquoi vouloir faire ça ?</h2>

<p>Tout d'abord, pourquoi voudrais-t-on compiler Vim alors que Debian nous
le fournit dans les paquets ? Je vois plusieurs raisons:</p>

<ol>
<li>Parce qu'on peut le faire. Mais je sens que cet argument n'est pas
fait pour vous convaincre.</li>
<li>Parce que c'est fun. Idem, pas convaincant, hein ?</li>
<li>Parce qu'on peut vouloir profiter d'une des dernières fonctionnalités
ajoutées, ou du dernier bugfix.</li>
<li>Parce que Debian est parfois à la ramasse lorsqu'il s'agit de nous
fournir des versions suffisament récentes de certains logiciels.
J'ai par exemple une machine qui est toujours en Debian 6 et que je
ne peux pas upgrader, Vim y est <em>coincé</em> en version 7.2.</li>
</ol>


<h2>On y va</h2>

<p>Assurez vous d'abord d'avoir toutes les dépendances:</p>

<pre><code>$ sudo apt-get build-dep vim
</code></pre>

<p>Ensuite, on va télécharger les sources depuis GitHub:</p>

<pre><code>$ git clone https://github.com/b4winckler/vim.git
</code></pre>

<p>Puis peut-être aller chercher une release particulière:</p>

<pre><code>$ cd vim
$ git checkout tags/v-7-4-155
</code></pre>

<p>Ensuite on va dans les sources:</p>

<pre><code>$ cd src
</code></pre>

<p>On nettoie (ça fait pas de mal):</p>

<pre><code>$ make distclean
</code></pre>

<p>On configure avec la plupart des features disponibles, notamment une
interface graphique et le support de perl, python et ruby:</p>

<pre><code>$ ./configure --with-features=huge --enable-gui=gnome2
  --with-compiledby=lkdjiin --enable-perlinterp  --enable-pythoninterp
  --enable-rubyinterp
</code></pre>

<p>Il reste à compiler:</p>

<pre><code>$ make
</code></pre>

<p>Et enfin à installer notre nouveau Vim:</p>

<pre><code>$ sudo make install
</code></pre>

<p>Et voilà:</p>

<p><img src="/images/vim-7-4-155.png"></p>

<h2>Désinstaller la version que vous avez compilé</h2>

<p>Si, pour une raison ou une autre, vous vouliez désinstaller
votre nouveau Vim, il faut d'abord trouver où il est installé.
Pour cela, lancez la commande suivante dans Vim:</p>

<p><code>vim
:echo $VIMRUNTIME
</code></p>

<p>Dans mon cas, cela donne: <code>/usr/local/share/vim/vim74</code>.</p>

<p>Rendez-vous ensuite dans les sources que vous avez téléchargées,
par exemple:</p>

<pre><code>$ cd ~/tmp/vim/src
</code></pre>

<p>Puis:</p>

<pre><code>$ make VIMRUNTIME=/usr/local/share/vim/vim74
$ sudo make uninstall
</code></pre>

<p>Et voilà.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[L'auto-complétion en Bash - partie 5]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/01/15/lauto-completion-en-bash-partie-5/"/>
    <updated>2014-01-15T20:44:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/01/15/lauto-completion-en-bash-partie-5</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Cet article est la suite de:
<a href="http://lkdjiin.github.io/blog/2014/01/14/lauto-completion-programmable-en-bash-partie-4/">L'auto complétion programmable en bash: partie 4</a>.</p>

<h2>Les bases de l'auto complétion programmable</h2>

<p>Une application peut proposer ses services d'auto complétion en déposant
un fichier bash dans le dossier <code>/etc/bash_completion.d/</code>.
On y voit un tas de fichiers, pour des programmes bien connus:</p>

<pre><code>[~]⇒ ls /etc/bash_completion.d/
abook
ant
apache2.2-common
apache2ctl
apt
...
git
...
</code></pre>

<p>Il suffit juste de savoir quoi mettre dedans. Allons-y:</p>

<!-- more -->


<p><code>bash /etc/bash_completion.d/mytool
complete -W "new compile test" mytool
</code></p>

<p>Le fichier sera chargé automatiquement au lancement de bash. Donc pour que
ça fonctionne maintenant, soit vous le sourcez, soit vous lancez une
nouvelle console et, &ndash; <em>roulements de tambours</em>&ndash;</p>

<pre><code>[~]⇒ mytool [TAB]
compile  new      test     
[~]⇒ mytool 
</code></pre>

<p>Magique, non ? Il faut noter que l'auto complétion fonctionnera aussi
avec des options:</p>

<p><code>bash /etc/bash_completion.d/mytool
complete -W "new compile test --verbose" mytool
</code></p>

<pre><code>[~]⇒ mytool c[TAB] -[TAB]
mytool compile --verbose
</code></pre>

<p>Donc, comment ça marche ? Voici la traduction de l'aide de <code>complete</code>,
simplifiée au maximum:</p>

<p><strong>complete</strong> [<em>options</em>] <em>name</em>   <br/>
Spécifie comment les arguments doivent être complétés, pour chaque <em>name</em>.</p>

<p>L'option <code>-W</code> permet de lui passer une liste de mots. Finalement c'était
facile ? Humm… En fait ce sera rarement aussi simple. Pour continuer notre
jeu de rôle, disons que l'option <code>--verbose</code> peut s'appliquer uniquement
à l'argument <code>new</code>, et pas aux deux autres. Du coup, notre commande
<code>complete</code> ne suffit plus. Il va falloir trouver autre chose et c'est ce
qu'on verra dans un prochain article.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[L'auto-complétion programmable en bash - partie 4]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/01/14/lauto-completion-programmable-en-bash-partie-4/"/>
    <updated>2014-01-14T20:54:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/01/14/lauto-completion-programmable-en-bash-partie-4</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Cet article est la suite de:
<a href="http://lkdjiin.github.io/blog/2014/01/13/lauto-completion-programmable-en-bash-partie-3/">L'auto complétion programmable en bash: partie 3</a>.</p>

<h2>Un programme bidon pour tester</h2>

<p>On va faire un petit jeu de rôle : Vous avez écrit un nouveau langage
informatique revolutionnaire, et maintenant vous voulez lui adjoindre
un outil pour faciliter la gestion des projets. Ce fameux programme, qui
va s'appeller «mytool» aura 3 commandes: <code>new</code>, pour créer un projet,
<code>compile</code>, pour compiler le projet, et <code>test</code>, pour le tester. Et bien sûr,
vous voulez profiter des joies de l'auto complétion:</p>

<pre><code>mytool c[TAB]
</code></pre>

<p>devra devenir:</p>

<pre><code>mytool compile
</code></pre>

<!-- more -->


<p>Pour comprendre les prochains articles, on est pas obligé d'avoir un «vrai»
programme. Mais c'est quand même plus drôle pour faire tout un tas de tests.
Voici donc le magnifique programme <code>mytool</code>:</p>

<p>``` bash mytool</p>

<h1>!/usr/bin/env bash</h1>

<p>case $1 in
  new )</p>

<pre><code>echo Project created ;;
</code></pre>

<p>  test )</p>

<pre><code>echo Project tested ;;
</code></pre>

<p>  compile )</p>

<pre><code>echo Project compiled ;;
</code></pre>

<ul>
<li>)
echo error ;;
esac
```</li>
</ul>


<p>Assurez vous que le programme ait les droits d'exécution (<code>chmod +x</code>)
et qu'il soit dans votre PATH:</p>

<pre><code>[~]⇒ mytool new
Project created
[~]⇒ mytool test
Project tested
[~]⇒ mytool compile
Project compiled
[~]⇒ mytool
error
</code></pre>

<p>La prochaine, promis, on commencera vraiment à faire de l'auto-complétion.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[L'auto-complétion programmable en Bash - partie 3]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/01/13/lauto-completion-programmable-en-bash-partie-3/"/>
    <updated>2014-01-13T20:50:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/01/13/lauto-completion-programmable-en-bash-partie-3</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Cet article est la suite de:
<a href="http://lkdjiin.github.io/blog/2014/01/11/lauto-completion-en-bash-partie-2/">L'auto complétion programmable en bash: partie 2</a>.</p>

<p>Je joue donc quelques minutes avec la commande <code>compgen</code>, juste pour voir
de quoi il s'agit. L'option <code>-W</code> retient particulièrement mon attention.
On lui passe une liste de mots entre guillemets et ça nous les renvoient:</p>

<pre><code>[~]⇒ compgen -W "foo bar baz"
foo
bar
baz
</code></pre>

<!-- more -->


<p>Ok, on va pas se mentir, vous ne voyez pas tellement l'intérêt, hein ?
Et si on passait un second argument à <code>compgen</code>, comme le début d'un
mot:</p>

<pre><code>[~]⇒ compgen -W "foo bar baz" f
foo
</code></pre>

<p>Ou bien encore:</p>

<pre><code>[~]⇒ compgen -W "foo bar baz" ba
bar
baz
</code></pre>

<p>Voilà qui est intéressant. Et si on lui donne un début de mot inexistant:</p>

<pre><code>[~]⇒ compgen -W "foo bar baz" o
[~]⇒ 
</code></pre>

<p>Les sections <strong>complete</strong> et surtout <strong>programmable completion</strong> de la page
de man sont particulièrement indigestes. Je me doute que je devrais les lire
si je veux aller plus loin, mais ça attendra encore.
Donc je google «bash programmable completion» et je trouve ce qu'il me faut pour
commencer. La suite la prochaine fois.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[L'auto-complétion programmable en Bash - partie 2]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/01/11/lauto-completion-en-bash-partie-2/"/>
    <updated>2014-01-11T20:33:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/01/11/lauto-completion-en-bash-partie-2</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Cet article est la suite de:
<a href="http://lkdjiin.github.io/blog/2014/01/10/lauto-completion-programmable-en-bash-partie-1/">L'auto complétion programmable en bash: partie 1</a>.</p>

<h2>Une première piste</h2>

<p>En parcourant rapidement la page de man de bash, je tombe sur une commande
pleine de promesse: la commande <code>compgen</code>.</p>

<!-- more -->


<p>Voici un extrait de la documentation:</p>

<p><strong>compgen</strong> [<em>option</em>] [<em>word</em>] <br/>
Generate possible completion matches for word according to the options, which
may be any option accepted by the <strong>complete</strong> builtin with the exception of -p
and -r, and write the matches to the standard output. When using the -F or -C
options, the various shell variables set by the <strong>programmable completion</strong>
<em>[&hellip;]</em></p>

<p>J'ai donc une commande <code>compgen</code>, qui semble fournir les différentes
possibilités de complétions pour un mot. J'ai aussi une commande <code>complete</code>,
dont le nom sonne vraiment bien. Et on me confirme que bash peut faire de
la <code>programmable completion</code>, même si je sais pas encore trop de quoi on
parle ici… Je vais devoir fouiller un peu les options de <code>complete</code> pour
apprendre comment fonctionne <code>compgen</code>. Ah, les joies du man Unix !</p>

<p>Mon voyage dans le monde de l'auto-complétion débute avec une page de man.
Y a plus sexy, mais bon, il faut bien commencer quelque part ;)</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
