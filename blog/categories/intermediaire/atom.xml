<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : intermédiaire | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/intermediaire/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2014-04-16T21:45:36+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ruby - Et si on écrivait un ORM ? - partie 3]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/04/16/ruby-et-si-on-ecrivait-un-orm-partie-3/"/>
    <updated>2014-04-16T21:23:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/04/16/ruby-et-si-on-ecrivait-un-orm-partie-3</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Cette fois je me dis qu'il faudrait quand même se connecter à la base de
données avant d'aller plus loin…</p>

<!-- more -->


<p>Alors au départ, la connexion est inexistante:</p>

<p>``` ruby sorm_spec.rb
require &lsquo;./sorm&rsquo;</p>

<p>describe SORM do
  describe &lsquo;connection&rsquo; do</p>

<pre><code>it 'is not connected' do
  expect(SORM.connected?).to be false
end
</code></pre>

<p>  end
end
```</p>

<p>On fait passer ce test très facilement:</p>

<p>``` ruby sorm.rb
require &lsquo;sqlite3&rsquo;</p>

<p>class SORM
  def self.connected?</p>

<pre><code>false
</code></pre>

<p>  end
end
```</p>

<p>Maintenant on cherche à se connecter à une base de données existante
(n'oubliez pas de la créer):</p>

<p>``` ruby sorm_spec.rb
require &lsquo;./sorm&rsquo;</p>

<p>describe SORM do
  describe &lsquo;connection&rsquo; do</p>

<pre><code>it 'is not connected' do
  expect(SORM.connected?).to be false
end

describe 'after connection' do
  it 'is connected' do
    SORM.connect('test.db')
    expect(SORM.connected?).to be true
  end
end
</code></pre>

<p>  end
end
```</p>

<p>Pour implémenter cette fonctionnalité, ce à quoi je pense de plus rapide
et de plus simple est une variable de classe. Même si on a parfois des
scrupules à utiliser les variables de classe parce qu'elles sont partagées
aussi par les sous-classes, je me dis que c'est bien le comportement que
je voudrais obtenir. Donc voici le code qui fait passer notre test:</p>

<p>``` ruby sorm.rb
require &lsquo;sqlite3&rsquo;</p>

<p>class SORM</p>

<p>  @@db = false</p>

<p>  def self.connect(database_filename)</p>

<pre><code>@@db = SQLite3::Database.open(database_filename)
</code></pre>

<p>  end</p>

<p>  def self.connected?</p>

<pre><code>@@db ? true : false
</code></pre>

<p>  end
end
```</p>

<p><em>To be continued</em></p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby - Et si on écrivait un ORM ? - partie 2]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/04/14/ruby-et-si-on-ecrivait-un-orm-partie-2/"/>
    <updated>2014-04-14T21:08:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/04/14/ruby-et-si-on-ecrivait-un-orm-partie-2</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Après avoir installé sqlite et la gem sqlite3-ruby, on installe maintenant
rspec et on fait passer un premier test pour notre futur <em>Simple ORM</em>.</p>

<!-- more -->


<p>Pour écrire SORM, on va faire du <em>Test Driven Development</em>, parce que j'ai
envie d'encourager les bonnes pratiques ;) Pour les tests j'utiliserai
Rspec, puisque c'est le framework que je connais le mieux:</p>

<pre><code>gem install rspec
</code></pre>

<p>On écrit un premier test:</p>

<p>``` ruby sorm_spec.rb
require &lsquo;./sorm&rsquo;</p>

<p>describe SORM do</p>

<p>  class Article &lt; SORM
  end</p>

<p>  describe &lsquo;.find_by_*&rsquo; do</p>

<pre><code>it 'returns an array' do
  article = Article.find_by_whatever('foobar')
  expect(article.class).to eq Array
end
</code></pre>

<p>  end
end
```</p>

<p>Alors c'est un test un peu <em>foireux</em>, ok. J'avoue que je n'ai pas réfléchi
une seconde au design de SORM. Je me dis qu'on s'adaptera au fur et à mesure.
Ici je teste qu'une méthode <code>.find_by_whatever</code> renvoie un tableau, c'est
tout. C'est histoire de se mettre en marche. Lancement du test:</p>

<pre><code>$ rspec sorm_spec.rb 
sorm_spec.rb:3:in `&lt;top (required)&gt;': uninitialized constant SORM (NameError)
</code></pre>

<p>Et c'est partie pour l'écriture de notre classe <code>SORM</code>:</p>

<p>``` ruby sorm.rb
class SORM</p>

<p>end
```</p>

<p>Je relance le test:</p>

<pre><code>$ rspec sorm_spec.rb 
F

Failures:

  1) SORM.find_by_* returns an array
     Failure/Error: article = Article.find_by_whatever('foobar')
     NoMethodError:
       undefined method `find_by_whatever' for Article:Class
     # ./sorm_spec.rb:10:in `block (3 levels) in &lt;top (required)&gt;'

Finished in 0.0009 seconds
1 example, 1 failure

Failed examples:

rspec ./sorm_spec.rb:9 # SORM.find_by_* returns an array
</code></pre>

<p>La méthode <code>find_by_whatever</code> est bien sûr inconnue. Comme je veux gérer
les méthodes <code>find_by_*</code> avec <code>method_missing</code> j'écris:</p>

<p>``` ruby sorm.rb
class SORM</p>

<p>  def self.method_missing(method, *args)</p>

<pre><code>[]
</code></pre>

<p>  end</p>

<p>end
```</p>

<p>Et maintenant on est sur la voie:</p>

<pre><code>$ rspec sorm_spec.rb 
.

Finished in 0.01664 seconds
1 example, 0 failures
</code></pre>

<p>On a pas avancé beaucoup, mais on a quand même mis en place le TDD et notre
classe <code>SORM</code>.</p>

<p><em>To be continued</em></p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby - Et si on écrivait un ORM ? - partie 1]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/04/13/ruby-et-si-on-ecrivait-un-orm-partie-1/"/>
    <updated>2014-04-13T21:29:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/04/13/ruby-et-si-on-ecrivait-un-orm-partie-1</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Les derniers articles sur la méta programmation m'ont donnés envie d'écrire
un <a href="http://fr.wikipedia.org/wiki/Mapping_objet-relationnel">ORM</a>.
Un truc simple, basé sur la base de données <a href="https://www.sqlite.org/sqlite.html">Sqlite</a>.
D'ailleurs on va l'appeller SORM, pour <em>Simple Object Relational Mapping</em> ;)</p>

<!-- more -->


<p>Dans ce premier article, on va prendre contact avec Sqlite. Une fois ce dernier
installé sur votre machine, le client console est <code>sqlite3</code>.
Pour créer une nouvelle base de données, <code>test1.db</code>, il suffit de:</p>

<pre><code>$ sqlite3 test1.db
Enter SQL statements terminated with a ";"
</code></pre>

<p>Pour créer une table article:</p>

<pre><code>sqlite&gt; create table article(id int, name varchar(100));
</code></pre>

<p>Pour enregistrer quelques articles:</p>

<pre><code>sqlite&gt; insert into article values(1, 'foo');
sqlite&gt; insert into article values(2, 'bar');
sqlite&gt; insert into article values(3, 'baz');
</code></pre>

<p>Pour faire une requête:</p>

<pre><code>sqlite&gt; select * from article;
1|foo
2|bar
3|baz
</code></pre>

<p>Enfin pour sortir du programme, tapez Control+D.</p>

<p>Passons maintenant à la partie Ruby. J'avais pensé dans un premier temps à
écrire le driver pour communiquer avec Sqlite, mais ça nous entrainerait trop
loin. On va donc utiliser la gem <a href="https://github.com/sparklemotion/sqlite3-ruby">sqlite3-ruby</a>:</p>

<pre><code>gem install sqlite3
</code></pre>

<p>L'utilisation est fort simple:</p>

<p>``` irb
$ irb</p>

<blockquote><blockquote><p>require &lsquo;sqlite3&rsquo;
db = SQLite3::Database.open &ldquo;test1.db&rdquo;
db.execute &lsquo;select * from article;&rsquo;
[[1, &ldquo;foo&rdquo;], [2, &ldquo;bar&rdquo;], [3, &ldquo;baz&rdquo;]]
```</p></blockquote></blockquote>

<p><em>To be continued</em></p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[La méta programmation en Ruby - partie 3]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/04/12/la-meta-programmation-en-ruby-partie-3/"/>
    <updated>2014-04-12T19:30:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/04/12/la-meta-programmation-en-ruby-partie-3</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Aujourd'hui une explication de <code>method_missing</code>, utilisée hier pour
écrire le constructeur de requête.</p>

<!-- more -->


<p>Tout d'abord un peu de pratique:</p>

<p>``` ruby
class Foo
  def method_missing(met)</p>

<pre><code>puts 'Inside method_missing ---'
puts met
</code></pre>

<p>  end
end</p>

<p>Foo.new.foo
Foo.new.foobarbaz
```</p>

<pre><code>$ ruby meta3.rb 
Inside method_missing ---
foo
Inside method_missing ---
foobarbaz
</code></pre>

<p>Et maintenant la théorie. Lorsque vous passez un message a un objet, comme
<code>Foo.new.foo</code> et que ce message (cette méthode) n'existe pas, Ruby regarde
si l'objet possède la méthode <code>method_missing</code> et dans ce cas, l'appelle.
L'argument passé à <code>method_missing</code> est le nom de la <em>méthode manquante</em>.</p>

<p>Maintenant on ajoute un argument à <code>method_missing</code>, c'est l'argument de
la <em>méthode manquante</em>:</p>

<p>``` ruby
class Foo
  def method_missing(met, arg)</p>

<pre><code>puts 'Inside method_missing ---'
puts met
puts arg
</code></pre>

<p>  end
end</p>

<p>Foo.new.foo(&lsquo;bar&rsquo;)
```</p>

<pre><code>$ ruby meta3.rb 
Inside method_missing ---
foo
bar
</code></pre>

<p>Alors que ce passe-t-il si on passe plusieurs arguments ? Essayons:</p>

<p><code>ruby
Foo.new.foo('bar', 'baz')
</code></p>

<pre><code>meta3.rb:13:in `method_missing': wrong number of arguments (3 for 2) 
</code></pre>

<p>Et oui, ça ne fonctionne pas. Comme on ne peut pas connaître à l'avance
le nombre d'arguments de la <em>méthode manquante</em>, il est bon de tous les
récupérer dans un tableau:</p>

<p>``` ruby
class Foo
  def method_missing(met, *arg)</p>

<pre><code>puts 'Inside method_missing ---'
puts met
puts arg.inspect
</code></pre>

<p>  end
end</p>

<p>Foo.new.foo
Foo.new.foo(&lsquo;bar&rsquo;)
Foo.new.foo(&lsquo;bar&rsquo;, &lsquo;baz&rsquo;)
```</p>

<p>Et dans ce cas là, il n'y a plus de problèmes, on peut gérer n'importe
quel nombre d'arguments:</p>

<pre><code>$ ruby meta3.rb 
Inside method_missing ---
foo
[]
Inside method_missing ---
foo
["bar"]
Inside method_missing ---
foo
["bar", "baz"]
</code></pre>

<p>Pour finir, il faut noter qu'on peut comme toujours passer un bloc:</p>

<p>``` ruby
class Foo
  def method_missing(met, *arg, &amp;block)</p>

<pre><code>puts 'Inside method_missing ---'
puts met
puts arg.inspect
puts block.call if block_given?
</code></pre>

<p>  end
end</p>

<p>Foo.new.foo(&lsquo;bar&rsquo;) do
  &lsquo;return from a block&rsquo;
end
```</p>

<pre><code>$ ruby meta3.rb 
Inside method_missing ---
foo
["bar"]
return from a block
</code></pre>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[La méta programmation en Ruby - partie 2]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/04/11/la-meta-programmation-en-ruby-partie-2/"/>
    <updated>2014-04-11T21:41:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/04/11/la-meta-programmation-en-ruby-partie-2</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Hier j'ai écris une <a href="http://lkdjiin.github.io/blog/2014/04/10/introduction-a-la-meta-programmation-en-ruby/">introduction à la méta programmation</a>.
Aujourd'hui j'approfondis un peu plus le sujet avec l'écriture d'un
<em>query builder</em> sommaire.</p>

<!-- more -->


<p>On va commencer avec une classe <code>Article</code>:</p>

<p><code>ruby
class Article
end
</code></p>

<p>On peut pas faire plus simple ;) Cette classe ne sera pas très importante
pour la démonstration, c'est juste un support pour la pensée.
Ce que je veux, c'est écrire un <em>fabricant de requête SQL</em>. Je me limite
à un simple SELECT:</p>

<p>``` ruby
class QueryBuilder
  def self.find(table, column, value)</p>

<pre><code>"SELECT * from #{table} where #{column} = #{value};"
</code></pre>

<p>  end
end</p>

<p>puts QueryBuilder.find(&lsquo;article&rsquo;, &lsquo;name&rsquo;, &lsquo;Foo&rsquo;)
```</p>

<p>Résultat:</p>

<p><code>bash
$ ruby meta2.rb
SELECT * from article where name = Foo;
</code></p>

<p>Notre <code>QueryBuilder</code> fait son travail. Il peut servir quelle que soit la
table (et la colonne) recherchée. Mais j'aime pas :( Trop d'arguments et
la classe <code>Article</code> ne sert à rien…</p>

<p>On va donc réécrire le <code>QueryBuilder</code> pour qu'il trouve tout seul comme
un grand le nom de la table:</p>

<p>``` ruby
module QueryBuilder
  extend self
  def find(column, value)</p>

<pre><code>"SELECT * from #{self.to_s.downcase} where #{column} = #{value};"
</code></pre>

<p>  end
end</p>

<p>class Article
  extend QueryBuilder
end</p>

<p>puts Article.find(&lsquo;name&rsquo;, &lsquo;Foo&rsquo;)
```</p>

<p>C'est bien mieux ! Maintenant le nom de la table est déduit du nom de la
classe. Bien sûr ça nécessite de suivre une convention. Ici la convention
est «Un objet <code>Article</code> = une table <code>article</code>». Ça donne ceci:</p>

<p><code>bash
$ ruby meta2.rb
SELECT * from article where name = Foo;
</code></p>

<p>Ça marche bien et je pourrais vivre avec ça. Mais Ruby permet de faire
encore mieux, en tous cas il permet d'ajouter de la <em>magie</em> comme on
entend souvent. Voyons cela, on va à nouveau réécrire le <code>QueryBuilder</code>
pour n'avoir à passer qu'un seul argument:</p>

<p>``` ruby
module QueryBuilder
  extend self
  def method_missing(method, value)</p>

<pre><code>column = method.id2name.to_s.sub(/find_by_/, '')
"SELECT * from #{self.to_s.downcase} where #{column} = #{value};"
</code></pre>

<p>  end
end</p>

<p>class Article
  extend QueryBuilder
end</p>

<p>p Article.find_by_id(123)
p Article.find_by_name(&lsquo;Foo&rsquo;)
p Article.find_by_price(12.34)
```</p>

<p>Et c'est magique, on a maintenant autant de méthode <code>find_by_*</code> que
l'on veut:</p>

<p><code>bash
$ ruby meta2.rb
"SELECT * from article where id = 123;"
"SELECT * from article where name = Foo;"
"SELECT * from article where price = 12.34;"
</code></p>

<p>Je vous laisse méditer là-dessus et j'expliquerais <code>method_missing</code>
dans le prochain article car il est déjà tard…</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
