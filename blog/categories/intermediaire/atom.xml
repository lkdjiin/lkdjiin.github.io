<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : intermédiaire | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/intermediaire/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2014-03-22T20:56:47+01:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Vim - un plugin pour markdown - partie 4]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/03/22/vim-un-plugin-pour-markdown-partie-4/"/>
    <updated>2014-03-22T20:42:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/03/22/vim-un-plugin-pour-markdown-partie-4</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Maintenant on fait tous les titres, jusqu'au niveau 6 donc.</p>

<!-- more -->


<p>``` vim autoload/quickmarkdown.vim
function s:build_big_title(char)
  let s:line_content = substitute(getline(&ldquo;.&rdquo;), &lsquo;.&rsquo;, a:char, &lsquo;g&rsquo;)
  call append(&lsquo;.&rsquo;, s:line_content)
endfunction</p>

<p>function s:build_little_title(str)
  call setline(line(&lsquo;.&rsquo;), a:str . getline(&lsquo;.&rsquo;))
endfunction</p>

<p>function! quickmarkdown#title1()
  call s:build_big_title(&ldquo;=&rdquo;)
endfunction</p>

<p>function! quickmarkdown#title2()
  call s:build_big_title(&ldquo;&ndash;&rdquo;)
endfunction</p>

<p>function! quickmarkdown#title3()
  call s:build_little_title(&ldquo;### &rdquo;)
endfunction</p>

<p>function! quickmarkdown#title4()
  call s:build_little_title(&ldquo;#### &rdquo;)
endfunction</p>

<p>function! quickmarkdown#title5()
  call s:build_little_title(&ldquo;##### &rdquo;)
endfunction</p>

<p>function! quickmarkdown#title6()
  call s:build_little_title(&ldquo;###### &rdquo;)
endfunction
```</p>

<p><code>vim plugin/quickmarkdown.vim
command! QuickMarkdownTitle1 call quickmarkdown#title1()
command! QuickMarkdownTitle2 call quickmarkdown#title2()
command! QuickMarkdownTitle3 call quickmarkdown#title3()
command! QuickMarkdownTitle4 call quickmarkdown#title4()
command! QuickMarkdownTitle5 call quickmarkdown#title5()
command! QuickMarkdownTitle6 call quickmarkdown#title6()
</code></p>

<p>J'ai aussi changé mon mapping pour qu'il soit plus homogène.</p>

<p><strong>En qwerty:</strong></p>

<p><code>vim .vimrc
nmap &lt;Leader&gt;m1 :QuickMarkdownTitle1&lt;Enter&gt;
nmap &lt;Leader&gt;m2 :QuickMarkdownTitle2&lt;Enter&gt;
nmap &lt;Leader&gt;m3 :QuickMarkdownTitle3&lt;Enter&gt;
nmap &lt;Leader&gt;m4 :QuickMarkdownTitle4&lt;Enter&gt;
nmap &lt;Leader&gt;m5 :QuickMarkdownTitle5&lt;Enter&gt;
nmap &lt;Leader&gt;m6 :QuickMarkdownTitle6&lt;Enter&gt;
</code></p>

<p><strong>En azerty:</strong></p>

<p><code>vim .vimrc
nmap &lt;Leader&gt;m&amp; :QuickMarkdownTitle1&lt;Enter&gt;
nmap &lt;Leader&gt;mé :QuickMarkdownTitle2&lt;Enter&gt;
nmap &lt;Leader&gt;m" :QuickMarkdownTitle3&lt;Enter&gt;
nmap &lt;Leader&gt;m' :QuickMarkdownTitle4&lt;Enter&gt;
nmap &lt;Leader&gt;m( :QuickMarkdownTitle5&lt;Enter&gt;
nmap &lt;Leader&gt;m- :QuickMarkdownTitle6&lt;Enter&gt;
</code></p>

<p><strong>En bépo:</strong></p>

<p><code>vim .vimrc
nmap &lt;Leader&gt;m" :QuickMarkdownTitle1&lt;Enter&gt;
nmap &lt;Leader&gt;m« :QuickMarkdownTitle2&lt;Enter&gt;
nmap &lt;Leader&gt;m» :QuickMarkdownTitle3&lt;Enter&gt;
nmap &lt;Leader&gt;m( :QuickMarkdownTitle4&lt;Enter&gt;
nmap &lt;Leader&gt;m) :QuickMarkdownTitle5&lt;Enter&gt;
nmap &lt;Leader&gt;m@ :QuickMarkdownTitle6&lt;Enter&gt;
</code></p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Redis - Comment supprimer un ensemble de clés]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/03/21/redis-comment-supprimer-un-ensemble-de-cles/"/>
    <updated>2014-03-21T21:44:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/03/21/redis-comment-supprimer-un-ensemble-de-cles</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Tiens, mon premier article sur Redis ! Normal, c'est une technologie que
j'ai découvert il y a peu…</p>

<!-- more -->


<p>Pour supprimer une clé dans Redis, on se connecte et on utilise la commande
<code>del</code>:</p>

<pre><code>$ redis-cli
&gt; del "nom:de:la:clef"
</code></pre>

<p>Mais quand on a des dizaines/centaines de clés, bof… Bien souvent (toujours
même ça vaut mieux) le nom des clés suit un motif. Par exemple:</p>

<pre><code>"motif:foo"
"motif:bar"
"motif:baz"
etc...
</code></pre>

<p>Dans ce cas on peut utiliser Bash pour s'en sortir rapidement:</p>

<p><code>bash
redis-cli keys "*motif*" | xargs redis-cli del
</code></p>

<p>Et voilà, au revoir toutes les clés.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Un éditeur pour le terminal - partie 9]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/03/13/un-editeur-pour-le-terminal-partie-9/"/>
    <updated>2014-03-13T21:04:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/03/13/un-editeur-pour-le-terminal-partie-9</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Dans le programme d'aujourd'hui, on s'occupe de déplacer le curseur.</p>

<!-- more -->


<p>``` ruby
require &lsquo;curses&rsquo;
include Curses</p>

<p>begin
  init_screen
  cbreak
  noecho
  stdscr.keypad(true)
  x = 0
  y = 0</p>

<p>  while (ch = getch) != KEY_F1</p>

<pre><code>case ch
when KEY_LEFT then x -= 1
when KEY_RIGHT then x += 1
when KEY_UP then y -= 1
when KEY_DOWN then y += 1
end
setpos(y, x)
refresh
</code></pre>

<p>  end
ensure
  close_screen
end
```</p>

<p>Les détails:</p>

<p>Pour éviter que les caractères s'affiche sur le terminal:</p>

<p><code>ruby
  noecho
</code></p>

<p>Pour rappel, le code suivant permet d'activer le pavé numérique, les
flèches, etc.</p>

<p><code>ruby
  stdscr.keypad(true)
</code></p>

<p>Positionner le curseur est aussi simple que ce qui suit. Comme toujours,
attention, c'est y d'abord et x ensuite:</p>

<p>``` ruby</p>

<pre><code>setpos(y, x)
</code></pre>

<p>```</p>

<p>Par contre, si vous jouer un peu avec ce programme, on voit que les
sauts de lignes ne sont pas gérer automatiquement (quand j'arrive à la
fin de la ligne et que j'appuie sur flèche droite, on ne passe pas à
la ligne suivante par exemple). Ce sera à nous de le gérer…</p>

<p>Si on veut utiliser HJKL (comme dans Vim) pour se déplacer, on peut
remplacer le contenu du <code>case</code> par:</p>

<p>``` ruby</p>

<pre><code>when ?h then x -= 1
when ?l then x += 1
when ?k then y -= 1
when ?j then y += 1
</code></pre>

<p>```</p>

<p>Voilà.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vim - Débarassez vous des buffers inutilisés]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/03/08/vim-debarassez-vous-des-buffers-inutilises/"/>
    <updated>2014-03-08T20:37:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/03/08/vim-debarassez-vous-des-buffers-inutilises</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>J'avais envie d'écrire un truc comme ça depuis quelques mois déjà.
Un plugin pour effacer tous les buffers inutilisés. Mais comme je ne
m'en servirais que 3 ou 4 fois par mois, et encore, j'ai toujours remis à
plus tard.</p>

<p>Quoiqu'il en soit, on l'a fait à ma place, parfait.</p>

<!-- more -->


<p>Le plugin
<a href="http://www.vim.org/scripts/script.php?script_id=4882">Wipeout</a>
permet de supprimer tous les buffers qui ne sont pas liés à une
fenêtre, ni à un onglet. On l'appelera comme ça:</p>

<pre><code>:Wipeout
</code></pre>

<p>Si vous n'utilisez pas les onglets, <a href="https://twitter.com/madx">@madx</a> en
a écrit un similaire qui supprimera les buffers qui ne sont pas affichés
(et donc du même coup les onglets autres que le courant):
<a href="https://github.com/madx/vim-plugins/blob/master/plugin/clean-buffers.vim">CleanBuffers</a>.
On le lancera avec:</p>

<pre><code>:CleanBuffers
</code></pre>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Un éditeur pour le terminal - partie 8]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/03/06/un-editeur-pour-le-terminal-partie-8/"/>
    <updated>2014-03-06T20:59:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/03/06/un-editeur-pour-le-terminal-partie-8</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Dans l'article d'aujourd'hui, on regarde comment utiliser la couleur.</p>

<!-- more -->


<p>``` ruby
require &lsquo;curses&rsquo;
include Curses</p>

<p>begin
  init_screen
  unless has_colors?</p>

<pre><code>close_screen
puts "Your terminal has no colors"
exit 1
</code></pre>

<p>  end
  start_color
  init_pair(1, COLOR_RED, COLOR_BLACK)
  attron(color_pair(1))
  setpos(10, 10)
  addstr(&ldquo;In colors&hellip;&rdquo;)
  attroff(color_pair(1))
  refresh
  getch
ensure
  close_screen
end
```</p>

<p>On peut savoir si le terminal est capable d'afficher en couleur grâce à
<code>has_colors?</code>:</p>

<p><code>ruby
  unless has_colors?
</code></p>

<p>Avant de pouvoir utiliser la couleur, il faut faire appel à <code>start_color</code>:</p>

<p><code>ruby
  start_color
</code></p>

<p>On crée un «assemblage» de couleurs avec <code>init_pair</code>, en lui passant un
identifiant, auquel on pourra se référer plus tard, une couleur de premier
plan et une couleur d'arrière plan:</p>

<p><code>ruby
  init_pair(1, COLOR_RED, COLOR_BLACK)
</code></p>

<p>On active un «assemblage» comme ceci:</p>

<p><code>ruby
  attron(color_pair(1))
</code></p>

<p>Et on le désactive comme cela:</p>

<p><code>ruby
  attroff(color_pair(1))
</code></p>

<p>Voilà.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
