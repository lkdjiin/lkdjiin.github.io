<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : intermédiaire | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/intermediaire/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2014-06-09T21:09:45+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Utiliser Enumerable en Ruby]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/06/09/utiliser-enumerable-en-ruby/"/>
    <updated>2014-06-09T16:47:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/06/09/utiliser-enumerable-en-ruby</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Il y a quelques jours, j'ai testé Opal.rb. Et pour ça, j'ai écris un jeu
du type Space Invaders ;) J'ai une classe <code>Enemy</code>, que je peux résumer ainsi:</p>

<p>``` ruby
class Enemy
  attr_reader :x, :y
  def initialize(x, y)</p>

<pre><code>@x = x
@y = y
</code></pre>

<p>  end</p>

<p>  def to_s</p>

<pre><code>"#&lt;Enemy x:#@x y:#@y&gt;"
</code></pre>

<p>  end
end
```</p>

<!-- more -->


<p>J'ai aussi une classe <code>Enemies</code>, pour gérer ce qui se passe au niveau de
tous les ennemies. Inclure le module <a href="http://ruby-doc.org/core-2.1.2/Enumerable.html">Enumerable</a>
et définir la méthode <code>each</code> me permet d'utiliser toutes les méthodes de ce
module.</p>

<p>``` ruby
class Enemies
  include Enumerable</p>

<p>  def initialize</p>

<pre><code>@enemies = []
</code></pre>

<p>  end</p>

<p>  def each(&amp;block)</p>

<pre><code>@enemies.each(&amp;block)
</code></pre>

<p>  end</p>

<p>  def &lt;&lt;(item)</p>

<pre><code>@enemies &lt;&lt; item
</code></pre>

<p>  end
end
```</p>

<p>Créons un groupe de trois ennemies :</p>

<p><code>ruby
enemies = Enemies.new
enemies &lt;&lt; Enemy.new(10, 15)
enemies &lt;&lt; Enemy.new(20, 15)
enemies &lt;&lt; Enemy.new(10, 40)
</code></p>

<p>Voyons si <code>each</code> fonctionne bien :</p>

<pre><code>&gt; enemies.each {|item| puts item }
#&lt;Enemy x:10 y:15&gt;
#&lt;Enemy x:20 y:15&gt;
#&lt;Enemy x:10 y:40&gt;
</code></pre>

<p>J'ai donc accès à toutes les autres méthodes de <code>Enumerable</code>, comme par
exemple <code>select</code>:</p>

<pre><code>&gt; puts enemies.select {|item| item.x == 10 }
#&lt;Enemy x:10 y:15&gt;
#&lt;Enemy x:10 y:40&gt;
</code></pre>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Trois bibliothèques de fonctions pour écrire vos plugins Vim]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/06/08/trois-bibliotheques-de-fonctions-pour-ecrire-vos-plugins-vim/"/>
    <updated>2014-06-08T21:27:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/06/08/trois-bibliotheques-de-fonctions-pour-ecrire-vos-plugins-vim</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Aujourd'hui je vous propose trois bibliothèques de fonctions Vimscript, pour
faciliter l'écriture de plugins pour Vim.</p>

<!-- more -->


<p>J'en ai pour l'instant testé… aucune ! Mais j'ai bien l'intention de les
essayer ;)</p>

<p>Tout d'abord <a href="https://github.com/google/maktaba">maktaba</a>, par Google. Parmi
les fonctionnalités qui m'intéresse, je note une interface pour <em>logger</em> et
la gestion des exceptions.</p>

<p>Ensuite <a href="https://github.com/vim-jp/vital.vim">vital.vim</a>. Le readme annonce
que le projet a pour objectif de réunir les fonctions de Bundler et de
jQuery, mais pour Vim.</p>

<p>Et enfin <a href="https://github.com/mattn/webapi-vim">webapi-vim</a>, qui gère notamment
la connexion OAuth, le parsing JSON et quelques algorithmes de hashage.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Un algorithme génétique en Julia - partie 17]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/06/04/un-algorithme-genetique-en-julia-partie-17/"/>
    <updated>2014-06-04T21:59:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/06/04/un-algorithme-genetique-en-julia-partie-17</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Aujourd'hui j'ai envie de faire une version récursive de la fonction
<code>run</code>. Voici la version actuelle:</p>

<p>``` julia
function run(population_size, genes_size, generations, fight_rate)
  current = create_population(population_size, genes_size)
  for i in 1:generations</p>

<pre><code>scores = score(current)
best = maximum(scores)
println("Generation $i Best $best")
selection = tournament(scores, fight_rate)
current = reproduction([], current, selection, population_size)
</code></pre>

<p>  end
end
```</p>

<!-- more -->


<p>Et en voici une version récursive (avec un <em>helper</em>):</p>

<p>``` julia
function run(population_size, genes_size, generations, fight_rate)
  current = create_population(population_size, genes_size)
  run_helper(current, population_size, fight_rate, generations)
end</p>

<p>function run_helper(current, population_size, fight_rate, generations,</p>

<pre><code>                generation = 1)
</code></pre>

<p>  scores = score(current)
  best = maximum(scores)
  println(&ldquo;Generation $generation Best $best&rdquo;)
  if generation &lt; generations</p>

<pre><code>selection = tournament(scores, fight_rate)
current = reproduction([], current, selection, population_size)
run_helper(current, population_size, fight_rate, generations, generation + 1)
</code></pre>

<p>  end
end
```</p>

<p>Alors je me doute que je suis sûrement assez maladroit avec Julia, que
j'apprend, et avec le style récursif, qui ne coule pas de source chez moi,
mais j'ai quand même l'impression que ça n'apporte rien du tout au
programme !</p>

<p>Pour l'instant, je pense que je vais me limiter souvent à des boucles
<code>for</code> ;)</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Un algorithme génétique en Julia - partie 16]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/06/03/un-algorithme-genetique-en-julia-partie-16/"/>
    <updated>2014-06-03T21:02:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/06/03/un-algorithme-genetique-en-julia-partie-16</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>J'ai retiré les nombres magiques et renommé les quelques variables qui étaient
abrégées. Puis j'ai voulu commencer à documenter le code. Là je me suis
aperçu que le <em>typage</em> était une bonne façon de documenter Julia. Par
exemple:</p>

<p><code>julia
type Chromosome
  genes::Array{Int}
end
</code></p>

<p>m'apparait quasiment comme étant <em>auto-documenté</em>, comparé à la version
précédente:</p>

<p><code>julia
type Chromosome
  genes
end
</code></p>

<!-- more -->


<p>Plus de documentation plus tard, quand j'aurais trouvé si il y a un
<em>standard</em> en Julia (j'ai bien l'impression qu'il n'y en a pas :( ).</p>

<p>Pour l'instant, voici le code après son enième remaniement:</p>

<p>``` julia main.jl
type Chromosome
  genes::Array{Int}
end</p>

<p>create_genes(size) = rand(0:1, size)</p>

<p>function create_population(size, chromosome_size)
  [ Chromosome(create_genes(chromosome_size)) for _ in 1:size ]
end</p>

<p>score(population) = map(chromosome &ndash;> sum(chromosome.genes), population)</p>

<p>function fight(scores, index1, index2, rate)
  if rand() &lt; rate</p>

<pre><code>scores[index1] &gt; scores[index2] ? index1 : index2
</code></pre>

<p>  else</p>

<pre><code>scores[index1] &gt; scores[index2] ? index2 : index1
</code></pre>

<p>  end
end</p>

<p>function tournament(scores, rate)
  population_size = length(scores)
  selection_size = population_size * 2
  [ fight(scores, rand(1:population_size), rand(1:population_size), rate)</p>

<pre><code>for _ in 1:selection_size ]
</code></pre>

<p>end</p>

<p>function crossover(chromosome1, chromosome2, population_size)
  cut_point = rand(1:length(chromosome1.genes))
  first_part = chromosome1.genes[1:cut_point]
  second_part = chromosome2.genes[cut_point + 1:end]
  mutate(Chromosome([ first_part, second_part]), population_size)
end</p>

<p>function reproduction(new_population, current_population, selection,</p>

<pre><code>                  population_size)
</code></pre>

<p>  if selection == []</p>

<pre><code>return new_population
</code></pre>

<p>  else</p>

<pre><code>father = current_population[selection[1]]
mother = current_population[selection[2]]
child = crossover(father, mother, population_size)
reproduction([new_population, child], current_population, selection[3:end],
             population_size)
</code></pre>

<p>  end
end</p>

<p>function mutate(chromosome, population_size)
  mutator(gene) = if rand(1:population_size) == 1</p>

<pre><code>gene == 1 ? 0 : 1
</code></pre>

<p>  else</p>

<pre><code>gene
</code></pre>

<p>  end
  Chromosome([ mutator(gene) for gene in chromosome.genes ])
end</p>

<p>function run(population_size, genes_size, generations, fight_rate)
  current = create_population(population_size, genes_size)
  for i in 1:generations</p>

<pre><code>scores = score(current)
best = maximum(scores)
println("Generation $i Best $best")
selection = tournament(scores, fight_rate)
current = reproduction([], current, selection, population_size)
</code></pre>

<p>  end
end
```</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Un algorithme génétique en Julia - partie 15]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/06/02/un-algorithme-genetique-en-julia-partie-15/"/>
    <updated>2014-06-02T21:02:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/06/02/un-algorithme-genetique-en-julia-partie-15</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Après avoir pondu <a href="blog/2014/06/01/un-algorithme-genetique-en-julia-partie-14/">une première version</a>
de l'algorithme hier, je me demande ce que je pourrais améliorer. C'était
un programme sympa pour découvrir Julia, mais je n'ai fait que gratter la
surface de ce langage.</p>

<!-- more -->


<p>Donc, voici ce que je compte/espère faire encore avec ce programme pour
comprendre un peu mieux Julia:</p>

<ul>
<li>Retirer les nombres magiques restants.</li>
<li>Retirer les abbreviations restantes.</li>
<li>Documenter les fonctions, sinon dans un mois, j'aurais tout oublié !</li>
<li>Essayer une version récursive de la fonction <code>run</code>.</li>
<li>Lire quelques tutos pour voir ce que je peux en tirer.</li>
<li>Lire du code julia pour mieux <em>sentir</em> (le code source de Julia <em>itself</em>
serait un bon début).</li>
<li>Mettre le code sur github et le donner à lire/critiquer à des développeurs qui
connaissent le langage.</li>
<li>Comprendre pourquoi avec 10.000 individus de 100 gènes, l'empreinte
mémoire est de 800 Mo ! Ça me semble beaucoup…</li>
<li>Écrire le même en Ruby et comparer le temps d'exécution.</li>
</ul>


<p>Voilà, il devrait donc y avoir encore pas mal d'articles sur le langage
Julia ;)</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
