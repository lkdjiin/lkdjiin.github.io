<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : intermédiaire | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/intermediaire/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2014-03-21T21:58:36+01:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Redis - Comment supprimer un ensemble de clés]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/03/21/redis-comment-supprimer-un-ensemble-de-cles/"/>
    <updated>2014-03-21T21:44:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/03/21/redis-comment-supprimer-un-ensemble-de-cles</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Tiens, mon premier article sur Redis ! Normal, c'est une technologie que
j'ai découvert il y a peu…</p>

<!-- more -->


<p>Pour supprimer une clé dans Redis, on se connecte et on utilise la commande
<code>del</code>:</p>

<pre><code>$ redis-cli
&gt; del "nom:de:la:clef"
</code></pre>

<p>Mais quand on a des dizaines/centaines de clés, bof… Bien souvent (toujours
même ça vaut mieux) le nom des clés suit un motif. Par exemple:</p>

<pre><code>"motif:foo"
"motif:bar"
"motif:baz"
etc...
</code></pre>

<p>Dans ce cas on peut utiliser Bash pour s'en sortir rapidement:</p>

<p><code>bash
redis-cli keys "*motif*" | xargs redis-cli del
</code></p>

<p>Et voilà, au revoir toutes les clés.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Un éditeur pour le terminal - partie 9]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/03/13/un-editeur-pour-le-terminal-partie-9/"/>
    <updated>2014-03-13T21:04:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/03/13/un-editeur-pour-le-terminal-partie-9</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Dans le programme d'aujourd'hui, on s'occupe de déplacer le curseur.</p>

<!-- more -->


<p>``` ruby
require &lsquo;curses&rsquo;
include Curses</p>

<p>begin
  init_screen
  cbreak
  noecho
  stdscr.keypad(true)
  x = 0
  y = 0</p>

<p>  while (ch = getch) != KEY_F1</p>

<pre><code>case ch
when KEY_LEFT then x -= 1
when KEY_RIGHT then x += 1
when KEY_UP then y -= 1
when KEY_DOWN then y += 1
end
setpos(y, x)
refresh
</code></pre>

<p>  end
ensure
  close_screen
end
```</p>

<p>Les détails:</p>

<p>Pour éviter que les caractères s'affiche sur le terminal:</p>

<p><code>ruby
  noecho
</code></p>

<p>Pour rappel, le code suivant permet d'activer le pavé numérique, les
flèches, etc.</p>

<p><code>ruby
  stdscr.keypad(true)
</code></p>

<p>Positionner le curseur est aussi simple que ce qui suit. Comme toujours,
attention, c'est y d'abord et x ensuite:</p>

<p>``` ruby</p>

<pre><code>setpos(y, x)
</code></pre>

<p>```</p>

<p>Par contre, si vous jouer un peu avec ce programme, on voit que les
sauts de lignes ne sont pas gérer automatiquement (quand j'arrive à la
fin de la ligne et que j'appuie sur flèche droite, on ne passe pas à
la ligne suivante par exemple). Ce sera à nous de le gérer…</p>

<p>Si on veut utiliser HJKL (comme dans Vim) pour se déplacer, on peut
remplacer le contenu du <code>case</code> par:</p>

<p>``` ruby</p>

<pre><code>when ?h then x -= 1
when ?l then x += 1
when ?k then y -= 1
when ?j then y += 1
</code></pre>

<p>```</p>

<p>Voilà.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vim - Débarassez vous des buffers inutilisés]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/03/08/vim-debarassez-vous-des-buffers-inutilises/"/>
    <updated>2014-03-08T20:37:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/03/08/vim-debarassez-vous-des-buffers-inutilises</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>J'avais envie d'écrire un truc comme ça depuis quelques mois déjà.
Un plugin pour effacer tous les buffers inutilisés. Mais comme je ne
m'en servirais que 3 ou 4 fois par mois, et encore, j'ai toujours remis à
plus tard.</p>

<p>Quoiqu'il en soit, on l'a fait à ma place, parfait.</p>

<!-- more -->


<p>Le plugin
<a href="http://www.vim.org/scripts/script.php?script_id=4882">Wipeout</a>
permet de supprimer tous les buffers qui ne sont pas liés à une
fenêtre, ni à un onglet. On l'appelera comme ça:</p>

<pre><code>:Wipeout
</code></pre>

<p>Si vous n'utilisez pas les onglets, <a href="https://twitter.com/madx">@madx</a> en
a écrit un similaire qui supprimera les buffers qui ne sont pas affichés
(et donc du même coup les onglets autres que le courant):
<a href="https://github.com/madx/vim-plugins/blob/master/plugin/clean-buffers.vim">CleanBuffers</a>.
On le lancera avec:</p>

<pre><code>:CleanBuffers
</code></pre>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Un éditeur pour le terminal - partie 8]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/03/06/un-editeur-pour-le-terminal-partie-8/"/>
    <updated>2014-03-06T20:59:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/03/06/un-editeur-pour-le-terminal-partie-8</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Dans l'article d'aujourd'hui, on regarde comment utiliser la couleur.</p>

<!-- more -->


<p>``` ruby
require &lsquo;curses&rsquo;
include Curses</p>

<p>begin
  init_screen
  unless has_colors?</p>

<pre><code>close_screen
puts "Your terminal has no colors"
exit 1
</code></pre>

<p>  end
  start_color
  init_pair(1, COLOR_RED, COLOR_BLACK)
  attron(color_pair(1))
  setpos(10, 10)
  addstr(&ldquo;In colors&hellip;&rdquo;)
  attroff(color_pair(1))
  refresh
  getch
ensure
  close_screen
end
```</p>

<p>On peut savoir si le terminal est capable d'afficher en couleur grâce à
<code>has_colors?</code>:</p>

<p><code>ruby
  unless has_colors?
</code></p>

<p>Avant de pouvoir utiliser la couleur, il faut faire appel à <code>start_color</code>:</p>

<p><code>ruby
  start_color
</code></p>

<p>On crée un «assemblage» de couleurs avec <code>init_pair</code>, en lui passant un
identifiant, auquel on pourra se référer plus tard, une couleur de premier
plan et une couleur d'arrière plan:</p>

<p><code>ruby
  init_pair(1, COLOR_RED, COLOR_BLACK)
</code></p>

<p>On active un «assemblage» comme ceci:</p>

<p><code>ruby
  attron(color_pair(1))
</code></p>

<p>Et on le désactive comme cela:</p>

<p><code>ruby
  attroff(color_pair(1))
</code></p>

<p>Voilà.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Écrire un éditeur pour le terminal - partie 7]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/03/04/ecrire-un-editeur-pour-le-terminal-partie-7/"/>
    <updated>2014-03-04T21:04:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/03/04/ecrire-un-editeur-pour-le-terminal-partie-7</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Notre futur éditeur aura un certain nombre de fenêtre (au sens de
<em>curses</em>) et pour les gérer, on sera bien inspiré d'utiliser un peu
de POO.
Voici donc une réécriture du programme vu
<a href="/blog/2014/03/02/ecrire-un-editeur-pour-le-terminal-partie-5/">ici</a>.</p>

<!-- more -->


<p>``` ruby</p>

<h1>!/usr/bin/env ruby</h1>

<p>require &lsquo;curses&rsquo;
include Curses</p>

<p>class StatusWindow
  def initialize(filename)</p>

<pre><code>@filename = filename
@win = Window.new(1, cols, 0, 0)
</code></pre>

<p>  end</p>

<p>  def display</p>

<pre><code>@win.setpos(0, (@win.maxx - @filename.size) / 2)
@win.addstr(@filename)
@win.refresh
</code></pre>

<p>  end</p>

<p>  def close</p>

<pre><code>@win.close
</code></pre>

<p>  end
end</p>

<p>class FileWindow
  def initialize(filename)</p>

<pre><code>@filename = filename
@win = Window.new(lines - 2, cols, 2, 0)
</code></pre>

<p>  end</p>

<p>  def display</p>

<pre><code>@win.setpos(0, 0)
File.open(@filename).each {|line| @win.addstr(line) }
@win.refresh
</code></pre>

<p>  end</p>

<p>  def close</p>

<pre><code>@win.close
</code></pre>

<p>  end
end</p>

<p>begin
  init_screen
  refresh
  status_window = StatusWindow.new(ARGV[0])
  file_window = FileWindow.new(ARGV[0])
  status_window.display
  file_window.display
  getch
  status_window.close
  file_window.close
ensure
  close_screen
end
```</p>

<p>Le code est plus conséquent, c'est vrai, mais la structure sera plus
claire, surtout quand on coupera le code en plusieurs fichiers, et
qu'on utilisera un peu, ou plutôt beaucoup, d'héritage.</p>

<p>Le détail à retenir, curieusement, est celui-ci:</p>

<p><code>ruby
begin
  init_screen
  refresh
</code></p>

<p>Il faut rafraichir l'écran juste après l'initialisation de <em>curses</em>, sinon
aucune fenêtre ne s'affichera…</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
