<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : intermédiaire | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/intermediaire/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2014-05-15T22:01:16+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Un algorithme génétique en Julia - partie 3]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/05/15/un-algorithme-genetique-en-julia-partie-3/"/>
    <updated>2014-05-15T21:28:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/05/15/un-algorithme-genetique-en-julia-partie-3</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Aujourd'hui j'essaye de faire la sélection en vue de la reprodution ;)
Si vous aviez suivi ma série d'articles
<a href="http://lkdjiin.github.io/blog/categories/algorithme-genetique/">les algorithmes génétiques démystifiés</a> vous savez de quoi je parle…</p>

<!-- more -->


<p>Voici d'abord les fonctions que j'ai jusqu'à présent :</p>

<p>``` julia main.jl
create_chromosome(size) = rand(0:1, size)</p>

<p>function create_population(size, chromosome_size)
  [ create_chromosome(chromosome_size) for _ in 1:size ]
end</p>

<p>score(population) = map(sum, population)
```</p>

<p>Alors j'ai remis des <code>_</code>, parce que sans j'y arrivais vraiment pas ;)
J'ai aussi ajouté l'argument <code>size</code> à la fonction de création d'un
chromosome pour éviter les nombres magiques.</p>

<p>Je veux opérer une sélection très simple : un tournoi. Pour ça, je
commence avec une fonction <code>fight</code> qui va renvoyer le meilleur chromosome
parmi deux:</p>

<p><code>julia
function fight(scores, index1, index2)
  scores[index1] &gt; scores[index2] ? index1 : index2
end
</code></p>

<p>En fait je ne passe pas de chromosome à cette fonction mais le tableau des
scores de la population, obtenu avec <code>score</code> et deux indexs.</p>

<pre><code>julia&gt; include("main.jl")

julia&gt; pop = create_population(8, 20)
8-element Array{Array{Int32,1},1}:
 [1,0,1,1,1,1,1,0,1,0,1,1,1,0,1,0,1,1,1,1]
 [1,1,0,0,0,1,0,1,0,1,0,0,0,0,0,1,0,1,1,1]
 [0,0,1,0,1,0,0,1,0,1,0,0,1,1,1,0,0,1,0,1]
 [1,1,0,1,1,1,0,1,1,0,0,1,1,1,0,1,0,1,1,1]
 [0,1,0,0,1,1,1,1,0,1,0,1,1,0,0,1,0,0,0,1]
 [1,1,0,0,0,1,0,0,1,0,1,1,1,0,1,1,1,0,1,0]
 [1,1,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,1]
 [0,0,0,1,0,1,0,0,0,1,1,1,0,1,0,1,1,1,1,1]

julia&gt; scores = score(pop)
8-element Array{Int32,1}:
 15
  9
  9
 14
 10
 11
 10
 11
</code></pre>

<p>Et la fonction <code>fight</code> renvoit l'index du meilleur des deux chromosomes
du <em>combat</em>:</p>

<pre><code>julia&gt; fight(scores, 1, 2)
1

julia&gt; fight(scores, 7, 8)
8
</code></pre>

<p>La prochaine fois je pourrais organiser le tournoi proprement dit.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Un algorithme génétique en Julia - partie 2]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/05/14/un-algorithme-genetique-en-julia-partie-2/"/>
    <updated>2014-05-14T21:04:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/05/14/un-algorithme-genetique-en-julia-partie-2</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Je continue l'algorithme génétique en Julia que j'ai commencé hier, en
cherchant la manière de calculer le score d'un chromosome.</p>

<!-- more -->


<p>Tout d'abord, je met les fonctions créées hier dans un fichier <code>main.jl</code>.
J'en profite pour les renommer. La convention en Julia veut qu'on accolle
les mots, sans séparation. Bien que je trouve ça curieux et illisible, je
vais m'y plier, après tout j'apprends…</p>

<p>``` julia main.jl
createchromosome() = rand(0:1, 10)</p>

<p>createpopulation(size) = [ createchromosome() for _ in 1:size ]
```</p>

<p>Une fois l'interpréteur Julia lancé, je charge les définitions de fonctions
du fichier <code>main.jl</code>:</p>

<pre><code>julia&gt; include("main.jl")
</code></pre>

<p>Puis je crée un chromosome:</p>

<pre><code>julia&gt; chromosome = createchromosome()
10-element Array{Int32,1}:
 1
 0
 0
 1
 1
 0
 0
 0
 1
 1
</code></pre>

<p>L'algorithme génétique que je veux mettre en place est le plus simple qui
existe. Je cherche à maximiser les chromosomes, c'est à dire que je veux
obtenir un chromosome qui ne comporte que des 1. Pour calculer son score,
il suffit donc de faire la somme de ses gènes. Très facile, puisque Julia
fournit la fonction <code>sum</code>:</p>

<pre><code>julia&gt; sum(chromosome)
5
</code></pre>

<p>Maintenant je dois trouver comment calculer le score de chaque chromosome.
Je crée donc une population:</p>

<pre><code>julia&gt; population = createpopulation(8)
8-element Array{Array{Int32,1},1}:
 [0,0,1,1,1,0,0,0,0,1]
 [1,0,0,0,1,0,1,1,0,0]
 [0,0,1,1,0,0,0,1,0,1]
 [1,0,0,1,1,0,0,0,0,0]
 [1,0,1,0,1,0,1,0,0,1]
 [0,1,1,1,1,1,0,1,0,0]
 [0,1,1,0,1,0,1,0,1,1]
 [0,1,1,1,1,1,0,1,0,0]
</code></pre>

<p>Et j'utilise <code>map</code>, qui va <em>mapper</em> la fonction <code>sum</code> sur chaque élément
de la population:</p>

<pre><code>julia&gt; map(sum, population)
8-element Array{Int32,1}:
 4
 4
 4
 3
 5
 6
 6
 6
</code></pre>

<p>Voilà, si on veut, on peut aussi créer une fonction <code>score</code>:</p>

<pre><code>julia&gt; score(population) = map(sum, population)

julia&gt; score(population)
8-element Array{Int32,1}:
 4
 4
 4
 3
 5
 6
 6
 6
</code></pre>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Un algorithme génétique en Julia - partie 1]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/05/13/un-algorithme-genetique-en-julia-partie-1/"/>
    <updated>2014-05-13T21:09:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/05/13/un-algorithme-genetique-en-julia-partie-1</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Pour continuer d'apprendre le langage Julia, je vais coder un algorithme
génétique simple.</p>

<!-- more -->


<p>Tout d'abord un chromosome, qui va contenir 10 valeurs, chaque valeur pouvant
être soit zéro, soit un:</p>

<pre><code>julia&gt; chromosome() = rand(0:1, 10)
</code></pre>

<p>La fonction <code>rand</code> prend un <em>range</em> en premier paramêtre.</p>

<p>On teste cette fonction:</p>

<pre><code>julia&gt; chromosome()
10-element Array{Int32,1}:
 0
 1
 1
 1
 1
 1
 1
 0
 1
 1
</code></pre>

<p>Maintenant je veux une population:</p>

<pre><code>julia&gt; population(size) = [ chromosome() for _ in 1:size ]
</code></pre>

<p>Il s'agit d'une <em>compréhension de liste</em>. Pour chaque valeur (symbolisée
par le <code>_</code>) du <em>range</em> de 1 à <code>size</code>, on applique la fonction <code>chromosome</code>.
Je peux donc avoir une population:</p>

<pre><code>julia&gt; population(8)
8-element Array{Array{Int32,1},1}:
 [1,0,1,0,1,0,0,1,1,0]
 [1,1,0,1,0,1,0,1,0,0]
 [1,0,1,1,0,1,1,1,1,1]
 [0,0,1,0,0,1,0,0,1,1]
 [1,0,0,1,0,1,1,1,1,0]
 [0,1,0,0,1,1,1,0,1,1]
 [0,0,0,1,0,1,0,1,1,1]
 [0,1,0,0,0,1,0,1,1,0]
</code></pre>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les fonctions en Julia - partie 2]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/05/12/les-fonctions-en-julia-partie-2/"/>
    <updated>2014-05-12T21:05:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/05/12/les-fonctions-en-julia-partie-2</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Suite du tour d'horizon des fonctions en Julia. Je m'intéresse aujourd'hui
aux arguments par défaut et aux arguments nommés (souvent appellés
<em>keyword arguments</em>).</p>

<!-- more -->


<p>La fonction suivante possède un argument <em>normal</em>, <code>a</code>, et un argument par
défaut, <code>b</code>:</p>

<pre><code>julia&gt; function add(a, b = 10)
           a + b
       end
</code></pre>

<p>Lorsqu'on l'appelle avec deux arguments, elle les additionne:</p>

<pre><code>julia&gt; add(1, 2)
3
</code></pre>

<p>Lorsqu'on l'appelle avec un seul argument, la valeur par défaut du second
argument est utilisé:</p>

<pre><code>julia&gt; add(1)
11
</code></pre>

<p>Tout ça est très classique, sans surprise. Voyons maintenant les arguments
nommés:</p>

<pre><code>julia&gt; function add(a, b = 10 ; c = 0)
           a + b + c
       end
</code></pre>

<p>J'ai ici défini la fonction <code>add</code> avec un argument normal, <code>a</code>, un argument par
défaut, <code>b</code>, et un argument nommé, <code>c</code>. On doit séparer les arguments
nommés par un point-virgule.</p>

<p>Avec une seule valeur, <code>b</code> vaut 10 et <code>c</code> vaut 0:</p>

<pre><code>julia&gt; add(1)
11
</code></pre>

<p>Avec deux valeurs, <code>b</code> vaut 2 et <code>c</code> vaut 0:</p>

<pre><code>julia&gt; add(1, 2)
3
</code></pre>

<p>Avec trois valeurs, je suis obligé de <em>nommer</em> <code>c</code>:</p>

<pre><code>julia&gt; add(1, 2, c = 10)
13
</code></pre>

<p>Lorsqu'on a uniquement des arguments nommés, la syntaxe peut paraître
étrange, il ne faut pas oublier le point-virgule:</p>

<pre><code>julia&gt; function foo(; bar = "bar", baz = "baz")
           "$bar $baz"
       end

julia&gt; foo()
"bar baz"

julia&gt; foo(bar = "hello", baz = "world")
"hello world"
</code></pre>

<p>Pour finir, on va mettre en exergue une différence de <em>portée</em> entre les
arguments par défaut et les arguments nommés. Soit <code>b</code> qui vaut 3:</p>

<pre><code>julia&gt; b = 3
3
</code></pre>

<p>Dans la fonction <code>foo</code> suivante je n'ai que des arguments par défaut.
L'argument <code>a</code> a comme valeur par défaut le contenu de <code>b</code>. Il s'agit du
contenu du <code>b</code> précédent, pas celui de l'argument:</p>

<pre><code>julia&gt; foo(a = b, b = 9) = a + b

julia&gt; foo()
12
</code></pre>

<p>Maintenant, même chose avec des arguments nommés:</p>

<pre><code>julia&gt; foo(; a = b, b = 9) = a + b

julia&gt; foo()
ERROR: b not defined
</code></pre>

<p>Oups ! Les arguments nommés n'ont pas accès au monde extérieur.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les fonctions en Julia]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/05/11/les-fonctions-en-julia/"/>
    <updated>2014-05-11T18:49:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/05/11/les-fonctions-en-julia</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Voici une présentation de base des fonctions en Julia, d'après ce que j'en ai retenu ;)</p>

<p>Tout d'abord, une définition d'une fonction nommée <code>double</code>:</p>

<p><code>julia
function double(x)
  x + x
end
</code></p>

<!-- more -->


<p>On voit que la valeur de retour est <em>implicite</em>, pas besoin du mot-clé
<code>return</code>. On peut le mettre si on veut, la fonction suivante est identique
à la précédente:</p>

<p><code>julia
function double(x)
  return x + x
end
</code></p>

<p>Et voilà comment on appelle cette fonction, rien à dire de particulier
là-dessus:</p>

<p><code>julia
double(12) # =&gt; 24
</code></p>

<p>Quand une fonction est aussi simple que la fonction <code>double</code>, on peut aussi
la définir comme suit:</p>

<p><code>julia
double(x) = x + x
</code></p>

<p>Si notre programme comporte de nombreuses petites fonctions, cette concision
peut être un atout.</p>

<p>Une fonction Julia est une valeur comme une autre:</p>

<p><code>julia
typeof(double) # =&gt; Function
</code></p>

<p>On peut donc affecter cette <em>valeur</em> à une autre variable:</p>

<p><code>julia
bis = double
bis(3) # =&gt; 6
</code></p>

<p>On peut passer une fonction en argument:</p>

<p><code>julia
map(double, [1, 2, 3]) # =&gt; [2, 4, 6]
</code></p>

<p>Un truc sympa en Julia, c'est qu'une fonction est composée de une ou plusieurs
méthodes ! Quand j'ai lu ça la première fois… j'ai pensé que l'auteur de cette
phrase était dingue. En fait il s'agit simplement de fonctions avec un nom
identique mais des signatures différentes. Par exemple, si j'essaye de
<em>doubler</em> une chaîne de caractères:</p>

<p>``` julia
double(&ldquo;hello&rdquo;)</p>

<h1>=> ERROR: no method +(ASCIIString, ASCIIString)</h1>

<h1>in double at none:1</h1>

<p>```</p>

<p>J'obtiens une erreur car il n'y a pas de fonction <code>+</code> pour les <em>strings</em>.
Je vais donc ajouter une seconde <em>méthode</em> à la fonction <code>double</code>, qui
s'occupera du cas particulier des chaînes de caractères:</p>

<p><code>julia
double(x::String) = "$x$x"
</code></p>

<p>Au passage, le caractère <code>$</code> permet l'interpolation. Plus intéressant, on voit
que j'ai donné un <em>type</em> à l'argument <code>x</code>. Quand <code>double</code> recevra un argument
de type <em>String</em>, c'est cette version (méthode) de la fonction qui sera
utilisée:</p>

<p><code>julia
double("hello") # =&gt; "hellohello"
</code></p>

<p>Alors que dans tous les autres cas, ce sera la version (méthode) <em>générique</em>
qui sera utilisée:</p>

<p><code>julia
double(12)   # =&gt; 24
double(0.78) # =&gt; 1.56
double(0xf)  # =&gt; 0x0000001e
</code></p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
