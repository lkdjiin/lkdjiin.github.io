<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : intermédiaire | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/intermediaire/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2014-02-18T21:09:43+01:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Curses et ncurses en Ruby]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/02/16/curses-et-ncurses-en-ruby/"/>
    <updated>2014-02-16T14:29:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/02/16/curses-et-ncurses-en-ruby</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Tiens, j'ai envie d'écrire en Ruby un embryon d'éditeur pour le terminal, qui
serait fortement inspiré de Vim. Juste histoire de voir comment ça marche.
La première étape sera d'utiliser la bibliothèque curses (ou ncurses) à
partir de Ruby.</p>

<!-- more -->


<h2>Curses</h2>

<p>La bibliothèque <em>curses</em> permet de gérer toutes les interactions
clavier et souris avec un terminal. Jusqu'à la version 2.1 de Ruby, elle
faisait partie de la bibliothèque standard. Donc, si vous utilisez
Ruby 2.1, n'oubliez pas de faire:</p>

<pre><code>gem install curses
</code></pre>

<p>Si vous utilisez Ruby 2.0 où inférieur, vous possédez déjà la bibliothèque
<em>curses</em>.</p>

<p>Voici donc un <em>hello world</em>:</p>

<p>``` ruby
require &lsquo;curses&rsquo;</p>

<p>include Curses</p>

<p>begin
  init_screen
  setpos(0, 0)
  addstr(&lsquo;Hello, world!&rsquo;)
  refresh
  getch
ensure
  close_screen
end
```</p>

<p>On remarque tout d'abord la paire:</p>

<pre><code>init_screen
close_screen
</code></pre>

<p>Il faut toujours appeler <code>close_screen</code> à la fin de votre programme, pour
remettre le terminal dans l'état où il se trouvait avant le lancement de
votre programme.</p>

<p>Pour positionner le curseur, on utilise:</p>

<pre><code>setpos(0, 0)
</code></pre>

<p>Attention, le premier nombre est le numéro de la ligne, et le second est le
numéro de la colonne. Et lignes et colonnes se comptent à partir de 0…</p>

<p>Pour écrire une chaîne de caractère à la position du curseur:</p>

<pre><code>addstr('Hello, world!')
refresh
</code></pre>

<p>Curses n'écrit directement dans le terminal, mais dans un buffer en mémoire,
c'est pourquoi il faut appeler <code>refresh</code> pour voir les changements.</p>

<p>Ensuite, on attends l'appui sur une touche du clavier avec:</p>

<pre><code>getch
</code></pre>

<h2>Ncurses</h2>

<p>Il existe aussi la bibliothèque <em>ncurses</em>, un peu plus puissante. Il existe
plusieurs wrappers pour Ruby. J'utilise personnelement <a href="https://github.com/seanohalpin/ffi-ncurses">ffi-ncurses</a>.</p>

<p>Le même programme que le précédent, mais pour ncurses:</p>

<p>``` ruby
require &lsquo;ffi-ncurses&rsquo;</p>

<p>include FFI::NCurses</p>

<p>begin
  initscr
  printw &ldquo;Hello World !!!&rdquo;
  refresh
  getch
ensure
  endwin
end
```</p>

<p>Les deux programmes se ressemblent beaucoup. Et pour cause, <em>ncurses</em> fait
la même chose que <em>curses</em>, avec des extensions en plus.</p>

<h2>Choisir entre curses et ncurses</h2>

<p>L'une et l'autre ont leurs avantages et leurs inconvénients. <em>curses</em> à
l'avantage d'avoir été distribuée en standard avec Ruby jusqu'à la version
2.0 incluse, et est donc très bien intégrée. Je pense qu'on doit pouvoir
l'utiliser facilement, même sur Windows. <em>ncurses</em> est plus puissante mais
requiert plus de dépendances, et il n'est pas toujours évident de trouver
un wrapper qui fonctionne avec une version récente de Ruby, même sur Linux.</p>

<p>Si je devais écrire un programme grand public, j'utiliserais <em>curses</em>, mais
comme il s'agit juste d'un programme exemple pour ce blog, je vais me faire
plaisir et utiliser <em>ncurses</em>…</p>

<p>La prochaine fois on commencera à écrire l'éditeur.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Simuler une honnête pièce de monnaie à partir d'une truquée]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/02/15/simuler-une-honnete-piece-de-monnaie-a-partir-dune-truquee/"/>
    <updated>2014-02-15T12:20:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/02/15/simuler-une-honnete-piece-de-monnaie-a-partir-dune-truquee</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p><em>Ce qui suit est une traduction assez libre de l'article original
<a href="http://jeremykun.com/2014/02/08/simulating-a-fair-coin-with-a-biased-coin/">Simulating a Fair Coin with a Biased Coin</a>,
j'ai laissé le code python original et ajouté du code Ruby.</em></p>

<!-- more -->


<p><strong>Problème</strong> : Simuler une honnête pièce de monnaie, alors qu'on a uniquement
accès à une pièce truquée.</p>

<p><strong>Solution</strong> :</p>

<p>En Python</p>

<p>``` python
def fairCoin(biasedCoin):
   coin1, coin2 = 0,0
   while coin1 == coin2:</p>

<pre><code>  coin1, coin2 = biasedCoin(), biasedCoin()
</code></pre>

<p>   return coin1
```</p>

<p>En Ruby</p>

<p><code>ruby
def fair_coin
  coin1, coin2 = 0, 0
  coin1, coin2 = biased_coin, biased_coin while coin1 == coin2
  coin1
end
</code></p>

<p><strong>Discussion</strong> : C'est à l'origine une idée brillante de
<a href="http://en.wikipedia.org/wiki/John_von_Neumann">von Neumann</a>. Si nous avons
une pièce truquée (c'est à dire une pièce qui tombe sur face avec une
probabilité différente de &frac12;), on peut simuler une pièce non truquée
en lançant deux pièces jusqu'à ce que les deux résultats (pile ou face)
soient différents. Comme on a des résultats différents, la probabilité que
la première pièce donne face et que la seconde donne pile est la même que
la probabilité d'obtenir le résultat inverse (pièce 1 donnant pile et pièce 2
donnant face). Donc, si on retourne simplement le résultat de la première
pièce, on aura pile ou face avec une probabilité de &frac12;.</p>

<p>Notez que l'on a pas besoin de connaître ni d'assumer quoique ce soit de
la fonction <code>biasedCoin</code>/<code>biased_coin</code>, mis à part qu'elle renvoit 1 ou 0
à chaque appel et que les résultats sont indépendant les uns des autres.
En particulier, nous n'avons pas besoin de connaître la probabilité
d'obtenir 1. De plus, nous n'utilisons pas le hasard directement (seulement
à travers la fonction <code>biasedCoin</code>/<code>biased_coin</code>).</p>

<p>Voici une simulation simple :</p>

<p>En python</p>

<p><code>python
from random import random
def biasedCoin():
   return int(random() &lt; 0.2)
</code></p>

<p>En Ruby</p>

<p><code>ruby
def biased_coin
  rand &lt; 0.2 ? 1 :  0
end
</code></p>

<p>Cette fonction renvoie 1 avec une probabilité de 0.2. Si nous essayons
maintenant:</p>

<p>En Python</p>

<p><code>python
sum(biasedCoin() for i in range(10000))
</code></p>

<p>En Ruby</p>

<p><code>ruby
(1..10_000).reduce {|sum| sum + biased_coin }
</code></p>

<p>Nous devrions obtenir un nombre proche de 2000. J'ai obtenu 2058.</p>

<p>D'un autre coté, si nous faisons:</p>

<p>En Python</p>

<p><code>python
sum(fairCoin(biasedCoin) for i in range(10000))
</code></p>

<p>En Ruby</p>

<p><code>ruby
(1..10_000).reduce {|sum| sum + fair_coin }
</code></p>

<p>Nous devrions obtenir approximativement 5000. Et quand j'ai essayé, j'ai
obtenu 4982, ce qui est la preuve que <code>fairCoin</code>/<code>fair_coin</code> renvoie bien
1 avec une probabilité de &frac12; (même si j'ai déjà fourni cette preuve !).</p>

<p>Pour plus d'informations sur ce sujet, regardez
<a href="http://www.eecs.harvard.edu/~michaelm/coinflipext.pdf">ces notes</a> par Michael Mitzenmacher de l'université de Harvard.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Quelques commandes Git par Michael Hartl]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/02/12/quelques-commandes-git-par-michael-hartl/"/>
    <updated>2014-02-12T20:29:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/02/12/quelques-commandes-git-par-michael-hartl</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Michael Hartl, l'auteur de <a href="http://ruby.railstutorial.org/">Ruby on Rails Tutorial</a>
a écrit plusieurs commandes Git bien utiles.</p>

<!-- more -->


<p>Le code se trouve sur Github : <a href="https://github.com/mhartl/git-utils">git-utils</a>.
On y trouve par exemple une commande <code>git cleanup</code>, qui supprime toutes
les branches locales qui ne sont pas encore mergées dans la branche
courante. Ou encore <code>git merge-branch</code>, qui merge la branche courante
dans master par défaut.</p>

<p>Aujourd'hui, toutes ces commandes sont écrites en Ruby, mais avant
elle l'était en Bash, comme la suivante:</p>

<p>``` bash</p>

<h1>!/bin/bash git-merge-branch</h1>

<h1>Copyright &copy; 2013 Michael Hartl</h1>

<h1>Released under the MIT License (<a href="http://opensource.org/licenses/MIT">http://opensource.org/licenses/MIT</a>)</h1>

<h1>Merges the current branch into the given branch (defaults to master).</h1>

<h1>E.g., &lsquo;git merge-branch foobar&rsquo; merges the current branch into foobar.</h1>

<h1>&lsquo;git merge-branch&rsquo;, merges the current branch into master.</h1>

<h1>git merge-branch uses the &mdash;no-ff &mdash;log options to ensure that the</h1>

<h1>merge creates a new commit object and that the individual commits appear</h1>

<h1>in the log file.</h1>

<p>CURRENT_BRANCH=<code>git rev-parse --abbrev-ref HEAD</code>
if [ $# -eq 1 ]
then
  TARGET_BRANCH=$1
else
  TARGET_BRANCH=&ldquo;master&rdquo;
fi
git checkout $TARGET_BRANCH
git merge &mdash;no-ff &mdash;log $CURRENT_BRANCH
```</p>

<p>Essayez les, certaines pourraient bien vous changer la vie.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vim - Sauvegarder et quitter les fichiers]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/02/01/vim-sauvegarder-et-quitter-les-fichiers/"/>
    <updated>2014-02-01T20:12:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/02/01/vim-sauvegarder-et-quitter-les-fichiers</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Il est temps pour moi de faire un point sur les différentes méthodes
qu'offre Vim pour quitter et/ou sauvegarder un fichier.</p>

<!-- more -->


<h2>Les basiques</h2>

<p>Voici, selon moi, les commandes à retenir en premier lieu.</p>

<p>Pour sauvegarder un fichier, utilisez la commande <code>write</code>, ou
plutôt son raccourci <code>w</code>:</p>

<pre><code>:w
:write
</code></pre>

<p>Je rappelle qu'on peut facilement obtenir une aide exhaustive sur une
commande quelconque:</p>

<pre><code>:h :write
</code></pre>

<p>Et je conseille de lire systématiquement l'aide de Vim sur les
commandes dont je vais vous parler. Vous découvrirez ainsi des tas
de variantes qui pourrait vous être utile.</p>

<p>Pour sauvegarder tous les fichiers en une seule fois:</p>

<pre><code>:wall
</code></pre>

<p>Pour quitter un fichier, on utilise <code>quit</code>, ou son raccourci <code>q</code>:</p>

<pre><code>:q
:quit
</code></pre>

<p>De même, pour quitter tous les fichiers (et fermer Vim):</p>

<pre><code>:qa
:qall
</code></pre>

<p>Si vous voulez fermer un fichier modifié <em>sans</em> enregistrer les
modifications, la commande suivante est indispensable:</p>

<pre><code>:q!
</code></pre>

<p>Voilà pour les basiques. Ces commandes sont simples à mémoriser.</p>

<h2>Les combinaisons</h2>

<p>Il arrive souvent qu'on veuille sauvegarder un fichier, <em>et en même
temps</em> le fermer. Je recommenderais aux débutants d'utiliser la
commande suivante:</p>

<pre><code>:wq
</code></pre>

<p>Elle est très facile à mémoriser, étant la combinaison de <code>write</code> et
de <code>quit</code>.</p>

<p>Quand du temps aura passé et que vous serez prêt à en apprendre
d'autres, essayez donc les deux qui suivent:</p>

<p>Un simple <code>:x</code> permet de sauver/quitter le fichier, vous gagnez une
touche par rapport à <code>:wq</code>:</p>

<pre><code>:x
</code></pre>

<p>Suivant le layout de votre clavier, la suivante peut vous convenir plus ou
moins. C'est la seule qui soit en mode normal et non pas en mode commande,
rapide comme l'éclair, je l'adore:</p>

<pre><code>ZZ
</code></pre>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Installation du plugin Airline pour Vim - partie 4]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/01/28/installation-du-plugin-airline-pour-vim-partie-4/"/>
    <updated>2014-01-28T20:42:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/01/28/installation-du-plugin-airline-pour-vim-partie-4</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Après <a href="/blog/2014/01/25/installation-du-plugin-airline-pour-vim-partie-1/">avoir installé</a> le plugin Airline pour Vim,
après <a href="/blog/2014/01/26/installation-du-plugin-airline-pour-vim-partie-2/">avoir configuré le thème</a>,
puis <a href="/blog/2014/01/27/installation-du-plugin-airline-pour-vim-partie-3/">personnalisé quelques sections</a>,
vous pensiez en avoir fini. Mais il se peut que la branche git
n'apparaisse pas dans votre barre de statut ?
Comment faire pour que Airline affiche le nom de la branche git ?</p>

<!-- more -->


<p>En fait, il ne peut pas. Enfin pas vraiment. Airline ne fait pas tout.
Par contre il intègre très bien d'autres plugins. Et notamment
l'excellent vim-fugitive de Tim Pope. Donc, pour que Airline affiche
votre branche git, il vous suffit d'installer vim-fugitive. Par
exemple, avec Pathogen:</p>

<pre><code>git clone git://github.com/tpope/vim-fugitive.git ~/.vim/bundle/vim-fugitive
</code></pre>

<p>Et voilà.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
