<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : intermédiaire | Xavier Nayrac]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/intermediaire/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2016-08-02T17:00:16+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ruby est un peu paresseux]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/07/02/ruby-est-un-peu-paresseux/"/>
    <updated>2015-07-02T17:17:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/07/02/ruby-est-un-peu-paresseux</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Voici un mécanisme interne du langage Ruby démontré le temps d’une petite session irb.</p>

<p>D’abord, créons la variable <code>a</code>, qui va contenir la chaîne <code>"one"</code> :</p>

<p><code>irb
$ irb
&gt;&gt; a = "one"
"one"
</code></p>

<p>Créons ensuite la variable <code>b</code>, qui va contenir ce que contient la variable <code>a</code>,
c’est à dire aussi <code>"one"</code> :</p>

<p><code>irb
&gt;&gt; b = a
"one"
</code></p>

<p>Question : est ce que les variables <code>a</code> et <code>b</code> partagent le même emplacement en
mémoire ? </p>

<!-- more -->

<p>Et bien oui, <code>b = a</code> n’a pas copié la <em>valeur</em> de <code>a</code> dans <code>b</code>, mais a assigné
à <code>b</code> la même case mémoire que <code>a</code> :</p>

<p><code>irb
&gt;&gt; a.object_id == b.object_id
true
&gt;&gt; a.object_id
81895060
&gt;&gt; b.object_id
81895060
</code></p>

<p>Mais alors si on change la valeur de la variable <code>a</code>, ça va changer aussi celle
de <code>b</code> ? Et non :</p>

<p><code>irb
&gt;&gt; a = "two"
"two"
&gt;&gt; a.object_id == b.object_id
false
&gt;&gt; b
"one"
</code></p>

<p>L’emplacement mémoire a été modifié. On a maintenant deux variables bien
distinctes :</p>

<p><code>irb
&gt;&gt; a.object_id
81648680
&gt;&gt; b.object_id
81895060
</code></p>

<p>Tant qu’il n’y a pas de modification de l’une ou de l’autre des variables, Ruby
agit en quelque sorte comme si il n’y en avait qu’une seule. J’imagine que c’est
pour soulager l’utilisation de la mémoire.</p>

<p>Mais dès que l’une ou l’autre est modifiée, les deux variables deviennent bien
distinctes.</p>

<p><code>irb
&gt;&gt; exit
</code></p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Comportement inattendu de Rspec]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/06/30/comportement-inattendu-de-rspec/"/>
    <updated>2015-06-30T15:37:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/06/30/comportement-inattendu-de-rspec</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Je suis tombé aujourd’hui sur un comportement inattendu de Rspec.
Je ne dis pas que le comportement est mauvais, seulement je m’attendais à
autre chose qui me semble plus logique. Quoiqu’il en soit, je partage mes
réflexions avec vous.</p>

<!-- more -->

<p>J’utilise beaucoup Rspec que j’aime bien. Pourtant je connais assez mal sa
mécanique interne. Un pattern dont je me sers de temps
en temps est de définir des méthodes helper dans le fichier de test :</p>

<p>``` ruby spec/thing1_spec.rb
require ‘spec_helper’</p>

<p>describe Thing1 do</p>

<p>it “returns ‘foo’” do
    expect(Thing1.new.get).to eq result
  end</p>

<p>end</p>

<p>def result
  ‘foo’
end
```</p>

<p>Avec <code>Thing1</code> défini ainsi :</p>

<p><code>ruby thing1.rb
class Thing1
  def get
    'foo'
  end
end
</code></p>

<p>Ça marche très bien :</p>

<pre><code>$ rspec -I. spec/thing1_spec.rb 
.

Finished in 0.00184 seconds (files took 0.23569 seconds to load)
1 example, 0 failures
</code></pre>

<p>Là où ça devient problématique, c’est si j’utilise le même nom de méthode helper
dans un autre fichier de test :</p>

<p>``` ruby spec/thing2_spec.rb
require ‘spec_helper’</p>

<p>describe Thing2 do</p>

<p>it “returns ‘bar’” do
    expect(Thing2.new.get).to eq result
  end</p>

<p>end</p>

<p>def result
  ‘bar’
end
```</p>

<p>Avec <code>Thing2</code> comme ceci :</p>

<p><code>ruby thing2.rb
class Thing2
  def get
    'bar'
  end
end
</code></p>

<p>Dans ce cas un test échoue :</p>

<pre><code>$ rspec -I.
F.

Failures:

  1) Thing1 returns 'foo'
     Failure/Error: expect(Thing1.new.get).to eq result
       
       expected: "bar"
            got: "foo"
       
       (compared using ==)
     # ./spec/thing1_spec.rb:6:in `block (2 levels) in &lt;top (required)&gt;'

Finished in 0.00232 seconds (files took 0.21784 seconds to load)
2 examples, 1 failure

Failed examples:

rspec ./spec/thing1_spec.rb:5 # Thing1 returns 'foo'
</code></pre>

<p>J’ai tenté de les jouer de différentes manières : seulement l’un, puis
seulement l’autre, Thing1 puis Thing2, Thing2 puis Thing1, pour voir…</p>

<p>J’en arrive à la conclusion que Rspec charge tous les fichiers de test avant de
démarrer un test. Comme Ruby est dynamique, c’est la dernière méthode <code>result</code> chargée qui, en quelque sorte, à raison.</p>

<p>La solution est donc simple, il faut <em>rentrer</em> les méthodes helper dans le
bloc <code>describe</code> :</p>

<p>``` ruby
require ‘spec_helper’</p>

<p>describe Thing1 do</p>

<p>it “returns ‘foo’” do
    expect(Thing1.new.get).to eq result
  end</p>

<p>def result
    ‘foo’
  end</p>

<p>end
```</p>

<p>Maintenant les deux tests fonctionnent comme attendu :</p>

<pre><code>$ rspec -I.
..

Finished in 0.00283 seconds (files took 0.21533 seconds to load)
2 examples, 0 failures
</code></pre>

<p><strong>Je m’attendais à ce que les différents fichiers de test soient joués en
isolation totale</strong>, sans connexion si mince soit elle avec d’autres fichiers.
Manifestement c’est pas le cas.</p>

<p>Pour être exhaustif voici le contenu du <em>spec helper</em> :</p>

<p><code>ruby spec/spec_helper.rb
require 'thing1'
require 'thing2'
</code></p>

<p>Et voici les fichiers :</p>

<pre><code>$ \tree
.
|-- spec
|   |-- spec_helper.rb
|   |-- thing1_spec.rb
|   `-- thing2_spec.rb
|-- thing1.rb
`-- thing2.rb
</code></pre>

<p>Si vous avez un avis sur la question il m’intéresse beaucoup, n’hésitez donc pas à laisser un
commentaire.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Le hack FizzBuzz en Ruby]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/04/30/le-hack-fizzbuzz-en-ruby/"/>
    <updated>2015-04-30T17:07:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/04/30/le-hack-fizzbuzz-en-ruby</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Voici ce qui trainait sur le net aujourd’hui, un jeu de
<a href="http://en.wikipedia.org/wiki/Fizz_buzz">FizzBuzz</a> en une ligne de Ruby:</p>

<p><code>ruby
1.upto(100){|n|puts'FizzBuzz '[o=n**4%-15,o+13]||n}
</code></p>

<p>Ce qui donne:</p>

<p><code>bash
ruby -e "1.upto(100){|n|puts'FizzBuzz '[o=n**4%-15,o+13]||n}"
1
2
Fizz
4
Buzz 
Fizz
7
8
Fizz
Buzz 
11
.
.
.
94
Buzz 
Fizz
97
98
Fizz
Buzz 
</code></p>

<p>Pour celles et ceux qui ne pigent pas cette ligne de code Ruby, on va la
déconstruire petit à petit.</p>

<!-- more -->

<p>Nous avons affaire à une boucle (j’ai remplacé les <code>{}</code> par <code>do end</code>):</p>

<p><code>ruby
1.upto(100) do |n|
  puts'FizzBuzz '[o=n**4%-15,o+13]||n
end
</code></p>

<p><code>a.upto(b)</code> itère de <code>a</code> jusqu’à <code>b</code>:</p>

<p><code>irb
$ irb
&gt;&gt; 10.upto(12) do |iteration|
?&gt;   puts iteration
&gt;&gt; end
10
11
12
</code></p>

<p>Regardons de plus près l’intérieur de la boucle, là où c’est intéressant.
Ruby permet d’appeler les
méthodes sans utiliser de parenthèses. Ici je les ai simplement rajouter pour
tenter de clarifier le code:</p>

<p><code>ruby
1.upto(100) do |n|
  puts( 'FizzBuzz '[o=n**4%-15,o+13]||n )
end
</code></p>

<p>Maintenant qu’on est bien sûr qu’il s’agit de la méthode <code>puts</code> avec un
argument bizarre dedans, je sépare les différents éléments de la <em>grammaire de
Ruby</em> par des espaces. Toujours pour essayer d’y voir plus clair:</p>

<p><code>ruby
1.upto(100) do |n|
  puts( 'FizzBuzz '[o = n ** 4 % -15, o + 13] || n )
end
</code></p>

<p>Arrêtons nous un peu sur les sous-ensembles de chaîne <code>[a, b]</code>.
Le premier chiffre est la position de départ, le second est le nombre de
caractères:</p>

<p><code>irb
$ irb
&gt;&gt; "abcdef"[0, 2]
"ab"
&gt;&gt; "abcdef"[3, 2]
"de"
</code></p>

<p>Ruby permet de donner une position de départ pas rapport à la fin:</p>

<p><code>irb
&gt;&gt; "abcdef"[-4, 2]
"cd"
</code></p>

<p>Pour la suite, notez bien que si on va chercher des caractères <strong>avant</strong> le début ou <strong>après</strong> la fin de la chaîne, on se retrouve avec <code>nil</code>. Ça n’est pas une erreur, c’est le comportement attendu:</p>

<p><code>irb
&gt;&gt; "abcdef"[-123, 2]
nil
&gt;&gt; "abcdef"[999, 2]
nil
</code></p>

<p>Maintenant essayons de décrypter la formule mathématique.
Utilisons une variable temporaire pour l’isoler:</p>

<p><code>ruby
1.upto(100) do |n|
  o = n ** 4 % -15
  puts( 'FizzBuzz '[o, o + 13] || n )
end
</code></p>

<p>En Ruby, <code>**</code> est l’opérateur de puissance:</p>

<p><code>irb
$ irb
&gt;&gt; 10 ** 2
100
&gt;&gt; 10 ** 3
1000
&gt;&gt; 10 ** 4
10000
</code></p>

<p>Quant à <code>%</code>, c’est l’opérateur de la division modulaire, souvent appelé
<em>modulo</em>. Si vous avez plein de temps devant vous il y a la page wikipédia sur
<a href="http://fr.wikipedia.org/wiki/Arithm%C3%A9tique_modulaire">l’arithmétique modulaire</a>.
Sinon voici une explication rapide du modulo: <strong>c’est le reste de la division
entière</strong>. Donc <code>9 % 4 == 1</code>.</p>

<p>Sauf qu’ici on utilise le modulo avec un nombre négatif. Et là les maths se
compliquent un peu, et surtout différents langages de programmation auront différents
comportements.</p>

<p>Essayons plutôt de <em>sentir</em> la formule en l’appliquant aux nombres de 1 à 16:</p>

<p><code>irb
$ irb
&gt;&gt; (1..16).each do |n|
?&gt;   o = n ** 4 % -15
&gt;&gt;   puts "#{n} =&gt; #{o}"
&gt;&gt; end
1 =&gt; -14
2 =&gt; -14
3 =&gt; -9
4 =&gt; -14
5 =&gt; -5
6 =&gt; -9
7 =&gt; -14
8 =&gt; -14
9 =&gt; -9
10 =&gt; -5
11 =&gt; -14
12 =&gt; -9
13 =&gt; -14
14 =&gt; -14
15 =&gt; 0
16 =&gt; -14
</code></p>

<p>J’imagine qu’à ce moment précis, vous êtes plusieurs à crier <strong>«Ha ha !»</strong>.</p>

<p>Cette formule, en Ruby, a donc 4 solutions possibles:</p>

<ul>
  <li>Quand <em>n</em> est un multiple de 3, la solution est <strong>-9</strong>.</li>
  <li>Quand <em>n</em> est un multiple de 5, la solution est <strong>-5</strong>.</li>
  <li>Quand <em>n</em> est un multiple de 15 (c’est à dire à la fois multiple de 3 et de
9), la solution est <strong>0</strong>.</li>
  <li>Dans les autres cas, la solution est <strong>-14</strong>.</li>
</ul>

<p>Voyons ce qu’il se passe avec <code>'FizzBuzz '</code> quand <code>o</code> vaut respectivement -9, -5, 0 puis -14:</p>

<p><code>irb
$ irb
&gt;&gt; 'FizzBuzz '[-9, -9 + 13]
"Fizz"
&gt;&gt; 'FizzBuzz '[-5, -5 + 13]
"Buzz "
&gt;&gt; 'FizzBuzz '[0, 13]
"FizzBuzz "
&gt;&gt; 'FizzBuzz '[-14, -14 + 13]
nil
</code></p>

<p>Peut-être vous demandez vous pourquoi il y a un espace après FizzBuzz ?
En pratique, voici la raison:</p>

<p><code>irb
&gt;&gt; 'FizzBuzz'[-9, -9 + 13]
nil
&gt;&gt; 'FizzBuzz'[-5, -5 + 13]
"zBuzz"
</code></p>

<p>En théorie, je vous laisse faire les calculs ;)</p>

<p>Pour finir, il reste à expliquer le <code>||</code>, un exemple vaut mieux qu’un long
discours:</p>

<p><code>irb
&gt;&gt; "foo" || 13
"foo"
&gt;&gt; nil || 13
13
</code></p>

<p>Voilà, si vous voulez ajouter d’autres explications, les commentaires sont fait
pour ça ;)</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Une machine de Turing en Ruby - La routine de copie]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/02/04/une-machine-de-turing-en-ruby-la-routine-de-copie/"/>
    <updated>2015-02-04T10:22:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/02/04/une-machine-de-turing-en-ruby-la-routine-de-copie</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>La routine de copie est une brique élémentaire d’un programme pour une machine
de Turing. Par exemple, si les données de la bande sont <code>111</code>, la routine de
copie va doubler ces trois symboles en insérant un zéro au milieu: <code>1110111</code>.</p>

<p><img class="center" src="/images/copie-clone.jpg"></p>

<!-- more -->

<p>Je ne vais pas expliquer la routine de copie
— <a href="http://en.wikipedia.org/wiki/Turing_machine_examples#A_copy_subroutine">cet article de Wikipédia</a>
le fait très bien — mais plutôt montrer comment j’ai du adapter
<a href="https://github.com/lkdjiin/turing_machine">ma machine de Turing</a>
pour pouvoir faire tourner cette routine.</p>

<p>Voici le jeu d’instructions de la routine de copie:</p>

<p><code>raw copy_with_data
0 A  =&gt; 1 L B
0 B  =&gt; 1 N s1
0 s1 =&gt; N N HALT
1 s1 =&gt; 0 R s2
0 s2 =&gt; 0 R s3
1 s2 =&gt; 1 R s2
0 s3 =&gt; 1 L s4
1 s3 =&gt; 1 R s3
0 s4 =&gt; 0 L s5
1 s4 =&gt; 1 L s4
0 s5 =&gt; 1 R s1
1 s5 =&gt; 1 L s5
</code></p>

<p>C’est en deux parties, les deux premières lignes écrivent des données sur la
bande (le nombre <code>11</code>) et les neuf dernières lignes sont effectivement la
routine de copie. Une des limitations actuelles de ma machine de Turing est de
ne pas pouvoir initialiser la bande avec des données spécifiques, il faut donc
le faire depuis le programme, comme ici les deux premières lignes.</p>

<p>Les nouveautés dans ce jeu d’instructions sont les caractères <code>N</code>, qu’on peut
trouver dans les symboles à écrire et dans le mouvement de la tête de lecture,
par exemple dans la 3ème ligne:</p>

<pre><code>0 s1 =&gt; N N HALT
</code></pre>

<p>Cela signifie pas d’écriture et pas de mouvement (<strong>N</strong>o write, <strong>N</strong>o move).</p>

<p>Le parser étant déjà capable d’attraper n’importe quel mot/symbole, il suffit de
faire évoluer la méthode de mise à jour de la bande ainsi (c’est un peu lourd
comme écriture mais ça reste clair et pragmatique):</p>

<p>``` ruby lib/turing_machine/instance.rb
module TuringMachine</p>

<p>class Instance</p>

<p>[…]</p>

<pre><code>def update_tape(current_action)
  @tape.head = current_action[:write] unless current_action[:write] == 'N'
  @tape.shift_left if current_action[:move] == 'L'
  @tape.shift_right if current_action[:move] == 'R'
end
</code></pre>

<p>[…]
```</p>

<p>Et maintenant la routine de copie fonctionne !</p>

<pre><code>$ turing_machine instruction_sets/copy_with_data
  1 0000000000000000000000000000000000000000 A -&gt; 1LB
                       ^
  2 0000000000000000000100000000000000000000 B -&gt; 1Ns1
                      ^
  3 0000000000000000001100000000000000000000 s1 -&gt; 0Rs2
                      ^
  4 0000000000000000000100000000000000000000 s2 -&gt; 1Rs2
                       ^
  5 0000000000000000000100000000000000000000 s2 -&gt; 0Rs3
                        ^
  6 0000000000000000000100000000000000000000 s3 -&gt; 1Ls4
                         ^
  7 0000000000000000000101000000000000000000 s4 -&gt; 0Ls5
                        ^
  8 0000000000000000000101000000000000000000 s5 -&gt; 1Ls5
                       ^
  9 0000000000000000000101000000000000000000 s5 -&gt; 1Rs1
                      ^
 10 0000000000000000001101000000000000000000 s1 -&gt; 0Rs2
                       ^
 11 0000000000000000001001000000000000000000 s2 -&gt; 0Rs3
                        ^
 12 0000000000000000001001000000000000000000 s3 -&gt; 1Rs3
                         ^
 13 0000000000000000001001000000000000000000 s3 -&gt; 1Ls4
                          ^
 14 0000000000000000001001100000000000000000 s4 -&gt; 1Ls4
                         ^
 15 0000000000000000001001100000000000000000 s4 -&gt; 0Ls5
                        ^
 16 0000000000000000001001100000000000000000 s5 -&gt; 1Rs1
                       ^
 17 0000000000000000001101100000000000000000 s1 -&gt; NNHALT
                        ^
 18 0000000000000000001101100000000000000000 HALT
</code></pre>

<p>Le code est <a href="https://github.com/lkdjiin/turing_machine">sur Github</a>, à plus tard.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Une machine de Turing en Ruby]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/02/01/une-machine-de-turing-en-ruby/"/>
    <updated>2015-02-01T10:11:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/02/01/une-machine-de-turing-en-ruby</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Avec le film <em>Imitation Game</em> sorti récemment, Alan Turing, qu’on peut considérer
comme un père fondateur de l’informatique, fait l’actualité.
Je vous propose, dans cet article, de réaliser une machine de Turing en Ruby.</p>

<p><img class="center" src="/images/alan-turing2.jpg"></p>

<!-- more -->

<h2 id="dfinition-de-la-machine-de-turing">Définition de la machine de Turing</h2>

<p>Ma définition personnelle sera la suivante:</p>

<p><strong>Une machine de Turing est une machine imaginaire et hyper-minimale, pouvant
faire tourner un algorithme.</strong></p>

<p>Si vous ressentez le besoin d’une définition plus formelle, les articles de
Wikipédia, en <a href="http://en.wikipedia.org/wiki/Turing_machine">anglais</a>
et en <a href="http://fr.wikipedia.org/wiki/Machine_de_Turing">français</a>
sont très bien fourni. Il y a aussi une présentation sympathique de la machine de
Turing dans une petite <a href="http://videotheque.cnrs.fr/doc=3001">vidéo en français</a>
de 7 minutes, par le CNRS.</p>

<p>Dans la suite de l’article, je prends comme hypothèse que vous savez ce qu’est
une machine de Turing. Si ça n’est pas le cas, ou si vous avez besoin de vous
rafraichir la mémoire, n’hésitez pas à visiter les liens précédents.</p>

<h2 id="on-fait-une-gem-">On fait une gem ?</h2>

<p>À terme, j’aimerais un programme qui puisse faire tourner n’importe quel jeu
d’instructions. Mais pour un premier jet, concret, rapidement réalisable, et
malgré tout intéressant,
on va faire tourner un <a href="http://en.wikipedia.org/wiki/Busy_beaver">busy beaver</a>
à 3 états.</p>

<p>Deux trucs à noter:</p>

<ol>
  <li><em>Busy beaver à 3 états</em> ça peut faire peur. Je vous assure qu’il n’y a pas
de quoi. C’est un algorithme relativement simple.</li>
  <li><em>Busy beaver</em> se traduit par <em>castor affairé</em>, c’est bien la preuve qu’il n’y
a pas de quoi avoir peur.</li>
</ol>

<p>Comme je veux une structure bien claire dès le départ, et pas un script vite
fait qu’on aura toutes les peines du monde à étendre, je vais faire une gem:</p>

<pre><code>$ bundle gem turing_machine -btV
      create  turing_machine/Gemfile
      create  turing_machine/Rakefile
      create  turing_machine/LICENSE.txt
      create  turing_machine/README.md
      create  turing_machine/.gitignore
      create  turing_machine/turing_machine.gemspec
      create  turing_machine/lib/turing_machine.rb
      create  turing_machine/lib/turing_machine/version.rb
      create  turing_machine/bin/turing_machine
      create  turing_machine/.rspec
      create  turing_machine/spec/spec_helper.rb
      create  turing_machine/spec/turing_machine_spec.rb
      create  turing_machine/.travis.yml
Initializing git repo in /home/xavier/devel/ruby/turing_machine
</code></pre>

<p>Vous pouvez trouver le code sur Github : <a href="https://github.com/lkdjiin/turing_machine">lkdjiin/turing_machine</a>.</p>

<h2 id="objectif-de-la-premire-version">Objectif de la première version</h2>

<p>Mon objectif est d’obtenir cette sortie quand je lance le programme
<code>turing_machine</code>:</p>

<pre><code>$ turing_machine 
  1 0000000000 A -&gt; 1RB
        ^
  2 0000100000 B -&gt; 1LA
         ^
  3 0000110000 A -&gt; 1LC
        ^
  4 0000110000 C -&gt; 1LB
       ^
  5 0001110000 B -&gt; 1LA
      ^
  6 0011110000 A -&gt; 1RB
     ^
  7 0111110000 B -&gt; 1RB
      ^
  8 0111110000 B -&gt; 1RB
       ^
  9 0111110000 B -&gt; 1RB
        ^
 10 0111110000 B -&gt; 1RB
         ^
 11 0111110000 B -&gt; 1LA
          ^
 12 0111111000 A -&gt; 1LC
         ^
 13 0111111000 C -&gt; 1RHALT
        ^
 14 0111111000 HALT
         ^
</code></pre>

<p>Explication d’une ligne de la sortie:</p>

<pre><code>  5 0001110000 B -&gt; 1LA
      ^ - Le `5` est le numéro de la séquence. - La suite de `0` et de `1` est le ruban. - Le `^` est la position de la tête de lecture. - Le `B` est l'état courant. - La fin, ici `1LA`, est la prochaine instruction à exécuter.
</code></pre>

<p>Une instruction est composé a) du symbole à écrire, b) du mouvement de la
tête de lecture et, c) du nouvel état. Par exemple <code>1LA</code> signifie: écrire <code>1</code>,
bouger la tête de lecture à gauche (<code>L</code>) et passer dans l’état <code>A</code>.</p>

<h2 id="une-classe-pour-le-ruban-et-la-tte-de-lecture">Une classe pour le ruban et la tête de lecture</h2>

<p>On commence par une classe <code>Tape</code> (ruban), que je combine avec <code>head</code> (tête de
lecture) pour aller plus vite.</p>

<p>``` ruby
class Tape</p>

<p>def initialize
    @symbols = Array.new(10) { ‘0’ }
    @index = 4
  end</p>

<p>attr_reader :index</p>

<p>def head
    @symbols[@index]
  end</p>

<p>def head=(symbol)
    @symbols[@index] = symbol
  end</p>

<p>def shift_left
    @index -= 1
  end</p>

<p>def shift_right
    @index += 1
  end</p>

<p>def to_s
    @symbols.join
  end
end
```</p>

<p>Il faut noter qu’une machine de Turing possède un ruban avec un nombre infini
de cellules. Ici ça n’est pas le cas puisqu’il n’y en a que 10. C’est un
raccourci qui permet d’aller plus vite, de garder le code simple, et 10 cellules
sont largement suffisantes pour le <em>busy beaver à 3 états</em>.</p>

<p><img class="center" src="/images/castor2.png"></p>

<h2 id="une-classe-pour-le-registre-dtat">Une classe pour le registre d’état</h2>

<p>Avoir une classe dédiée à conserver l’état peut sembler
<a href="http://fr.wikipedia.org/wiki/Overkill">overkill</a>. Et pour être honnête, je dois
dire que ça l’est certainement. Une simple variable aurait été suffisante pour
cette première version. Mais bon, je suis sûr que cette classe sera bientôt
utile ;)</p>

<p>``` ruby
class StateRegister</p>

<p>def initialize(state)
    @state = state
  end</p>

<p>def current
    @state
  end</p>

<p>def change(new_state)
    @state = new_state
  end</p>

<p>def to_s
    @state.to_s
  end
end
```</p>

<h2 id="une-classe-pour-la-table-dinstructions">Une classe pour la table d’instructions</h2>

<p>Ici aussi, j’aurais pu (du ?) faire appel au
<a href="http://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it">YAGNI</a>.
Un simple hash pourrait faire l’affaire pour l’instant.</p>

<p>``` ruby
class Instruction</p>

<p>def initialize(table)
    @table = table
  end</p>

<p>def for(symbol, state)
    @table[[symbol, state]]
  end</p>

<p>end
```</p>

<h2 id="une-instance-dune-machine-de-turing">Une instance d’une machine de Turing</h2>

<p>Les trois petites classes ci-dessus vont se combiner à l’intérieur de la
classe <code>Instance</code> suivante, pour simuler une machine de Turing. Même si elle
est un peu plus complexe que les précédentes, cette classe reste malgré tout
très simple.</p>

<p>``` ruby
class Instance</p>

<p>def initialize(instructions, initial_state)
    @instruction = Instruction.new(instructions)
    @state = StateRegister.new(initial_state)
    @tape = Tape.new
    @sequence = 1
  end</p>

<p>def to_s
    “#{‘%3d’ % @sequence} #{@tape} #{@state}#{instr_to_s}\n    “ +
    ‘ ‘ * @tape.index + ‘^’
  end</p>

<p>def proceed
    current = action
    update_sequence
    update_tape(current)
    update_state(current)
  end</p>

<p>def halted?
    @state.current == ‘HALT’
  end</p>

<p>private</p>

<p>def update_sequence
    @sequence += 1
  end</p>

<p>def update_tape(current_action)
    @tape.head = current_action[:write]
    current_action[:move] == ‘L’ ? @tape.shift_left : @tape.shift_right
  end</p>

<p>def update_state(current_action)
    @state.change(current_action[:next_state])
  end</p>

<p>def action
    @instruction.for(@tape.head, @state.current)
  end</p>

<p>def instr_to_s
    if halted?
      ‘’
    else
      “ -&gt; “ + action[:write] + action[:move] + action[:next_state]
    end
  end
end
```</p>

<h2 id="le-binaire">Le binaire</h2>

<p>Enfin quand je dis le binaire c’est un abus de langage puisque ça reste un
fichier texte ;) Quoiqu’il en soit voici le programme <code>turing_machine</code> qui
implémente le <em>busy beaver à 3 états</em>.</p>

<p>``` ruby bin/turing_machine
#!/usr/bin/env ruby</p>

<p>require ‘turing_machine’</p>

<p>include TuringMachine</p>

<p>instructions = {
  [‘0’, ‘A’] =&gt; {write: ‘1’, move: ‘R’, next_state: ‘B’},
  [‘1’, ‘A’] =&gt; {write: ‘1’, move: ‘L’, next_state: ‘C’},
  [‘0’, ‘B’] =&gt; {write: ‘1’, move: ‘L’, next_state: ‘A’},
  [‘1’, ‘B’] =&gt; {write: ‘1’, move: ‘R’, next_state: ‘B’},
  [‘0’, ‘C’] =&gt; {write: ‘1’, move: ‘L’, next_state: ‘B’},
  [‘1’, ‘C’] =&gt; {write: ‘1’, move: ‘R’, next_state: ‘HALT’},
}</p>

<p>initial_state = ‘A’</p>

<p>instance = Instance.new(instructions, initial_state)</p>

<p>loop do
  puts instance.to_s
  break if instance.halted?
  instance.proceed
end
```</p>

<p>Cette version (<a href="https://github.com/lkdjiin/turing_machine">voir le code complet</a>) est juste une mise en train. Il faudrait maintenant disposer
d’un ruban infini et pouvoir entrer n’importe quel jeu d’instructions.</p>

<p>À plus tard.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
