<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : intermédiaire | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/intermediaire/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2013-11-09T18:43:38+01:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Une regex pour savoir si un nombre est premier]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/11/05/une-regex-pour-savoir-si-un-nombre-est-premier/"/>
    <updated>2013-11-05T16:55:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/11/05/une-regex-pour-savoir-si-un-nombre-est-premier</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Aujourd'hui je traduis (approximativement) un article de 2007 qui m'a fasciné:
<a href="http://www.noulakaz.net/weblog/2007/03/18/a-regular-expression-to-check-for-prime-numbers/">A regular expression to check for prime numbers</a>.</p>

<!-- more -->


<p>Les regexs sont très puissantes. C'est un truc que je lis une ou deux fois par
jour sur le web.</p>

<p>Pendant que j'étais sur le net aujourd'hui, je suis tombé sur
<a href="http://montreal.pm.org/tech/neil_kandalgaonkar.shtml">cette page</a>
qui décrit minutieusement la regex <code>/^1?$|^(11+?)\1+$/</code> en Perl pour voir
si un nombre est premier ou non !</p>

<p>Pour être franc, j'étais sceptique. La regex semble être magique ! Et je
voulais la comprendre mieux. Je l'ai réécrite en Ruby, pour la tester:</p>

<p>``` irb
[~]⇒ irb</p>

<blockquote><blockquote><p>def prime?(n)
  (&ldquo;1&rdquo; * n) !~ /^1?$|^(11+?)\1+$/
end
=>
prime? 10
=> false
prime? 11
=> true
prime? 12
=> false
prime? 13
=> true
prime? 99
=> false
prime? 100
=> false
prime? 101
=> true
```</p></blockquote></blockquote>

<p>Cool ! Ça marche aussi en Ruby ! Ce qui veut dire qu'il n'y a aucune magie
due à Perl. La regex fonctionne vraiment. Mais comment ? Essayons de la
décortiquer.</p>

<h2>Est-ce-que 7 est un nombre premier ?</h2>

<p>Pour le savoir, la méthode génère &ldquo;1111111&rdquo; et regarde si cette chaîne
<strong>ne correspond pas</strong> avec <code>/^1?$|^(11+?)\1+$/</code>. Si il n'y a pas
correspondance, alors le nombre est premier.</p>

<p>Notez que la regex a deux parties (séparées par une barre verticale <code>|</code>).</p>

<p>La première partie <code>/^1?$/</code> est triviale, et cherche une correspondance
avec un début de ligne (<code>^</code>), un 1 optionel (<code>1?</code>) et une fin de ligne
(<code>$</code>), ce qui implique une chaîne vide ou &ldquo;1&rdquo;. Donc l'appel de cette
méthode quand n vaut 0 ou 1 renverra false, le bon résultat.</p>

<p>La seconde partie est plus… magique…</p>

<p><code>/^(11+?)\1+$/</code> cherche une correspondance avec un début de ligne (<code>^</code>)
puis <code>11+?</code> puis <code>\1+</code> et finalement une fin de ligne (<code>$</code>).
Je suppose que vous savez que <code>\1</code> est une variable attachée à ce qui a été
mis en correspondance précédement (dans notre cas avec <code>11+?</code>).</p>

<p>Allons y lentement…</p>

<p><code>(11+?)</code> fait deux choses:</p>

<ol>
<li>Il cherche une correspondance avec un &ldquo;1&rdquo; suivi par un ou plusieurs autres
&ldquo;1&rdquo; <strong>de façon minimale</strong>. Ce qui signifie qu'on aura une correspondance
avec &ldquo;11&rdquo; la première fois (notez que si il n'y avait pas de <code>?</code> dans
<code>(11+?)</code> c'est la chaîne entière qui serait mise en correspondance).</li>
<li>La chaîne obtenue (&ldquo;11&rdquo; la première fois) est attachée à la variable <code>\1</code>.</li>
</ol>


<p><code>\1+</code> cherche alors une correspondance avec ce qu'on a obtenu avant (&ldquo;11&rdquo;
la première fois) <strong>de manière répétitive, une ou plusieurs fois</strong>.
Si une correspondance est trouvée, alors le nombre n'est pas premier.</p>

<p>Si vous suivez jusqu'ici, vous avez peut-être réalisé que cela éliminait tout
les nombres pairs, excepté 2 (par exemple, 8 est &ldquo;11111111&rdquo; and donc <code>(11+?)</code>
va correspondre avec &ldquo;11&rdquo; et <code>\1+</code> va correspondre avec &ldquo;111111&rdquo;).</p>

<p>Pour les nombres impairs (7 dans notre cas), le <code>(11+?)</code> correspond à &ldquo;11&rdquo;
la première fois mais <code>\1+$</code> ne peut pas être vrai (notez le <code>$</code>) puisqu'il
reste cinq &ldquo;1&rdquo;. Le moteur de regexp va <strong>revenir en arrière</strong> et <code>(11+?)</code>
va alors correspondre avec &ldquo;111&rdquo; et là aussi, <code>\1+$</code> sera faux puisqu'il
reste quatre &ldquo;1&rdquo; (et à ce moment là, <code>\1+$</code> ne peut correspondre qu'avec un
nombre de &ldquo;1&rdquo; qui est multiple de 3, suivi par une fin de ligne), etc…
D'où le fait que &ldquo;1111111&rdquo; ne correspondra jamais avec la regex, ce qui
implique que 7 est un nombre premier.</p>

<p>[&hellip;] Voyons ce qu'il se passe avec 9, qui n'est pas un nombre premier:
&ldquo;1&rdquo; * 9 devrait correspondre avec la regex.</p>

<p>&ldquo;1&rdquo; * 9 = &ldquo;111111111&rdquo;. <code>(11+?)</code> correspond initialement à &ldquo;11&rdquo;. <code>\1+$</code> ne
peut être mis en correspondance puisqu'il reste 7 &ldquo;1&rdquo;. Quand le moteur de
regex repart en arrière, <code>(11+?)</code> correspond alors avec &ldquo;111&rdquo;. Et cette
fois <code>\1+$</code> correspond aux 6 &ldquo;1&rdquo; restants ! D'où 9 n'est pas premier.</p>

<p>Simple et beau en même temps.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Écrire une fonction Vim avec Ruby]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/11/04/ecrire-une-fonction-vim-avec-ruby/"/>
    <updated>2013-11-04T17:01:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/11/04/ecrire-une-fonction-vim-avec-ruby</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Parfois, pas besoin de faire appel à un plugin, une simple petite fonction
suffit pour ce qu'on veut faire. Mais il faut avouer que le Vim Script est
un langage qui est loin de faire l'unanimité. Si on pouvait faire appel
à Ruby (ou Python, etc) pour écrire en partie nos fonctions Vim, ce serait
cool, non ?</p>

<!-- more -->


<h2>Un cas d'utilisation simple</h2>

<p>Prenons un cas habituel: supprimer les espaces en fin de ligne dans tout un
fichier. Pour cela il nous suffit d'écrire directement dans Vim:</p>

<p><code>vim
:%s/\s\+$//
</code></p>

<p>Mouais… Ça fonctionne, c'est sûr. Mais j'ai deux petits problèmes:</p>

<ol>
<li>Je ne veux pas taper ça à chaque fois, parce qu'il faut que je me
concentre un minimum pour bien écrire une regex, même si là y a pas
de quoi fouetter un chat. En même temps, ça ne vaut pas le coup
d'écrire un plugin juste pour ça.</li>
<li>Y'a rien à faire, je ne me rappelle jamais comment fonctionnent les
regex Vim, quels sont les méta-caractères et tout et tout. 9 fois
sur 10 j'oublierais par exemple d'échapper le <code>+</code>.</li>
</ol>


<h2>Une fonction Vim</h2>

<p>Si ça ne vaut pas un plugin, ça vaut bien une petite fonction à mettre,
par exemple, dans son <code>.vimrc</code>:</p>

<p><code>vim
function RemoveTrailingSpaces()
  %s/\s\+$//
endfunction
</code></p>

<p>Maintenant, on peut appeler notre fonction ainsi:</p>

<p><code>vim
:call RemoveTrailingSpaces()
</code></p>

<p>Ou bien la mapper sur une touche, si on l'utilise souvent:</p>

<p><code>vim
map &lt;Leader&gt;r :call RemoveTrailingSpaces()&lt;Enter&gt;
</code></p>

<p>Premier problème réglé, au suivant.</p>

<h2>Utiliser Ruby dans une fonction Vim</h2>

<p>Il faut bien sûr que votre Vim ait été compilé avec le support de Ruby.
Pour le savoir vous pouvez taper la ligne suivante dans votre console,
si &ldquo;+ruby&rdquo; s'affiche, c'est bon:</p>

<p><code>bash
[~]⇒ vim --version | grep --color -i \+ruby
+printer +profile +python -python3 +quickfix +reltime +rightleft +ruby
</code></p>

<p>Voilà ce que donnerait notre fonction en utilisant Ruby:</p>

<p><code>vim
function RemoveTrailingSpaces()
  rubydo gsub /\s+$/, ''
endfunction
</code></p>

<p>C'est tout, <code>rubydo</code> suivi de l'instruction en Ruby !  Et vous, vous auriez des
petites astuces de ce genre à partager ?</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les algorithmes génétiques démystifiés 36]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/10/22/les-algorithmes-genetiques-demystifies-36/"/>
    <updated>2013-10-22T08:25:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/10/22/les-algorithmes-genetiques-demystifies-36</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Il reste à voir deux fonctions <em>techniques</em> pour faire tourner notre
programme: la copie d'un individu et le rendu d'une image. Je les appelle
<em>techniques</em> car elles n'ont rien à voir avec l'algorithme lui-même. La
copie d'un individu est rendue nécessaire par le langage utilisé, Javascript,
et le rendu d'une image est nécessaire puisqu'on veut …et bien… afficher
des images, quoi…</p>

<!-- more -->


<p>Voyons d'abord la copie d'un individu:</p>

<p>``` javascript
function copy(individual) {
  var indiCopy = [];
  for(var i = 0; i &lt; TOTAL_SQUARES; i++) {</p>

<pre><code>var objectCopy = {},
    prop;
for(prop in individual[i]) {
  objectCopy[prop] = individual[i][prop];
}
indiCopy.push(objectCopy);
</code></pre>

<p>  }
  return indiCopy;
}
```</p>

<p>Un individu est un tableau, contenant des objets, chaque objets contenants
des propriétés… <em>Là, je m'interroge et je demande l'avis de spécialistes:
est-ce-qu'il ne vaudrait pas mieux utiliser une librairie pour faire ça,
comme jQuery ou Underscore.js ?</em></p>

<p>Maintenant le rendu d'une image:</p>

<p>``` javascript
function renderIndividual(individual, ctx) {
  ctx.fillStyle = &ldquo;white&rdquo;;
  ctx.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);
  for (var i = 0; i &lt; TOTAL_SQUARES; i++) {</p>

<pre><code>ctx.globalAlpha = individual[i].alpha;
ctx.fillStyle = 'rgb(' + individual[i].red + ',' +
  individual[i].green + ',' + individual[i].blue + ')';
ctx.fillRect(individual[i].x, individual[i].y,
  individual[i].size, individual[i].size);
</code></pre>

<p>  }
}
```</p>

<p><code>ctx</code> est un contexte de Canvas. Je vois ça tout simplement comme un objet
dans lequel on peut dessiner. Tout d'abord on <em>efface</em> l'image en la
remplissant de blanc:</p>

<pre><code>ctx.fillStyle = "white";
ctx.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);
</code></pre>

<p>Puis on dessine chacuns des carrés:</p>

<pre><code>for (var i = 0; i &lt; TOTAL_SQUARES; i++) {
</code></pre>

<p>Pour chaque carré il faut sélectionner sa transparence:</p>

<pre><code>ctx.globalAlpha = individual[i].alpha;
</code></pre>

<p>Puis sa couleur:</p>

<pre><code>ctx.fillStyle = 'rgb(' + individual[i].red + ',' +
  individual[i].green + ',' + individual[i].blue + ')';
</code></pre>

<p>On peut alors dessiner un carré:</p>

<pre><code>ctx.fillRect(individual[i].x, individual[i].y,
  individual[i].size, individual[i].size);
</code></pre>

<p>Voilà. Reste à voir maintenant le programme dans son ensemble. Voici les
fichiers HTML et CSS:</p>

<p>``` html
&lt;!DOCTYPE html>
<html lang="fr">
  <head></p>

<pre><code>&lt;meta charset="utf-8" /&gt;
&lt;link rel="stylesheet" type="text/css" href="picture.css" /&gt; 
</code></pre>

<p>  </head>
  <body></p>

<pre><code>&lt;canvas width="400" height="400" id="canvas1"&gt;&lt;/canvas&gt;
&lt;canvas width="400" height="400" id="canvas2"&gt;&lt;/canvas&gt;
&lt;p id="generation"&gt;0&lt;/p&gt;
&lt;p id="quality"&gt;0&lt;/p&gt;
&lt;script src="picture.js"&gt;&lt;/script&gt;
</code></pre>

<p>  </body>
</html>
```</p>

<p>``` css
body {
  background-color: #222;
}</p>

<p>p {
  color: #ccc;
}
```</p>

<p>Et voici le programme Javascript complet:</p>

<p>``` javascript
var canvasImgOrigin = document.getElementById(&lsquo;canvas1&rsquo;);
var canvasGenetic = document.getElementById(&lsquo;canvas2&rsquo;);
var ctxOrigin = canvas1.getContext(&lsquo;2d&rsquo;);
var ctx = canvas2.getContext(&lsquo;2d&rsquo;);
var TOTAL_SQUARES = 400;
var IMAGE_WIDTH = 400;
var IMAGE_HEIGHT = 400;
var SQUARE_MAX_SIZE = 40;
var img = new Image();
var generation = 0;
var htmlGeneration = document.getElementById(&ldquo;generation&rdquo;);
var htmlQuality = document.getElementById(&ldquo;quality&rdquo;);
var solution = [];
var canvasBuffer = document.createElement(&lsquo;canvas&rsquo;);
canvasBuffer.width = IMAGE_WIDTH;
canvasBuffer.height = IMAGE_HEIGHT;
var ctxBuffer = canvasBuffer.getContext(&lsquo;2d&rsquo;);</p>

<p>img.onload = function() { ctxOrigin.drawImage(img, 0, 0); };
img.src = &lsquo;photo.jpg&rsquo;;
solution = makeIndividual();</p>

<p>var interval = setInterval(hillClimb, 150);</p>

<p>function makeIndividual() {
  var individual = [];
  for (var i = 0; i &lt; TOTAL_SQUARES; i++) {</p>

<pre><code>individual.push({
  x: Math.floor(Math.random() * IMAGE_WIDTH),
  y: Math.floor(Math.random() * IMAGE_HEIGHT),
  size: Math.floor(Math.random() * SQUARE_MAX_SIZE),
  red: Math.floor(Math.random() * 256),
  green: Math.floor(Math.random() * 256),
  blue: Math.floor(Math.random() * 256),
  alpha: Math.random()
});
</code></pre>

<p>  }
  return individual;
}</p>

<p>function renderIndividual(individual, ctx) {
  ctx.fillStyle = &ldquo;white&rdquo;;
  ctx.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);
  for (var i = 0; i &lt; TOTAL_SQUARES; i++) {</p>

<pre><code>ctx.globalAlpha = individual[i].alpha;
ctx.fillStyle = 'rgb(' + individual[i].red + ',' +
  individual[i].green + ',' + individual[i].blue + ')';
ctx.fillRect(individual[i].x, individual[i].y,
  individual[i].size, individual[i].size);
</code></pre>

<p>  }
}</p>

<p>function quality(individual) {
  var imgOrigin = ctxOrigin.getImageData(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);
  var pixelArrayOrigin = imgOrigin.data;
  var score = 0;
  renderIndividual(individual, ctxBuffer);
  var imgBuffer = ctxBuffer.getImageData(0, 0, 400, 400);
  var pixelArrayCandidate = imgBuffer.data;
  for (var i = 0, n = pixelArrayOrigin.length; i &lt; n; i += 4) {</p>

<pre><code>score += Math.abs(pixelArrayOrigin[i] - pixelArrayCandidate[i]);
score += Math.abs(pixelArrayOrigin[i+1] - pixelArrayCandidate[i+1]);
score += Math.abs(pixelArrayOrigin[i+2] - pixelArrayCandidate[i+2]);
</code></pre>

<p>  }
  return 1 / score;
}</p>

<p>function hillClimb() {
  var opponent = mutate(copy(solution));
  var score_opponent = quality(opponent);
  var score_solution = quality(solution);
  if (score_opponent > score_solution) {</p>

<pre><code>solution = opponent;
</code></pre>

<p>  }
  generation++;
  if (generation % 100 == 0) renderIndividual(solution, ctx);
  htmlGeneration.innerHTML = generation;
  htmlQuality.innerHTML = score_solution;
  if (generation >= 100000) {</p>

<pre><code>clearInterval(interval);
</code></pre>

<p>  }
}</p>

<p>function copy(individual) {
  var indiCopy = [];
  for(var i = 0; i &lt; TOTAL_SQUARES; i++) {</p>

<pre><code>var objectCopy = {},
    prop;
for(prop in individual[i]) {
  objectCopy[prop] = individual[i][prop];
}
indiCopy.push(objectCopy);
</code></pre>

<p>  }
  return indiCopy;
}</p>

<p>function mutate(individual) {
  var gene = Math.floor(Math.random() * TOTAL_SQUARES),</p>

<pre><code>  squareProperty = Math.floor(Math.random() * 7);
</code></pre>

<p>  switch (squareProperty) {</p>

<pre><code>case 0:
  individual[gene].x = Math.floor(Math.random() * IMAGE_WIDTH);
  break;
case 1:
  individual[gene].y = Math.floor(Math.random() * IMAGE_HEIGHT);
  break;
case 2:
  individual[gene].size = Math.floor(Math.random() * SQUARE_MAX_SIZE);
  break;
case 3:
  individual[gene].red = Math.floor(Math.random() * 256);
  break;
case 4:
  individual[gene].green = Math.floor(Math.random() * 256);
  break;
case 5:
  individual[gene].blue = Math.floor(Math.random() * 256);
  break;
case 6:
  individual[gene].alpha = Math.random();
  break;
</code></pre>

<p>  }
  return individual;
}
```</p>

<p>Pour le faire tourner vous aurez besoin d'une photo de 400x400 pixels et
de beaucoup de patience… Avec Firefox, ça marche tout seul mais avec
Chrome il faudra passer par un serveur Web. Si Ruby est installé sur
votre machine, vous pouvez démarrer un serveur en entrant ceci dans un
terminal (même répertoire que votre fichier HTML):</p>

<pre><code>ruby -rwebrick -e'WEBrick::HTTPServer.new(:Port =&gt; 3000, :DocumentRoot =&gt; Dir.pwd).start'
</code></pre>

<p>Le code se trouve aussi sur Github: <a href="https://github.com/lkdjiin/picture_genetic_algorithm">github.com/lkdjiin/picture_genetic_algorithm</a>.
Je suis sûr que certains d'entre-vous connaissent Javascript bien mieux que
moi et peuvent l'améliorer, alors n'hésitez pas.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les algorithmes génétiques démystifiés 35]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/10/20/les-algorithmes-genetiques-demystifies-35/"/>
    <updated>2013-10-20T21:21:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/10/20/les-algorithmes-genetiques-demystifies-35</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>On continue aujourd'hui avec la mise en place de l'algorithme de <em>Hill-climbing</em>
pour s'assurer que la fonction d'évaluation de nos images est pertinente.</p>

<!-- more -->


<p>J'ai déjà parlé du <em>Hill-climbing</em> dans
<a href="http://lkdjiin.github.io/blog/2013/09/17/les-algorithmes-genetiques-demystifies-16-le-hill-climbing/">cet article</a>.
On peut le considérer comme une version très basique d'un algorithme
génétique, sans population et sans reproduction. Utile donc, pour
tester rapidement et facilement l'évaluation:</p>

<p>``` javascript
var solution = makeIndividual();
var generation = 0;
var htmlGeneration = document.getElementById(&ldquo;generation&rdquo;);
var htmlQuality = document.getElementById(&ldquo;quality&rdquo;);
var interval = setInterval(hillClimb, 150);</p>

<p>function hillClimb() {
  var opponent = mutate(copy(solution));
  var score_opponent = quality(opponent);
  var score_solution = quality(solution);
  if (score_opponent > score_solution) {</p>

<pre><code>solution = opponent;
</code></pre>

<p>  }
  generation++;
  if (generation % 100 == 0) renderIndividual(solution, ctx);
  htmlGeneration.innerHTML = generation;
  htmlQuality.innerHTML = score_solution;
  if (generation >= 100000) {</p>

<pre><code>clearInterval(interval);
</code></pre>

<p>  }
}
```</p>

<p>Les explications maintenant. À chaque tour on compare les scores obtenus
par la solution courante (la meilleure jusqu'ici) avec une version mutée
de lui-même (<code>opponent</code>). Si l'opposant est meilleur, il prend la place
de la solution:</p>

<pre><code>var opponent = mutate(copy(solution));
var score_opponent = quality(opponent);
var score_solution = quality(solution);
if (score_opponent &gt; score_solution) {
  solution = opponent;
}
</code></pre>

<p>J'affiche ensuite la solution courante, toutes les 100 générations:</p>

<pre><code>generation++;
if (generation % 100 == 0) renderIndividual(solution, ctx);
</code></pre>

<p>À chaque tour, j'affiche la génération courante et son score:</p>

<pre><code>htmlGeneration.innerHTML = generation;
htmlQuality.innerHTML = score_solution;
</code></pre>

<p>Enfin, on stoppe tout au bout de 100.000 essais:</p>

<pre><code>if (generation &gt;= 100000) {
  clearInterval(interval);
}
</code></pre>

<p>La fonction de mutation est longue, mais simple. On sélectionne au hasard
un carré et une de ses propriétés puis on la modifie:</p>

<p>``` javascript
function mutate(individual) {
  var gene = Math.floor(Math.random() * TOTAL_SQUARES),</p>

<pre><code>  squareProperty = Math.floor(Math.random() * 7);
</code></pre>

<p>  switch (squareProperty) {</p>

<pre><code>case 0:
  individual[gene].x = Math.floor(Math.random() * IMAGE_WIDTH);
  break;
case 1:
  individual[gene].y = Math.floor(Math.random() * IMAGE_HEIGHT);
  break;
case 2:
  individual[gene].size = Math.floor(Math.random() * SQUARE_MAX_SIZE);
  break;
case 3:
  individual[gene].red = Math.floor(Math.random() * 256);
  break;
case 4:
  individual[gene].green = Math.floor(Math.random() * 256);
  break;
case 5:
  individual[gene].blue = Math.floor(Math.random() * 256);
  break;
case 6:
  individual[gene].alpha = Math.random();
  break;
</code></pre>

<p>  }
  return individual;
}
```</p>

<p>La prochaine fois on verra deux dernières fonctions <em>techniques</em>:
<code>copy</code> et <code>renderIndividual</code> et on sera près à faire tourner
notre algorithme.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les algorithmes génétiques démystifiés 34]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/10/18/les-algorithmes-genetiques-demystifies-34/"/>
    <updated>2013-10-18T20:44:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/10/18/les-algorithmes-genetiques-demystifies-34</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Après avoir vu comment créer un individu qui représente une image,
on regarde aujourd'hui comment évaluer une image.</p>

<!-- more -->


<p>N'étant pas familier du traitement d'image et de tout ce qui s'y rapporte,
j'avoue avoir eu un petit instant de panique quand je me suis demandé:
«Comment savoir, entre deux images, laquelle est <em>la plus proche</em> d'une image
de référence ?».</p>

<p>Et puis j'ai respiré un bon coup: après tout une image n'est rien d'autre
qu'une liste de données, on a qu'à faire au plus simple, c'est à dire
comparer chaque pixel. Y'avait vraiment pas de quoi paniquer ! Voilà donc
la fonction <code>quality</code> qui mesure la similitude entre une image d'origine
et une image candidate:</p>

<p>``` javascript
function quality(individual) {
  var imgOrigin = ctxOrigin.getImageData(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);
  var pixelArrayOrigin = imgOrigin.data;
  var score = 0;
  renderIndividual(individual, ctxBuffer);
  var imgBuffer = ctxBuffer.getImageData(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);
  var pixelArrayCandidate = imgBuffer.data;
  for (var i = 0, n = pixelArrayOrigin.length; i &lt; n; i += 4) {</p>

<pre><code>score += Math.abs(pixelArrayOrigin[i] - pixelArrayCandidate[i]);
score += Math.abs(pixelArrayOrigin[i+1] - pixelArrayCandidate[i+1]);
score += Math.abs(pixelArrayOrigin[i+2] - pixelArrayCandidate[i+2]);
</code></pre>

<p>  }
  return 1 / score;
}
```</p>

<p>C'est parti pour quelques explications. On récupère les pixels de
l'image d'origine (qui se trouve dans un canvas) dans la variable
<code>pixelArrayOrigin</code>:</p>

<pre><code>var imgOrigin = ctxOrigin.getImageData(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);
var pixelArrayOrigin = imgOrigin.data;
</code></pre>

<p>Ensuite, on construit l'image candidate dans un canvas non-affiché. La
fonction <code>renderIndividual</code> sera détaillée plus tard:</p>

<pre><code>renderIndividual(individual, ctxBuffer);
</code></pre>

<p>On récupère les pixels de cette image candidate dans <code>pixelArrayCandidate</code>:</p>

<pre><code>var imgBuffer = ctxBuffer.getImageData(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);
var pixelArrayCandidate = imgBuffer.data;
</code></pre>

<p>Maintenant on vérifie les pixels un à un. Un pixel est représenté par quatre
nombres, respectivement rouge, vert, bleu et alpha. Le score augmente de la
différence entre les composantes rouges, vertes et bleues:</p>

<pre><code>for (var i = 0, n = pixelArrayOrigin.length; i &lt; n; i += 4) {
  score += Math.abs(pixelArrayOrigin[i] - pixelArrayCandidate[i]);
  score += Math.abs(pixelArrayOrigin[i+1] - pixelArrayCandidate[i+1]);
  score += Math.abs(pixelArrayOrigin[i+2] - pixelArrayCandidate[i+2]);
}
</code></pre>

<p>Finalement on retourne l'inverse pour avoir un score compris entre
0 et 1:</p>

<pre><code>return 1 / score;
</code></pre>

<p>La prochaine fois, on met l'algorithme de <em>Hill-Climbing</em> en place.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
