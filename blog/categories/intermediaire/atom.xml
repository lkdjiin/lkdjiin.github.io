<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : intermédiaire | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/intermediaire/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2014-04-05T21:25:20+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ruby Timecop - Comment ça marche ?]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/04/02/ruby-timecop-comment-ca-marche/"/>
    <updated>2014-04-02T21:07:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/04/02/ruby-timecop-comment-ca-marche</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Hier je vous parlais de Timecop, une gem Ruby qui <em>arrête le
temps</em>, très utile pour tester les dates. J'y ai repensé un
peu aujourd'hui sur le mode : «j'aurais pu y penser avant !».</p>

<p>Alors justement, si j'avais eu cette idée, comment j'aurais
fait ? C'est l'occasion de parler de méta-programmation.
Allez j'essaye d'écrire ma propre méthode
<code>Time.freeze</code>, on verra bien…</p>

<!-- more -->


<p>Voilà les étapes qui me semble nécessaires:</p>

<ol>
<li>Geler le temps et le retenir.</li>
<li>Faire un backup de Time.now.</li>
<li>Définir une nouvelle méthode Time.now qui renvoie toujours
le même temps.</li>
<li>Appeler le block passé à la méthode.</li>
<li>Restaurer la méthode Time.now originale.</li>
</ol>


<p>Avant de coder, j'écris un test:</p>

<p>``` ruby
puts &ldquo;Time before #{Time.now}&rdquo;
sleep 3</p>

<p>Time.freeze do
  puts Time.now.to_s
  sleep 3
  puts Time.now.to_s
end</p>

<p>sleep 3
puts &ldquo;Time after #{Time.now}&rdquo;
```</p>

<p>Je veux donc obtenir un affichage du genre:</p>

<pre><code>Time before hh:mm:00
hh:mm:03
hh:mm:03
Time after hh:mm:09
</code></pre>

<p>Ok ? C'est parti.</p>

<h2>Ouvrir la classe Time</h2>

<p><code>ruby
class Time
  def self.freeze
  end
end
</code></p>

<p>Premier truc à savoir, une classe Ruby est toujours ouverte
à la modification. Même si il s'agit d'une classe du coeur
du langage, comme Object ou Kernel. <em>Si vous êtes perdus,
faites une recherche sur «ruby open class».</em></p>

<h2>Arrêter le temps</h2>

<p>``` ruby
class Time
  def self.freeze</p>

<pre><code>freezed = Time.now
</code></pre>

<p>  end
end
```</p>

<p>Pas grand chose à dire. On pourra renvoyer l'objet <code>freezed</code>
chaque fois qu'on nous demandera <code>Time.now</code>.</p>

<h2>Sauvegarder Time.now original</h2>

<p>``` ruby
class Time
  def self.freeze</p>

<pre><code>freezed = Time.now
singleton_class.send(:alias_method, :old_now, :now)
</code></pre>

<p>  end
end
```</p>

<p>Là il y a beaucoup à dire. On rentre dans la
méta-programmation et je n'ai pas la place (ni le temps) dans
cet article pour parler du modêle objet de Ruby.
N'hésitez pas à faire une recherche sur «ruby object model» ou
«ruby eigenclass».</p>

<p>On dit à la classe <code>Time</code> de créer un alias de la méthode de
classe <code>now</code> avec le nom <code>old_now</code>.</p>

<h2>Un nouveau Time.now</h2>

<p>``` ruby
class Time
  def self.freeze</p>

<pre><code>freezed = Time.now
singleton_class.send(:alias_method, :old_now, :now)
define_singleton_method('now') { freezed }
</code></pre>

<p>  end
end
```</p>

<p>Cette fois, je dis à la classe <code>Time</code> de créer une méthode de
classe qui s'appelle <code>now</code> et qui renvoie notre objet
<code>freezed</code>.</p>

<h2>Appeler le block</h2>

<p>``` ruby
class Time
  def self.freeze</p>

<pre><code>freezed = Time.now
singleton_class.send(:alias_method, :old_now, :now)
define_singleton_method('now') { freezed }
yield
</code></pre>

<p>  end
end
```</p>

<p>Bon, ça c'était facile ;)</p>

<h2>Restaurer Time.now</h2>

<p>``` ruby
class Time
  def self.freeze</p>

<pre><code>freezed = Time.now
singleton_class.send(:alias_method, :old_now, :now)
define_singleton_method('now') { freezed }
yield
singleton_class.send(:alias_method, :now, :old_now)
</code></pre>

<p>  end
end
```</p>

<p>Ça me semble tout bon. On teste ?</p>

<h2>Le test</h2>

<p>``` ruby freeze.rb
class Time
  def self.freeze</p>

<pre><code>freezed = Time.now
singleton_class.send(:alias_method, :old_now, :now)
define_singleton_method('now') { freezed }
yield
singleton_class.send(:alias_method, :now, :old_now)
# singleton_class.send(:remove_method, :old_now)
</code></pre>

<p>  end
end</p>

<p>puts &ldquo;Time before #{Time.now}&rdquo;
sleep 3</p>

<p>Time.freeze do
  puts Time.now.to_s
  sleep 3
  puts Time.now.to_s
end</p>

<p>sleep 3
puts &ldquo;Time after #{Time.now}&rdquo;
```</p>

<p><code>bash
$ ruby freeze.rb
Time before 2014-04-02 21:40:57 +0200
2014-04-02 21:41:00 +0200
2014-04-02 21:41:00 +0200
Time after 2014-04-02 21:41:06 +0200
</code></p>

<p>Excellent !</p>

<p>Il reste un léger problème : la méthode <code>Time.old_now</code>
existe toujours, ce qui n'est pas très propre. On pourra
la supprimer ainsi:</p>

<pre><code>singleton_class.send(:remove_method, :old_now)
</code></pre>

<p>Voilà, j'aurais quand même pu y penser avant… J'espère
trouver du temps une prochaine fois pour jeter un coup
d'oeil au code de Timecop pour comparer avec le code
d'aujourd'hui.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ActiveRecord - Executer une commande SQL quelconque]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/03/27/activerecord-executer-une-commande-sql-quelconque/"/>
    <updated>2014-03-27T20:59:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/03/27/activerecord-executer-une-commande-sql-quelconque</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Chaque SGBD (Systême de Gestion de Base de Données), comme postgresql ou
mysql par exemple, définissent des tables avec des infos très
intéressantes (appelées meta-data, shéma, catalogue, etc.).</p>

<p>Ces <em>méta-données</em> ne sont pas reliées à un modèle ActiveRecord, alors
comment y accéder si vous en avez besoin ?</p>

<!-- more -->


<p>En utilisant la méthode <code>execute</code> sur la méthode <code>connection</code>:</p>

<p><code>ruby
sql = "ma requete SQL"
result = ActiveRecord::Base.connection.execute(sql)
</code></p>

<p><code>result</code> possède maintenant les lignes dont vous aviez tant besoin:</p>

<p><code>ruby
result.each do |row|
  puts row
end
</code></p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vim - Un plugin pour markdown - partie 5]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/03/23/vim-un-plugin-pour-markdown-partie-5/"/>
    <updated>2014-03-23T20:57:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/03/23/vim-un-plugin-pour-markdown-partie-5</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>On fait un peu de nettoyage en mettant du code en commun, et on voit un
mapping plus intéressant.</p>

<!-- more -->


<p>Voici ce que ça donne après un refactoring:</p>

<p>``` vim autoload/quickmarkdown.vim
function s:build_big_title(char)
  let s:line_content = substitute(getline(&ldquo;.&rdquo;), &lsquo;.&rsquo;, a:char, &lsquo;g&rsquo;)
  call append(&lsquo;.&rsquo;, s:line_content)
endfunction</p>

<p>function s:build_little_title(str)
  call setline(line(&lsquo;.&rsquo;), a:str . getline(&lsquo;.&rsquo;))
endfunction</p>

<p>function! quickmarkdown#title(level)
  if a:level == 1</p>

<pre><code>call s:build_big_title("=")
</code></pre>

<p>  elseif a:level == 2</p>

<pre><code>call s:build_big_title("-")
</code></pre>

<p>  elseif a:level == 3</p>

<pre><code>call s:build_little_title("### ")
</code></pre>

<p>  elseif a:level == 4</p>

<pre><code>call s:build_little_title("#### ")
</code></pre>

<p>  elseif a:level == 5</p>

<pre><code>call s:build_little_title("##### ")
</code></pre>

<p>  elseif a:level == 6</p>

<pre><code>call s:build_little_title("###### ")
</code></pre>

<p>  endif
endfunction
```</p>

<p><code>vim plugin/quickmarkdown.vim
command! QuickMarkdownTitle1 call quickmarkdown#title(1)
command! QuickMarkdownTitle2 call quickmarkdown#title(2)
command! QuickMarkdownTitle3 call quickmarkdown#title(3)
command! QuickMarkdownTitle4 call quickmarkdown#title(4)
command! QuickMarkdownTitle5 call quickmarkdown#title(5)
command! QuickMarkdownTitle6 call quickmarkdown#title(6)
</code></p>

<p>On n'a plus qu'un seule fonction <code>quickmarkdown#title</code>, à laquelle on passe
en paramêtre le niveau du titre.</p>

<p>J'ai aussi changé le mapping.
Tout d'abord j'utilise leader+q, au lieu de leader+m. Pourquoi, parce que
je voulais m'en servir aussi en mode insertion avec la touche Control. Et
en mode insertion, Control+m est équivalent à la touche Entrée, ce qui pose
bien sûr quelques problèmes ;) Voici le mapping pour un clavier qwerty:</p>

<p><code>vim .vimrc
nmap &lt;Leader&gt;q1 :QuickMarkdownTitle1&lt;Enter&gt;
nmap &lt;Leader&gt;q2 :QuickMarkdownTitle2&lt;Enter&gt;
nmap &lt;Leader&gt;q3 :QuickMarkdownTitle3&lt;Enter&gt;
nmap &lt;Leader&gt;q4 :QuickMarkdownTitle4&lt;Enter&gt;
nmap &lt;Leader&gt;q5 :QuickMarkdownTitle5&lt;Enter&gt;
nmap &lt;Leader&gt;q6 :QuickMarkdownTitle6&lt;Enter&gt;
imap &lt;C-q&gt;1 &lt;C-o&gt;:QuickMarkdownTitle1&lt;Enter&gt;
imap &lt;C-q&gt;2 &lt;C-o&gt;:QuickMarkdownTitle2&lt;Enter&gt;
imap &lt;C-q&gt;3 &lt;C-o&gt;:QuickMarkdownTitle3&lt;Enter&gt;
imap &lt;C-q&gt;4 &lt;C-o&gt;:QuickMarkdownTitle4&lt;Enter&gt;
imap &lt;C-q&gt;5 &lt;C-o&gt;:QuickMarkdownTitle5&lt;Enter&gt;
imap &lt;C-q&gt;6 &lt;C-o&gt;:QuickMarkdownTitle6&lt;Enter&gt;
</code></p>

<p>Au fait, vous pouvez trouver ce plugin sur <a href="https://github.com/lkdjiin/quickmarkdown">Github</a>.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vim - un plugin pour markdown - partie 4]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/03/22/vim-un-plugin-pour-markdown-partie-4/"/>
    <updated>2014-03-22T20:42:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/03/22/vim-un-plugin-pour-markdown-partie-4</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Maintenant on fait tous les titres, jusqu'au niveau 6 donc.</p>

<!-- more -->


<p>``` vim autoload/quickmarkdown.vim
function s:build_big_title(char)
  let s:line_content = substitute(getline(&ldquo;.&rdquo;), &lsquo;.&rsquo;, a:char, &lsquo;g&rsquo;)
  call append(&lsquo;.&rsquo;, s:line_content)
endfunction</p>

<p>function s:build_little_title(str)
  call setline(line(&lsquo;.&rsquo;), a:str . getline(&lsquo;.&rsquo;))
endfunction</p>

<p>function! quickmarkdown#title1()
  call s:build_big_title(&ldquo;=&rdquo;)
endfunction</p>

<p>function! quickmarkdown#title2()
  call s:build_big_title(&ldquo;&ndash;&rdquo;)
endfunction</p>

<p>function! quickmarkdown#title3()
  call s:build_little_title(&ldquo;### &rdquo;)
endfunction</p>

<p>function! quickmarkdown#title4()
  call s:build_little_title(&ldquo;#### &rdquo;)
endfunction</p>

<p>function! quickmarkdown#title5()
  call s:build_little_title(&ldquo;##### &rdquo;)
endfunction</p>

<p>function! quickmarkdown#title6()
  call s:build_little_title(&ldquo;###### &rdquo;)
endfunction
```</p>

<p><code>vim plugin/quickmarkdown.vim
command! QuickMarkdownTitle1 call quickmarkdown#title1()
command! QuickMarkdownTitle2 call quickmarkdown#title2()
command! QuickMarkdownTitle3 call quickmarkdown#title3()
command! QuickMarkdownTitle4 call quickmarkdown#title4()
command! QuickMarkdownTitle5 call quickmarkdown#title5()
command! QuickMarkdownTitle6 call quickmarkdown#title6()
</code></p>

<p>J'ai aussi changé mon mapping pour qu'il soit plus homogène.</p>

<p><strong>En qwerty:</strong></p>

<p><code>vim .vimrc
nmap &lt;Leader&gt;m1 :QuickMarkdownTitle1&lt;Enter&gt;
nmap &lt;Leader&gt;m2 :QuickMarkdownTitle2&lt;Enter&gt;
nmap &lt;Leader&gt;m3 :QuickMarkdownTitle3&lt;Enter&gt;
nmap &lt;Leader&gt;m4 :QuickMarkdownTitle4&lt;Enter&gt;
nmap &lt;Leader&gt;m5 :QuickMarkdownTitle5&lt;Enter&gt;
nmap &lt;Leader&gt;m6 :QuickMarkdownTitle6&lt;Enter&gt;
</code></p>

<p><strong>En azerty:</strong></p>

<p><code>vim .vimrc
nmap &lt;Leader&gt;m&amp; :QuickMarkdownTitle1&lt;Enter&gt;
nmap &lt;Leader&gt;mé :QuickMarkdownTitle2&lt;Enter&gt;
nmap &lt;Leader&gt;m" :QuickMarkdownTitle3&lt;Enter&gt;
nmap &lt;Leader&gt;m' :QuickMarkdownTitle4&lt;Enter&gt;
nmap &lt;Leader&gt;m( :QuickMarkdownTitle5&lt;Enter&gt;
nmap &lt;Leader&gt;m- :QuickMarkdownTitle6&lt;Enter&gt;
</code></p>

<p><strong>En bépo:</strong></p>

<p><code>vim .vimrc
nmap &lt;Leader&gt;m" :QuickMarkdownTitle1&lt;Enter&gt;
nmap &lt;Leader&gt;m« :QuickMarkdownTitle2&lt;Enter&gt;
nmap &lt;Leader&gt;m» :QuickMarkdownTitle3&lt;Enter&gt;
nmap &lt;Leader&gt;m( :QuickMarkdownTitle4&lt;Enter&gt;
nmap &lt;Leader&gt;m) :QuickMarkdownTitle5&lt;Enter&gt;
nmap &lt;Leader&gt;m@ :QuickMarkdownTitle6&lt;Enter&gt;
</code></p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Redis - Comment supprimer un ensemble de clés]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/03/21/redis-comment-supprimer-un-ensemble-de-cles/"/>
    <updated>2014-03-21T21:44:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/03/21/redis-comment-supprimer-un-ensemble-de-cles</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Tiens, mon premier article sur Redis ! Normal, c'est une technologie que
j'ai découvert il y a peu…</p>

<!-- more -->


<p>Pour supprimer une clé dans Redis, on se connecte et on utilise la commande
<code>del</code>:</p>

<pre><code>$ redis-cli
&gt; del "nom:de:la:clef"
</code></pre>

<p>Mais quand on a des dizaines/centaines de clés, bof… Bien souvent (toujours
même ça vaut mieux) le nom des clés suit un motif. Par exemple:</p>

<pre><code>"motif:foo"
"motif:bar"
"motif:baz"
etc...
</code></pre>

<p>Dans ce cas on peut utiliser Bash pour s'en sortir rapidement:</p>

<p><code>bash
redis-cli keys "*motif*" | xargs redis-cli del
</code></p>

<p>Et voilà, au revoir toutes les clés.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
