<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : intermédiaire | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/intermediaire/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2014-06-10T21:59:00+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Un space invaders avec Opal.rb - partie 1]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/06/10/un-space-invaders-avec-opal-dot-rb-partie-1/"/>
    <updated>2014-06-10T21:25:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/06/10/un-space-invaders-avec-opal-dot-rb-partie-1</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Après une courte <a href="blog/2014/06/06/introduction-a-opal-dot-rb/">introduction à Opal.rb</a>,
on va essayer de faire un truc plus ambitieux avec Opal: un jeu du genre
Space Invaders.</p>

<!-- more -->


<p>Pour ce jeu, je vais utiliser jQuery pour manipuler le DOM, parce que c'est
plus simple ;) On va aussi utiliser une structure de dossier un peu plus
<em>pro</em> que dans l'introduction et un Gemfile que voici:</p>

<p>``` ruby Gemfile
source &lsquo;<a href="https://rubygems.org">https://rubygems.org</a>&rsquo;</p>

<p>gem &lsquo;opal&rsquo;, &lsquo;~>0.6&rsquo;
gem &lsquo;opal-jquery&rsquo;
```</p>

<p>Au fait, Opal.rb supporte Ruby à partir de la version 2.0.</p>

<p>Il nous faut à présent un fichier HTML:</p>

<p>``` html index.html
&lt;!DOCTYPE html>
<html>
  <head></p>

<pre><code>&lt;meta charset="utf-8" /&gt;
&lt;script src="http://code.jquery.com/jquery-1.11.0.min.js"&gt;&lt;/script&gt;
</code></pre>

<p>  </head>
  <body></p>

<pre><code>&lt;canvas width="700" height="600" id="canvas"&gt;&lt;/canvas&gt;
&lt;script src="build.js"&gt;&lt;/script&gt;
</code></pre>

<p>  </body>
</html>
```</p>

<p>Vous remarquerez l'inclusion de jQuery, d'un canvas pour notre jeu et d'un
script <code>build.js</code> qui est notre objectif.</p>

<p>Maintenant, voici un Rakefile qui va justement construire ce fameux
<code>build.js</code>:</p>

<p>``` ruby Rakefile
require &lsquo;opal&rsquo;
require &lsquo;opal-jquery&rsquo;</p>

<p>desc &ldquo;Build our app to build.js&rdquo;
task :build do
  env = Opal::Environment.new
  env.append_path &ldquo;app&rdquo;</p>

<p>  File.open(&ldquo;build.js&rdquo;, &ldquo;w+&rdquo;) do |out|</p>

<pre><code>out &lt;&lt; env["application"].to_s
</code></pre>

<p>  end
end
```</p>

<p>Si vous vous posez des questions sur ce fichier, les réponses sont sur
la <a href="http://opalrb.org/docs/static_applications/">documentation d'Opal</a>.</p>

<p>On s'occupe maintenant de notre canvas avec une classe Ruby qui va afficher
un arrière-plan noir:</p>

<p>``` ruby app/application.rb
require &lsquo;opal&rsquo;
require &lsquo;opal-jquery&rsquo;</p>

<p>class SpaceCanvas</p>

<p>  def initialize</p>

<pre><code>@canvas  = `document.getElementById(#{'canvas'})`
@context = `#@canvas.getContext('2d')`
@height  = `#@canvas.height`
@width   = `#@canvas.width`
</code></pre>

<p>  end</p>

<p>  def clear_background</p>

<pre><code>`#@context.fillStyle = 'black'`
`#@context.fillRect(0, 0, #{@width}, #{@height})`
</code></pre>

<p>  end
end</p>

<p>canvas = SpaceCanvas.new
canvas.clear_background
```</p>

<p>Les explications ligne par ligne de cette classe seront demain dans le prochain
car je suis préssé par le temps…</p>

<p>Pour construire le fichier <code>build.js</code>, on se sert de rake:</p>

<pre><code>rake build
</code></pre>

<p>Il suffit maintenant d'ouvrir le fichier HTML pour voir apparaitre un beau
rectangle tout noir ;)</p>

<p>Pour infos, voici la structure de notre jeu:</p>

<pre><code>● tree
.
├── app
│   └── application.rb
├── build.js
├── Gemfile
├── Gemfile.lock
├── index.html
└── Rakefile
</code></pre>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Utiliser Enumerable en Ruby]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/06/09/utiliser-enumerable-en-ruby/"/>
    <updated>2014-06-09T16:47:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/06/09/utiliser-enumerable-en-ruby</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Il y a quelques jours, j'ai testé Opal.rb. Et pour ça, j'ai écris un jeu
du type Space Invaders ;) J'ai une classe <code>Enemy</code>, que je peux résumer ainsi:</p>

<p>``` ruby
class Enemy
  attr_reader :x, :y
  def initialize(x, y)</p>

<pre><code>@x = x
@y = y
</code></pre>

<p>  end</p>

<p>  def to_s</p>

<pre><code>"#&lt;Enemy x:#@x y:#@y&gt;"
</code></pre>

<p>  end
end
```</p>

<!-- more -->


<p>J'ai aussi une classe <code>Enemies</code>, pour gérer ce qui se passe au niveau de
tous les ennemies. Inclure le module <a href="http://ruby-doc.org/core-2.1.2/Enumerable.html">Enumerable</a>
et définir la méthode <code>each</code> me permet d'utiliser toutes les méthodes de ce
module.</p>

<p>``` ruby
class Enemies
  include Enumerable</p>

<p>  def initialize</p>

<pre><code>@enemies = []
</code></pre>

<p>  end</p>

<p>  def each(&amp;block)</p>

<pre><code>@enemies.each(&amp;block)
</code></pre>

<p>  end</p>

<p>  def &lt;&lt;(item)</p>

<pre><code>@enemies &lt;&lt; item
</code></pre>

<p>  end
end
```</p>

<p>Créons un groupe de trois ennemies :</p>

<p><code>ruby
enemies = Enemies.new
enemies &lt;&lt; Enemy.new(10, 15)
enemies &lt;&lt; Enemy.new(20, 15)
enemies &lt;&lt; Enemy.new(10, 40)
</code></p>

<p>Voyons si <code>each</code> fonctionne bien :</p>

<pre><code>&gt; enemies.each {|item| puts item }
#&lt;Enemy x:10 y:15&gt;
#&lt;Enemy x:20 y:15&gt;
#&lt;Enemy x:10 y:40&gt;
</code></pre>

<p>J'ai donc accès à toutes les autres méthodes de <code>Enumerable</code>, comme par
exemple <code>select</code>:</p>

<pre><code>&gt; puts enemies.select {|item| item.x == 10 }
#&lt;Enemy x:10 y:15&gt;
#&lt;Enemy x:10 y:40&gt;
</code></pre>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Trois bibliothèques de fonctions pour écrire vos plugins Vim]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/06/08/trois-bibliotheques-de-fonctions-pour-ecrire-vos-plugins-vim/"/>
    <updated>2014-06-08T21:27:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/06/08/trois-bibliotheques-de-fonctions-pour-ecrire-vos-plugins-vim</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Aujourd'hui je vous propose trois bibliothèques de fonctions Vimscript, pour
faciliter l'écriture de plugins pour Vim.</p>

<!-- more -->


<p>J'en ai pour l'instant testé… aucune ! Mais j'ai bien l'intention de les
essayer ;)</p>

<p>Tout d'abord <a href="https://github.com/google/maktaba">maktaba</a>, par Google. Parmi
les fonctionnalités qui m'intéresse, je note une interface pour <em>logger</em> et
la gestion des exceptions.</p>

<p>Ensuite <a href="https://github.com/vim-jp/vital.vim">vital.vim</a>. Le readme annonce
que le projet a pour objectif de réunir les fonctions de Bundler et de
jQuery, mais pour Vim.</p>

<p>Et enfin <a href="https://github.com/mattn/webapi-vim">webapi-vim</a>, qui gère notamment
la connexion OAuth, le parsing JSON et quelques algorithmes de hashage.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Un algorithme génétique en Julia - partie 17]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/06/04/un-algorithme-genetique-en-julia-partie-17/"/>
    <updated>2014-06-04T21:59:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/06/04/un-algorithme-genetique-en-julia-partie-17</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Aujourd'hui j'ai envie de faire une version récursive de la fonction
<code>run</code>. Voici la version actuelle:</p>

<p>``` julia
function run(population_size, genes_size, generations, fight_rate)
  current = create_population(population_size, genes_size)
  for i in 1:generations</p>

<pre><code>scores = score(current)
best = maximum(scores)
println("Generation $i Best $best")
selection = tournament(scores, fight_rate)
current = reproduction([], current, selection, population_size)
</code></pre>

<p>  end
end
```</p>

<!-- more -->


<p>Et en voici une version récursive (avec un <em>helper</em>):</p>

<p>``` julia
function run(population_size, genes_size, generations, fight_rate)
  current = create_population(population_size, genes_size)
  run_helper(current, population_size, fight_rate, generations)
end</p>

<p>function run_helper(current, population_size, fight_rate, generations,</p>

<pre><code>                generation = 1)
</code></pre>

<p>  scores = score(current)
  best = maximum(scores)
  println(&ldquo;Generation $generation Best $best&rdquo;)
  if generation &lt; generations</p>

<pre><code>selection = tournament(scores, fight_rate)
current = reproduction([], current, selection, population_size)
run_helper(current, population_size, fight_rate, generations, generation + 1)
</code></pre>

<p>  end
end
```</p>

<p>Alors je me doute que je suis sûrement assez maladroit avec Julia, que
j'apprend, et avec le style récursif, qui ne coule pas de source chez moi,
mais j'ai quand même l'impression que ça n'apporte rien du tout au
programme !</p>

<p>Pour l'instant, je pense que je vais me limiter souvent à des boucles
<code>for</code> ;)</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Un algorithme génétique en Julia - partie 16]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/06/03/un-algorithme-genetique-en-julia-partie-16/"/>
    <updated>2014-06-03T21:02:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/06/03/un-algorithme-genetique-en-julia-partie-16</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>J'ai retiré les nombres magiques et renommé les quelques variables qui étaient
abrégées. Puis j'ai voulu commencer à documenter le code. Là je me suis
aperçu que le <em>typage</em> était une bonne façon de documenter Julia. Par
exemple:</p>

<p><code>julia
type Chromosome
  genes::Array{Int}
end
</code></p>

<p>m'apparait quasiment comme étant <em>auto-documenté</em>, comparé à la version
précédente:</p>

<p><code>julia
type Chromosome
  genes
end
</code></p>

<!-- more -->


<p>Plus de documentation plus tard, quand j'aurais trouvé si il y a un
<em>standard</em> en Julia (j'ai bien l'impression qu'il n'y en a pas :( ).</p>

<p>Pour l'instant, voici le code après son enième remaniement:</p>

<p>``` julia main.jl
type Chromosome
  genes::Array{Int}
end</p>

<p>create_genes(size) = rand(0:1, size)</p>

<p>function create_population(size, chromosome_size)
  [ Chromosome(create_genes(chromosome_size)) for _ in 1:size ]
end</p>

<p>score(population) = map(chromosome &ndash;> sum(chromosome.genes), population)</p>

<p>function fight(scores, index1, index2, rate)
  if rand() &lt; rate</p>

<pre><code>scores[index1] &gt; scores[index2] ? index1 : index2
</code></pre>

<p>  else</p>

<pre><code>scores[index1] &gt; scores[index2] ? index2 : index1
</code></pre>

<p>  end
end</p>

<p>function tournament(scores, rate)
  population_size = length(scores)
  selection_size = population_size * 2
  [ fight(scores, rand(1:population_size), rand(1:population_size), rate)</p>

<pre><code>for _ in 1:selection_size ]
</code></pre>

<p>end</p>

<p>function crossover(chromosome1, chromosome2, population_size)
  cut_point = rand(1:length(chromosome1.genes))
  first_part = chromosome1.genes[1:cut_point]
  second_part = chromosome2.genes[cut_point + 1:end]
  mutate(Chromosome([ first_part, second_part]), population_size)
end</p>

<p>function reproduction(new_population, current_population, selection,</p>

<pre><code>                  population_size)
</code></pre>

<p>  if selection == []</p>

<pre><code>return new_population
</code></pre>

<p>  else</p>

<pre><code>father = current_population[selection[1]]
mother = current_population[selection[2]]
child = crossover(father, mother, population_size)
reproduction([new_population, child], current_population, selection[3:end],
             population_size)
</code></pre>

<p>  end
end</p>

<p>function mutate(chromosome, population_size)
  mutator(gene) = if rand(1:population_size) == 1</p>

<pre><code>gene == 1 ? 0 : 1
</code></pre>

<p>  else</p>

<pre><code>gene
</code></pre>

<p>  end
  Chromosome([ mutator(gene) for gene in chromosome.genes ])
end</p>

<p>function run(population_size, genes_size, generations, fight_rate)
  current = create_population(population_size, genes_size)
  for i in 1:generations</p>

<pre><code>scores = score(current)
best = maximum(scores)
println("Generation $i Best $best")
selection = tournament(scores, fight_rate)
current = reproduction([], current, selection, population_size)
</code></pre>

<p>  end
end
```</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
