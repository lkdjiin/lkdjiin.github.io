<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : intermédiaire | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/intermediaire/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2014-07-05T15:45:26+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Les tours de Hanoi - partie 1]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/07/05/les-tours-de-hanoi-partie-1/"/>
    <updated>2014-07-05T15:25:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/07/05/les-tours-de-hanoi-partie-1</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Je vais commencer par implémenter une classe <code>Board</code>, dont la tâche est
de retenir l'état du plateau de jeu, c'est à dire la position des pièces.
J'ai envie de faire des tests avec Rspec, donc voici les premiers fichiers:</p>

<pre><code>$ tree
.
├── board.rb
└── spec
    └── board_spec.rb
</code></pre>

<!-- more -->


<p>Voici les tests de <code>Board</code>, qui décrivent ce que j'attend de cette classe:</p>

<p>``` ruby spec/board_spec.rb
require &lsquo;./board&rsquo;</p>

<p>describe Board do</p>

<p>  before { @board = Board.new(3) }</p>

<p>  it &lsquo;has a position&rsquo; do</p>

<pre><code>expect(@board.position).to eq [ [3, 2, 1], [], [] ]
</code></pre>

<p>  end</p>

<p>  it &lsquo;accepts a position&rsquo; do</p>

<pre><code>@board.position = [ [], [3], [2, 1] ]
expect(@board.position).to eq [ [], [3], [2, 1] ]
</code></pre>

<p>  end</p>

<p>  describe &lsquo;position evalution&rsquo; do</p>

<pre><code>specify { expect(@board.eval).to eq 0 }

specify do
  @board.position = [ [], [3], [2, 1] ]
  expect(@board.eval).to eq 9
end

specify do
  @board.position = [ [], [], [3, 2, 1] ]
  expect(@board.eval).to eq 12
end
</code></pre>

<p>  end</p>

<p>end
```</p>

<p>On doit pouvoir l'initialiser avec un nombre de pièces:</p>

<pre><code>before { @board = Board.new(3) }
</code></pre>

<p>À l'initialisation, les pièces sont en position de départ:</p>

<pre><code>it 'has a position' do
  expect(@board.position).to eq [ [3, 2, 1], [], [] ]
end
</code></pre>

<p>On peut modifier la position à volonté:</p>

<pre><code>it 'accepts a position' do
  @board.position = [ [], [3], [2, 1] ]
  expect(@board.position).to eq [ [], [3], [2, 1] ]
end
</code></pre>

<p>Enfin, la position actuelle peut être évaluée:</p>

<pre><code>describe 'position evalution' do

  specify { expect(@board.eval).to eq 0 }

  specify do
    @board.position = [ [], [3], [2, 1] ]
    expect(@board.eval).to eq 9
  end

  specify do
    @board.position = [ [], [], [3, 2, 1] ]
    expect(@board.eval).to eq 12
  end

end
</code></pre>

<p>Pour finir, l'implémentation minimum:</p>

<p>``` ruby board.rb
class Board</p>

<p>  def initialize(number_of_pieces)</p>

<pre><code>@pegs = [ (1..number_of_pieces).to_a.reverse, [], [] ]
</code></pre>

<p>  end</p>

<p>  def position</p>

<pre><code>@pegs
</code></pre>

<p>  end</p>

<p>  def position=(pegs)</p>

<pre><code>@pegs = pegs
</code></pre>

<p>  end</p>

<p>  def eval</p>

<pre><code>@pegs[1].reduce(0, :+) + 2 * @pegs[2].reduce(0, :+)
</code></pre>

<p>  end</p>

<p>end
```</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Un algorithme génétique pour les tours de Hanoi avec Opal.rb]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/07/04/un-algorithme-genetique-pour-les-tours-de-hanoi-avec-opal-dot-rb/"/>
    <updated>2014-07-04T21:07:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/07/04/un-algorithme-genetique-pour-les-tours-de-hanoi-avec-opal-dot-rb</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Pour débuter la résolution du jeu des tours de Hanoi à l'aide d'un algorithme
génétique, j'ai envie de commencer par réfléchir à la représentation des
chromosomes, aux règles de mouvement, à la fonction d'évaluation, sans
forcément commencer à coder.</p>

<!-- more -->


<p>Les règles sont sur <a href="http://fr.wikipedia.org/wiki/Tours_de_Hano%C3%AF">wikipédia</a>.</p>

<p>J'apprend un truc qui va me servir, il faut 2<sup>n</sup> &ndash; 1 coups au minimum pour
solutionner le problème (n est le nombre de disques). Du coup, mes chromosomes
devront posséder 2<sup>n</sup> &ndash; 1 gènes. Ce qui ira sans trop de soucis jusqu'à une
dizaines de disques, mais au delà c'est pas gagné.</p>

<p>Pour faire simple, un gène va représenter un mouvement à l'aide d'un nombre:</p>

<pre><code>0 -&gt; du 1er poteau au 2ème poteau
1 -&gt; du 1er poteau au 3ème poteau
2 -&gt; du 2ème poteau au 1er poteau
3 -&gt; du 2ème poteau au 3ème poteau
4 -&gt; du 3ème poteau au 1er poteau
5 -&gt; du 3ème poteau au 2ème poteau
</code></pre>

<p>Que faire quand un mouvement est illégal ? Le plus simple est de l'ignorer,
c'est donc ce que je vais faire.</p>

<p>La fonction d'évaluation, maintenant ? J'ai envie de donner un <em>poids</em> à
chaque disque suivant le poteau où il se trouve. Sur le premier poteau, un
disque vaut 0 point. Sur le second poteau, il vaut 1 point, et sur le
troisième, il vaut 2 points.</p>

<p>Par exemple, si je commence avec seulement 3 disques, la position suivante
vaut 0 point:</p>

<pre><code>  x|x      |       |   
 xx|xx     |       |   
xxx|xxx    |       |    
</code></pre>

<p>Alors que la suivante vaut 6 points:</p>

<pre><code>   |       |      x|x   
   |       |     xx|xx 
   |       |    xxx|xxx
</code></pre>

<p>C'est pas suffisant pour différencier certaines solutions, donc on appliquera
un multiplicateur suivant la taille du disque, 1 pour le plus petit, 2 pour
le suivant et 3 pour le plus grand. Je vous laisse faire les calculs, ça me
prend trop de temps de faire les petits dessins ;)</p>

<p>Allez, la prochaine fois on code…</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Exercise Ruby - Reduce ranges - d'autres solutions]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/07/02/exercise-ruby-reduce-ranges-dautres-solutions/"/>
    <updated>2014-07-02T21:03:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/07/02/exercise-ruby-reduce-ranges-dautres-solutions</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Hier j'ai proposé <a href="http://lkdjiin.github.io/blog/2014/07/01/exercise-ruby-reduce-ranges-une-solution/">une solution</a> à cet exercise de <a href="http://lkdjiin.github.io/blog/2014/06/30/exercice-ruby-reduce-ranges/">Range reduce</a>.
Bien qu'élégante (du moins pour moi), elle prenait vraiment trop de temps par
rapport à l'originale. En voici d'autres. Meilleures ?</p>

<!-- more -->


<p>Pour rappel, voici l'originale:</p>

<p>``` ruby
def original(array)
  arr = array.dup
  arr.each_with_index do |el, index|</p>

<pre><code>range_index = index + 1
prev = el
while arr[range_index] == prev + 1 do
  prev = arr[range_index]
  range_index += 1
end
arr[index..range_index-1] = (arr[index]..arr[range_index-1]) unless index == range_index - 1
</code></pre>

<p>  end
end
```</p>

<p>Et voici ma solution d'hier:</p>

<p>``` ruby
def range_reduce(array)
  previous = array.first
  array.slice_before do |element|</p>

<pre><code>previous, previous2 = element, previous
previous2.succ != element
</code></pre>

<p>  end.map do |element|</p>

<pre><code>element.size == 1 ? element.first : element.first..element.last
</code></pre>

<p>  end
end
```</p>

<p>Maintenant, voici celle que j'ai eu en tête toute la journée:</p>

<p>``` ruby
def range_reduce_1(array)
  temp = []
  result = []</p>

<p>  array.each do |element|</p>

<pre><code>if temp.empty?
  temp &lt;&lt; element
else
  if temp.last + 1 == element
    temp &lt;&lt; element
  else
    if temp.size == 1
      result &lt;&lt; temp.first
    else
      result &lt;&lt; (temp.first..temp.last)
    end
    temp = [element]
  end
end
</code></pre>

<p>  end</p>

<p>  if temp.size == 1</p>

<pre><code>result &lt;&lt; temp.first
</code></pre>

<p>  else</p>

<pre><code>result &lt;&lt; (temp.first..temp.last)
</code></pre>

<p>  end</p>

<p>  result
end
```</p>

<p>C'est moche, hein ? Mais ne riez quand même pas trop, attendez de voir les
benchmarks ;)</p>

<p>Je me suis dis que j'allais aussi tester une solution <em>propre</em>, avec un
pattern que j'aime beaucoup:</p>

<p>``` ruby
class ArrayReduce</p>

<p>  def self.ranges(array)</p>

<pre><code>new(array).ranges
</code></pre>

<p>  end</p>

<p>  def initialize(array)</p>

<pre><code>@array = array
@result = [ [@array.first] ]
</code></pre>

<p>  end</p>

<p>  def ranges</p>

<pre><code>@array[1..-1].each do |element|
  suite?(element) ? @result.last &lt;&lt; element : @result &lt;&lt; [element]
end

@result.map do |element|
  element.size == 1 ? element.first : element.first..element.last
end
</code></pre>

<p>  end</p>

<p>  private</p>

<p>  def suite?(element)</p>

<pre><code>@result.last.last == element.pred
</code></pre>

<p>  end</p>

<p>end
```</p>

<p>Et voici la solution qu'a posté un lecteur, Calyhre. J'ai pris la liberté de
la transformer en méthode, comme j'ai fait pour la solution originale qui
<em>monkey patch</em> la classe Array (<a href="https://gist.github.com/Calyhre/280ee41136ad2a62e6c3">solution originale de Calyhre</a>):</p>

<p>``` ruby
def calyhre(array)
  temp = results = []
  array.each do |e|</p>

<pre><code>temp &lt;&lt; e and next if temp.last == e - 1
results &lt;&lt; ( temp[1].nil? ? temp[0] : (temp.first..temp.last) ) unless temp.empty?
temp = [e]
</code></pre>

<p>  end
  results &lt;&lt; ( temp[1].nil? ? temp[0] : (temp.first..temp.last) )
end
```</p>

<p>Du coup, pour être équitable, il faudrait un autre benchmark pour les
<em>monkey patches</em> ! Peut-être plus tard.</p>

<p>Voici donc les résultats avec Ruby 2.1:</p>

<pre><code>$ 21:16 [~/devel/ruby/tests] (ruby-2.1.0) 
$ ruby range_reduce.rb 
Rehearsal --------------------------------------------------
original         0.690000   0.000000   0.690000 (  0.694524)
range_reduce     2.310000   0.000000   2.310000 (  2.305131)
range_reduce_1   0.650000   0.000000   0.650000 (  0.648863)
ArrayReduce      1.080000   0.000000   1.080000 (  1.088213)
Calyhre          0.680000   0.000000   0.680000 (  0.676048)
----------------------------------------- total: 5.410000sec

                     user     system      total        real
original         0.690000   0.000000   0.690000 (  0.692163)
range_reduce     2.250000   0.000000   2.250000 (  2.253139)
range_reduce_1   0.630000   0.000000   0.630000 (  0.636611)
ArrayReduce      1.050000   0.010000   1.060000 (  1.077018)
Calyhre          0.660000   0.000000   0.660000 (  0.662596)
</code></pre>

<p>Puis avec Rubinius 2.0:</p>

<pre><code>$ 21:19 [~/devel/ruby/tests] (rbx-2.0.0) 
$ ruby range_reduce.rb 
Rehearsal --------------------------------------------------
original         1.984124   0.004000   1.988124 (  1.994156)
range_reduce     3.220201   0.012001   3.232202 (  3.248281)
range_reduce_1   0.620038   0.000000   0.620038 (  0.775944)
ArrayReduce      1.156072   0.000000   1.156072 (  1.195206)
Calyhre          0.788049   0.000000   0.788049 (  1.007030)
----------------------------------------- total: 7.784485sec

                     user     system      total        real
original         1.008063   0.000000   1.008063 (  1.152041)
range_reduce     2.504157   0.020001   2.524158 (  2.525078)
range_reduce_1   0.320020   0.000000   0.320020 (  0.319301)
ArrayReduce      0.652041   0.000000   0.652041 (  0.653359)
Calyhre          0.352022   0.000000   0.352022 (  0.349252)
</code></pre>

<p>Ma méthode bien moche fonctionne plutôt bien ici :)</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Exercise Ruby : Reduce ranges - une solution]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/07/01/exercise-ruby-reduce-ranges-une-solution/"/>
    <updated>2014-07-01T21:07:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/07/01/exercise-ruby-reduce-ranges-une-solution</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Je rappelle le sujet/énoncé : en partant de ce tableau:</p>

<pre><code>[1, 2, 3, 7, 9, 17, 18, 19, 20]
</code></pre>

<p>on doit obtenir celui-ci:</p>

<pre><code>[1..3, 7, 9, 17..20]
</code></pre>

<p>En y réflechissant un peu, je me suis demandé si le module <code>Enumerable</code>
offrait une méthode qui nous aiderait. Bingo ! J'ai trouvé la méthode
<code>slice_before</code>, que je n'avais jamais utilisé jusqu'ici. Voici donc ma
solution:</p>

<!-- more -->


<p>``` ruby
def range_reduce(array)
  previous = array.first
  array.slice_before do |element|</p>

<pre><code>previous, previous2 = element, previous
previous2.succ != element
</code></pre>

<p>  end.map do |element|</p>

<pre><code>element.size == 1 ? element.first : element.first..element.last
</code></pre>

<p>  end
end
```</p>

<p>Quand je la compare à la solution originale de l'auteur de la gem:</p>

<p>``` ruby
def original(array)
  arr = array.dup
  arr.each_with_index do |el, index|</p>

<pre><code>range_index = index + 1
prev = el
while arr[range_index] == prev + 1 do
  prev = arr[range_index]
  range_index += 1
end
arr[index..range_index-1] = (arr[index]..arr[range_index-1]) unless index == range_index - 1
</code></pre>

<p>  end
end
```</p>

<p>Je me dis que je préfère la mienne, que je la trouve plus claire. Et j'étais
à deux doigts de balancer ma belle solution dans une <em>Pull Request</em> à l'auteur,
quand je me suis dis que je ferais bien de faire un benchmark quand même.
Et là, <em>patatra</em>:</p>

<p>``` ruby
require &lsquo;benchmark&rsquo;</p>

<p>array1 = [1, 2, 3, 7, 9, 17, 18, 19, 20]</p>

<p>Benchmark.bmbm do |x|
  x.report(&ldquo;mine&rdquo;) { 100_000.times { range_reduce(array1) } }
  x.report(&ldquo;original&rdquo;) { 100_000.times { original(array1) } }
end
```</p>

<pre><code>Rehearsal --------------------------------------------
mine       2.270000   0.000000   2.270000 (  2.270935)
original   0.710000   0.000000   0.710000 (  0.709436)
----------------------------------- total: 2.980000sec

               user     system      total        real
mine       2.320000   0.000000   2.320000 (  2.321878)
original   0.690000   0.000000   0.690000 (  0.692148)
</code></pre>

<p>Le score est sans appel ! Ma belle méthode sucre les fraises :(</p>

<p>Du coup j'ai bien envie de voir si je peux faire mieux que la méthode
originale ;) Soit en tentant d'améliorer ma méthode, soit en déroulant
un algorithme «à la C». On verra peut-être demain.</p>

<p>En attendant, vos solutions m'intéresse, n'hésitez pas à les envoyer dans
un commentaire.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Exercice Ruby : Reduce Ranges]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/06/30/exercice-ruby-reduce-ranges/"/>
    <updated>2014-06-30T21:09:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/06/30/exercice-ruby-reduce-ranges</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Je suis tombé récemment sur une nouvelle gem, <a href="https://github.com/jacobaweiss/reduce_ranges">ReduceRanges</a>.</p>

<p>Le sujet de cette gem est de transformer ceci:</p>

<pre><code>[1, 2, 3, 7, 9, 17, 18, 19, 20]
</code></pre>

<p>en cela:</p>

<pre><code>[1..3, 7, 9, 17..20]
</code></pre>

<!-- more -->


<p>Au delà de l'intéret d'une telle gem (je n'ai pas vraiment de <em>use cases</em> à
proposer, si vous en connaissez, laissez moi donc un commentaire) j'ai trouvé
l'exercice intéressant.</p>

<p>Demain je vous proposerais ma solution. Si vous voulez jouer, ne regardez pas
le code de la gem et proposez moi le votre ici, où dans l'article de demain.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
