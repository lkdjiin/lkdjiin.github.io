<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : intermédiaire | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/intermediaire/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2014-04-26T14:46:41+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ruby - Et si on écrivait un ORM ? - partie 9]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/04/26/ruby-et-si-on-ecrivait-un-orm-partie-9/"/>
    <updated>2014-04-26T14:23:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/04/26/ruby-et-si-on-ecrivait-un-orm-partie-9</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Encore du refactoring, cette fois ci dans la classe <code>Base</code>. Regardons le
code suivant:</p>

<p>``` ruby
  class Base</p>

<pre><code>def self.sql(raw_query)
  Database.connection.execute(raw_query)
end
</code></pre>

<p>```</p>

<p>Le <code>Database.connection.execute</code> me dérange. Il viole
<a href="http://fr.wikipedia.org/wiki/Loi_de_D%C3%A9m%C3%A9ter">la loi de Demeter</a>.</p>

<!-- more -->


<p>À bien y réfléchir, je n'ai tout simplement pas envie d'exposer la méthode
<code>connection</code>, qu'on trouve aussi un peu plus loin dans la class <code>Base</code>:</p>

<p>``` ruby</p>

<pre><code>def self.save(parameters)
  Recorder.new(Database.connection, self.to_s.downcase, parameters).save
  self.new(parameters)
end
</code></pre>

<p>```</p>

<p>La classe <code>Database</code> est actuellement comme ça:</p>

<p>``` ruby
  class Database</p>

<pre><code>@@connection = false

def self.connect(database_filename)
  @@connection = SQLite3::Database.open(database_filename)
end

def self.connected?
  !!@@connection
end

def self.connection
  @@connection
end
</code></pre>

<p>  end
```</p>

<p>Je supprime purement et simplement la méthode <code>connection</code>:</p>

<p>``` ruby
  class Database</p>

<pre><code>@@connection = false

def self.connect(database_filename)
  @@connection = SQLite3::Database.open(database_filename)
end

def self.connected?
  !!@@connection
end
</code></pre>

<p>  end
```</p>

<p>Maintenant, on rejoue les tests, qui vont nous indiquer ce qui doit être
réécrit:</p>

<pre><code>$ rspec sorm_spec.rb 
[...]
     NoMethodError:
       undefined method `connection' for SORM::Database:Class
     # ./sorm.rb:19:in `sql'
[...]
     NoMethodError:
       undefined method `connection' for SORM::Database:Class
     # ./sorm.rb:23:in `save'
[...]
7 examples, 5 failures
</code></pre>

<p>On va simplement créer une méthode <code>Database.execute</code>, qui elle, pourra
utiliser l'objet <code>connection</code>:</p>

<p>``` ruby
  class Database</p>

<pre><code>@@connection = false

def self.connect(database_filename)
  @@connection = SQLite3::Database.open(database_filename)
end

def self.connected?
  !!@@connection
end

def self.execute(sql)
  @@connection.execute(sql)
end
</code></pre>

<p>  end</p>

<p>  class Base</p>

<pre><code>def self.sql(raw_query)
  Database.execute(raw_query)
end
</code></pre>

<p>  # &hellip;
```</p>

<p>À y regarder de près, je ne suis plus certain de trouver un intérêt à
<code>Base.sql</code>. Il faudrait la supprimer puisqu'elle peut être remplacée par
<code>Database.execute</code>. Mais il faudra attendre car il y a encore des tests qui ne
passent plus, à cause de ce code:</p>

<p>``` ruby</p>

<pre><code>def self.save(parameters)
  Recorder.new(Database.connection, self.to_s.downcase, parameters).save
  self.new(parameters)
end
</code></pre>

<p>```</p>

<p>On s'en occupera la prochaine fois.</p>

<p><em>To be continued</em></p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby - Et si on écrivait un ORM ? - partie 8]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/04/25/ruby-et-si-on-ecrivait-un-orm-partie-8/"/>
    <updated>2014-04-25T21:17:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/04/25/ruby-et-si-on-ecrivait-un-orm-partie-8</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Je continue le refactoring de SORM. Voici la classe <code>Database</code> dans son
état actuel:</p>

<p>``` ruby sorm.rb
require &lsquo;sqlite3&rsquo;</p>

<p>module SORM</p>

<p>  class Database</p>

<pre><code>@@db = false

def self.connect(database_filename)
  @@db = SQLite3::Database.open(database_filename)
end

def self.connected?
  @@db ? true : false
end

def self.connection
  @@db
end
</code></pre>

<p>  end</p>

<h1>&hellip;</h1>

<p>end
```</p>

<!-- more -->


<p>La première chose que j'ai envie de faire, c'est de supprimer l'abbréviation
<code>db</code>. De plus, comme il s'agit plutôt d'établir une <em>connexion</em>, je change
pour <code>connection</code>:</p>

<p>``` ruby
  class Database</p>

<pre><code>@@connection = false

def self.connect(database_filename)
  @@connection = SQLite3::Database.open(database_filename)
end

def self.connected?
  @@connection ? true : false
end

def self.connection
  @@connection
end
</code></pre>

<p>  end
```</p>

<p>À ce sujet, j'applique <a href="http://lkdjiin.github.io/blog/2013/08/21/code-propre-non-aux-abreviations/">mes propres principes</a> ;)</p>

<p>Ensuite je vais modifier l'implémentation de la méthode <code>.connected?</code>. Elle
va passer de:</p>

<p>``` ruby</p>

<pre><code>def self.connected?
  @@db ? true : false
end
</code></pre>

<p>```</p>

<p>À quelque chose de plus expressif:</p>

<p>``` ruby</p>

<pre><code>def self.connected?
  !!@@connection
end
</code></pre>

<p>```</p>

<p>J'ai écris récemment un article sur <a href="http://lkdjiin.github.io/blog/2014/04/23/le-double-bang-en-ruby/">le double bang</a> si vous vous
demandez ce que c'est ;)</p>

<p>La prochaine fois, on <em>refactorera</em> un peu plus la classe <code>Base</code>.</p>

<p><em>To be continued</em></p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby - Et si on écrivait un ORM ? - partie 7]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/04/24/ruby-et-si-on-ecrivait-un-orm-partie-7/"/>
    <updated>2014-04-24T21:01:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/04/24/ruby-et-si-on-ecrivait-un-orm-partie-7</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Seconde partie du refactoring de SORM, mon <em>toy ORM</em> qui me sert de
prétexte pour quelques articles ;)</p>

<!-- more -->


<p>Parce que j'espère que vous avez compris que je n'était pas sérieusement
en train d'écrire un nouvel ORM pour Ruby, hein ? C'est juste pour étudier
un peu ensemble comment ça fonctionne…</p>

<p>Bref, il est temps je pense d'utiliser quelques namespace. <code>SORM::Database</code>
pour gérer la connexion et <code>SORM::Base</code> comme modèle de base. Voici donc les
tests remaniés:</p>

<p>``` ruby sorm_spec.rb
require &lsquo;./sorm&rsquo;</p>

<p>describe SORM::Database do
  describe &lsquo;connection&rsquo; do</p>

<pre><code>it 'is not connected' do
  expect(SORM::Database.connected?).to be false
end

describe 'after connection' do
  it 'is connected' do
    SORM::Database.connect('test.db')
    expect(SORM::Database.connected?).to be true
  end
end
</code></pre>

<p>  end
end</p>

<p>describe SORM::Base do
  class Article &lt; SORM::Base ; end</p>

<p>  describe &lsquo;.sql&rsquo; do</p>

<pre><code>before do
  Article.sql("INSERT INTO article VALUES(1, 'Foo');")
  Article.sql("INSERT INTO article VALUES(2, 'Bar');")
end

after do
  Article.sql("DELETE FROM article;")
end

it 'returns the correct number of rows' do
  rows = Article.sql("SELECT * FROM article;")
  expect(rows.size).to eq 2
end

it 'returns correct values' do
  rows = Article.sql("SELECT * FROM article;")
  expect(rows[0][0]).to eq 1
  expect(rows[0][1]).to eq 'Foo'
  expect(rows[1][0]).to eq 2
  expect(rows[1][1]).to eq 'Bar'
end
</code></pre>

<p>  end</p>

<p>  describe &lsquo;object creation&rsquo; do</p>

<pre><code>after { Article.sql("DELETE FROM article;") }

it 'creates a record' do
  Article.save(id: 1, name: 'bépo')
  rows = Article.sql("SELECT * FROM article WHERE id = 1;")
  expect(rows[0][0]).to eq 1
  expect(rows[0][1]).to eq 'bépo'
end

it 'returns an object with correct class' do
  article = Article.save(id: 1, name: 'bépo')
  expect(article.class).to eq Article
end

it 'returns an object with correct attributes' do
  article = Article.save(id: 1, name: 'bépo')
  expect(article.id).to eq 1
  expect(article.name).to eq 'bépo'
end
</code></pre>

<p>  end
end
```</p>

<p>Et bien sûr la nouvelle implémentation qui va avec:</p>

<p>``` ruby sorm.rb
require &lsquo;sqlite3&rsquo;</p>

<p>module SORM</p>

<p>  class Database</p>

<pre><code>@@db = false

def self.connect(database_filename)
  @@db = SQLite3::Database.open(database_filename)
end

def self.connected?
  @@db ? true : false
end

def self.connection
  @@db
end
</code></pre>

<p>  end</p>

<p>  class Base</p>

<pre><code>def self.sql(raw_query)
  Database.connection.execute(raw_query)
end

def self.save(parameters)
  Recorder.new(Database.connection, self.to_s.downcase, parameters).save
  self.new(parameters)
end

def initialize(attributes)
  attributes.each do |name, value|
    instance_variable_set("@#{name}", value)
    singleton_class.class_eval{attr_reader name.to_sym}
  end
end
</code></pre>

<p>  end</p>

<p>  class Recorder</p>

<pre><code>def initialize(connection, table, parameters)
  @connection = connection
  @table = table
  @parameters = parameters
end

def save
  @connection.execute(query)
end

def query
  "INSERT INTO #@table (#{columns}) VALUES(#{values});"
end

def columns
  @parameters.keys.join(',')
end

def values
  @parameters.values.map do |item|
    item.class == String ? "'#{item}'" : item
  end.join(',')
end
</code></pre>

<p>  end
end
```</p>

<p>Voilà, ça fait pas mal de code sans explication :( mais j'ai peu de temps
aujourd'hui. La prochaine on fera… je sais pas… on verra bien ;)</p>

<p><em>To be continued</em></p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby - Et si on écrivait un ORM ? - partie 6]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/04/20/ruby-et-si-on-ecrivait-un-orm-partie-6/"/>
    <updated>2014-04-20T12:53:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/04/20/ruby-et-si-on-ecrivait-un-orm-partie-6</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Hier je m'étais arrêté sur cette implémentation de <code>SORM.save</code>:</p>

<p>``` ruby
  def self.save(parameters)</p>

<pre><code>table = self.to_s.downcase
columns = parameters.keys.join(',')
values = parameters.values.map do |item|
  item.class == String ? "'#{item}'" : item
end.join(',')
query = "INSERT INTO #{table} (#{columns}) VALUES(#{values});"
@@db.execute(query)
</code></pre>

<p>  end
```</p>

<p>Cette méthode est déja bien trop longue selon mes critères, et si on ne fait
pas quelque chose tout de suite on va vite se retrouver avec un tas de
méthodes de classe impossibles à remanier.</p>

<!-- more -->


<p>Une première partie du refactoring va consister à extraire une classe que
je vais nommer <code>Recorder</code>:</p>

<p>``` ruby
  def self.save(parameters)</p>

<pre><code>recorder = Recorder.new(@@db, self.to_s.downcase, parameters)
recorder.save
</code></pre>

<p>  end</p>

<p>  class Recorder</p>

<pre><code>def initialize(connection, table, parameters)
  @connection = connection
  @table = table
  @parameters = parameters
end

def save
  @connection.execute(query)
end

def query
  "INSERT INTO #@table (#{columns}) VALUES(#{values});"
end

def columns
  @parameters.keys.join(',')
end

def values
  @parameters.values.map do |item|
    item.class == String ? "'#{item}'" : item
  end.join(',')
end
</code></pre>

<p>  end
```</p>

<p>Ça permet d'avoir des méthodes simples, faciles à comprendre.</p>

<p>Une seconde partie du refactoring consistera à <em>namespacer</em> correctement
les différentes parties de SORM. Pour ça il faudra aussi modifier les tests.</p>

<p><em>To be continued</em></p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby - Et si on écrivait un ORM ? - partie 5]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/04/19/ruby-et-si-on-ecrivait-un-orm-partie-5/"/>
    <updated>2014-04-19T21:14:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/04/19/ruby-et-si-on-ecrivait-un-orm-partie-5</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Au menu d'aujourd'hui: réparation du test défecteux et début de la
création/insertion d'un objet.</p>

<!-- more -->


<p>Tout d'abord on répare le test d'hier. Je sors les appels à <code>INSERT</code> dans
un bloc <code>before</code> et j'ajoute ce qui manquait cruellement, un appel à
<code>DELETE</code> dans un bloc <code>after</code>:</p>

<p>``` ruby
  describe &lsquo;.sql&rsquo; do</p>

<pre><code>before do
  Article.sql("INSERT INTO article VALUES(1, 'Foo');")
  Article.sql("INSERT INTO article VALUES(2, 'Bar');")
end

after do
  Article.sql("DELETE FROM article;")
end

it 'returns the correct number of rows' do
  rows = Article.sql("SELECT * FROM article;")
  expect(rows.size).to eq 2
end

it 'returns correct values' do
  rows = Article.sql("SELECT * FROM article;")
  expect(rows[0][0]).to eq 1
  expect(rows[0][1]).to eq 'Foo'
  expect(rows[1][0]).to eq 2
  expect(rows[1][1]).to eq 'Bar'
end
</code></pre>

<p>  end
```</p>

<p>Voilà, maintenant on peut passer à la partie création. J'ai envie que SORM
ait une méthode <code>save</code>, qui enregistrera les données en base et
renverra un objet. On commence avec un test pour l'enregistrement:</p>

<p>``` ruby sorm_spec.rb
require &lsquo;./sorm&rsquo;</p>

<p>describe SORM do
  describe &lsquo;connection&rsquo; do</p>

<pre><code># ...
</code></pre>

<p>  end</p>

<p>  class Article &lt; SORM
  end</p>

<p>  describe &lsquo;.sql&rsquo; do</p>

<pre><code># ...
</code></pre>

<p>  end</p>

<p>  describe &lsquo;object creation&rsquo; do</p>

<pre><code>after { Article.sql("DELETE FROM article;") }

it 'creates a record' do
  Article.save(id: 1, name: 'bépo')
  rows = Article.sql("SELECT * FROM article WHERE id = 1;")
  expect(rows[0][0]).to eq 1
  expect(rows[0][1]).to eq 'bépo'
end
</code></pre>

<p>  end
end
```</p>

<p>J'écris un premier jet de la méthode <code>save</code>, pour faire passer le test:</p>

<p>``` ruby sorm.rb
require &lsquo;sqlite3&rsquo;</p>

<p>class SORM</p>

<p>  @@db = false</p>

<p>  def self.connect(database_filename)</p>

<pre><code>@@db = SQLite3::Database.open(database_filename)
</code></pre>

<p>  end</p>

<p>  def self.connected?</p>

<pre><code>@@db ? true : false
</code></pre>

<p>  end</p>

<p>  def self.sql(raw_query)</p>

<pre><code>@@db.execute(raw_query)
</code></pre>

<p>  end</p>

<p>  def self.save(parameters)</p>

<pre><code>table = self.to_s.downcase
columns = parameters.keys.join(',')
values = parameters.values.map do |item|
  item.class == String ? "'#{item}'" : item
end.join(',')
query = "INSERT INTO #{table} (#{columns}) VALUES(#{values});"
@@db.execute(query)
</code></pre>

<p>  end
end
```</p>

<p>Ça fonctionne, mais la méthode est moche. Ce sera l'occasion de faire du
refactoring dans un prochain article.</p>

<p><em>To be continued</em></p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
