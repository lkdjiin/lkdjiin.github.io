<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : intermédiaire | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/intermediaire/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2013-12-14T17:30:13+01:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Les algorithmes génétiques démystifiés 43: Économie, la population]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/12/13/les-algorithmes-genetiques-demystifies-43-economie-la-population/"/>
    <updated>2013-12-13T21:36:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/12/13/les-algorithmes-genetiques-demystifies-43-economie-la-population</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Après avoir vu dernièrement l'énoncé du <a href="http://lkdjiin.github.io/blog/2013/12/11/les-algorithmes-genetiques-demystifies-42-un-probleme-deconomie/">problème d'investissement</a>
que je me propose de résoudre à l'aide d'un algorithme génétique, on
peut maintenant créer la population initiale.</p>

<!-- more -->


<p>Je me base sur le programme développé pour le problème du sac à dos
<a href="https://github.com/lkdjiin/knapsack_genetic_algorithm/blob/master/knapsack3.rb">disponible sur Github</a>.
Par contre, le code nécessite la version 2.1 de Ruby (disponible en
preview2 à l'heure où j'écris ces lignes).</p>

<p>Tout d'abord la classe <code>Individual</code>, qui recueille toutes les informations
sur nos individus: chromosome, score et fitness.</p>

<p>``` ruby
class Individual</p>

<p>  class &lt;&lt; self</p>

<pre><code>def random(items)
  new(nil, items)
end

def from_chromosome(chromosome)
  new(chromosome)
end

def listing(chromosome:, items:)
  chromosome.map.with_index do |gene, index|
    "#{gene} #{items[index].name}"
  end.join("\n")
end
</code></pre>

<p>  end</p>

<p>  attr_accessor :score, :fitness
  attr_reader :chromosome</p>

<p>  def initialize(chromosome = nil, items = nil)</p>

<pre><code>if chromosome
  @chromosome = chromosome
else
  @chromosome = []
  items.each_with_index do |item, index|
    @chromosome &lt;&lt; rand(0..item.number)
  end
end
</code></pre>

<p>  end
  private_class_method :new</p>

<p>  def >(other)</p>

<pre><code>return true if other.nil?
score &gt; other.score
</code></pre>

<p>  end
end
```</p>

<p>J'ai ajouté une méthode de classe <code>listing</code>:</p>

<p>``` ruby</p>

<pre><code>def listing(chromosome:, items:)
  chromosome.map.with_index do |gene, index|
    "#{gene} #{items[index].name}"
  end.join("\n")
end
</code></pre>

<p>```</p>

<p>Elle utilise <a href="http://lkdjiin.github.io/blog/2013/11/27/du-nouveau-dans-ruby-2-dot-1-argument-nomme-et-requis/">les arguments nommés requis</a> de Ruby 2.1 et prend en
paramêtre un chromosome et la liste des actions (<code>Knapsack::ITEMS</code>,
<a href="http://lkdjiin.github.io/blog/2013/12/11/les-algorithmes-genetiques-demystifies-42-un-probleme-deconomie/">voir l'article précédent</a>). Elle servira à afficher la liste des actions,
avec le nombre retenu pour chacune d'entres elles à la fin de l'algorithme.</p>

<p>Dans la méthode <code>initialize</code>, on peut voir comment je crée les chromosomes
de la population initiale:</p>

<p>``` ruby</p>

<pre><code>else
  @chromosome = []
  items.each_with_index do |item, index|
    @chromosome &lt;&lt; rand(0..item.number)
  end
end
</code></pre>

<p>```</p>

<p><code>items</code> se réfère à la liste des actions (<code>Knapsack::ITEMS</code>). Un chromosome est
une liste de la même taille que <code>items</code>. Chaque gène (ou emplacement dans
la liste) est un nombre compris entre zéro et le nombre maximum d'actions
pour cette action particulière (voir encore une fois <code>Knapsack::ITEMS</code>).</p>

<p>Maintenant, pour la création de la population proprement dite, il n'y a
rien de nouveau:</p>

<p>``` ruby
class Population &lt; Array
  def initialize(items, population_size)</p>

<pre><code>population_size.times { self &lt;&lt; Individual.random(items) }
</code></pre>

<p>  end</p>

<p>  def best</p>

<pre><code>self.sort_by{|individual| individual.score}.last
</code></pre>

<p>  end
end
```</p>

<p>La prochaine fois on verra l'évaluation…</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les algorithmes génétiques démystifiés 42: Un problème d'économie]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/12/11/les-algorithmes-genetiques-demystifies-42-un-probleme-deconomie/"/>
    <updated>2013-12-11T20:56:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/12/11/les-algorithmes-genetiques-demystifies-42-un-probleme-deconomie</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Jusqu'ici les problèmes abordés dans cette série d'articles ont été très
<em>théoriques</em>.  Le dernier algorithme génétique qu'on a exploré a permis de
résoudre
<a href="http://lkdjiin.github.io/blog/2013/11/12/les-algorithmes-genetiques-demystifies-37-le-probleme-du-sac-a-dos/">le problème du sac à dos</a>. Ce problème du sac à dos est une bonne base
<em>théorique</em> pour aborder certains problèmes plus <em>concrets</em>. On va justement
se rapprocher un peu du monde réel en tentant de résoudre un problème
d'économie: optimiser un investissement.</p>

<!-- more -->


<p>Voici l'énoncé du problème: Vous êtes un investisseur et vous disposez
d'une somme de 15 000 € pour acheter des actions du CAC 40.
Vous connaissez le coût
d'une action (son prix), vous savez combien elle rapportera dans, disons un
an, et vous connaissez le nombre d'actions disponibles (combien vous pouvez
en acheter). L'objectif est de savoir combien d'actions acheter pour chaque
entreprise du CAC 40, histoire de faire un maximum de profit.</p>

<p>Alors si on se rapproche du monde réel, on est encore dans un monde
fantastique, puisque pour savoir combien rapportera
une action, soit vous avez un super-pouvoir, soit vous connaissez un
ami médium. Quoiqu'il en soit, il me semble que c'est un problème intéressant,
donc c'est parti.</p>

<p>Ce problème est très proche du problème du sac à dos, je vais donc me baser
sur le code développé dans les derniers articles, et qui est
<a href="https://github.com/lkdjiin/knapsack_genetic_algorithm/blob/master/knapsack3.rb">disponible sur Github</a>.</p>

<p>Dans le problème du sac à dos, on devait choisir des objets ; ici les actions
remplacent les objets. Les objets avaient un poid ; ici les actions ont un
coût. Les objets avaient une valeur ; ici aussi les actions ont une
valeur, qu'on nommera «profit». La différence, c'est qu'ici on va pouvoir
choisir plusieurs actions de même type.</p>

<p>Voici comment on peut représenter une action:</p>

<p><code>ruby
KnapsackItem = Struct.new(:name, :cost, :profit, :number)
</code></p>

<p>On a le nom de l'action (<code>name</code>), son coût en euros (<code>cost</code>), le profit
attendu en euros (<code>profit</code>) et le nombre d'actions disponibles (<code>number</code>).</p>

<p>Pour le stock d'actions dans lequel on va puiser, j'ai été voir le CAC 40,
j'ai pris la valeur réelle des actions (arrondi à l'entier) et j'ai
généré aléatoirement les champs profit et number:</p>

<p>``` ruby
module Knapsack
  ITEMS = [</p>

<pre><code>KnapsackItem.new('ACCOR', 32, 9, 60),
KnapsackItem.new('AIR_LIQUIDE', 97, 7, 32),
KnapsackItem.new('ALSTOM', 25, 5, 6),
KnapsackItem.new('ARCELORMITTAL_REG', 12, 9, 43),
KnapsackItem.new('AXA', 18, 2, 65),
KnapsackItem.new('BNP_PARIBAS', 53, 3, 24),
KnapsackItem.new('BOUYGUES', 25, 9, 38),
KnapsackItem.new('CAP_GEMINI', 46, 1, 47),
KnapsackItem.new('CARREFOUR', 27, 3, 37),
KnapsackItem.new('CREDIT_AGRICOLE_SA', 8, 4, 99),
KnapsackItem.new('DANONE', 51, 1, 43),
KnapsackItem.new('EADS', 49, 6, 63),
KnapsackItem.new('EDF', 26, 5, 87),
KnapsackItem.new('ESSILOR_INTERNATIONAL', 73, 6, 49),
KnapsackItem.new('GDF_SUEZ', 16, 1, 42),
KnapsackItem.new('GEMALTO', 76, 2, 53),
KnapsackItem.new('KERING', 150, 5, 97),
KnapsackItem.new("L'OREAL", 126, 7, 100),
KnapsackItem.new('LAFARGE', 49, 3, 93),
KnapsackItem.new('LEGRAND_SA', 39, 2, 49),
KnapsackItem.new('LVMH_MOET_VUITTON', 129, 9, 8),
KnapsackItem.new('MICHELIN', 75, 4, 43),
KnapsackItem.new('ORANGE', 8, 7, 1),
KnapsackItem.new('PERNOD_RICARD', 80, 4, 53),
KnapsackItem.new('PUBLICIS_GROUPE', 63, 11, 49),
KnapsackItem.new('RENAULT', 58, 4, 32),
KnapsackItem.new('SAFRAN', 47, 2, 61),
KnapsackItem.new('SAINT_GOBAIN', 36, 7, 33),
KnapsackItem.new('SANOFI', 73, 9, 70),
KnapsackItem.new('SCHNEIDER_ELECTRIC', 58, 6, 21),
KnapsackItem.new('SOCIETE_GENERALE', 40, 3, 93),
KnapsackItem.new('SOLVAY', 108, 5, 33),
KnapsackItem.new('STMICROELECTRONICS', 5, 1, 75),
KnapsackItem.new('TECHNIP', 72, 3, 47),
KnapsackItem.new('TOTAL', 42, 10, 95),
KnapsackItem.new('UNIBAIL-RODAMCO', 184, 9, 82),
KnapsackItem.new('VALLOUREC', 39, 4, 51),
KnapsackItem.new('VEOLIA_ENVIRONNEMENT', 11, 10, 2),
KnapsackItem.new('VINCI', 45, 6, 53),
KnapsackItem.new('VIVENDI', 17, 5, 38)
</code></pre>

<p>  ]
end
```</p>

<p>La prochaine fois on s'occupera de générer la population initiale.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vim: Plier (folder) les commentaires de style Unix]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/11/28/vim-plier-folder-les-commentaires-de-style-unix/"/>
    <updated>2013-11-28T16:39:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/11/28/vim-plier-folder-les-commentaires-de-style-unix</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Certains fichiers sources contiennent une proportion non négligeable de
commentaires, ou documentation interne. Par exemple, le fichier
<a href="https://github.com/ruby/ruby/blob/trunk/lib/csv.rb">ruby/lib/csv.rb</a> de
Ruby contient à ce jour 46% de lignes qui sont des commentaires. Quand on
cherche à étudier ces sources  pour la première fois, le nombre
important de commentaire est un frein pour naviguer ou se repérer dans
un tel fichier. Aujourd'hui je montre comment replier facilement les
ensembles de lignes commençant par <code>#</code>.</p>

<!-- more -->


<h2>Présentation</h2>

<p>Les fonctions de Vim qu'on va utiliser sont les suivantes:</p>

<pre><code>Fonction      Raccourci
=======================
foldmethod    fdm
foldexpr      fde
</code></pre>

<p>Vim comporte plusieurs méthodes de pliage (<em>folding</em>) de code, qu'on
spécifie avec <code>foldmethod</code>. Ici on va utiliser la méthode <code>expr</code>, qui
permet de faire à peu près tout ce qu'on veut. L'expression sera
spécifiée avec <code>foldexpr</code>.</p>

<h2>Essai en direct</h2>

<p>On va d'abord voir comment ça marche en entrant les commandes en direct live.
Ouvrez le fichier
<a href="https://github.com/ruby/ruby/blob/trunk/lib/csv.rb">ruby/lib/csv.rb</a>
(ou un autre avec beaucoup de commentaires de style Unix) et entrez ce qui
suit:</p>

<p><code>vim
:set fdm=expr
:set fde=getline(v:lnum)=~'^\\s*#'
</code></p>

<p>Badaboum ! Tout les commentaires sont pliés. Explications:</p>

<pre><code>getline(v:lnum)
</code></pre>

<p>Cette fonction retrouve une ligne du fichier. <code>v:lnum</code> est une variable
prédéfinie qui contient le numéro de la ligne courante.</p>

<pre><code>=~
</code></pre>

<p>Cet opérateur a le même sens qu'en Ruby, par exemple. Autrement dit,
est-ce que la chaîne à ma gauche correspond à la regex à ma droite ?</p>

<pre><code>'^\\s*#'
</code></pre>

<p>C'est notre regex: début de ligne (<code>^</code>), suivi par un nombre quelconque
de blancs (<code>\\s*</code>), suivi par le caractère <code>#</code>.</p>

<p>L'expression spécifiée dans <code>foldexpr</code> (ou comme ici <code>fde</code>) sera appelée
par Vim sur chaque ligne du fichier.</p>

<h2>Embarqué dans le fichier</h2>

<p>Maintenant qu'on sait comment ça marche, voyons comment faire pour ne pas
avoir à taper ces 2 lignes à chaque fois.</p>

<p>Si vous écrivez la ligne suivante dans un fichier, typiquement à la fin, les
commandes seront executées automatiquement à l'ouverture du fichier.
C'est un truc utile à connaitre.</p>

<p>``` vim</p>

<h1>vim:fdm=expr:fde=getline(v\:lnum)=~&lsquo;^\s*#&rsquo;:</h1>

<p>```</p>

<p>Notez qu'il a fallu échapper le <code>:</code> de <code>v:lnum</code> pour que ça fonctionne.</p>

<h2>Une fonction</h2>

<p>Une fonction dans le <code>.vimrc</code> sera plus intéressante:</p>

<p><code>vim
function FoldUnixComments()
  set foldmethod=expr
  set foldexpr=getline(v:lnum)=~'^\\s*#'
endfunction
</code></p>

<p>Pour l'executer:</p>

<p><code>vim
:call FoldUnixComments()
</code></p>

<h2>Conclusion</h2>

<p>La méthode présentée ici n'est pas parfaite. En effet <code>foldmethod=expr</code>
<em>écrase</em> votre ancienne méthode. Néanmoins, elle me semble suffisante
quand il s'agit juste d'étudier un fichier.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Du nouveau dans Ruby 2.1: Définition de méthode]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/11/22/du-nouveau-dans-ruby-2-dot-1-definition-de-methode/"/>
    <updated>2013-11-22T17:40:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/11/22/du-nouveau-dans-ruby-2-dot-1-definition-de-methode</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Ruby 2.1 devrait être là dans pas longtemps, il est temps de regarder
ce que cette nouvelle version nous offre. Aujourd'hui on va voir un petit
changement dans la définition des méthodes.</p>

<!-- more -->


<h2>Ce qui change avec def</h2>

<p>Jusqu'ici, <code>def</code> renvoyait <code>nil</code>:</p>

<pre><code>[~]⇒ rvm use 2.0.0
[~]⇒ irb
&gt;&gt; def foo;end
nil
</code></pre>

<p>Dans Ruby 2.1, <code>def</code> va renvoyer le nom de la méthode (en tant que symbole):</p>

<pre><code>[~]⇒ rvm use 2.1.0-preview1
[~]⇒ irb
&gt;&gt; def foo;end
=&gt; :foo
</code></pre>

<h2>Un cas d'utilisation</h2>

<p>Pour l'instant je ne connais qu'un seul cas d'utilisation:</p>

<p><code>ruby
private def foo ; end
</code></p>

<p>On peut utiliser Ruby pendant très longtemps avant de se rendre compte que
<code>private</code> est une méthode et non un mot-clé. Avant Ruby 2.1, l'utilisation
typique de <code>private</code> est celle-ci:</p>

<p>``` ruby
class Foo
  def foo ; end</p>

<p>  private</p>

<p>  def bar ; end
end
```</p>

<p>Autrement dit: les méthodes publiques avant <code>private</code> et les méthodes privées
après. Une autre possibilité intéressante est la suivante:</p>

<p>``` ruby
class Foo
  def foo ; end</p>

<p>  def foo_helper ; end
  private :bar
end
```</p>

<p>Moins utilisée mais pourtant cool, cette façon de faire permet de garder,
par exemple, une méthode helper sous la méthode appellante.</p>

<p>Avec Ruby 2.1 nous aurons donc la possibilité d'écrire ceci:</p>

<p>``` ruby
class Foo
  def foo ; end</p>

<p>  private foo_helper ; end
end
```</p>

<p>Voilà. Si vous connaissez un autre cas d'utilisation, laissez donc un
commentaire.</p>

<p><strong>Source (pdf)</strong> <a href="http://www.atdot.net/~ko1/activities/toruby05-ko1.pdf">toruby</a></p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les algorithmes génétiques démystifiés 41: Les individus invalides]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/11/19/les-algorithmes-genetiques-demystifies-41-les-individus-invalides/"/>
    <updated>2013-11-19T20:56:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/11/19/les-algorithmes-genetiques-demystifies-41-les-individus-invalides</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>La dernière fois on a vu comment l'introduction d'une petite dose
d'élitisme augmentait légèrement les performances d'un algorithme
génétique (<a href="http://lkdjiin.github.io/blog/2013/11/18/les-algorithmes-genetiques-demystifies-40-ajout-delitisme/">lire l'article</a>).
Aujourd'hui on va <em>véritablement booster</em> ces performances
dans le cadre du problème du sac à dos, en tenant compte des individus
invalides.</p>

<!-- more -->


<h2>Bref rappel du problème</h2>

<p>La capacité du sac à dos est de 400 (grammes, kilos, unités, etc…) et on ne
doit pas la dépasser. Autrement dit, un couple {<em>poids</em>, <em>valeur</em>} de
{401, 1000} est bien plus proche de la solution idéale que le couple
{399, 500}. Pourtant, d'après les règles qu'on a utilisées jusqu'ici, la
solution {401, 1000} est purement et simplement éliminée puisque jugée
invalide.</p>

<p>Il est légitime de se demander ici si on ne perd pas des gènes précieux en
éliminant de telles solutions ?</p>

<h2>Prise en compte des solutions invalides</h2>

<p>L'idée est donc de permettre aux solutions qui dépassent un peu le poids
d'être prise en considération, sans pour autant mettre les solutions
invalides à égalité avec les solutions valides.</p>

<p>Pour cela, on va appliquer une pénalité, une sanction, aux solutions
invalides. Tout se passe dans la méthode <code>score</code> de la classe
<code>Evaluator</code>. Vous pouvez trouver le code complet de cette troisième
version du programme sur Github: <a href="https://github.com/lkdjiin/knapsack_genetic_algorithm/blob/master/knapsack3.rb">knapsack3.rb</a>.
Voici ce qui change:</p>

<p>``` ruby
  def score(individual)</p>

<pre><code># [...]
if weight &gt; @capacity
  value -= 2 * (weight - @capacity)
  value = 0 if value &lt; 0
end
individual.score = value
</code></pre>

<p>  end
```</p>

<p>La pénalité appliquée à une sanction invalide est ici: 2 fois la différence
entre le poids du sac et sa capacité. C'est une valeur obtenue par
tatonnement, il n'y a rien de magique et vous devriez faire d'autres
essais… Je m'assure ensuite que la valeur n'est pas négative puisque la
méthode <code>fitness</code> attend une valeur positive.</p>

<h2>Les performances</h2>

<p>J'ai fait tourner chaque programme 200 fois et fait la moyenne de la
génération où la meilleure solution (score de 1030) est trouvée:</p>

<pre><code>Programme    | Génération moyenne | Remarques
=========================================================
knapsack.rb  |              72.06 | algo original
---------------------------------------------------------
knapsack2.rb |              67.61 | + élite
---------------------------------------------------------
knapsack3.rb |              22.55 | + élite + invalides
</code></pre>

<p>Le gain de performance est remarquable ! Moralité de cette affaire:
Pensez y à deux fois avant de jeter un chromosome invalide à la poubelle,
il contient peut-être des gènes importants.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
