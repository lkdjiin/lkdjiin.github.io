<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : investissement | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/investissement/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2014-12-20T18:30:31+01:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Les algorithmes génétiques démystifiés 48: Économie - Résolution du problème]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/12/26/les-algorithmes-genetiques-demystifies-48-economie-resolution-du-probleme/"/>
    <updated>2013-12-26T20:41:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/12/26/les-algorithmes-genetiques-demystifies-48-economie-resolution-du-probleme</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>On termine le problème d'investissement, qui je le rappelle est basiquement
un problème de sac à dos avec des objets multiples.</p>

<!-- more -->


<p>Le code complet sur trouve sur Github: <a href="https://github.com/lkdjiin/knapsack_genetic_algorithm/blob/master/invest.rb">invest.rb</a>.</p>

<p>Il restait à voir la classe <code>Mutator</code>:</p>

<p>``` ruby
class Mutator
  def initialize(mutation_rate:, items:)</p>

<pre><code>@rate = mutation_rate
@items = items
</code></pre>

<p>  end</p>

<p>  def mutate(chromosome)</p>

<pre><code>chromosome.map.with_index do |gene, index|
  if rand &lt; @rate
    rand(0..@items[index].number)
  else
    gene
  end
end
</code></pre>

<p>  end
end
```</p>

<p>La formule pour muter un gène est basique, on crée aléatoirement un
nombre compris entre 0 et le nombre d'actions maximum pour cette
action particulière:</p>

<p>``` ruby</p>

<pre><code>  if rand &lt; @rate
    rand(0..@items[index].number)
</code></pre>

<p>```</p>

<p>Il reste à initialiser l'algorithme et à le lancer:</p>

<p><code>ruby
population = Population.new(Knapsack::ITEMS, 1000)
puts "Initialized!"
GeneticAlgorithm.new(
  generations: 1_000,
  population: population,
  capacity: 15_000,
  mutation_rate: 1.0 / 1000,
  items: Knapsack::ITEMS).run
</code></p>

<p>On dispose de 1 000 individus dans la population. On s'arrête
à la 1 000ème génération. Notre capacité d'investissement est
de 15 000 €. Et le taux de mutation est fixé classiquement
comme étant l'inverse du nombre d'individus.</p>

<p>Et c'est parti:</p>

<p>``` bash
[~]⇒ ruby invest.rb
Initialized!
<invalid> Gen: 0 Profit: 4202 Cost: 35599
<invalid> Gen: 1 Profit: 3567 Cost: 34133
.
.
.</p>

<h2>VALID     Gen: 999 Profit: 3430 Cost: 14067</h2>

<h2>Best ever</h2>

<p>Profit: 3430
Cost:   14067
Listing:
49 ACCOR
0 AIR_LIQUIDE
5 ALSTOM
42 ARCELORMITTAL_REG
1 AXA
3 BNP_PARIBAS
37 BOUYGUES
0 CAP_GEMINI
7 CARREFOUR
94 CREDIT_AGRICOLE_SA
0 DANONE
7 EADS
70 EDF
1 ESSILOR_INTERNATIONAL
6 GDF_SUEZ
2 GEMALTO
1 KERING
2 L'OREAL
0 LAFARGE
0 LEGRAND_SA
1 LVMH_MOET_VUITTON
2 MICHELIN
1 ORANGE
1 PERNOD_RICARD
1 PUBLICIS_GROUPE
0 RENAULT
1 SAFRAN
21 SAINT_GOBAIN
0 SANOFI
1 SCHNEIDER_ELECTRIC
7 SOCIETE_GENERALE
0 SOLVAY
73 STMICROELECTRONICS
1 TECHNIP
90 TOTAL
1 UNIBAIL-RODAMCO
8 VALLOUREC
0 VEOLIA_ENVIRONNEMENT
1 VINCI
36 VIVENDI
```</p>

<p>Si vous pensez à quelques améliorations, et il y en a,
n'hésitez pas à les tester et/ou à m'en faire part dans un
commentaire.</p>

<p>La prochaine fois, on s'attaquera sûrement à un problème de
sac à dos multiple. C'est à dire plusieurs objets de chaque
sortes et plusieurs sacs à dos.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les algorithmes génétiques démystifiés 47: Économie]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/12/23/les-algorithmes-genetiques-demystifies-47-economie/"/>
    <updated>2013-12-23T16:13:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/12/23/les-algorithmes-genetiques-demystifies-47-economie</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>La dernière fois on a vu <a href="http://lkdjiin.github.io/blog/2013/12/19/les-algorithmes-genetiques-demystifies-46-economie-la-boucle-principale/">la classe GeneticAlgorithm</a>, qui faisait usage
d'une classe IndividualFormatter. Cette classe est le sujet de l'article
d'aujourd'hui.</p>

<!-- more -->


<p>Cette classe, <code>IndividualFormatter</code>, est responsable de la transformation
d'un individu de la population en une chaîne de caractères qui véhicule
des informations <em>affichables</em> sur cet individu:</p>

<p>``` ruby
class IndividualFormatter</p>

<p>  def self.display(individual:, generation:, items:, capacity:)</p>

<pre><code>profit, cost = Score.profit_and_cost individual, items
if cost &gt; capacity
  "&lt;invalid&gt; Gen: #{generation} Profit: #{profit} Cost: #{cost}"
else
  "VALID     Gen: #{generation} Profit: #{profit} Cost: #{cost}"
end
</code></pre>

<p>  end</p>

<p>  def self.display_best_ever(individual:, items:)</p>

<pre><code>profit, cost = Score.profit_and_cost individual, items
"----------------------\n"\
"Best ever\n"\
"----------------------\n"\
"Profit: #{profit}\n"\
"Cost:   #{cost}\n"\
"Listing:\n"\
"#{Individual.listing(chromosome: individual.chromosome, items: items)}"
</code></pre>

<p>  end
end
```</p>

<p>La méthode <code>display</code> est utilisée à chaque génération, pour afficher succintement
le meilleur individu trouvé jusqu'ici.</p>

<p>La méthode <code>display_best_ever</code> est elle, utilisée à la fin de l'algorithme,
pour afficher la meilleure solution avec plus de détails.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les algorithmes génétiques démystifiés 46: Économie, la boucle principale]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/12/19/les-algorithmes-genetiques-demystifies-46-economie-la-boucle-principale/"/>
    <updated>2013-12-19T14:26:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/12/19/les-algorithmes-genetiques-demystifies-46-economie-la-boucle-principale</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Après <a href="http://lkdjiin.github.io/blog/2013/12/16/les-algorithmes-genetiques-demystifies-45-economie-calcul-du-score/">le calcul du score</a>
d'un individu, voici maintenant le coeur du programme, la classe
<code>GeneticAlgorithm</code>.</p>

<!-- more -->


<p>Cette classe est batie sur le même modèle que pour les problèmes vus
précédement, je ne vais donc pas la commenter en détails. Voici d'abord
les méthodes publiques:</p>

<p>``` ruby
class GeneticAlgorithm
  def initialize(generations:, population:, capacity:, mutation_rate:, items:)</p>

<pre><code>@generations = generations
@population = population
@capacity = capacity
@mutation_rate = mutation_rate
@items = items
@crossover = Crossover.new chromosome_size: items.size,
  mutation_rate: mutation_rate,
  items: items
@best_ever = nil
</code></pre>

<p>  end</p>

<p>  def run</p>

<pre><code>@generations.times do |generation|
  Evaluator.new(capacity: @capacity, population: @population,
    items: @items).evaluate!
  find_best_ever(generation)
  next_generation
end
puts IndividualFormatter.display_best_ever individual: @best_ever,
  items: @items
</code></pre>

<p>  end</p>

<p>  # &hellip;</p>

<p>end
```</p>

<p>L'initialisation est des plus basiques. Quant à la méthode <code>run</code>, elle
introduit une nouvelle classe : <code>IndividualFormatter</code>. Cette classe sera
discutée en détail dans le prochain article.</p>

<p>Maintenant les méthodes privées:</p>

<p>``` ruby
class GeneticAlgorithm</p>

<p>  # &hellip;</p>

<p>  private</p>

<p>  def find_best_ever(generation)</p>

<pre><code>best = @population.best
@best_ever = best if best &gt; @best_ever
puts IndividualFormatter.display individual: @best_ever,
  generation: generation,
  items: @items,
  capacity: @capacity
</code></pre>

<p>  end</p>

<p>  def next_generation</p>

<pre><code>@population.sort_by! {|i| i.score}
elite = @population.pop(4)
pool = MatingPool.new(@population)
population_size = @population.size
@population.clear
population_size.times do
  @population &lt;&lt; @crossover.two_point(pool.random, pool.random)
end
@population.concat elite
</code></pre>

<p>  end
end
```</p>

<p><code>find_best_ever</code> va trouver le meilleur individu à un moment précis, toutes
générations confondues <em>et</em> va afficher cet individu via <code>IndividualFormatter</code>
(<em>Je sais, c'est mal, cette méthode fait deux choses…</em>).</p>

<p>Quant à la méthode <code>next_generation</code>, c'est la même que pour
<a href="http://lkdjiin.github.io/blog/2013/11/16/les-algorithmes-genetiques-39-resolution-du-sac-a-dos/">le problème précédent</a>.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les algorithmes génétiques démystifiés 45: Économie, calcul du score]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/12/16/les-algorithmes-genetiques-demystifies-45-economie-calcul-du-score/"/>
    <updated>2013-12-16T18:15:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/12/16/les-algorithmes-genetiques-demystifies-45-economie-calcul-du-score</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Hier j'ai <a href="http://lkdjiin.github.io/blog/2013/12/15/les-algorithmes-genetiques-demystifies-44-economie/">survolé les trois classes/modules</a> qui s'occupent de l'évaluation,
<code>Evaluator</code>, <code>Score</code> et <code>Fitness</code>. Aujourd'hui je parle en détail du
module <code>Score</code>.</p>

<!-- more -->


<p>Revoici donc le module <code>Score</code> au complet:</p>

<p>``` ruby
module Score
  def self.profit_and_cost(individual, items)</p>

<pre><code>profit = cost = 0
individual.chromosome.each_with_index do |number, index|
  profit += items[index].profit * number
  cost += items[index].cost * number
end
[profit, cost]
</code></pre>

<p>  end</p>

<p>  def compute_score!</p>

<pre><code>@population.each {|individual| individual.score = score(individual) }
shift
</code></pre>

<p>  end</p>

<p>  def score(individual)</p>

<pre><code>profit, cost = Score.profit_and_cost individual, @items
malus(profit, cost)
</code></pre>

<p>  end</p>

<p>  def malus(profit, cost)</p>

<pre><code>profit -= 2 * (cost - @capacity) if cost &gt; @capacity
profit
</code></pre>

<p>  end</p>

<p>  def shift</p>

<pre><code>score_min = @population.map(&amp;:score).min.abs
@population.map {|individual| individual.score += score_min + 1 }
</code></pre>

<p>  end
end
```</p>

<p>Voyons d'abord rapidement la méthode <code>compute_score!</code>:</p>

<p>``` ruby
  def compute_score!</p>

<pre><code>@population.each {|individual| individual.score = score(individual) }
shift
</code></pre>

<p>  end
```</p>

<p>On calcule/affecte le score de chaque individu. Puis on appelle une méthode
<code>shift</code>, dont on verra l'utilité bientôt.</p>

<p>La méthode <code>score</code> maintenant:</p>

<p>``` ruby
  def score(individual)</p>

<pre><code>profit, cost = Score.profit_and_cost individual, @items
malus(profit, cost)
</code></pre>

<p>  end
```</p>

<p>On calcule le profit et le coût du portefeuille d'actions que représente
un individu via la méthode de classe <code>Score.profit_and_cost</code>. Puis on envoit
tout ça dans une méthode <code>malus</code>, qui va gérer les individus invalides.</p>

<p>La méthode <code>Score.profit_and_cost</code> est le <em>coeur</em> du calcul:</p>

<p>``` ruby
  def self.profit_and_cost(individual, items)</p>

<pre><code>profit = cost = 0
individual.chromosome.each_with_index do |number, index|
  profit += items[index].profit * number
  cost += items[index].cost * number
end
[profit, cost]
</code></pre>

<p>  end
```</p>

<p>Comme je vais m'en servir dans d'autres parties du programme, j'en ai fait
une méthode de classe. On calcule le profit de l'individu en additionnant
le profit généré par chacune des actions. <code>items[index].profit</code> se
réfère à la liste <code>Knapsack::ITEMS</code> et <code>number</code> est un gène de l'individu.
On procède à l'identique pour le calculer le coût.</p>

<p>On peut passer à la méthode <code>malus</code>:</p>

<p>``` ruby
  def malus(profit, cost)</p>

<pre><code>profit -= 2 * (cost - @capacity) if cost &gt; @capacity
profit
</code></pre>

<p>  end
```</p>

<p>J'ai utilisé le même principe empirique que dans notre
<a href="http://lkdjiin.github.io/blog/2013/11/19/les-algorithmes-genetiques-demystifies-41-les-individus-invalides/">dernier programme</a>,
à savoir que si le coût dépasse la capacité d'investissement
je diminue le profit de deux fois la différence entre coût
et capacité.</p>

<p>Il reste à parler de la méthode <code>shift</code>:</p>

<p>``` ruby
  def shift</p>

<pre><code>score_min = @population.map(&amp;:score).min.abs
@population.map {|individual| individual.score += score_min + 1 }
</code></pre>

<p>  end
```</p>

<p>De la façon dont on a calculé le score, celui-ci peut être négatif. Ce
qui pose un problème avec le calcul de la <em>fitness</em>, qui attend un
nombre positif. La méthode <code>shift</code> sert à regler ceci.
Tout d'abord je calcule la valeur absolue du score minimum. Puis j'ajoute
cette valeur, plus 1, à chacun des scores. Ainsi je suis sûr que le score
minimal sera 1.</p>

<p>Voilà pour aujourd'hui. Comme d'habitude, c'est l'évaluation qui demande
le plus de reflexion et d'explications.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les algorithmes génétiques démystifiés 44: Économie]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/12/15/les-algorithmes-genetiques-demystifies-44-economie/"/>
    <updated>2013-12-15T18:25:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/12/15/les-algorithmes-genetiques-demystifies-44-economie</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Maintenant que <a href="">la population initiale est créée</a>,
voyons comment l'évaluer.</p>

<!-- more -->


<p>Voici la classe <code>Evaluator</code>, qui a pris un coup de jeune:</p>

<p>``` ruby
class Evaluator
  include Score
  include Fitness</p>

<p>  def initialize(capacity:, population:, items:)</p>

<pre><code>@capacity = capacity
@population = population
@items = items
</code></pre>

<p>  end</p>

<p>  def evaluate!</p>

<pre><code>compute_score!
compute_fitness!
</code></pre>

<p>  end
end
```</p>

<p>J'ai transferé les calculs du score et de la <em>fitness</em> dans des modules
car cette classe <code>Evaluator</code> commence à enfler (et aussi car je teste
quelques idées en vue d'un futur framework).</p>

<p>Le module <code>Score</code> est bien sûr responsable de l'évaluation d'un
portefeuille d'actions. Je le présenterais demain, car je n'ai
malheureusement pas le temps nécessaire aujourd'hui. Je vous donne
malgré tout le code dès maintenant:</p>

<p>``` ruby
module Score
  def self.profit_and_cost(individual, items)</p>

<pre><code>profit = cost = 0
individual.chromosome.each_with_index do |number, index|
  profit += items[index].profit * number
  cost += items[index].cost * number
end
[profit, cost]
</code></pre>

<p>  end</p>

<p>  def compute_score!</p>

<pre><code>@population.each {|individual| individual.score = score(individual) }
shift
</code></pre>

<p>  end</p>

<p>  def score(individual)</p>

<pre><code>profit, cost = Score.profit_and_cost individual, @items
malus(profit, cost)
</code></pre>

<p>  end</p>

<p>  def malus(profit, cost)</p>

<pre><code>profit -= 2 * (cost - @capacity) if cost &gt; @capacity
profit
</code></pre>

<p>  end</p>

<p>  def shift</p>

<pre><code>score_min = @population.map(&amp;:score).min.abs
@population.map {|individual| individual.score += score_min + 1 }
</code></pre>

<p>  end
end
```</p>

<p>En ce qui concerne le module <code>Fitness</code>, le code est le même que
d'habitude.</p>

<p>``` ruby
module Fitness
  def compute_fitness!</p>

<pre><code>total = @population.inject(0) {|sum, individual| sum + individual.score }
size = @population.size
@population.each do |individual|
  individual.fitness = individual.score.to_f / total * size
end
</code></pre>

<p>  end
end
```</p>

<p>Voilà, demain on verra en détail le module <code>Score</code>.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
