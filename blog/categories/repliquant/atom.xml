<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : répliquant | Xavier Nayrac]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/repliquant/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2015-10-10T18:22:47+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Un quine en R]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/10/10/un-quine-en-r/"/>
    <updated>2015-10-10T18:11:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/10/10/un-quine-en-r</id>
    <content type="html"><![CDATA[<p>J’ai lu récemment l’article <a href="http://blog.chaps.io/2015/10/01/generating-quines-in-ruby.html">generating Quines in Ruby</a> qui m’a beaucoup plu. Et j’ai eu envie d’en faire un dans le langage R.</p>

<p>Alors c’est quoi un quine ? Un quine est un programme informatique
auto répliquant (<em>self-reproducing</em>).  Il doit satisfaire à deux conditions:</p>

<ol>
  <li>Il produit son code source en tant que unique sortie.</li>
  <li>Il ne prend aucune entrée, ce qui exclus par exemple de lire un fichier.</li>
</ol>

<!-- more -->

<p>Voici ma solution en R, elle affiche son code source sur la sortie standard
quand on l’exécute. Je me suis beaucoup inspiré de la solution en C de l’article
original:</p>

<p><code>r quine.r
src &lt;-"\nescape &lt;- function(x) {\n    cat('\"')\n    for(e in strsplit(x, '')[[1]]) {\n        if(e == '\\n') {\n            cat('\\\\n')\n        } else if(e == '\\\\') {\n            cat('\\\\\\\\')\n        } else if(e == '\"') {\n            cat('\\\\\"')\n        } else {\n            cat(e)\n        }\n    }\n    cat('\"')\n}\ncat(\"src &lt;-\")\nescape(src)\nwriteLines(src)"
escape &lt;- function(x) {
    cat('"')
    for(e in strsplit(x, '')[[1]]) {
        if(e == '\n') {
            cat('\\n')
        } else if(e == '\\') {
            cat('\\\\')
        } else if(e == '"') {
            cat('\\"')
        } else {
            cat(e)
        }
    }
    cat('"')
}
cat("src &lt;-")
escape(src)
writeLines(src)
</code></p>

<p>Comme il est noté dans l’article original, il est bon de tester sa solution à
l’aide de <code>diff</code>. Si la sortie de votre programme et le source sont identiques,
<code>diff</code> ne produira aucune sortie, sinon bon débogage ;)</p>

<p><code>bash
$ diff -u quine.r &lt;(Rscript quine.r)
</code></p>

<p>Ma solution est beaucoup plus longue que celle qui se trouve sur le <a href="http://rosettacode.org/wiki/Quine#R">rosetta code</a> par exemple. Mais c’est pas grave, c’était marrant à faire, c’était un bon petit casse-tête qui m’a bien fait réfléchir. Et j’ai même appris une fonction R qui m’était inconnue (<code>writeLines</code>).</p>

<p>À vous de jouer maintenant ; tenez moi au courant si vous écrivez un quine, quel
que soit le langage ;)</p>

<p></p>
]]></content>
  </entry>
  
</feed>
