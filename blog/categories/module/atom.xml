<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : module | Xavier Nayrac]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/module/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2015-10-29T15:17:17+01:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Utiliser Enumerable en Ruby]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/06/09/utiliser-enumerable-en-ruby/"/>
    <updated>2014-06-09T16:47:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/06/09/utiliser-enumerable-en-ruby</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Il y a quelques jours, j’ai testé Opal.rb. Et pour ça, j’ai écris un jeu
du type Space Invaders ;) J’ai une classe <code>Enemy</code>, que je peux résumer ainsi:</p>

<p>``` ruby
class Enemy
  attr_reader :x, :y
  def initialize(x, y)
    @x = x
    @y = y
  end</p>

<p>def to_s
    “#&lt;Enemy x:#@x y:#@y&gt;”
  end
end
```</p>

<!-- more -->

<p>J’ai aussi une classe <code>Enemies</code>, pour gérer ce qui se passe au niveau de
tous les ennemies. Inclure le module <a href="http://ruby-doc.org/core-2.1.2/Enumerable.html">Enumerable</a>
et définir la méthode <code>each</code> me permet d’utiliser toutes les méthodes de ce
module.</p>

<p>``` ruby
class Enemies
  include Enumerable</p>

<p>def initialize
    @enemies = []
  end</p>

<p>def each(&amp;block)
    @enemies.each(&amp;block)
  end</p>

<p>def «(item)
    @enemies « item
  end
end
```</p>

<p>Créons un groupe de trois ennemies :</p>

<p><code>ruby
enemies = Enemies.new
enemies &lt;&lt; Enemy.new(10, 15)
enemies &lt;&lt; Enemy.new(20, 15)
enemies &lt;&lt; Enemy.new(10, 40)
</code></p>

<p>Voyons si <code>each</code> fonctionne bien :</p>

<pre><code>&gt; enemies.each {|item| puts item }
#&lt;Enemy x:10 y:15&gt;
#&lt;Enemy x:20 y:15&gt;
#&lt;Enemy x:10 y:40&gt;
</code></pre>

<p>J’ai donc accès à toutes les autres méthodes de <code>Enumerable</code>, comme par
exemple <code>select</code>:</p>

<pre><code>&gt; puts enemies.select {|item| item.x == 10 }
#&lt;Enemy x:10 y:15&gt;
#&lt;Enemy x:10 y:40&gt;
</code></pre>

<script id="fb33k8u">(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby - extend self]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/03/28/ruby-extend-self/"/>
    <updated>2014-03-28T21:16:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/03/28/ruby-extend-self</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Vous débutez en Ruby et vous vous demandez ce que peut bien signifier
ce <code>extend self</code> qu’on rencontre parfois dans un module utilitaire ?</p>

<!-- more -->

<p>Voici un exemple:</p>

<p>``` ruby
module M
  extend self</p>

<p>def foo
    puts ‘foo’
  end
end</p>

<p>M.foo
#=&gt; foo
```</p>

<p>La ligne <code>extend self</code> nous permet de définir toutes les méthodes du
module comme étant des méthodes de classe. C’est pas plus compliqué que
ça.</p>

<p>On aurait pu écrire à la place:</p>

<p><code>ruby
module M
  def self.foo
    puts 'foo'
  end
end
</code></p>

<p>Ou bien encore:</p>

<p><code>ruby
module M
  class &lt;&lt; self
    def foo
      puts 'foo'
    end
  end
end
</code></p>

<p>Il y a quand même une subtilité qui fait toute la différence !
Sinon ça ne serait pas drôle. En utilisant la syntaxe <code>extend self</code>,
<strong>toutes les méthodes sont des méthodes de classe</strong>, ou de module si
vous préférez ;) La différence est importante puisqu’ainsi on ne pourra
pas mélanger méthodes utilitaires et méthodes à inclure dans une classe.
Ce qui est parfois tentant, mais c’est mal. Mais tentant. Mais mal…</p>

<script id="fb33k8u">(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>

<p>À demain.</p>

<p></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Racket pour les Rubyists 7: Module basique]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/11/15/racket-pour-les-rubyists-7-module-basique/"/>
    <updated>2013-11-15T10:18:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/11/15/racket-pour-les-rubyists-7-module-basique</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>La dernière fois, on a écrit notre <a href="http://lkdjiin.github.io/blog/2013/11/11/racket-pour-les-rubyists-6-une-premiere-fonction/">première fonction en Racket</a>. Et avant
d’écrire des tests unitaires pour pouvoir la passer à la moulinette du
<em>refactoring</em>, il faut explorer un peu les modules Racket.</p>

<!-- more -->

<h2 id="la-notion-de-module-en-racket">La notion de module en Racket</h2>

<p>Jusqu’ici on a utilisé le REPL, il est temps maintenant de mettre notre
code dans un fichier. Voyons le programme suivant, à mettre dans un
fichier <code>foo.rkt</code>:</p>

<p>``` racket foo.rkt
#lang racket</p>

<p>(define (times-2 n)
  (* 2 n))</p>

<p>(define (times-3 n)
  (* 3 n))</p>

<p>(provide times-2)
```</p>

<p>Vous reconnaissez la définition de deux fonctions: <code>times-2</code> et <code>times-3</code>
qui multiplient respectivements leur argument par 2 et par 3. En plus de ça,
il y a trois éléments nouveaux:</p>

<h3 id="spcification-dun-dialecte">Spécification d’un dialecte</h3>

<p>La ligne <code>#lang racket</code> spécifie à Racket le dialecte utilisé. Il y en a
plein et je n’utiliserais que celui-ci. Il faudra penser à toujours placé
cette ligne au début de chaque fichier.</p>

<h3 id="convention-de-nommage">Convention de nommage</h3>

<p>Un petit exemple vaut mieux qu’un long discours:</p>

<pre><code>thisIsJavaConvention

this_is_ruby_convention

this-is-racket-convention
</code></pre>

<h3 id="la-fonction-provide">La fonction provide</h3>

<p>La fonction <code>provide</code>, qu’on peut placer n’importe où dans le fichier (donc
au début ou à la fin), permet <em>d’exporter</em> les fonctions données en
argument. Les autres fonctions (celle qui ne sont pas données à <code>provide</code>)
sont visible dans le fichier, mais pas à l’extérieur. Autrement dit,
<code>provide</code> permet de spécifier l’API, les fonctions publiques.</p>

<h2 id="utilisation-dun-module">Utilisation d’un module</h2>

<p>Dans le REPL, <em>démaré dans le même dossier que le fichier “foo.rkt”</em>,
on utilise la fonction <code>require</code>:</p>

<pre><code>-&gt; (require "foo.rkt")
</code></pre>

<p>On peut maintenant utiliser la fonction <em>publique</em> <code>times-2</code>:</p>

<pre><code>-&gt; (times-2 9)
18
</code></pre>

<p>Et comme attendu, on ne peut pas utiliser <code>times-3</code>:</p>

<pre><code>-&gt; (times-3 9)
; times-3: undefined;
;  cannot reference undefined identifier
</code></pre>

<h2 id="comparaison-avec-les-modules-ruby">Comparaison avec les modules Ruby</h2>

<p>Voici le pendant du fichier <code>foo.rkt</code> écrit en Ruby:</p>

<p>``` ruby foo.rb
module Foo
  class « self
    def times_2(n)
      2 * n
    end</p>

<pre><code>private

def times_3(n)
  3 * n
end   end end ```
</code></pre>

<p>Et voici comment on s’en sert dans une session irb:</p>

<p><code>irb
&gt;&gt; require "foo"
LoadError: cannot load such file -- foo
&gt;&gt; require "./foo"
true
&gt;&gt; Foo.times_2 9
18
&gt;&gt; Foo.times_3 9
NoMethodError: private method `times_3' called for Foo:Module
</code></p>

<p>Le comportement est assez similaire. Petite différence, Ruby oblige à définir
le fichier requis par rapport au dossier courant alors que Racket le fait
automatiquement (ok, j’aurais pu utiliser <code>require_relative</code>…).</p>

<p>Mais la <strong>grande différence</strong> est qu’un module Ruby définit un espace
de nom, pas un module Racket. <em>À l’heure actuelle je ne sais pas si Racket
possède un mécanisme pour les espaces de nom, je n’en suis pas encore là,
mais j’espère que oui…</em></p>

<p>La prochaine fois, on verra comment faire des tests unitaires simples en
Racket.</p>

<script id="fb33k8u">(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>

<p>À demain.</p>

<p></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Apprendre Ruby en faisant des maths 6: méthodes utilitaires et module]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/11/01/apprendre-ruby-en-faisant-des-maths-6-methodes-utilitaires-et-module/"/>
    <updated>2013-11-01T21:54:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/11/01/apprendre-ruby-en-faisant-des-maths-6-methodes-utilitaires-et-module</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Dans les articles précédents, nous avons définis trois méthodes:
<code>divisors</code>, <code>proper_divisors</code> et <code>sum_of_proper_divisors</code>.
Ces trois méthodes commencent à former ce qu’on appelle une
collection, ou un ensemble, de méthodes utilitaires. Nous allons
aujourd’hui les regrouper dans un module.</p>

<!-- more -->

<p>Pour l’instant nous n’avons que trois méthodes, et elles portent toutes
sur les nombres. Mais nous allons bientôt en ajouter d’autres, peut-être
beaucoup d’autres. Certaines porteront peut-être sur la géométrie ou les
probabilités ? Il est plus propre de regrouper entre elles les méthodes
qui traitent du même sujet, alors pourquoi attendre ?</p>

<p>Voici comment on peut regrouper nos méthodes au sein du module <code>Number</code>:</p>

<p>``` ruby number.rb
module Number
  def self.divisors(n)
    (1..n).select {|i| n % i == 0 }
  end</p>

<p>def self.proper_divisors(n)
    divisors(n)[0..-2]
  end</p>

<p>def self.sum_of_proper_divisors(n)
    proper_divisors(n).reduce(:+)
  end
end
```</p>

<p>Vous voyez que les méthodes sont insérées à l’intérieur de:</p>

<p><code>ruby
module Number
end
</code></p>

<p>Vous voyez aussi qu’on a ajouté <code>self.</code> devant le nom de chaque méthode.
Cela indique à Ruby qu’on veut utiliser ces méthodes sans pour autant
avoir à créer un objet (<em>si vous ne savez pas encore ce qu’est un objet,
ne vous inquiétez pas, nous n’en avons pas besoin pour l’instant</em>).</p>

<p>Voici une seconde manière de regrouper nos méthodes au sein du module <code>Number</code>:</p>

<p>``` ruby number.rb
module Number
  class « self
    def divisors(n)
      (1..n).select {|i| n % i == 0 }
    end</p>

<pre><code>def proper_divisors(n)
  divisors(n)[0..-2]
end

def sum_of_proper_divisors(n)
  proper_divisors(n).reduce(:+)
end   end end ```
</code></pre>

<p>Cette deuxième syntaxe, qui peut sembler un peu bizarre si vous la
rencontrez pour la première fois, fait exactement la même chose que
la première syntaxe. Avec Ruby, il y a souvent plusieurs façons de dire
une même chose.
Je ne vais pas expliquer cette syntaxe aujourd’hui, mais sachez qu’elle
est très prisée dans la communauté Ruby et que vous la rencontrerez
souvent. Vous pouvez choisir celle que vous voulez.</p>

<p>Notez que, <strong>par convention</strong>, le module Number doit être enregistré
dans le fichier <code>number.rb</code>. Il n’y a pas d’obligation, mais avouez
que ça facilite grandement les choses.</p>

<h2 id="comment-utiliser-un-module-">Comment utiliser un module ?</h2>

<p><strong>Première solution</strong>, vous pouvez écrire votre code à la suite du module:</p>

<p>``` ruby number.rb
module Number
  class « self
    def divisors(n)
      (1..n).select {|i| n % i == 0 }
    end</p>

<pre><code>def proper_divisors(n)
  divisors(n)[0..-2]
end

def sum_of_proper_divisors(n)
  proper_divisors(n).reduce(:+)
end   end end
</code></pre>

<p>puts Number.sum_of_proper_divisors 8
```</p>

<p>Puis vous lancez le programme:</p>

<pre><code>[~/]⇒ ruby number.rb 
7
</code></pre>

<p><strong>Deuxième solution</strong>, vous lancez irb, <em>dans le même dossier</em> que le fichier
<code>number.rb</code> et vous chargez le module:</p>

<pre><code>[~/]⇒ irb
&gt;&gt; require "./number"
true
&gt;&gt; Number.sum_of_proper_divisors 8
7
</code></pre>

<p><strong>Troisième solution</strong>, vous écrivez un programme dans un fichier séparé, par
exemple <code>test.rb</code>, <em>dans le même dossier</em> que le fichier
<code>number.rb</code>:</p>

<p>``` ruby test.rb
require “./number”</p>

<p>puts Number.sum_of_proper_divisors 8
```</p>

<p>Puis vous le lancez:</p>

<pre><code>[~/]⇒ ruby test.rb
7
</code></pre>

<script id="fb33k8u">(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>

<p>À demain.</p>

<p></p>

]]></content>
  </entry>
  
</feed>
