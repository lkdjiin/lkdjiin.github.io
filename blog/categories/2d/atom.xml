<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : 2d | Xavier Nayrac]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/2d/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2019-12-02T21:20:54+01:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Retour du MOOC Designer dans un fablab]]></title>
    <link href="http://lkdjiin.github.io/blog/2016/12/20/retour-du-mooc-designer-dans-un-fablab/"/>
    <updated>2016-12-20T16:25:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2016/12/20/retour-du-mooc-designer-dans-un-fablab</id>
    <content type="html"><![CDATA[<p>L’idée est excellente. Et originale. Je n’ai trouvé ça nulle part ailleurs.
Le potentiel est indéniable.</p>

<p>Le résultat est d’autant plus décevant. Ça aurait pu être un MOOC fabuleux
dont on se souvient pendant des années, à l’instar de
<a href="https://www.edx.org/course/electronic-interfaces-bridging-physical-uc-berkeleyx-ee40lx-0">BerkeleyX: EE40LX Electronic Interfaces</a>
ou de
<a href="https://www.coursera.org/learn/build-a-computer">Build a Modern Computer from First Principles: From Nand to Tetris</a>.
C’est finalement un MOOC baclé.</p>

<!-- more -->

<p>Le sujet avait de quoi m’intérésser : conception 2D et 3D, utilisation de
fraiseuse numérique, découpeuse laser et imprimante 3D. Malheureusement le
contenu pédagogique est quasi inexistant. Vous voulez faire de la 2D ? Regardez
notre unique vidéo sur Inkscape dans laquelle nous vous montrons, en accéléré, sans
expliquer quoi que ce soit, comment utiliser 2 ou 3 outils.
Vous voulez faire de la 3D ? Pareil, mais en plus court.
Vous voulez imprimer en 3D ou utiliser une découpeuse ? Regardez donc ces
quelques vidéos réalisées par d’autres et disponibles sur youtube depuis des
années.</p>

<p>Ce MOOC est la suite de 
<a href="https://www.fun-mooc.fr/courses/MinesTelecom/04018S02/session02/about">Fabriquer un objet connecté</a>
en pire. J’ai suivi <em>Fabriquer un objet connecté</em> qui lui aussi partait d’une
excellente et originale idée. Lui aussi était une première session. On sentait
que les types en voulaient vraiment, qu’ils avaient envie de bien faire et
qu’ils faisaient ce qu’ils pouvaient. Ça n’était pas abouti (par manque de
moyens ou de temps ?) et on restait sur sa faim. Mais on pardonnait aisément
parceque c’était une première édition et qu’on sentait vraiment la volonté de
bien faire (je me répète).  Dans cette suite on a l’impression qu’ils n’en
peuvent plus et qu’ils l’on fait parce qu’il fallait le faire, pour s’en
débarasser le plus vite possible.</p>

<h2 id="conclusion">Conclusion</h2>

<p>J’espère de tout coeur qu’il y aura une seconde édition dans
laquelle les auteurs auront retravaillé leur sujet. Parce que ça le mérite.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Écrire un jeu en 2d avec Ruby et Gosu - partie 7]]></title>
    <link href="http://lkdjiin.github.io/blog/2016/05/01/ecrire-un-jeu-en-2d-avec-ruby-et-gosu-partie-7/"/>
    <updated>2016-05-01T09:29:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2016/05/01/ecrire-un-jeu-en-2d-avec-ruby-et-gosu-partie-7</id>
    <content type="html"><![CDATA[<p>Ça fait plus de 2 mois que je dois terminer ce jeu et cette série d’article, alors au boulot !</p>

<p>Pour cette nouvelle version je voudrais ajouter une musique différente pour le
game over.  Et aussi pouvoir enfin recommencer une nouvelle partie après
un <em>game over</em>.</p>

<p><img class="center" src="/images/gosu8.png"></p>

<!-- more -->

<p>La totalité des articles:</p>

<ol>
  <li><a href="/blog/2016/02/10/ecrire-un-jeu-en-2d-avec-ruby-et-gosu-partie-1/">Installation de Gosu, affichage d’images statiques</a></li>
  <li><a href="/blog/2016/02/11/ecrire-un-jeu-en-2d-avec-ruby-et-gosu-partie-2/">Déplacer le joueur et pluie de smileys</a></li>
  <li><a href="/blog/2016/02/12/ecrire-un-jeu-en-2d-avec-ruby-et-gosu-partie-3/">Beep, fonte et collecte des smileys</a></li>
  <li><a href="/blog/2016/02/13/ecrire-un-jeu-en-2d-avec-ruby-et-gosu-partie-4/">On s’occupe des vies</a></li>
  <li><a href="/blog/2016/02/15/ecrire-un-jeu-en-2d-avec-ruby-et-gosu-partie-5/">Musique et game over</a></li>
  <li><a href="/blog/2016/02/25/ecrire-un-jeu-en-2d-avec-ruby-et-gosu-partie-6/">Affichage selon un angle</a></li>
  <li>Plusieurs musiques et reset de la partie</li>
</ol>

<h2 id="plusieurs-musiques">Plusieurs musiques</h2>

<p>Nous allons devoir gérer plusieurs musiques. Donnons leur des noms plus simple
à manipuler que leurs <em>paths</em> :</p>

<p><code>ruby song.rb
module Song
  GameOver = "assets/songs/In early time.ogg"
  Level1   = "assets/songs/Around the Bend.ogg"
end
</code></p>

<p>Et avec quoi écoute-t-on de la musique ? Avec un <em>song player</em> :</p>

<p><code>ruby song_player.rb
class SongPlayer
  def play(file)
    @song.stop if @song
    @song = Gosu::Song.new(file)
    @song.volume = 0.25
    @song.play(true)
  end
end
</code></p>

<p>Dans la classe <code>Window</code> on remplace l’ancienne manière de jouer une musique :</p>

<p><code>ruby
@song = Gosu::Song.new("assets/songs/Around the Bend.ogg")
@song.volume = 0.25
@song.play(true)
</code></p>

<p>par notre nouvelle abstraction :</p>

<p><code>ruby
@song_player = SongPlayer.new
@song_player.play(Song::Level1)
</code></p>

<p>N’oubliez pas d’ajouter les require qui vont bien dans le fichier <code>main.rb</code> :</p>

<p><code>ruby main.rb
require_relative 'song'
require_relative 'song_player'
</code></p>

<p>Trouver un bon endroit où mettre le code pour changer la musique après un
<em>game over</em> n’est pas si 
évident que ça. Le moment où l’on capte que le jeu est dans l’état game over est
la méthode <code>update_player</code> :</p>

<p><code>ruby
def update_player
  @player.update(@items)
  @game_over = true if @player.lives &lt;= 0
end
</code></p>

<p>Et il semblerait vraiment bizarre de modifier la musique alors qu’on est
sensé mettre à jour le joueur. Autrement dit, le code suivant ne me plait pas :</p>

<p><code>ruby
def update_player
  @player.update(@items)
  if @player.lives &lt;= 0
    @game_over = true
    @song_player.play(Song::GameOver)
  end
end
</code></p>

<p>À bien y réfléchir, le problème vient d’avant. On ne devrait pas changer l’état
de <code>@game_over</code> ici, mais plutôt dans la méthode <code>update</code> :</p>

<p>```ruby window.rb
class Window &lt; Gosu::Window
  def update
    return if @game_over</p>

<pre><code>@game_over = true if @player.lives &lt;= 0
update_items
update_player   end
</code></pre>

<p>def update_player
    @player.update(@items)
  end
end
```</p>

<p>Changer la musique se fera donc de cette manière :</p>

<p>```ruby
def update
  return if @game_over</p>

<p>if @player.lives &lt;= 0
    @game_over = true
    @song_player.play(Song::GameOver)
  end</p>

<p>update_items
  update_player
end
```</p>

<p>Après extraction d’une nouvelle méthode, nous obtenons un code plus clair :</p>

<p>```ruby
def update
  return if @game_over</p>

<p>update_game_over
  update_items
  update_player
end</p>

<p>def update_game_over
  return unless @player.lives &lt;= 0</p>

<p>@game_over = true
  @song_player.play(Song::GameOver)
end
```</p>

<h2 id="nouvelle-partie">Nouvelle partie</h2>

<p>Ok, il est temps maintenant de pouvoir jouer une nouvelle partie après un
game over. Pour cela, il faut regarder si le joueur appuie sur la touche
espace pendant l’état game over, et dans ce cas faire un reset :</p>

<p>```ruby
def update
  reset if @game_over &amp;&amp; Button.space?</p>

<p>return if @game_over</p>

<p>update_game_over
  update_items
  update_player
end
```</p>

<p>On peut tout de suite extraire une méthode <code>new_game?</code> :</p>

<p>```ruby
def update
  reset if new_game?
  # […]
end</p>

<p>def new_game?
  @game_over &amp;&amp; Button.space?
end
```</p>

<p>On peut maintenant réfléchir à la méthode <code>reset</code>, qui a son tour appellera
la méthode <code>reset</code> du joueur. Ces deux méthodes sont évidentes :</p>

<p><code>ruby window.rb
class Window &lt; Gosu::Window
  def reset
    @items = []
    @player.reset
    @song_player.play(Song::Level1)
    @game_over = false
  end
end
</code></p>

<p><code>ruby player.rb
class Player
  def reset
    @score = 0
    @lives = 3
    @angle = 0.0
    @velocity = 0.0
  end
end
</code></p>

<p>Pour terminer cette version, on va ajouter un message «press space to start»
qui bouge pour attirer l’attention. Pour ça, on varie régulièrement d’une
petite quantité la coordonnée <strong>y</strong> du message.</p>

<p>```ruby
class UI
  # …
  PressSpaceLow = 210
  PressSpaceHigh = 270</p>

<p>def initialize
    # …
    @y = 240
    @y_velocity = -0.3
  end</p>

<p>private</p>

<p>def draw_game_over
    @big_font.draw_rel(“Game Over”, WindowWidth / 2, WindowHeight / 3,
                       ZOrder::UI, 0.5, 0.5)
    @big_font.draw_rel(“Press Space To Start”, WindowWidth / 2, y,
                       ZOrder::UI, 0.5, 0.5)
  end</p>

<p>def y
    @y += y_velocity
  end</p>

<p>def y_velocity
    if @y &lt; PressSpaceLow || @y &gt; PressSpaceHigh
      @y_velocity = -@y_velocity
    end
    @y_velocity
  end
end
```</p>

<p>Pour finir, voici le contenu du jeu pour l’instant:</p>

<pre><code>$ tree
.
├── assets
│   ├── fonts
│   │   └── VT323
│   │       ├── OFL.txt
│   │       └── VT323-Regular.ttf
│   ├── images
│   │   ├── background.png
│   │   ├── heart.gif
│   │   ├── player.png
│   │   ├── smiley-green.png
│   │   └── smiley-yellow.png
│   ├── songs
│   │   ├── Around the Bend.ogg
│   │   └── In early time.ogg
│   └── sound
│       ├── collect.wav
│       └── life-lost.wav
├── button.rb
├── main.rb
├── player.rb
├── smiley.rb
├── song_player.rb
├── song.rb
├── ui.rb
├── window.rb
└── z_order.rb
</code></pre>

<p>Le code et les assets se trouvent <a href="https://github.com/lkdjiin/collect-the-smiles">sur Github</a>.
La version précise pour cet article est la <a href="https://github.com/lkdjiin/collect-the-smiles/releases/tag/v0.7.0">version 0.7.0</a>.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Écrire un jeu en 2d avec Ruby et Gosu - partie 6]]></title>
    <link href="http://lkdjiin.github.io/blog/2016/02/25/ecrire-un-jeu-en-2d-avec-ruby-et-gosu-partie-6/"/>
    <updated>2016-02-25T11:37:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2016/02/25/ecrire-un-jeu-en-2d-avec-ruby-et-gosu-partie-6</id>
    <content type="html"><![CDATA[<p>Pour augmenter l’effet dramatique lorsque le joueur perd une vie, je voudrais
que celui-ci se mette à tourner sur lui-même. Pour ça, on affichera l’image du
joueur selon un certain angle, et cet angle sera mis à jour à chaque appel de
<code>update</code>. Voyons cela pas à pas.</p>

<p><img class="center" src="/images/gosu7.png"></p>

<!-- more -->

<p>La totalité des articles:</p>

<ol>
  <li><a href="/blog/2016/02/10/ecrire-un-jeu-en-2d-avec-ruby-et-gosu-partie-1/">Installation de Gosu, affichage d’images statiques</a></li>
  <li><a href="/blog/2016/02/11/ecrire-un-jeu-en-2d-avec-ruby-et-gosu-partie-2/">Déplacer le joueur et pluie de smileys</a></li>
  <li><a href="/blog/2016/02/12/ecrire-un-jeu-en-2d-avec-ruby-et-gosu-partie-3/">Beep, fonte et collecte des smileys</a></li>
  <li><a href="/blog/2016/02/13/ecrire-un-jeu-en-2d-avec-ruby-et-gosu-partie-4/">On s’occupe des vies</a></li>
  <li><a href="/blog/2016/02/15/ecrire-un-jeu-en-2d-avec-ruby-et-gosu-partie-5/">Musique et game over</a></li>
  <li>Affichage selon un angle</li>
  <li><a href="/blog/2016/05/01/ecrire-un-jeu-en-2d-avec-ruby-et-gosu-partie-7/">Plusieurs musiques et reset de la partie</a></li>
</ol>

<h2 id="affichage-selon-un-angle">Affichage selon un angle</h2>

<p>Il nous faut d’abord un angle:</p>

<p><code>ruby player.rb
  def initialize
    # ...
    @angle = 0.0
  end
</code></p>

<p>Ensuite nous ajoutons une méthode <code>update</code> à la classe Player. Quand le joueur
vient de perdre une vie, la seule chose à mettre à jour est l’angle. Dans les
autres cas, on fait la même mise à jour qu’avant:</p>

<p><code>ruby player.rb
  def update(items)
    just_lost_a_life? ? update_angle : update_general(items)
  end
</code></p>

<p>La mise à jour de l’angle d’affichage de l’image du joueur ne demande pas
d’explications:</p>

<p><code>ruby player.rb
  def update_angle
    @angle += 10
  end
</code></p>

<p>En ce qui concerne la mise à jour générale, j’ai effectué un petit refactoring
pour passer dans la classe Player du code venant de la classe Window, et qui
n’avait pas à s’y trouver. Au passage j’ai aussi créé le module <code>Button</code> qu’on
verra plus tard:</p>

<p><code>ruby player.rb
  def update_general(items)
    go_left if Button.left?
    go_right if Button.right?
    move
    collect(items)
  end
</code></p>

<p>On peut maintenant regarder l’affichage. Pour afficher une image selon un
certain angle, Gosu propose la méthode <code>draw_rot</code>. L’image sera orientée par
rapport à un point précis, ici je choisi le centre de l’image:</p>

<p>```ruby player.rb
  def draw
    if just_lost_a_life?
      @image.draw_rot(x_middle, y_middle, ZOrder::Player, @angle)
    else
      @image.draw(@x, Y, ZOrder::Player)
    end
  end</p>

<p>alias_method :x_middle, :x_center_of_mass</p>

<p>def y_middle
    Y + @image.height / 2
  end
```</p>

<p>Voici tout ce qui change dans la classe <code>Player</code> en un coup d’œil:</p>

<p>```ruby
class Player</p>

<p>def initialize
    # …
    @angle = 0.0
  end</p>

<p>def update(items)
    just_lost_a_life? ? update_angle : update_general(items)
  end</p>

<p>def draw
    if just_lost_a_life?
      @image.draw_rot(x_middle, y_middle, ZOrder::Player, @angle)
    else
      @image.draw(@x, Y, ZOrder::Player)
    end
  end</p>

<p>alias_method :x_middle, :x_center_of_mass</p>

<p>def y_middle
    Y + @image.height / 2
  end</p>

<p>def update_angle
    @angle += 10
  end</p>

<p>def update_general(items)
    go_left if Button.left?
    go_right if Button.right?
    move
    collect(items)
  end</p>

<p>end
```</p>

<p>Voici maintenant le contenu du module <code>Button</code>:</p>

<p>```ruby
module Button</p>

<p>def self.left?
    Gosu::button_down?(Gosu::KbLeft)
  end</p>

<p>def self.right?
    Gosu::button_down?(Gosu::KbRight)
  end</p>

<p>end
```</p>

<p>On peut légitimement se demander «Mais pourquoi ajouter un tel module ?».
Simplement parce que je préfère 100 fois lire ceci:</p>

<pre><code>do_this if Button.left?
</code></pre>

<p>… plutôt que cela:</p>

<pre><code>do_this if Gosu::button_down?(Gosu::KbLeft)
</code></pre>

<p>Voyons enfin ce qui change dans la classe Window.
J’ai déplacé la ligne <code>return if @player.just_lost_a_life?</code> de la méthode
<code>update</code> vers la méthode <code>update_items</code>. Ainsi la méthode <code>update_player</code> est
toujours appelée et peut changer l’angle d’affichage du joueur:</p>

<p>```ruby
class Window &lt; Gosu::Window
  def update
    return if @game_over</p>

<pre><code>update_items
update_player   end
</code></pre>

<p>def update_items
    return if @player.just_lost_a_life?
    # …
  end</p>

<p>def update_player
    @player.update(@items)
    @game_over = true if @player.lives &lt;= 0
  end</p>

<p>end
```</p>

<p>Pour finir, voici le contenu du jeu pour l’instant:</p>

<pre><code>$ tree
.
├── assets
│   ├── fonts
│   │   └── VT323
│   │       ├── OFL.txt
│   │       └── VT323-Regular.ttf
│   ├── images
│   │   ├── background.png
│   │   ├── heart.gif
│   │   ├── player.png
│   │   ├── smiley-green.png
│   │   └── smiley-yellow.png
│   ├── songs
│   │   └── Around the Bend.ogg
│   └── sound
│       ├── collect.wav
│       └── life-lost.wav
├── button.rb
├── main.rb
├── player.rb
├── smiley.rb
├── ui.rb
├── window.rb
└── z_order.rb
</code></pre>

<p>Le code et les assets se trouvent <a href="https://github.com/lkdjiin/collect-the-smiles">sur Github</a>.
La version précise pour cet article est la <a href="https://github.com/lkdjiin/collect-the-smiles/releases/tag/v0.6.0">version 0.6.0</a>.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Écrire un jeu en 2d avec Ruby et Gosu - partie 5]]></title>
    <link href="http://lkdjiin.github.io/blog/2016/02/15/ecrire-un-jeu-en-2d-avec-ruby-et-gosu-partie-5/"/>
    <updated>2016-02-15T09:12:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2016/02/15/ecrire-un-jeu-en-2d-avec-ruby-et-gosu-partie-5</id>
    <content type="html"><![CDATA[<p>Aujourd’hui on ajoute de la musique de fond, on s’intéresse à ce qui se passe
quand on perd une vie, et on écrit un beau «Game Over» quand on a perdu toutes
les vies.</p>

<p><img class="center" src="/images/gosu6.png"></p>

<!-- more -->

<p>La totalité des articles:</p>

<ol>
  <li><a href="/blog/2016/02/10/ecrire-un-jeu-en-2d-avec-ruby-et-gosu-partie-1/">Installation de Gosu, affichage d’images statiques</a></li>
  <li><a href="/blog/2016/02/11/ecrire-un-jeu-en-2d-avec-ruby-et-gosu-partie-2/">Déplacer le joueur et pluie de smileys</a></li>
  <li><a href="/blog/2016/02/12/ecrire-un-jeu-en-2d-avec-ruby-et-gosu-partie-3/">Beep, fonte et collecte des smileys</a></li>
  <li><a href="/blog/2016/02/13/ecrire-un-jeu-en-2d-avec-ruby-et-gosu-partie-4/">On s’occupe des vies</a></li>
  <li>Musique et game over</li>
  <li><a href="/blog/2016/02/25/ecrire-un-jeu-en-2d-avec-ruby-et-gosu-partie-6/">Affichage selon un angle</a></li>
  <li><a href="/blog/2016/05/01/ecrire-un-jeu-en-2d-avec-ruby-et-gosu-partie-7/">Plusieurs musiques et reset de la partie</a></li>
</ol>

<h2 id="de-la-musique">De la musique</h2>

<p>Ajouter une musique de fond est très simple avec Gosu. On crée la ressource
comme on a créé des sons ou des images. Ensuite on règle le volume entre
0 et 1. Et enfin on appuie sur <code>play</code>:</p>

<p>```ruby
class Window &lt; Gosu::Window</p>

<p>def initialize(width, height)
    # …
    @song = Gosu::Song.new(“assets/songs/Around the Bend.ogg”)
    @song.volume = 0.25
    @song.play(true)
  end</p>

<p>end
```</p>

<p>Le paramètre <code>true</code> passé à la méthode <code>play</code> lui indique qu’on veut jouer la
musique en boucle.</p>

<blockquote>
  <p>Un paramètre booléen est ce que j’appelle un «paramètre de contrôle»
(Martin Fowler appelle ça un <a href="http://martinfowler.com/bliki/FlagArgument.html">Flag argument</a>.
C’est un bon vieux code smell et je suis un peu déçu de trouver ça dans Gosu.
Surtout qu’il est ici facile de s’en débarrasser en proposant deux méthodes sans paramètres,
par exemple <code>play</code> et <code>loop</code>.</p>
</blockquote>

<h2 id="petite-pause-quand-on-perd-une-vie">Petite pause quand on perd une vie</h2>

<p>Pour marquer le coup, je voudrais que le jeu <em>pause</em> pendant un certain temps
(ici une seconde et demi) quand le joueur perd une vie. Voici d’abord le code,
puis les explications:</p>

<p>```ruby
class Player</p>

<p># …
  LifeLostPause = 1500</p>

<p>def initialize
    # …
    @lost_life_at = -20_000
  end</p>

<p>def just_lost_a_life?
    Gosu::milliseconds - @lost_life_at &lt; LifeLostPause
  end</p>

<p>private</p>

<p>def collision(type)
    case type
    when :smiley_up
      # …
    when :smiley_down
      # …
      @lost_life_at = Gosu::milliseconds
    end</p>

<pre><code>true   end
</code></pre>

<p>end
```</p>

<p>Commençons par ce qui change dans <code>collision</code>. Lorsque le joueur entre en
collision avec un smiley à l’envers, j’enregistre l’instant de cette collision.
<code>Gosu::milliseconds</code> retourne le nombre de millisecondes écoulées depuis le
début du jeu.</p>

<p>Pour savoir si le joueur vient de perdre une vie, la méthode <code>just_lost_a_life?</code>
compare le temps présent (<code>Gosu::milliseconds</code>) avec l’instant où le joueur a
perdu une vie (<code>@lost_life_at</code>). Si la différence est de moins de 1500
millisecondes (une seconde et demi) <code>just_lost_a_life?</code> retournera <code>true</code>.</p>

<p>Lors de l’initialisation on trouve cette ligne:</p>

<pre><code>@lost_life_at = -20_000
</code></pre>

<p>… qui est nécessaire pour que <code>@lost_life_at</code> ne soit pas <code>nil</code> au début
du jeu, ce qui provoquerait une erreur dans <code>just_lost_a_life?</code>. Mais pourquoi
-20,000 ? Essayez de la définir à zéro pour voir… En fait -20,000 est une
valeur arbitraire, qui aurait aussi bien pu être -10,000 ou -9999, etc.
Une autre solution aurait été d’écrire <code>just_lost_a_life?</code> comme ceci:</p>

<p><code>ruby
def just_lost_a_life?
  if @lost_life_at
    Gosu::milliseconds - @lost_life_at &lt; LifeLostPause
  else
    false
  end
end
</code></p>

<p>Mais j’aime moins cette solution, pour deux raisons, 1) c’est moins performant
puisqu’on a un test de plus à chaque update (ok c’est pas grand chose, mais ça
plus ça plus ça…, et là c’est très facilement évitable pour rien) et 2) je préfère que toutes les variables d’objets soient
définies dans le constructeur (peut-être un vieux reste de mon passé de
javaïste, ou un truc comme ça).</p>

<p>Quoiqu’il en soit, la ligne <code>@lost_life_at = -20_000</code> mérite un commentaire
expliquant la raison de cette valeur arbitraire. J’espère que ce sera
compréhensible:</p>

<p><code>ruby
    # It's important to note that this value is necessary for the game
    # to avoid to freeze at startup.
    # −20_000 is an arbitrary value. One can use -9999 or -5000 instead.
    @lost_life_at = -20_000
</code></p>

<p>Pour que tout ceci fonctionne, il suffit maintenant d’esquiver les updates au
bon moment:</p>

<p>```ruby
class Window &lt; Gosu::Window</p>

<p>def update
    return if @player.just_lost_a_life?</p>

<pre><code>update_items
update_player   end
</code></pre>

<p>end
```</p>

<h2 id="game-over-quand-0-vies">Game over quand 0 vies</h2>

<p>Vous avez maintenant compris que j’avance par petites itérations successives,
qui ne sont d’ailleurs pas toujours des fonctionnalités complètes.
Cette fois on va afficher «Game Over» et geler le jeu quand le joueur atteint
zéro vies:</p>

<p>```ruby
class Window &lt; Gosu::Window</p>

<p>def initialize(width, height)
    # …
    @game_over = false
  end</p>

<p>def update
    return if @player.just_lost_a_life?
    return if @game_over
    # …
  end</p>

<p>def draw
    # …
    @ui.draw(game_state)
  end</p>

<p>private</p>

<p># …</p>

<p>def update_player
    # …
    @game_over = true if @player.lives &lt;= 0
  end</p>

<p>def game_state
    {
      score: @player.score,
      lives: @player.lives,
      game_over: @game_over,
    }
  end</p>

<p>end
```</p>

<p>Ce qui mérite des explications c’est ce nouveau <code>game_state</code>. Plutôt que
d’envoyer les informations à l’UI sous la forme <code>@ui.draw(@player, @game_over)</code>
je préfère envoyer un <em>état</em> du jeu. Tout d’abord je n’envoie que le nécessaire
et ensuite on a un seul paramètre et non pas une liste de paramètres condamnée
à enfler.</p>

<p>Reste à refléter ça dans la classe UI:</p>

<p>```ruby
class UI
  # …</p>

<p>def initialize
    # …
    @big_font = Gosu::Font.new(80, name: “assets/fonts/VT323/VT323-Regular.ttf”)
  end</p>

<p>def draw(game)
    draw_score(game[:score])
    draw_lives(game[:lives])
    draw_game_over if game[:game_over]
  end</p>

<p>private</p>

<p>def draw_game_over
    @big_font.draw_rel(“Game Over”,
                       WindowWidth / 2, WindowHeight / 2,
                       ZOrder::UI,
                       0.5, 0.5)
  end</p>

<p>end
```</p>

<p>La nouveauté est la méthode <code>draw_rel</code>, qui va écrire son texte
<em>relativement</em> à lui-même. Oui je sais, ça sonne bizarre. Mais si vous
essayez les valeurs 0 et/ou 1 à la place de 0.5, vous devriez vite comprendre.
Là on va centrer le texte autour du milieu de l’écran, à la fois
horizontalement et verticalement.</p>

<blockquote>
  <p>Le fait que <code>draw_rel</code> soit l’abréviation de <code>draw_relative</code> ne sautera pas
forcement aux yeux de tout le monde. Alors pourquoi avoir utilisé une
abréviation ?</p>
</blockquote>

<p>Pour finir, voici le contenu du jeu pour l’instant:</p>

<pre><code>$ tree
.
├── assets
│   ├── fonts
│   │   └── VT323
│   │       ├── OFL.txt
│   │       └── VT323-Regular.ttf
│   ├── images
│   │   ├── background.png
│   │   ├── heart.gif
│   │   ├── player.png
│   │   ├── smiley-green.png
│   │   └── smiley-yellow.png
│   ├── songs
│   │   └── Around the Bend.ogg
│   └── sound
│       ├── collect.wav
│       └── life-lost.wav
├── main.rb
├── player.rb
├── smiley.rb
├── ui.rb
├── window.rb
└── z_order.rb
</code></pre>

<p>Le code et les assets se trouvent <a href="https://github.com/lkdjiin/collect-the-smiles">sur Github</a>.
La version précise pour cet article est la <a href="https://github.com/lkdjiin/collect-the-smiles/releases/tag/v0.5.0">version 0.5.0</a>.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Écrire un jeu en 2d avec Ruby et Gosu - partie 4]]></title>
    <link href="http://lkdjiin.github.io/blog/2016/02/13/ecrire-un-jeu-en-2d-avec-ruby-et-gosu-partie-4/"/>
    <updated>2016-02-13T16:19:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2016/02/13/ecrire-un-jeu-en-2d-avec-ruby-et-gosu-partie-4</id>
    <content type="html"><![CDATA[<p>Dans cet article on va s’occuper de gérer les vies de notre joueur.
On va les afficher et les perdre.</p>

<p><img class="center" src="/images/gosu5.png"></p>

<!-- more -->

<p>La totalité des articles:</p>

<ol>
  <li><a href="/blog/2016/02/10/ecrire-un-jeu-en-2d-avec-ruby-et-gosu-partie-1/">Installation de Gosu, affichage d’images statiques</a></li>
  <li><a href="/blog/2016/02/11/ecrire-un-jeu-en-2d-avec-ruby-et-gosu-partie-2/">Déplacer le joueur et pluie de smileys</a></li>
  <li><a href="/blog/2016/02/12/ecrire-un-jeu-en-2d-avec-ruby-et-gosu-partie-3/">Beep, fonte et collecte des smileys</a></li>
  <li>On s’occupe des vies</li>
  <li><a href="/blog/2016/02/15/ecrire-un-jeu-en-2d-avec-ruby-et-gosu-partie-5/">Musique et game over</a></li>
  <li><a href="/blog/2016/02/25/ecrire-un-jeu-en-2d-avec-ruby-et-gosu-partie-6/">Affichage selon un angle</a></li>
  <li><a href="/blog/2016/05/01/ecrire-un-jeu-en-2d-avec-ruby-et-gosu-partie-7/">Plusieurs musiques et reset de la partie</a></li>
</ol>

<h2 id="sourire--lenvers--autre-son-et-pas-de-points">Sourire à l’envers : autre son et pas de points</h2>

<p>Pour l’instant notre joueur collecte tout les smileys. Quel qu’ils soient.
Or, si les smiley oranges (sourire à l’endroit) doivent rapporter des points, les
smileys verts (sourire à l’envers) doivent eux faire perdre une vie à notre joueur.</p>

<p>On va commencer simplement par ne pas augmenter le score et jouer un son
différent quand le joueur entre en collision avec un smiley vert.
Dans la classe Player on charge le nouveau son (<code>life-lost.wav</code>) et on
modifie la méthode <code>collision</code> pour qu’elle réagisse au type du smiley:</p>

<p>```ruby
class Player</p>

<p>def initialize
    # …
    @sound_life_lost = Gosu::Sample.new(“assets/sound/life-lost.wav”)
  end</p>

<p>def collect(items)
    items.reject! {|item| collide?(item) ? collision(item.type) : false }
  end</p>

<p>def collision(type)
    case type
    when :smiley_up
      @score += 10
      @sound_collect.play(1.0)
    when :smiley_down
      @sound_life_lost.play(1.0)
    end</p>

<pre><code>true   end
</code></pre>

<p>end
```</p>

<p>Il ne faut pas oublier d’ajouter une méthode <code>type</code> à la classe Smiley:</p>

<p>```ruby
class Smiley
  attr_reader :x, :y, :type</p>

<p>def initialize(type)
    @type = type
    # …
  end</p>

<p>end
```</p>

<p>Avouez que c’était simple…</p>

<h2 id="afficher-les-vies">Afficher les vies</h2>

<p>L’objectif de cet article est de gérer les vies du joueur. Pour cela,
commençons par lui en donner 3:</p>

<p>```ruby player.rb
class Player</p>

<p># …</p>

<p>attr_reader :score, :lives</p>

<p>def initialize
    # …
    @lives = 3
  end</p>

<p>end
```</p>

<p>Les vies seront affichées au niveau de l’UI, c’est donc dans la classe du même
nom que cela va se passer. Jusqu’ici l’UI n’affichait que le score, et c’était
ce score que recevait en paramètre la méthode <code>draw</code>. On va modifier cela pour
pouvoir afficher le score et les vies.</p>

<p>On charge une nouvelle image, <code>heart.gif</code>, qui va symboliser une vie.
Puis dans <code>draw_lives</code> on affiche autant de <code>heart.gif</code> qu’il y a de vies:</p>

<p>```ruby ui.rb
class UI
  ScoreX = 10
  ScoreY = 10
  ScoreColor = 0xff_ffff00</p>

<p>LivesX = 10
  LivesXShift = 20
  LivesY = 30</p>

<p>def initialize
    @font = Gosu::Font.new(20, name: “assets/fonts/VT323/VT323-Regular.ttf”)
    @heart = Gosu::Image.new(“assets/images/heart.gif”)
  end</p>

<p>def draw(player)
    draw_score(player.score)
    draw_lives(player.lives)
  end</p>

<p>private</p>

<p>def draw_score(score)
    @font.draw(“Score: #{score}”, ScoreX, ScoreY, ZOrder::UI, 1.0, 1.0,
               ScoreColor)
  end</p>

<p>def draw_lives(number)
    number.times do |index|
      @heart.draw(LivesXShift * index + LivesX, LivesY, ZOrder::UI)
    end
  end
end
```</p>

<p>L’affichage des vies commence à la coordonnée x <code>LiveX</code> (soit 10), et se
poursuit en étant décalé à chaque fois de <code>LivesXShift</code> pixels vers la droite (soit 20).</p>

<p>Pour finir, il faut modifier l’appel à <code>UI#draw</code> depuis la classe <code>Window</code>:</p>

<p><code>ruby window.rb
class Window &lt; Gosu::Window
  def draw
    # ...
    @ui.draw(@player)
  end
end
</code></p>

<h2 id="perdre-une-vie">Perdre une vie</h2>

<p>Maintenant qu’on peut comptabiliser et afficher les vies du joueur, on est
prêt à lui en faire perdre. Il n’y a qu’une seule ligne à ajouter:</p>

<p>```ruby
class Player
  def collision(type)
    case type
    when :smiley_up
      @score += 10
      @sound_collect.play(1.0)
    when :smiley_down
      @lives -= 1                # &lt;—————– Ici
      @sound_life_lost.play(1.0)
    end</p>

<pre><code>true   end end ```
</code></pre>

<p>Cette méthode <code>collision</code> est déjà trop longue à mon goût, mais je préfère
attendre qu’elle enfle encore avant d’y remédier. Je veux être certain que
même les plus débutant(e)s d’entre vous puissent voir cette méthode devenir
hors de contrôle avant de proposer une solution qui pourrait être vue comme
trop compliquée dans cette version.</p>

<p>Pour finir, voici le contenu du jeu pour l’instant:</p>

<pre><code>$ tree
.
├── assets
│   ├── fonts
│   │   └── VT323
│   │       ├── OFL.txt
│   │       └── VT323-Regular.ttf
│   ├── images
│   │   ├── background.png
│   │   ├── heart.gif
│   │   ├── player.png
│   │   ├── smiley-green.png
│   │   └── smiley-yellow.png
│   └── sound
│       ├── collect.wav
│       └── life-lost.wav
├── main.rb
├── player.rb
├── smiley.rb
├── ui.rb
├── window.rb
└── z_order.rb
</code></pre>

<p>Le code et les assets se trouvent <a href="https://github.com/lkdjiin/collect-the-smiles">sur Github</a>.
La version précise pour cet article est la <a href="https://github.com/lkdjiin/collect-the-smiles/releases/tag/v0.4.0">version 0.4.0</a>.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
