<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : ruby 2.2 | lkdjiin]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/ruby-2-dot-2/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2015-01-25T18:52:15+01:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ruby 2.2 - Une sélection des nouvelles méthodes]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/12/27/ruby-2-dot-2-une-selection-des-nouvelles-methodes/"/>
    <updated>2014-12-27T15:40:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/12/27/ruby-2-dot-2-une-selection-des-nouvelles-methodes</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Ça y est, noël est passé et Ruby 2.2.0 est arrivé.
Je vous ai préparé une sélection (personnelle) des nouveautés de cette dernière
version de Ruby.</p>

<p>Vous pouvez voir la liste exhaustive des changements ici:
<a href="https://github.com/ruby/ruby/blob/v2_2_0/NEWS">ruby v2.2.0 NEWS</a></p>

<!-- more -->


<h2>Les symboles pour les clés d'un Hash peuvent être entre guillemets</h2>

<p>Ce qui autorise l'utilisation des espaces.</p>

<p>``` irb</p>

<blockquote><blockquote><p>hash = { &ldquo;foo bar&rdquo;: &ldquo;baz&rdquo; }
=> {:&ldquo;foo bar&rdquo;=>&ldquo;baz&rdquo;}</p>

<p>hash[:&ldquo;foo bar&rdquo;]
=> &ldquo;baz&rdquo;
```</p></blockquote></blockquote>

<h2>Enumerable#slice_when</h2>

<p>J'ai le tableau suivant:</p>

<p>``` irb</p>

<blockquote><blockquote><p>a = [1, 2, 4, 9, 10, 11, 12, 15, 16, 19, 20, 21]
```</p></blockquote></blockquote>

<p>Je veux rassembler ensemble les séries de nombre qui se suivent. Autrement dit,
je veux obtenir ceci:</p>

<pre><code>[ [1, 2], [4], [9, 10, 11, 12], [15, 16], [19, 20, 21] ]
</code></pre>

<p><code>slice_when</code> me fait ça facilement:</p>

<p>``` irb</p>

<blockquote><blockquote><p>a.slice_when {|i, j| i+1 != j }.to_a
=> [[1, 2], [4], [9, 10, 11, 12], [15, 16], [19, 20, 21]]
```</p></blockquote></blockquote>

<h2>max et min peuvent retourner plusieurs valeurs</h2>

<p>Plutôt que d'obtenir la seule et unique valeur limite, on peut maintenant
obtenir une liste.</p>

<p>``` irb</p>

<blockquote><blockquote><p>[1, 2, 3].max
=> 3</p>

<p>[1, 2, 3].max(2)
=> [3, 2]</p>

<p>[1, 2, 3, 3].max(2)
=> [3, 3]
```</p></blockquote></blockquote>

<h2>Method#curry</h2>

<p>Tout d'abord, voici une méthode <code>add</code>, qui prend 3 arguments:</p>

<p><code>ruby
def add(a, b, c)
  a + b + c
end
</code></p>

<p>On <em>currifie</em> cette méthode:</p>

<p>``` irb</p>

<blockquote><blockquote><p>proc = self.method(:add).curry
=> #&lt;Proc:0x8f945a4 (lambda)>
```</p></blockquote></blockquote>

<p>Je peux maintenant l'appliquer partiellement:</p>

<p>``` irb</p>

<blockquote><blockquote><p>proc = proc.call(1, 2)
=> #&lt;Proc:0x9407dfc (lambda)></p>

<p>proc.call(3)
=> 6</p>

<p>proc.call(10)
=> 13
```</p></blockquote></blockquote>

<h2>La lib Etc</h2>

<p>Pour finir, voici deux nouvelles méthodes de la bibliothèque standard <code>Etc</code>.</p>

<p>``` irb</p>

<blockquote><blockquote><p>require &lsquo;etc&rsquo;</p>

<p>Etc.uname
=> {:sysname=>&ldquo;Linux&rdquo;, &hellip; }</p>

<p>Etc.nprocessors
=> 2
```</p></blockquote></blockquote>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p></p>
]]></content>
  </entry>
  
</feed>
