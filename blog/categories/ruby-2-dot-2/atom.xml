<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : ruby 2.2 | Xavier Nayrac]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/ruby-2-dot-2/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2015-08-20T17:00:56+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ruby 2.2 - Une sélection des nouvelles méthodes]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/12/27/ruby-2-dot-2-une-selection-des-nouvelles-methodes/"/>
    <updated>2014-12-27T15:40:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/12/27/ruby-2-dot-2-une-selection-des-nouvelles-methodes</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Ça y est, noël est passé et Ruby 2.2.0 est arrivé.
Je vous ai préparé une sélection (personnelle) des nouveautés de cette dernière
version de Ruby.</p>

<p>Vous pouvez voir la liste exhaustive des changements ici:
<a href="https://github.com/ruby/ruby/blob/v2_2_0/NEWS">ruby v2.2.0 NEWS</a></p>

<!-- more -->

<h2 id="les-symboles-pour-les-cls-dun-hash-peuvent-tre-entre-guillemets">Les symboles pour les clés d’un Hash peuvent être entre guillemets</h2>

<p>Ce qui autorise l’utilisation des espaces.</p>

<p>``` irb
» hash = { “foo bar”: “baz” }
=&gt; {:”foo bar”=&gt;”baz”}</p>

<blockquote>
  <blockquote>
    <p>hash[:”foo bar”]
=&gt; “baz”
```</p>
  </blockquote>
</blockquote>

<h2 id="enumerableslicewhen">Enumerable#slice_when</h2>

<p>J’ai le tableau suivant:</p>

<p><code>irb
&gt;&gt; a = [1, 2, 4, 9, 10, 11, 12, 15, 16, 19, 20, 21]
</code></p>

<p>Je veux rassembler ensemble les séries de nombre qui se suivent. Autrement dit,
je veux obtenir ceci:</p>

<pre><code>[ [1, 2], [4], [9, 10, 11, 12], [15, 16], [19, 20, 21] ]
</code></pre>

<p><code>slice_when</code> me fait ça facilement:</p>

<p><code>irb
&gt;&gt; a.slice_when {|i, j| i+1 != j }.to_a
=&gt; [[1, 2], [4], [9, 10, 11, 12], [15, 16], [19, 20, 21]]
</code></p>

<h2 id="max-et-min-peuvent-retourner-plusieurs-valeurs">max et min peuvent retourner plusieurs valeurs</h2>

<p>Plutôt que d’obtenir la seule et unique valeur limite, on peut maintenant
obtenir une liste.</p>

<p>``` irb
» [1, 2, 3].max
=&gt; 3</p>

<blockquote>
  <blockquote>
    <p>[1, 2, 3].max(2)
=&gt; [3, 2]</p>
  </blockquote>
</blockquote>

<blockquote>
  <blockquote>
    <p>[1, 2, 3, 3].max(2)
=&gt; [3, 3]
```</p>
  </blockquote>
</blockquote>

<h2 id="methodcurry">Method#curry</h2>

<p>Tout d’abord, voici une méthode <code>add</code>, qui prend 3 arguments:</p>

<p><code>ruby
def add(a, b, c)
  a + b + c
end
</code></p>

<p>On <em>currifie</em> cette méthode:</p>

<p><code>irb
&gt;&gt; proc = self.method(:add).curry
=&gt; #&lt;Proc:0x8f945a4 (lambda)&gt;
</code></p>

<p>Je peux maintenant l’appliquer partiellement:</p>

<p>``` irb
» proc = proc.call(1, 2)
=&gt; #&lt;Proc:0x9407dfc (lambda)&gt;</p>

<blockquote>
  <blockquote>
    <p>proc.call(3)
=&gt; 6</p>
  </blockquote>
</blockquote>

<blockquote>
  <blockquote>
    <p>proc.call(10)
=&gt; 13
```</p>
  </blockquote>
</blockquote>

<h2 id="la-lib-etc">La lib Etc</h2>

<p>Pour finir, voici deux nouvelles méthodes de la bibliothèque standard <code>Etc</code>.</p>

<p>``` irb
» require ‘etc’</p>

<blockquote>
  <blockquote>
    <p>Etc.uname
=&gt; {:sysname=&gt;”Linux”, … }</p>
  </blockquote>
</blockquote>

<blockquote>
  <blockquote>
    <p>Etc.nprocessors
=&gt; 2
```</p>
  </blockquote>
</blockquote>

<script id="fb33k8u">(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>

<p></p>
]]></content>
  </entry>
  
</feed>
