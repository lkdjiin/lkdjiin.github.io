<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : ruby 2.1 | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/ruby-2-dot-1/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2013-12-05T19:22:30+01:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Du nouveau dans Ruby 2.1: Argument nommé et requis]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/11/27/du-nouveau-dans-ruby-2-dot-1-argument-nomme-et-requis/"/>
    <updated>2013-11-27T18:14:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/11/27/du-nouveau-dans-ruby-2-dot-1-argument-nomme-et-requis</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Ruby 2.0 a introduit les arguments nommés, appelés <em>keyword argument</em>
dans la langue de Shakespeare, soit: «argument mot-clé». Ruby 2.1 ajoute
la notion d'argument nommé <strong>et</strong> requis.</p>

<p>Voilà à quoi ça ressemble, un argument nommé:</p>

<!-- more -->


<p>``` ruby
def foo(arg: &ldquo;hello&rdquo;)
  puts arg
end</p>

<p>foo #=> &ldquo;hello&rdquo;
```</p>

<h2>Avant Ruby 2.1</h2>

<p>Mais en Ruby 2.0, vous êtes obligé de donner une valeur par défaut:</p>

<pre><code>[~]⇒ rvm use 2.0.0
[~]⇒ irb
</code></pre>

<p>``` irb</p>

<blockquote><blockquote><p>def foo(arg:)
  puts arg
end
SyntaxError: (irb):10: syntax error, unexpected &lsquo;)&rsquo;
```</p></blockquote></blockquote>

<p>Imaginez que ça soit pareil avec les arguments dit
<em>normaux</em>. On ne pourrait pas écrire:</p>

<pre><code>def foo(arg)
</code></pre>

<p>On serait obligé d'écrire à la place:</p>

<pre><code>def foo(arg="hello")
</code></pre>

<p>Un peu bizarre, non ?</p>

<h2>Avec Ruby 2.1</h2>

<p>On peut maintenant définir un argument nommé sans valeur par défaut, et
donc faire en sorte qu'il soit requis:</p>

<pre><code>[~]⇒ rvm use 2.1.0-preview1
[~]⇒ irb
</code></pre>

<p>``` irb</p>

<blockquote><blockquote><p>def foo(arg:)
  puts arg
end
=> :foo
foo
ArgumentError: missing keyword: arg
foo &ldquo;hello&rdquo;
ArgumentError: missing keyword: arg
foo arg: &ldquo;hello&rdquo;
hello
```</p></blockquote></blockquote>

<p><strong>Source (pdf)</strong> <a href="http://www.atdot.net/~ko1/activities/toruby05-ko1.pdf">toruby</a></p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Du nouveau dans Ruby 2.1: Le suffixe f pour les chaînes de caractères]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/11/26/du-nouveau-dans-ruby-2-dot-1-le-suffixe-f-pour-les-chaines-de-caracteres/"/>
    <updated>2013-11-26T20:33:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/11/26/du-nouveau-dans-ruby-2-dot-1-le-suffixe-f-pour-les-chaines-de-caracteres</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Aujourd'hui c'est au tour du nouveau suffixe <code>f</code> (comme frozen) d'être passé
en revue.</p>

<!-- more -->


<h2>Avant Ruby 2.1</h2>

<p>Les chaînes de caractères en Ruby sont des objets <em>mutables</em>. Ce qui
signifie qu'à chaque fois que l'interpréteur rencontre <code>"foo"</code>, il crée
un nouvel objet:</p>

<pre><code>[~]⇒ rvm use 2.0.0
[~]⇒ irb
&gt;&gt; "foo".object_id
74667700
&gt;&gt; "foo".object_id
74664050
</code></pre>

<p>Ce qui peut influer sur les performances d'un programme quand on compare
beaucoup de chaînes. Voici un exemple trivial:</p>

<p><code>ruby
def foo?(string)
  foo = "foo"
  p foo.object_id
  string == foo
end
</code></p>

<p>Encore une fois, on peut constater qu'un nouvel objet est créé à chaque
appel de la méthode:</p>

<p>``` irb</p>

<blockquote><blockquote><p>foo? &ldquo;bépo&rdquo;
76675080
false
foo? &ldquo;bar&rdquo;
76669680
false
```</p></blockquote></blockquote>

<p>Et géler (<em>freeze</em>) l'objet n'empêchera pas sa création à chaque appel:</p>

<p>``` irb</p>

<blockquote><blockquote><p>def foo
  foo = &ldquo;foo&rdquo;.freeze
  foo.object_id
end
nil
foo
82081130
foo
82079520
```</p></blockquote></blockquote>

<h2>Avec Ruby 2.1</h2>

<pre><code>[~]⇒ rvm use 2.1.0-preview1
[~]⇒ irb
</code></pre>

<p>Le suffixe <code>f</code> permet de géler (<em>freeze</em>) les chaînes de
caractères:</p>

<p>``` irb</p>

<blockquote><blockquote><p>a = &ldquo;foo"f
=> "foo&rdquo;
a.reverse!
RuntimeError: can&rsquo;t modify frozen String
```</p></blockquote></blockquote>

<p>Et surtout, le suffixe <code>f</code> les gèlent une fois pour toutes.
L'exemple précédent donne ceci:</p>

<p>``` irb</p>

<blockquote><blockquote><p>def foo?(string)
  foo = &ldquo;foo"f
  p foo.object_id
  string == foo
end
=> :foo?
foo? "bépo&rdquo;
79029020
=> false
foo? &ldquo;bar&rdquo;
79029020
=> false
```</p></blockquote></blockquote>

<p><strong>Source (pdf)</strong> <a href="http://www.atdot.net/~ko1/activities/toruby05-ko1.pdf">toruby</a></p>

<p><strong>Edit du 1er décembre 2013</strong> Cette fonctionnalité a été supprimé dans
la version <a href="https://www.ruby-lang.org/en/news/2013/11/22/ruby-2-1-0-preview2-is-released/">2.1.0-preview2</a>.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Du nouveau dans Ruby 2.1: Le suffixe r]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/11/25/du-nouveau-dans-ruby-2-dot-1-le-suffixe-r/"/>
    <updated>2013-11-25T23:56:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/11/25/du-nouveau-dans-ruby-2-dot-1-le-suffixe-r</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Aujourd'hui on voit une nouvelle façon d'écrire un nombre rationnel dans
Ruby 2.1.</p>

<!-- more -->


<p>Jusqu'ici pour écrire un nombre rationnel, on devait faire ceci:</p>

<p><code>ruby
Rational('1/3')
</code></p>

<p>Ce qui est loin d'être concis:</p>

<pre><code>[~]⇒ rvm use 2.0.0
[~]⇒ irb
&gt;&gt; Rational('1/3') + Rational('1/9')
4/9
</code></pre>

<p>Désormais, avec Ruby 2.1, on pourra se servir du suffixe <code>r</code>:</p>

<pre><code>[~]⇒ rvm use 2.1.0-preview1
[~]⇒ irb
&gt;&gt; 1/3r + 1/9r
=&gt; (4/9)
</code></pre>

<p>Encore un peu plus de sucre dans notre langage ;)</p>

<p><strong>Source (pdf)</strong> <a href="http://www.atdot.net/~ko1/activities/toruby05-ko1.pdf">toruby</a></p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Du nouveau dans Ruby 2.1: Définition de méthode]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/11/22/du-nouveau-dans-ruby-2-dot-1-definition-de-methode/"/>
    <updated>2013-11-22T17:40:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/11/22/du-nouveau-dans-ruby-2-dot-1-definition-de-methode</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Ruby 2.1 devrait être là dans pas longtemps, il est temps de regarder
ce que cette nouvelle version nous offre. Aujourd'hui on va voir un petit
changement dans la définition des méthodes.</p>

<!-- more -->


<h2>Ce qui change avec def</h2>

<p>Jusqu'ici, <code>def</code> renvoyait <code>nil</code>:</p>

<pre><code>[~]⇒ rvm use 2.0.0
[~]⇒ irb
&gt;&gt; def foo;end
nil
</code></pre>

<p>Dans Ruby 2.1, <code>def</code> va renvoyer le nom de la méthode (en tant que symbole):</p>

<pre><code>[~]⇒ rvm use 2.1.0-preview1
[~]⇒ irb
&gt;&gt; def foo;end
=&gt; :foo
</code></pre>

<h2>Un cas d'utilisation</h2>

<p>Pour l'instant je ne connais qu'un seul cas d'utilisation:</p>

<p><code>ruby
private def foo ; end
</code></p>

<p>On peut utiliser Ruby pendant très longtemps avant de se rendre compte que
<code>private</code> est une méthode et non un mot-clé. Avant Ruby 2.1, l'utilisation
typique de <code>private</code> est celle-ci:</p>

<p>``` ruby
class Foo
  def foo ; end</p>

<p>  private</p>

<p>  def bar ; end
end
```</p>

<p>Autrement dit: les méthodes publiques avant <code>private</code> et les méthodes privées
après. Une autre possibilité intéressante est la suivante:</p>

<p>``` ruby
class Foo
  def foo ; end</p>

<p>  def foo_helper ; end
  private :bar
end
```</p>

<p>Moins utilisée mais pourtant cool, cette façon de faire permet de garder,
par exemple, une méthode helper sous la méthode appellante.</p>

<p>Avec Ruby 2.1 nous aurons donc la possibilité d'écrire ceci:</p>

<p>``` ruby
class Foo
  def foo ; end</p>

<p>  private foo_helper ; end
end
```</p>

<p>Voilà. Si vous connaissez un autre cas d'utilisation, laissez donc un
commentaire.</p>

<p><strong>Source (pdf)</strong> <a href="http://www.atdot.net/~ko1/activities/toruby05-ko1.pdf">toruby</a></p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
