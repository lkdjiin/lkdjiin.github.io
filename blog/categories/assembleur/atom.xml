<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : assembleur | Xavier Nayrac]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/assembleur/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2016-01-19T14:14:32+01:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Les langages que j'aimerais (ré)apprendre]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/06/18/les-langages-que-jaimerais-re-apprendre/"/>
    <updated>2015-06-18T10:46:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/06/18/les-langages-que-jaimerais-re-apprendre</id>
    <content type="html"><![CDATA[<p>Ça fait 5 ans que je fais presque exclusivement du Ruby.  J’ai envie que ça
change. Je n’ai pas de problème avec Ruby ; j’aime toujours autant ce langage ;
je pense qu’il a encore pas mal d’avenir (inertie des projets rails, ruby
dans le navigateur avec opal.rb, ruby dans l’embarqué avec mruby) ; c’est juste
que j’ai besoin d’air frais.</p>

<p>Voici une liste de 8 langages informatiques que j’aimerais apprendre,
réapprendre, tester ou approfondir, plus ou moins dans l’ordre.</p>

<h2 id="r">R</h2>

<p>Le langage de base du <em>data scientist</em>. Je m’y met à fond en ce moment.
Ce langage est parfois bizarre, mais parfait pour l’exploration des données,
les statistiques et les graphes en interactif dans la console.</p>

<!-- more -->

<h2 id="jruby">JRuby</h2>

<p>Bon ok, c’est pas un langage. Mais je ne me suis jamais intéressé à JRuby.
C’est peut-être le moment d’essayer. Je me dis que JRuby pourrait pallier les
lacunes de Ruby en matière de graphisme.</p>

<h2 id="java">Java</h2>

<p>Des fois je ressens le besoin de faire des programmes rapides. J’ai fait du
Java pendant des années, il est peut-être temps de voir les nouveautés que ce
langage a à m’offrir.</p>

<h2 id="assembleur">Assembleur</h2>

<p>J’ai fait de l’assembleur il y a longtemps. Ça ne m’a jamais vraiment manqué,
mais j’explorerais bien les micro contrôleurs en assembleur, par exemple.</p>

<h2 id="elm">Elm</h2>

<p>Un langage fonctionnel, réactif, sympa pour les jeux en
2D. Pas besoin d’en dire plus, je suis intrigué et je veux l’essayer, même si
ça se passe dans le navigateur.</p>

<h2 id="julia">Julia</h2>

<p>Lui, il veut carrément remplacer R, matlab, Octave, etc. Et d’après ce que j’en
ai déjà vu, il pourrait en avoir les moyens. Par contre je ne pense pas
apprendre R <strong>et</strong> Julia en même temps, donc Julia devra attendre.</p>

<h2 id="c">C</h2>

<p>Je n’avais pas fait de C depuis plusieurs années, à part avec l’Arduino mais ça
compte pas vraiment, n’est-ce pas ? Dernièrement j’ai écris un patch en C pour
le langage R et ça m’a donné envie de m’y remettre. Mais bon, c’est juste une
envie.</p>

<h2 id="f-sharp">F sharp</h2>

<p>Certainement que ça n’arrivera jamais (parce que pas le besoin) mais je trouve la
syntaxe élégante et intrigante. J’aimerais bien l’essayer.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Un exemple de polymorphisme en situation réelle]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/05/14/un-exemple-de-polymorphisme-en-situation-reelle/"/>
    <updated>2015-05-14T19:16:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/05/14/un-exemple-de-polymorphisme-en-situation-reelle</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-3'>Niveau : <span>avancé</span></div></p>

<p>J’écris en ce moment un <a href="http://fr.wikipedia.org/wiki/%C3%89mulation">émulateur</a>
pour <a href="http://fr.wikipedia.org/wiki/CHIP-8">Chip-8</a>, en Ruby. Dans les outils que
j’écris à coté il y a un <a href="http://fr.wikipedia.org/wiki/D%C3%A9sassembleur">désassembleur</a> de code Chip-8. Dans ce
désassembleur il y a un bel exemple de polymorphisme.</p>

<!-- more -->

<h2 id="un-peu-de-contexte">Un peu de contexte</h2>

<p>La classe Opcode permet de faire la correspondance entre un <a href="http://fr.wikipedia.org/wiki/Langage_machine#Opcode">opcode</a> Chip-8
et une ligne de code assembleur. Un opcode Chip-8 est toujours représenté par
un nombre <a href="http://fr.wikipedia.org/wiki/Syst%C3%A8me_hexad%C3%A9cimal">hexadécimal</a> de 4 chiffres.</p>

<p>Voici quelques exemples d’opcodes et leur correspondance en assembleur :</p>

<pre><code>Opcode | Assembleur  | Remarque
-------|-------------|---------
2a00   | CALL a00    |
7012   | ADD V0, 12  | V0 est un registre
a22e   | LOAD I, 22e | I est un registre
</code></pre>

<p>On pourra remarquer (même si ça n’est pas ultra visible avec seulement trois
exemples) que c’est le premier chiffre (ici <code>2</code>, <code>7</code> et <code>a</code>) qui décide du
type d’instruction.</p>

<p>De <code>0</code> à <code>f</code>, on a donc 16 types possibles, ce qui donne ce genre de code :</p>

<p>``` ruby opcode.rb
class Opcode</p>

<p>def initialize(opcode)
    @opcode = opcode
    @assembly = compute_assembly
    …
  end</p>

<p>…</p>

<p>private</p>

<p>def compute_assembly
    case @opcode[0]
    when ‘0’ then “Return this code”
    when ‘1’ then “Return that code”
    when ‘2’ then # …
    …
    when ‘d’ then # …
    when ‘e’ then # …
    when ‘f’ then # …
    end
  end</p>

<p>end
```</p>

<p>De plus, certains type d’instruction sont partagés en sous type, selon le
quatrième chiffre, ou bien selon les troisième et quatrième, ça dépend. Comme
toujours, on se retrouve à devoir gérer des cas particuliers, et le code
ressemble rapidement à la monstruosité qui suit :</p>

<p><code>ruby
def compute_assembly
  case @opcode[0]
  when '0'
    if @opcode == '00e0'
      # do that
    elsif @opcode == '00ee'
      # do that
    else
      # do that
    end
  when '1' then # do that
  when '2' then # do that
  when '3' then # do that
  when '4' then # do that
  when '5' then # do that
  when '6' then # do that
  when '7' then # do that
  when '8'
    case @opcode[3]
    when '0' then # do that
    when '1' then # do that
    when '2' then # do that
    when '3' then # do that
    when '4' then # do that
    when '5' then # do that
    when '6' then # do that
    when '7' then # do that
    when 'e' then # do that
    else
      # do that
    end
  when '9' then ...
  when 'a' then ...
  when 'b' then ...
  when 'c' then ...
  when 'd' then ...
  when 'e'
    # Ici, encore 2 sous-groupes
  when 'f'
    # Ici, encore 10 autres sous-groupes
  end
end
</code></p>

<p>C’est pas bon, hein ? Pour arranger ça, rien de tel qu’un peu de polymorphisme.
La classe Opcode va donc se contenter de ceci :</p>

<p>``` ruby Opcode
class Opcode</p>

<pre><code>def initialize(opcode)
  asm = Assembly.new(opcode)
  @assembly = asm.to_s
end
</code></pre>

<p>end
```</p>

<p>Vous devinez que c’est maintenant dans une nouvelle classe <code>Assembly</code> que sont géré les différentes
instructions et sous instructions :</p>

<p>``` ruby Assembly
class Assembly</p>

<p>def initialize(opcode)
    @opcode = opcode
    @assembly = build_assembly.to_s || ‘’
  end</p>

<p>def to_s
    @assembly
  end</p>

<p>private</p>

<p>def build_assembly
    klass = Kernel.const_get(‘Asm’ + @opcode[0])
    klass.new(@opcode)
  end</p>

<p>end
```</p>

<p>Et bien non, elles sont gérées chacune dans sa classe respective, à savoir
<code>Asm0</code>, <code>Asm1</code>, <code>Asm2</code>, et cetera jusqu’à <code>Asmf</code>. Voici un exemple :</p>

<p>``` ruby asm2.rb
class Asm2 &lt; AsmBase</p>

<p>def to_s
    “CALL #{nnn}”
  end</p>

<p>end
```</p>

<p>Chacune des classes <code>Asm0</code> à <code>Asmf</code> hérite de <code>AsmBase</code> qui définit le
comportement commun (nnn, kk, x et y sont simplement des conventions de nommage en
assembleur Chip-8) :</p>

<p>``` ruby asm_base.rb
class AsmBase</p>

<p>def initialize(opcode)
    @opcode = opcode
  end</p>

<p>def nnn
    @opcode[1, 3]
  end</p>

<p>def kk
    @opcode[2, 2]
  end</p>

<p>def x
    @opcode[1]
  end</p>

<p>def y
    @opcode[2]
  end</p>

<p>end
```</p>

<p>C’est un cas classique d’utilisation du polymorphisme. On troque
un long switch/case (virtuellement infini) pour plusieurs petites classes simples.
Le système est toujours aussi complexe dans son ensemble, mais sa maintenance
est maintenant plus facile.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Implémenter un langage sur la machine virtuelle Parrot: partie 3]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/08/03/implementer-un-langage-sur-la-machine-virtuelle-parrot-partie-3/"/>
    <updated>2013-08-03T08:16:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/08/03/implementer-un-langage-sur-la-machine-virtuelle-parrot-partie-3</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Après avoir vu
<a href="http://lkdjiin.github.io/blog/2013/08/02/implementer-un-langage-sur-la-machine-virtuelle-parrot-partie-2/">l’installation de Parrot</a>,
il est temps d’écrire
notre premier programme en PIR. On va réaliser une version simpliste
d’une fonction qui renvoie le signe d’un nombre entier. On oublie
momentanément l’existence du zéro pour n’avoir que deux cas à traiter:
positif ou négatif.</p>

<pre><code>simple_sign(n) = 1 si n &gt; 0
simple_sign(n) = -1 sinon
</code></pre>

<!-- more -->

<h2 id="la-procdure-simplesign">La procédure simple_sign</h2>
<p>Voici un programme PIR qui fait ça:</p>

<p>``` gas simple_sign.pir
.sub simple_sign
  .param int n</p>

<p>.local int result</p>

<p>if n &gt; 0 goto POSITIVE</p>

<p>result = -1
  goto RETURN</p>

<p>POSITIVE:
  result = 1</p>

<p>RETURN:
  .return(result)
.end</p>

<p>.sub main :main
  .local int f
  f = simple_sign(4)
  say f
.end
```</p>

<p>Pour le lancer:</p>

<pre><code>parrot simple_sign.pir
</code></pre>

<p>Comme c’est de l’assembleur, le plus simple est d’expliquer les lignes de
code une par une.</p>

<pre><code>.sub simple_sign
</code></pre>

<p>C’est la définition d’une procédure <code>simple_sign</code>.</p>

<pre><code>.param int n
</code></pre>

<p>On signale à l’assembleur que notre fonction <code>simple_sign</code> prend un
argument de type <code>int</code> et qu’on souhaite s’y réferer
par la suite à l’aide du nom <code>n</code>. Ça ressemble donc fortement à une
déclaration de variable.</p>

<pre><code>.local int result
</code></pre>

<p>Cette fois on déclare une variable locale nommée. Elle est de type <code>int</code> et
on pourra s’y réferer avec le nom <code>result</code>.</p>

<pre><code>if n &gt; 0 goto POSITIVE
</code></pre>

<p>Littéralement: Si la valeur de n est supérieur à zéro, sauter à l’adresse
réferencée par le label POSITIVE. Le saut conditionnel ou non est la seule
instruction de branchement dont on dispose avec PIR. Vous avez surement
appris que «goto c’est mal !». Oubliez le:</p>

<p><blockquote><p>En assembleur, goto est normal.</p></blockquote></p>

<p>Et c’est souvent la seule façon d’obtenir le résultat voulu.</p>

<pre><code>result = -1
</code></pre>

<p>Voilà comment affecter une valeur.</p>

<pre><code>goto RETURN
</code></pre>

<p>Voilà un saut inconditionnel vers l’adresse réferencée par le label
RETURN.</p>

<pre><code>POSITIVE:
  result = 1
</code></pre>

<p><code>POSITIVE:</code> définit une adresse. Chaque fois qu’on écrit <code>goto POSITIVE</code>, le
programme débranche à cette adresse (en fait à la ligne de code suivante).
Notez qu’on peut écrire les deux lignes précédentes en une seule :
<code>POSITIVE: result = 1</code>.</p>

<pre><code>RETURN:
  .return(result)
</code></pre>

<p>Définition du label RETURN puis renvoi du résultat avec la directive
<code>.return</code>. Les instructions qui commencent par un <code>.</code> sont des directives.
Ce qui veut dire qu’elles seront remplacées dans notre dos par plusieurs
instructions de plus bas niveau.</p>

<pre><code>.end
</code></pre>

<p>Fin de notre procédure <code>simple_sign</code>.</p>

<pre><code>.sub main :main
</code></pre>

<p>Nouvelle procédure, nommée <code>main</code>. Le <code>:main</code> dit à Parrot que c’est cette
procédure qu’il faut lancer à l’ouverture du programme. Si on ne le fait
pas, Parrot lance la première procédure qu’il rencontre.</p>

<pre><code>.local int f
f = simple_sign(4)
say f
.end
</code></pre>

<p>La fin du programme se comprend maintenant facilement.</p>

<p>Voilà, si vous avez déjà travaillé en assembleur, la syntaxe PIR ne
devrait pas vous poser de problèmes particuliers car c’est un
assembleur de plutôt haut niveau ; par exemple on n’a pas encore eu
besoin de manipuler directement les registres. Si au contraire c’est
votre première rencontre avec un assembleur, vous allez devoir apprendre
à décomposer vos actions/pensées. Par exemple vous pourriez être tenté
d’écrire la procédure <code>main</code> de cette façon:</p>

<pre><code>.sub main :main
  say simple_sign(4)
.end
</code></pre>

<p>Mais ça ne marcheras pas, il faut décomposer…</p>

<script id="fb33k8u">(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
