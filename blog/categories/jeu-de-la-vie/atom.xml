<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : jeu de la vie | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/jeu-de-la-vie/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2014-10-29T07:28:31+01:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Le jeu de la vie en ruby (opal) - partie 3]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/10/29/le-jeu-de-la-vie-en-ruby-opal-partie-3/"/>
    <updated>2014-10-29T07:18:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/10/29/le-jeu-de-la-vie-en-ruby-opal-partie-3</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Il est temps de tout assembler, pour ça on va écrire une classe <code>Game</code> qui va
jouer le rôle de chef d'orchestre.</p>

<!-- more -->


<h2>La classe Game</h2>

<p>``` ruby
class Game</p>

<p>  def initialize(generation, canvas, iterations)</p>

<pre><code>@iterations = iterations
@height = generation.size
@width = generation.first.size
@generation = generation
@canvas = canvas
</code></pre>

<p>  end</p>

<p>  def start</p>

<pre><code>draw
@iterations -= 1
if @iterations &gt; 0
  update
  after_ms(500) { start }
end
</code></pre>

<p>  end</p>

<p>  def draw</p>

<pre><code>@canvas.clear
@generation.each_with_index do |line, y|
  line.each_with_index do |cell, x|
    @canvas.pixel(x, y) if cell == 1
  end
end
</code></pre>

<p>  end</p>

<p>  def update</p>

<pre><code>new_generation = (0...@height).map do |y|
  (0...@width).map do |x|
    extractor = NeighborhoodExtractor.new(@generation, x, y)
    Neighborhood.new(extractor.cells).next_state
  end
end
@generation = new_generation
</code></pre>

<p>  end</p>

<p>end
```</p>

<p>Rien d'exceptionnel dans ce code, à part la ligne suivante, extraite de la
méthode <code>start</code>:</p>

<p>``` ruby</p>

<pre><code>  after_ms(500) { start }
</code></pre>

<p>```</p>

<p>Qu'est-ce que c'est que cette méthode <code>after_ms</code> ?</p>

<p>Je ne peux pas faire une bête boucle <code>loop</code>, ou un appel récursif à <code>start</code>
puisqu'on est en Opal.rb, et pas <em>vraiment</em> en Ruby. Le code qui tourne, au
final, sera du Javascript. Et si on n'insère pas des petites pauses, le
navigateur ne va pas aimer du tout. Et puisqu'en Javascript il n'existe pas de
fonction <code>pause</code>, il n'y en a pas non plus en Opal.rb.</p>

<p>J'avoue que je me suis gratter un peu la tête avant de trouver une solution
toute simple. Il suffit d'écrire un <em>wrapper</em> autour de la fonction Javascript
<code>setTimeout</code>:</p>

<p>``` ruby app/kernel.rb
module Kernel</p>

<p>  def after_ms(n, &amp;block)</p>

<pre><code>`setTimeout(function() {`
  block.call
`}, n);`
</code></pre>

<p>  end</p>

<p>end
```</p>

<h2>Mise à l'échelle de l'affichage</h2>

<p>Ça, c'est très simple.</p>

<p>``` html index.html
&lt;!DOCTYPE html>
<html>
  &hellip;
  <body></p>

<pre><code>&lt;canvas width="400" height="400" id="canvas"&gt;&lt;/canvas&gt;
&lt;script src="build.js"&gt;&lt;/script&gt;
</code></pre>

<p>  </body>
</html>
```</p>

<p>``` ruby app/canvas.rb
class Canvas</p>

<p>  SCALE = 4</p>

<p>  def initialize</p>

<pre><code>@canvas  = `document.getElementById('canvas')`
@context = `#@canvas.getContext('2d')`
@height  = `#@canvas.height`
@width   = `#@canvas.width`
</code></pre>

<p>  end</p>

<p>  def clear</p>

<pre><code>draw_rect(0, 0, @width, @height, 'black')
</code></pre>

<p>  end</p>

<p>  def pixel(x, y)</p>

<pre><code>draw_rect(x * SCALE, y * SCALE, SCALE, SCALE, 'white')
</code></pre>

<p>  end</p>

<p>  private</p>

<p>  def draw_rect(x, y, w, h, color)</p>

<pre><code>`#@context.fillStyle = #{color}`
`#@context.fillRect(#{x}, #{y}, #{w}, #{h})`
</code></pre>

<p>  end</p>

<p>end
```</p>

<h2>Supprimer les bordures</h2>

<p>Ça, c'est très ennuyeux, vous pouvez sauter directement à la fin de l'article.</p>

<p>Je désactive les tests des bordures, puis je les réécrit un par un.</p>

<p>``` ruby spec/neighborhood_extractor_spec.rb
require &lsquo;./app/neighborhood_extractor.rb&rsquo;</p>

<p>describe NeighborhoodExtractor do</p>

<p>  let(:generation) do</p>

<pre><code>[
  [0, 1, 0, 1],
  [1, 0, 1, 0],
  [0, 1, 1, 0]
]
</code></pre>

<p>  end</p>

<p>  &hellip;</p>

<p>  describe &lsquo;borders&rsquo; do</p>

<pre><code>specify 'x=1 y=0' do
  extractor = NeighborhoodExtractor.new(generation, 1, 0)
  expect(extractor.cells).to eq [0, 1, 1, 0, 1, 0, 1, 0, 1]
end

# specify 'x=2 y=2' do
#   extractor = NeighborhoodExtractor.new(generation, 2, 2)
#   expect(extractor.cells).to eq [0, 1, 0, 1, 1, 0, 0, 0, 0]
# end

# specify 'x=0 y=1' do
#   extractor = NeighborhoodExtractor.new(generation, 0, 1)
#   expect(extractor.cells).to eq [0, 0, 1, 0, 1, 0, 0, 0, 1]
# end

# specify 'x=3 y=1' do
#   extractor = NeighborhoodExtractor.new(generation, 3, 1)
#   expect(extractor.cells).to eq [0, 1, 0, 1, 0, 0, 1, 0, 0]
# end
</code></pre>

<p>  end
end
```</p>

<p>``` ruby app/neighborhood_extractor.rb
  def group_of_tree(row_index)</p>

<pre><code>if row_index &lt; 0
  generation[generation.size-1][x-1..x+1]
elsif row_index == generation.size
  [0, 0, 0]
else
  if x == 0
    [ 0, *generation[row_index][x..x+1] ]
  elsif x == generation.first.size - 1
    [*generation[row_index][x-1..x], 0]
  else
    generation[row_index][x-1..x+1]
  end
end
</code></pre>

<p>  end
```</p>

<p>Après refactoring</p>

<p>``` ruby app/neighborhood_extractor.rb
class NeighborhoodExtractor &lt; Struct.new(:generation, :x, :y)</p>

<p>  def cells</p>

<pre><code>[ *extract(y - 1), *extract(y), *extract(y + 1) ]
</code></pre>

<p>  end</p>

<p>  private</p>

<p>  def extract(row_index)</p>

<pre><code>row_index = generation.size - 1 if row_index &lt; 0
group_of_tree(row_index)
</code></pre>

<p>  end</p>

<p>  def group_of_tree(row_index)</p>

<pre><code>if row_index == generation.size
  [0, 0, 0]
else
  if x == 0
    [ 0, *generation[row_index][x..x+1] ]
  elsif x == generation.first.size - 1
    [*generation[row_index][x-1..x], 0]
  else
    generation[row_index][x-1..x+1]
  end
end
</code></pre>

<p>  end</p>

<p>end
```</p>

<p>``` ruby spec/neighborhood_extractor_spec.rb
  describe &lsquo;borders&rsquo; do</p>

<pre><code>...

specify 'x=2 y=2' do
  extractor = NeighborhoodExtractor.new(generation, 2, 2)
  expect(extractor.cells).to eq [0, 1, 0, 1, 1, 0, 1, 0, 1]
end
</code></pre>

<p>```</p>

<p>``` ruby app/neighborhood_extractor.rb
class NeighborhoodExtractor &lt; Struct.new(:generation, :x, :y)</p>

<p>  def cells</p>

<pre><code>[ *extract(y - 1), *extract(y), *extract(y + 1) ]
</code></pre>

<p>  end</p>

<p>  private</p>

<p>  def extract(row_index)</p>

<pre><code>group_of_tree(ensure_overlapping(row_index))
</code></pre>

<p>  end</p>

<p>  def ensure_overlapping(index)</p>

<pre><code>if index &lt; 0
  generation.size - 1
elsif index == generation.size
  0
else
  index
end
</code></pre>

<p>  end</p>

<p>  def group_of_tree(row_index)</p>

<pre><code>if x == 0
  [ 0, *generation[row_index][x..x+1] ]
elsif x == generation.first.size - 1
  [*generation[row_index][x-1..x], 0]
else
  generation[row_index][x-1..x+1]
end
</code></pre>

<p>  end</p>

<p>end
```</p>

<p>``` ruby spec/neighborhood_extractor_spec.rb
  describe &lsquo;borders&rsquo; do</p>

<pre><code>...

specify 'x=0 y=1' do
  extractor = NeighborhoodExtractor.new(generation, 0, 1)
  expect(extractor.cells).to eq [1, 0, 1, 0, 1, 0, 0, 0, 1]
end

specify 'x=3 y=1' do
  extractor = NeighborhoodExtractor.new(generation, 3, 1)
  expect(extractor.cells).to eq [0, 1, 0, 1, 0, 1, 1, 0, 0]
end
</code></pre>

<p>```</p>

<p>Ça y est, on y voit plus clair.</p>

<p>``` ruby app/neighborhood_extractor.rb
class NeighborhoodExtractor &lt; Struct.new(:generation, :x, :y)</p>

<p>  def cells</p>

<pre><code>[ *extract(y - 1), *extract(y), *extract(y + 1) ]
</code></pre>

<p>  end</p>

<p>  private</p>

<p>  def extract(row_index)</p>

<pre><code>group_of_tree(ensure_overlapping(row_index))
</code></pre>

<p>  end</p>

<p>  def ensure_overlapping(index)</p>

<pre><code>if index &lt; 0
  generation.size - 1
elsif index == generation.size
  0
else
  index
end
</code></pre>

<p>  end</p>

<p>  def group_of_tree(row_index)</p>

<pre><code>row = generation[row_index]
if x == 0
  [row[-1], *row[x..x+1] ]
elsif x == generation.first.size - 1
  [*row[x-1..x], row[0]]
else
  row[x-1..x+1]
end
</code></pre>

<p>  end</p>

<p>end
```</p>

<p>Voilà, Ruby/Opal.rb c'est fait. Vous pouvez trouver le code sur Github si vous
êtes intéressés : <a href="https://github.com/lkdjiin/game-of-life-ruby">Le jeu de la vie en ruby/opal.rb</a>.</p>

<p>La prochaine version sera écrite en Racket, un dialecte de Lisp.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Le jeu de la vie en ruby (opal) - partie 2]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/10/27/le-jeu-de-la-vie-en-ruby-opal-partie-2/"/>
    <updated>2014-10-27T21:09:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/10/27/le-jeu-de-la-vie-en-ruby-opal-partie-2</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Deuxième partie du jeu de la vie en Ruby/Opal.rb, on va calculer le prochain
état d'une cellule, et extraire un <em>voisinage</em> de cellules d'une génération.
Après l'avoir écrit en Javascript, j'avoue que cette partie est quelque peu
ennuyeuse à reproduire. Je vais montrer du code, mais il y aura peu
d'explications, la logique étant la même qu'en Javascript (quoiqu'à base de
classes cette fois-ci).</p>

<!-- more -->


<p>Premier test et première classe pour spécifier une API.</p>

<p>``` ruby spec/neighborhood_spec.rb
require &lsquo;./app/neighborhood.rb&rsquo;</p>

<p>describe Neighborhood do</p>

<p>  let(:alive) { [1, 1, 1, 0, 0, 0, 0, 0, 0] }</p>

<p>  describe &lsquo;#next_state&rsquo; do</p>

<pre><code>it 'returns 1 when it will be alive' do
  neighborhood = Neighborhood.new(alive)
  expect(neighborhood.next_state).to eq 1
end
</code></pre>

<p>  end</p>

<p>end
```</p>

<p>``` ruby app/neighborhood.rb
class Neighborhood</p>

<p>  def initialize(cells)</p>

<pre><code>@cells = cells
</code></pre>

<p>  end</p>

<p>  def next_state</p>

<pre><code>1
</code></pre>

<p>  end
end
```</p>

<p><code>next_state</code> doit être capable de determiner que la cellule va mourrir.</p>

<p>``` ruby spec/neighborhood_spec.rb
require &lsquo;./app/neighborhood.rb&rsquo;</p>

<p>describe Neighborhood do</p>

<p>  let(:alive)       { [1, 1, 1, 0, 0, 0, 0, 0, 0] }
  let(:dead)        { [0, 0, 1, 0, 0, 0, 0, 0, 0] }
  let(:dead2)       { [1, 1, 1, 1, 1, 1, 1, 1, 1] }
  let(:dead3)       { [0, 0, 0, 0, 0, 0, 0, 0, 0] }</p>

<p>  describe &lsquo;#next_state&rsquo; do</p>

<pre><code>...

it 'returns 0 when it will be dead' do
  [dead, dead2, dead3].each do |cells|
    neighborhood = Neighborhood.new(cells)
    expect(neighborhood.next_state).to eq 0
  end
end
</code></pre>

<p>```</p>

<p>``` ruby app/neighborhood.rb
class Neighborhood</p>

<p>  ALIVE = 3</p>

<p>  def initialize(cells)</p>

<pre><code>@sum = cells.reduce(:+)
</code></pre>

<p>  end</p>

<p>  def next_state</p>

<pre><code>@sum == ALIVE ? 1 : 0
</code></pre>

<p>  end
end
```</p>

<p>Quand le nombre de cellules vivantes du voisinage est 4, le prochain état de
la cellule est le même que l'état actuel.</p>

<p>``` ruby spec/neighborhood_spec.rb
require &lsquo;./app/neighborhood.rb&rsquo;</p>

<p>describe Neighborhood do</p>

<p>  &hellip;</p>

<p>  let(:status_quo1) { [1, 1, 1, 1, 0, 0, 0, 0, 0] }
  let(:status_quo2) { [0, 1, 1, 1, 1, 0, 0, 0, 0] }</p>

<p>  describe &lsquo;#next_state&rsquo; do</p>

<pre><code>...

it 'returns old state in other cases' do
  neighborhood = Neighborhood.new(status_quo1)
  expect(neighborhood.next_state).to eq 0

  neighborhood = Neighborhood.new(status_quo2)
  expect(neighborhood.next_state).to eq 1
end
</code></pre>

<p>  end</p>

<p>end
```</p>

<p>``` ruby app/neighborhood.rb
class Neighborhood</p>

<p>  ALIVE = 3
  STATUS_QUO = 4</p>

<p>  def initialize(cells)</p>

<pre><code>@subject = cells[4]
@sum = cells.reduce(:+)
</code></pre>

<p>  end</p>

<p>  def next_state</p>

<pre><code>case @sum
when ALIVE then 1
when STATUS_QUO then @subject
else
  0
end
</code></pre>

<p>  end
end
```</p>

<h2>Extraire un voisinage de cellules</h2>

<p>Il faut pouvoir extraire un ensemble de 9 cellules (le <em>voisinage</em>) d'une
génération.</p>

<p>``` ruby spec/neighborhood_extractor_spec.rb
require &lsquo;./app/neighborhood_extractor.rb&rsquo;</p>

<p>describe NeighborhoodExtractor do</p>

<p>  let(:generation) do</p>

<pre><code>[
  [0, 1, 0, 1],
  [1, 0, 1, 0],
  [0, 1, 1, 0]
]
</code></pre>

<p>  end</p>

<p>  it &lsquo;returns 9 cells&rsquo; do</p>

<pre><code>x, y = 1, 1
extractor = NeighborhoodExtractor.new(generation, x, y)
expect(extractor.cells.size).to eq 9
</code></pre>

<p>  end</p>

<p>end
```</p>

<p>Ça, c'est juste la mise en train.</p>

<p>``` ruby app/neighborhood_extractor.rb
class NeighborhoodExtractor</p>

<p>  def initialize(generation, x, y)
  end</p>

<p>  def cells</p>

<pre><code>Array.new(9)
</code></pre>

<p>  end
end
```</p>

<p>Là, on commence à faire quelque chose d'utile.</p>

<p>``` ruby spec/neighborhood_extractor_spec.rb
describe NeighborhoodExtractor do</p>

<p>  let(:generation) do</p>

<pre><code>[
  [0, 1, 0, 1],
  [1, 0, 1, 0],
  [0, 1, 1, 0]
]
</code></pre>

<p>  end</p>

<p>  &hellip;</p>

<p>  describe &lsquo;inner position&rsquo; do</p>

<pre><code>specify 'x=1 y=1' do
  extractor = NeighborhoodExtractor.new(generation, 1, 1)
  expect(extractor.cells).to eq [0, 1, 0, 1, 0, 1, 0, 1, 1]
end
</code></pre>

<p>  end
end
```</p>

<p>``` ruby app/neighborhood_extractor.rb
class NeighborhoodExtractor &lt; Struct.new(:generation, :x, :y)</p>

<p>  def cells</p>

<pre><code>[
  *generation[y-1][x-1..x+1],
  *generation[y][x-1..x+1],
  *generation[y+1][x-1..x+1],
]
</code></pre>

<p>  end
end
```</p>

<p>Maintenant, voyons le problème des bordures.</p>

<p>``` ruby spec/neighborhood_extractor_spec.rb
  describe &lsquo;borders&rsquo; do</p>

<pre><code>specify 'x=1 y=0' do
  extractor = NeighborhoodExtractor.new(generation, 1, 0)
  expect(extractor.cells).to eq [0, 0, 0, 0, 1, 0, 1, 0, 1]
end
</code></pre>

<p>  end
```</p>

<p>La manière dont le test échoue est intéressante. C'est du à la façon dont Ruby
gère les indexs négatifs pour les tableaux, ceux-cis sont parfaitement
autorisés.</p>

<pre><code>Failures:

  1) NeighborhoodExtractor borders x=1 y=0
     Failure/Error: expect(extractor.cells).to eq [0, 0, 0, 0, 1, 0, 1, 0, 1]

       expected: [0, 0, 0, 0, 1, 0, 1, 0, 1]
            got: [0, 1, 1, 0, 1, 0, 1, 0, 1]

       (compared using ==)
     # ./spec/neighborhood_extractor_spec.rb:29:in `block (3 levels) in &lt;top (required)&gt;'
</code></pre>

<p>``` ruby app/neighborhood_extractor.rb
class NeighborhoodExtractor &lt; Struct.new(:generation, :x, :y)</p>

<p>  def cells</p>

<pre><code>[
  *row1,
  *generation[y][x-1..x+1],
  *generation[y+1][x-1..x+1],
]
</code></pre>

<p>  end</p>

<p>  def row1</p>

<pre><code>if y == 0
  [0, 0, 0]
else
  generation[y-1][x-1..x+1]
end
</code></pre>

<p>  end
end
```</p>

<p>Testons avec la bordure du bas.</p>

<p>``` ruby spec/neighborhood_extractor_spec.rb</p>

<pre><code>specify 'x=2 y=2' do
  extractor = NeighborhoodExtractor.new(generation, 2, 2)
  expect(extractor.cells).to eq [0, 1, 0, 1, 1, 0, 0, 0, 0]
end
</code></pre>

<p>```</p>

<p>``` ruby app/neighborhood_extractor.rb
class NeighborhoodExtractor &lt; Struct.new(:generation, :x, :y)</p>

<p>  &hellip;</p>

<p>  def row3</p>

<pre><code>if y == generation.size - 1
  [0, 0, 0]
else
  generation[y+1][x-1..x+1]
end
</code></pre>

<p>  end
end
```</p>

<p>Un peu de refactoring.</p>

<p>``` ruby app/neighborhood_extractor.rb
class NeighborhoodExtractor &lt; Struct.new(:generation, :x, :y)</p>

<p>  def cells</p>

<pre><code>[ *group_of_tree(y - 1), *group_of_tree(y), *group_of_tree(y + 1) ]
</code></pre>

<p>  end</p>

<p>  def group_of_tree(row)</p>

<pre><code>if row &lt; 0 || row == generation.size
  [0, 0, 0]
else
  generation[row][x-1..x+1]
end
</code></pre>

<p>  end</p>

<p>end
```</p>

<p>La bordure de gauche.</p>

<p>``` ruby spec/neighborhood_extractor_spec.rb</p>

<pre><code>specify 'x=0 y=1' do
  extractor = NeighborhoodExtractor.new(generation, 0, 1)
  expect(extractor.cells).to eq [0, 0, 1, 0, 1, 0, 0, 0, 1]
end
</code></pre>

<p>```</p>

<p>``` ruby app/neighborhood_extractor.rb
class NeighborhoodExtractor &lt; Struct.new(:generation, :x, :y)</p>

<p>  def cells</p>

<pre><code>[ *group_of_tree(y - 1), *group_of_tree(y), *group_of_tree(y + 1) ]
</code></pre>

<p>  end</p>

<p>  def group_of_tree(row)</p>

<pre><code>if row &lt; 0 || row == generation.size
  [0, 0, 0]
else
  if x == 0
    [ 0, *generation[row][x..x+1] ]
  else
    generation[row][x-1..x+1]
  end
end
</code></pre>

<p>  end</p>

<p>end
```</p>

<p>Et enfin celle de droite.</p>

<p>``` ruby spec/neighborhood_extractor_spec.rb</p>

<pre><code>specify 'x=3 y=1' do
  extractor = NeighborhoodExtractor.new(generation, 3, 1)
  expect(extractor.cells).to eq [0, 1, 0, 1, 0, 0, 1, 0, 0]
end
</code></pre>

<p>```</p>

<p>Ok, c'est moche, mais ça fonctionne.</p>

<p>``` ruby app/neighborhood_extractor.rb
class NeighborhoodExtractor &lt; Struct.new(:generation, :x, :y)</p>

<p>  def cells</p>

<pre><code>[ *group_of_tree(y - 1), *group_of_tree(y), *group_of_tree(y + 1) ]
</code></pre>

<p>  end</p>

<p>  def group_of_tree(row_index)</p>

<pre><code>if row_index &lt; 0 || row_index == generation.size
  [0, 0, 0]
else
  if x == 0
    [ 0, *generation[row_index][x..x+1] ]
  elsif x == generation.first.size - 1
    [*generation[row_index][x-1..x], 0]
  else
    generation[row_index][x-1..x+1]
  end
end
</code></pre>

<p>  end</p>

<p>end
```</p>

<p>Je devrais <em>refactorer</em> ce code, mais comme je sais qu'il va bientôt changer
(quand on va supprimer les bordures de la surface de jeu) je me dis qu'on verra
bien à ce moment là.</p>

<p>À noter pour finir que je ne teste pas les cas des cellules de coin. Nous avons
vu dans la version Javascript que si les cellules des bords droits, gauches,
hauts et bas fonctionnent, alors les coins fonctionnent aussi.</p>

<p>La prochaine fois on verra la classe <code>Game</code> et une petite astuce pour faire
un <code>sleep</code> like en Opal.rb.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Le jeu de la vie en ruby (opal) - partie 1]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/10/25/le-jeu-de-la-vie-en-ruby-opal-partie-1/"/>
    <updated>2014-10-25T18:13:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/10/25/le-jeu-de-la-vie-en-ruby-opal-partie-1</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Après la <a href="http://lkdjiin.github.io/blog/2014/10/16/le-jeu-de-la-vie-en-javascript-partie-1/">version Javascript</a> du jeu de la vie, je débute la version
Ruby/Opal.</p>

<!-- more -->


<h2>Obtenir une première génération au hasard</h2>

<pre><code>$ touch app/generation.rb
$ touch spec/generation_spec.rb
$ tree
.
├── app
│   └── generation.rb
└── spec
    └── generation_spec.rb
</code></pre>

<p>Mon premier test consiste à spécifier l'interface publique.</p>

<p>``` ruby generation_spec.rb
require &lsquo;./app/generation.rb&rsquo;</p>

<p>describe Generation do</p>

<p>  before do</p>

<pre><code>@width = 4
@height = 3
</code></pre>

<p>  end</p>

<p>  specify { expect(Generation.new(@width, @height)).to respond_to :create }</p>

<p>end
```</p>

<p>Et on le fait passer facilement.</p>

<p>``` ruby generation.rb
class Generation</p>

<p>  def initialize(width, height)
  end</p>

<p>  def create
  end</p>

<p>end
```</p>

<p>Un test en plus pour s'assurer que le tableau possède le bon nombre de lignes.</p>

<p>``` ruby generation_spec.rb
  describe &lsquo;#create&rsquo; do</p>

<pre><code>it 'returns an array with the right height' do
  generation = Generation.new(@width, @height).create
  expect(generation.size).to eq @height
end
</code></pre>

<p>  end
```</p>

<p>Encore une fois, le code vient facilement.</p>

<p>``` ruby generation.rb
class Generation</p>

<p>  def initialize(width, height)</p>

<pre><code>@height = height
</code></pre>

<p>  end</p>

<p>  def create</p>

<pre><code>Array.new(@height)
</code></pre>

<p>  end
end
```</p>

<p>Même chose maintenant avec le nombre de colonnes.</p>

<p>``` ruby generation_spec.rb
  describe &lsquo;#create&rsquo; do</p>

<pre><code>...
it 'returns an array with the right width' do
  generation = Generation.new(@width, @height).create
  expect(generation.first.size).to eq @width
end
</code></pre>

<p>  end
```</p>

<p>Pour faire passer ce test, on crée un tableau à deux dimensions.</p>

<p>``` ruby generation.rb
class Generation</p>

<p>  def initialize(width, height)</p>

<pre><code>@height = height
@width = width
</code></pre>

<p>  end</p>

<p>  def create</p>

<pre><code>Array.new(@height) { Array.new(@width) }
</code></pre>

<p>  end
end
```</p>

<p>On remarque l'expression <code>Generation.new(@width, @height)</code>, en commun dans
chaque test. C'est notre premier refactoring.</p>

<p>``` ruby generation_spec.rb
require &lsquo;./app/generation.rb&rsquo;</p>

<p>describe Generation do</p>

<p>  before do</p>

<pre><code>@width = 4
@height = 3
@generation = Generation.new(@width, @height)
</code></pre>

<p>  end</p>

<p>  specify { expect(@generation).to respond_to :create }</p>

<p>  describe &lsquo;#create&rsquo; do</p>

<pre><code>it 'returns an array with the right height' do
  expect(@generation.create.size).to eq @height
end

it 'returns an array with the right width' do
  expect(@generation.create.first.size).to eq @width
end
</code></pre>

<p>  end</p>

<p>end
```</p>

<h3>Du hasard maitrisé</h3>

<p>Je veux être sûr que la méthode <code>create</code> remplit bien le tableau avec soit des
<code>0</code>, soit des <code>1</code>. Pour tester ça facilement, je vais <em>figer</em> le générateur de
nombre aléatoire à l'aide de <code>srand</code>.</p>

<p>``` ruby generation_spec.rb</p>

<pre><code>it 'creates random cells' do
  srand(0)
  expect(@generation.create.first).to eq [0, 1, 1, 0]
end
</code></pre>

<p>```</p>

<p>``` ruby app/generation.rb
  def create</p>

<pre><code>Array.new(@height) { Array.new(@width) { rand(2) } }
</code></pre>

<p>  end
```</p>

<h2>Afficher une génération</h2>

<p>C'est la partie que je crains le plus avec certains langages. Avec Javascript
par exemple, pas de problème, mais avec Haskell, Rust ou Julia je n'ai aucune
idée des bibliothèques/frameworks/wrappers à employer.</p>

<p>Avec Ruby le souci est ailleurs. Je considère que l'écosystème Ruby est
horrible dès qu'on touche de près ou de loin au GUI. Je vais donc tricher
quelque peu et utiliser <a href="http://opalrb.org/">opal.rb</a>.</p>

<p>La structure de l'application va bien changer :</p>

<pre><code>$ tree
.
├── app
│   ├── application.rb
│   ├── canvas.rb
│   └── generation.rb
├── build.js
├── Gemfile
├── index.html
├── Rakefile
└── spec
    └── generation_spec.rb
</code></pre>

<p><code>ruby Gemfile
gem "opal", "&gt;= 0.6.2"
</code></p>

<p>``` ruby Rakefile
require &lsquo;opal&rsquo;</p>

<p>desc &ldquo;Build our app to build.js&rdquo;
task :build do
  Opal::Processor.source_map_enabled = false
  env = Opal::Environment.new
  env.append_path &ldquo;app&rdquo;</p>

<p>  File.open(&ldquo;build.js&rdquo;, &ldquo;w+&rdquo;) do |out|</p>

<pre><code>out &lt;&lt; env["application"].to_s
</code></pre>

<p>  end
end
```</p>

<p>``` html index.html
&lt;!DOCTYPE html>
<html>
  <head></p>

<pre><code>&lt;meta charset="utf-8" /&gt;
&lt;title&gt;Game of Life&lt;/title&gt;
</code></pre>

<p>  </head>
  <body></p>

<pre><code>&lt;canvas width="100" height="100" id="canvas"&gt;&lt;/canvas&gt;
&lt;script src="build.js"&gt;&lt;/script&gt;
</code></pre>

<p>  </body>
</html>
```</p>

<p>Dans <code>Canvas</code> j'écris une sorte d'adaptateur pour utiliser un <code>canvas</code>
Javascript.</p>

<p>``` ruby app/canvas.rb
class Canvas</p>

<p>  attr_reader :width, :height</p>

<p>  def initialize</p>

<pre><code>@canvas  = `document.getElementById('canvas')`
@context = `#@canvas.getContext('2d')`
@height  = `#@canvas.height`
@width   = `#@canvas.width`
</code></pre>

<p>  end</p>

<p>  def clear</p>

<pre><code>draw_rect(0, 0, @width, @height, 'black')
</code></pre>

<p>  end</p>

<p>  def pixel(x, y)</p>

<pre><code>draw_rect(x, y, 1, 1, 'white')
</code></pre>

<p>  end</p>

<p>  private</p>

<p>  def draw_rect(x, y, w, h, color)</p>

<pre><code>`#@context.fillStyle = #{color}`
`#@context.fillRect(#{x}, #{y}, #{w}, #{h})`
</code></pre>

<p>  end</p>

<p>end
```</p>

<p>Dans <code>app/application.rb</code> je peux maintenant afficher une génération.</p>

<p>``` ruby app/application.rb
require &lsquo;opal&rsquo;
require &lsquo;canvas&rsquo;
require &lsquo;generation&rsquo;</p>

<p>canvas = Canvas.new
canvas.clear</p>

<p>generation = Generation.new(canvas.width, canvas.height)
cells = generation.create</p>

<p>cells.each_with_index do |line, y|
  line.each_with_index do |cell, x|</p>

<pre><code>canvas.pixel(x, y) if cell == 1
</code></pre>

<p>  end
end
```</p>

<p>Après un <code>rake build</code>, on peut lancer l'application avec <code>see index.html</code>.</p>

<p>La suite la prochaine fois.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Le jeu de la vie en javascript - partie 3]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/10/18/le-jeu-de-la-vie-en-javascript-partie-3/"/>
    <updated>2014-10-18T12:29:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/10/18/le-jeu-de-la-vie-en-javascript-partie-3</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>C'est le moment de mettre ensemble tous les éléments codés jusqu'ici pour
contempler le jeu de la vie s'épanouir devant nos yeux.
Seulement je n'ai pas d'idée claire sur la manière dont ça peut-être fait
en javascript, et même sur les problèmes que ça pourrait poser, et encore
moins sur la manière de tester ça avec Jasmine.</p>

<p>Le TDD n'est pas une religion ! Ce n'est pas un précepte qu'on suit
aveuglement. On peut, et on doit, le questionner. Comment écrire un test quand
on n'a pas la moindre idée du problème à résoudre ?</p>

<!-- more -->


<p>Quand cette situation m'arrive, j'expérimente. Et voilà le résultat de mon
expérimentation:</p>

<p>``` javascript app/application.js
&hellip;</p>

<p>function draw(context2d, generation, totalGeneration) {
  var height = generation.length;
  var width = generation[0].length;</p>

<p>  clearBackground(context2d, width, height);
  drawCells(context2d, generation, width, height);</p>

<p>  if(totalGeneration > 0)</p>

<pre><code>setTimeout(update, 500, context2d, generation, totalGeneration);
</code></pre>

<p>}</p>

<p>&hellip;</p>

<p>function update(context2d, generation, totalGeneration) {
  var height = generation.length,</p>

<pre><code>  width = generation[0].length;
</code></pre>

<p>  // Create an empty generation.
  var nextGeneration = new Array(height);
  for(var y = 0; y &lt; height; y++) {</p>

<pre><code>nextGeneration[y] = new Array(width);
</code></pre>

<p>  }</p>

<p>  // Fill the next generation.
  for(var y = 0; y &lt; height; y++) {</p>

<pre><code>for(var x = 0; x &lt; width; x++) {
  var neighborhood = extractNeighborhood(generation, x, y);
  var state = nextCellState(neighborhood);
  nextGeneration[y][x] = state;
}
</code></pre>

<p>  }</p>

<p>  setTimeout(draw, 500, context2d, nextGeneration, totalGeneration &ndash; 1);
}</p>

<p>(function() {
  var generation = createGeneration(100, 100);
  var c = document.getElementById(&lsquo;canvas&rsquo;);
  var context2d = c.getContext(&lsquo;2d&rsquo;);
  var totalGeneration = 100;</p>

<p>  draw(context2d, generation, totalGeneration);
})()
```</p>

<p>Maintenant que j'ai une meilleure connaissance du problème à résoudre, j'efface
toutes les modifications que je viens de faire et je recommence en TDD.</p>

<p>Enfin c'est ce que je ferais normalement sur un projet réèl. Là, j'ai la flemme.</p>

<h2>Un meilleur affichage</h2>

<p>Je vais simplement faire un zoom 4x. Repérez <code>scale</code> dans le code suivant pour
savoir ce que j'ai modifié.</p>

<p>``` javascript app/application.js
function draw(context2d, generation, totalGeneration) {
  var height = generation.length;
  var width = generation[0].length;
  var scale = 4;</p>

<p>  clearBackground(context2d, width, height, scale);
  drawCells(context2d, generation, width, height, scale);</p>

<p>  if(totalGeneration > 0)</p>

<pre><code>setTimeout(update, 500, context2d, generation, totalGeneration);
</code></pre>

<p>}</p>

<p>function clearBackground(context2d, width, height, scale) {
  context2d.fillStyle = &lsquo;black&rsquo;;
  context2d.fillRect(0, 0, width * scale, height * scale);
}</p>

<p>function drawCells(context2d, generation, width, height, scale) {
  context2d.fillStyle = &lsquo;white&rsquo;;
  for(var y = 0; y &lt; height; y++) {</p>

<pre><code>for(var x = 0; x &lt; width; x++) {
  if(generation[x][y] === 1) {
    context2d.fillRect(x * scale, y * scale, scale, scale);
  }
}
</code></pre>

<p>  }
}
```</p>

<h2>Une surface de jeu «sans bord»</h2>

<p>Autre amélioration, mais non des moindres, on va connecter les bords du
haut et du bas, ainsi que les bords de gauche et de droite. On aura ainsi un
<a href="http://fr.wikipedia.org/wiki/Tore">tore</a>.</p>

<p>Cette nouvelle fonctionnalité simule assez bien ce qu'il se passe dans le
boulot du monde réèl. Je pourrais modifier le code, le regarder fonctionner,
puis modifier les tests en conséquence. Je vois ça souvent. Seulement cette
façon de faire revient à écrire les tests <strong>après</strong> le code. Et ça, ça n'est
pas du TDD. Je vais d'abord modifier les test, quitte à en désactiver certains
temporairement, <strong>puis</strong> modifier le code pour faire passer les nouveaux tests.</p>

<p>C'est la fonction <code>extractNeighborhood</code> qui doit être modifée. Je vais donc
réécrire les <em>expect</em>s de:</p>

<pre><code>describe("returns the neighborhood of a border's cell", function() {
</code></pre>

<p>et de</p>

<pre><code>describe("returns the neighborhood of a corner's cell", function() {
</code></pre>

<p>Cela fait 8 tests à réécrire. Je les ai tous désactivés, sauf le premier.</p>

<p>``` javascript
  describe(&ldquo;returns the neighborhood of a border&rsquo;s cell&rdquo;, function() {</p>

<pre><code>it("x=2, y=0", function() {
  var x = 2,
      y = 0,
      result = extractNeighborhood(this.generation, x, y);
  expect(result).toEqual([1, 1, 0, 1, 0, 1, 0, 1, 0]);
});

xit("x=2, y=2", function() {
  var x = 2,
      y = 2,
      result = extractNeighborhood(this.generation, x, y);
  expect(result).toEqual([0, 1, 0, 1, 1, 0, 1, 0, 1]);
});

xit("x=0, y=1", function() {
  var x = 0,
      y = 1,
      result = extractNeighborhood(this.generation, x, y);
  expect(result).toEqual([1, 0, 1, 0, 1, 0, 0, 0, 1]);
});

xit("x=3, y=1", function() {
  var x = 3,
      y = 1,
      result = extractNeighborhood(this.generation, x, y);
  expect(result).toEqual([0, 1, 0, 1, 0, 1, 1, 0, 0]);
});
</code></pre>

<p>  });</p>

<p>  xdescribe(&ldquo;returns the neighborhood of a corner&rsquo;s cell&rdquo;, function() {</p>

<pre><code>it("x=0, y=0", function() {
  var x = 0,
      y = 0,
      result = extractNeighborhood(this.generation, x, y);
  expect(result).toEqual([0, 0, 1, 1, 0, 1, 0, 1, 0]);
});

it("x=3, y=0", function() {
  var x = 3,
      y = 0,
      result = extractNeighborhood(this.generation, x, y);
  expect(result).toEqual([1, 0, 0, 0, 1, 0, 1, 0, 1]);
});

it("x=0, y=2", function() {
  var x = 0,
      y = 2,
      result = extractNeighborhood(this.generation, x, y);
  expect(result).toEqual([0, 1, 0, 0, 0, 1, 1, 0, 1]);
});

it("x=3, y=2", function() {
  var x = 3,
      y = 2,
      result = extractNeighborhood(this.generation, x, y);
  expect(result).toEqual([1, 0, 1, 1, 0, 0, 0, 1, 0]);
});
</code></pre>

<p>  });
```</p>

<p>Je vais donc les refaire passer un par un. Pour mémoire, voici l'ancien code:</p>

<p>``` javascript app/application.js
function extractNeighborhood(generation, x, y) {
  var cells = extractLine(generation[y-1], x).concat(</p>

<pre><code>          extractLine(generation[y], x),
          extractLine(generation[y+1], x));
</code></pre>

<p>  return cells.map(function(cell) {</p>

<pre><code>return cell === undefined ? 0 : cell;
</code></pre>

<p>  });
}</p>

<p>function extractLine(line, x) {
  if(line === void 0)</p>

<pre><code>return [0, 0, 0];
</code></pre>

<p>  else</p>

<pre><code>return [line[x-1], line[x], line[x+1]];
</code></pre>

<p>}
```</p>

<p>Et voici le code réécrit pour faire passer ce premier test:</p>

<p>``` javascript app/application.js
function extractNeighborhood(generation, x, y) {
  var cells,</p>

<pre><code>  line1,
  line2,
  line3;
</code></pre>

<p>  if(y > 0)</p>

<pre><code>line1 = extractLine(generation[y-1], x);
</code></pre>

<p>  else</p>

<pre><code>line1 = extractLine(generation[generation.length-1], x);
</code></pre>

<p>  line2 = extractLine(generation[y], x);
  line3 = extractLine(generation[y+1], x);</p>

<p>  cells = line1.concat(line2, line3);</p>

<p>  return cells.map(function(cell) {</p>

<pre><code>return cell === undefined ? 0 : cell;
</code></pre>

<p>  });
}</p>

<p>function extractLine(line, x) {
  return [line[x-1], line[x], line[x+1]];
}
```</p>

<p>Je réactive le second test, lance la suite de test pour confirmer qu'il
échoue, et voici le nouveau code:</p>

<p>``` javascript app/application.js
function extractNeighborhood(generation, x, y) {</p>

<p>  &hellip;</p>

<p>  if(y > 0)</p>

<pre><code>line1 = extractLine(generation[y-1], x);
</code></pre>

<p>  else</p>

<pre><code>line1 = extractLine(generation[generation.length-1], x);
</code></pre>

<p>  line2 = extractLine(generation[y], x);</p>

<p>  if(y === generation.length &ndash; 1)</p>

<pre><code>line3 = extractLine(generation[0], x);
</code></pre>

<p>  else</p>

<pre><code>line3 = extractLine(generation[y+1], x);
</code></pre>

<p>  &hellip;
}
```</p>

<p>Au tour du 3ème test. Pour le faire passer c'est <code>extractLine</code> que je dois
modifier.</p>

<p>``` javascript app/application.js
function extractLine(line, x) {
  if(x === 0)</p>

<pre><code>return [line[line.length-1], line[x], line[x+1]];
</code></pre>

<p>  else</p>

<pre><code>return [line[x-1], line[x], line[x+1]];
</code></pre>

<p>}
```</p>

<p>Et enfin je réactive le 4ème test.</p>

<p>``` javascript app/application.js
function extractLine(line, x) {
  if(x === 0)</p>

<pre><code>return [line[line.length-1], line[x], line[x+1]];
</code></pre>

<p>  else if(x === line.length-1)</p>

<pre><code>return [line[x-1], line[x], line[0]];
</code></pre>

<p>  else</p>

<pre><code>return [line[x-1], line[x], line[x+1]];
</code></pre>

<p>}
```</p>

<p>Puis je réactive les 4 tests restants (ceux des coins) et je vérifie que tout
passe. C'est un bon moment pour lancer le programme et vérifier visuellement
que des objets <em>traversent</em> bien les bords.</p>

<p>J'ai ensuite fait un peu de refactoring:</p>

<p>``` javascript app/application.js
function extractNeighborhood(generation, x, y) {
  var cells = line1(generation, x, y)</p>

<pre><code>          .concat(line2(generation, x, y), line3(generation, x, y));
</code></pre>

<p>  return cells.map(function(cell) {</p>

<pre><code>return cell === undefined ? 0 : cell;
</code></pre>

<p>  });
}</p>

<p>function line1(generation, x, y) {
  if(y > 0)</p>

<pre><code>return extractLine(generation[y-1], x);
</code></pre>

<p>  else</p>

<pre><code>return extractLine(generation[generation.length - 1], x);
</code></pre>

<p>}</p>

<p>function line2(generation, x, y) {
  return extractLine(generation[y], x);
}</p>

<p>function line3(generation, x, y) {
  if(y === generation.length &ndash; 1)</p>

<pre><code>return extractLine(generation[0], x);
</code></pre>

<p>  else</p>

<pre><code>return extractLine(generation[y+1], x);
</code></pre>

<p>}</p>

<p>function extractLine(line, x) {
  var left = x &ndash; 1,</p>

<pre><code>  right = x + 1;
</code></pre>

<p>  if(x === 0)</p>

<pre><code>left = line.length - 1;
</code></pre>

<p>  else if(x === line.length-1)</p>

<pre><code>right = 0;
</code></pre>

<p>  return [line[left], line[x], line[right]];
}
```</p>

<p>J'avoue que je ne sais pas si c'est mieux. Quoiqu'il en soit, vous pouvez
trouver le <a href="https://github.com/lkdjiin/game-of-life-javascript">code complet sur Github</a>.</p>

<p>La prochaine fois je m'attaquerais à la version Ruby/Opal.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Le jeu de la vie en javascript - partie 2]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/10/17/le-jeu-de-la-vie-en-javascript-partie-2/"/>
    <updated>2014-10-17T21:12:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/10/17/le-jeu-de-la-vie-en-javascript-partie-2</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p><a href="http://lkdjiin.github.io/blog/2014/10/16/le-jeu-de-la-vie-en-javascript-partie-1/">Précédement</a> nous avons écrit une fonction pour produire une génération de
cellules au hasard. Nous allons aujourd'hui afficher une telle génération.
Je veux maintenant calculer le prochain état d'une cellule, en fonction de son
voisinage. Pour rappel:</p>

<ul>
<li>Si la somme des 9 cellules du voisinage est 3, le nouvel état est «vivant».</li>
<li>Si la somme des 9 cellules du voisinage est 4, le nouvel état est le même
que l'ancien.</li>
<li>Dans tous les autres cas, le nouvel état est «mort».</li>
</ul>


<!-- more -->


<h2>Calculer le prochain état d'une cellule</h2>

<p>Voici les différents tests qui m'ont conduits à l'écriture de la fonction
<code>nextCellState</code>. Notez bien que, selon les principes du TDD, je ne les ai pas
écrit tous d'un coup, mais bien un par un, en implémentant la fonction
minimale à chaque nouveau test.</p>

<p>``` javascript
describe(&ldquo;nextCellState&rdquo;, function() {</p>

<p>  it(&ldquo;returns an integer&rdquo;, function() {</p>

<pre><code>var cells = [1, 1, 1, 0, 0, 0, 0, 0, 0];
var result = nextCellState(cells);
expect(Number.isInteger(result)).toBe(true);
</code></pre>

<p>  });</p>

<p>  it(&ldquo;returns 1 when it&rsquo;ll be alive&rdquo;, function() {</p>

<pre><code>var cells = [
  [1, 1, 1, 0, 0, 0, 0, 0, 0],
  [0, 1, 1, 0, 0, 1, 0, 0, 0],
  [0, 1, 0, 0, 0, 1, 0, 1, 0]
];
for(var i = 0; i &lt; cells.length; i++) {
  expect(nextCellState(cells[i])).toBe(1);
}
</code></pre>

<p>  });</p>

<p>  it(&ldquo;returns 0 when it&rsquo;ll be dead&rdquo;, function() {</p>

<pre><code>var cells = [
  [1, 1, 1, 1, 1, 1, 1, 1, 1],
  [0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 1, 0, 0, 0, 0, 0, 0, 0]
];
for(var i = 0; i &lt; cells.length; i++) {
  expect(nextCellState(cells[i])).toBe(0);
}
</code></pre>

<p>  });</p>

<p>  it(&ldquo;returns current state as next state&rdquo;, function() {</p>

<pre><code>var cells = [
  [1, 1, 1, 1, 0, 0, 0, 0, 0],
  [0, 1, 0, 0, 1, 1, 1, 0, 0]
];
expect(nextCellState(cells[0])).toBe(0);
expect(nextCellState(cells[1])).toBe(1);
</code></pre>

<p>  });</p>

<p>});
```</p>

<p>Et voici cette fonction.</p>

<p>``` javascript app/application.js
function nextCellState(neighborhood) {
  var result = neighborhood.reduce(function(a, b) {</p>

<pre><code>return a + b
</code></pre>

<p>  }, 0);</p>

<p>  if(result === 3)</p>

<pre><code>return 1;
</code></pre>

<p>  else if(result === 4)</p>

<pre><code>return neighborhood[4];
</code></pre>

<p>  else</p>

<pre><code>return 0;
</code></pre>

<p>}
```</p>

<p>Maintenant il me faut une fonction qui extrait un <em>voisinage</em> à partir d'une
position dans une génération. C'est la partie la plus complexe. Comme toujours,
je commence doucement avec un test très simple et son code d'implémentation.</p>

<p>``` javascript
describe(&ldquo;extractNeighborhood&rdquo;, function() {</p>

<p>  it(&ldquo;returns an array&rdquo;, function() {</p>

<pre><code>var result = extractNeighborhood();
expect(Array.isArray(result)).toBe(true);
</code></pre>

<p>  });</p>

<p>});
```</p>

<p><code>javascript app/application.js
function extractNeighborhood() {
  return [];
}
</code></p>

<p>Je peux commencer à <em>specer</em> les choses sérieuses.</p>

<p>``` javascript
describe(&ldquo;extractNeighborhood&rdquo;, function() {</p>

<p>  beforeEach(function() {</p>

<pre><code>this.generation = [
  [0, 1, 0, 1],
  [1, 0, 1, 0],
  [0, 1, 1, 0]];
</code></pre>

<p>  });</p>

<p>  it(&ldquo;returns an array&rdquo;, function() {</p>

<pre><code>var result = extractNeighborhood(this.generation, 1, 1);
expect(Array.isArray(result)).toBe(true);
</code></pre>

<p>  });</p>

<p>  it(&ldquo;returns the neighborhood of a cell at x, y&rdquo;, function() {</p>

<pre><code>var x = 1,
    y = 1,
    result = extractNeighborhood(this.generation, x, y);

expect(result).toEqual([0, 1, 0, 1, 0, 1, 0, 1, 1]);
</code></pre>

<p>  });</p>

<p>});
```</p>

<p>On note l'utilisation de <code>toEqual</code> pour tester l'égalité de deux tableaux,
<code>toBe()</code> testant l'identité d'après ce que j'ai compris.
Et voici le code qui fait passer tout ça, moche mais pragmatique.</p>

<p>``` javascript app/application.js
function extractNeighborhood(generation, x, y) {
  return [</p>

<pre><code>generation[y-1][x-1], generation[y-1][x], generation[y-1][x+1],
generation[y][x-1], generation[y][x], generation[y][x+1],
generation[y+1][x-1], generation[y+1][x], generation[y+1][x+1] ];
</code></pre>

<p>}
```</p>

<p>C'est au tour des cellules du bord, d'abord en haut.</p>

<p>``` javascript
describe(&ldquo;extractNeighborhood&rdquo;, function() {</p>

<p>  &hellip;</p>

<p>  describe(&ldquo;returns the neighborhood of a border&rsquo;s cell&rdquo;, function() {</p>

<pre><code>it("x=2, y=0", function() {
  var x = 2,
      y = 0,
      result = extractNeighborhood(this.generation, x, y);
  expect(result).toEqual([0, 0, 0, 0, 0, 1, 0, 1, 0]);
});
</code></pre>

<p>  });</p>

<p>});
```</p>

<p>Le code devient de plus en plus moche.</p>

<p>``` javascript app/application.js
function extractNeighborhood(generation, x, y) {
  return firstLine(generation, x, y-1).concat(</p>

<pre><code>[generation[y][x-1], generation[y][x], generation[y][x+1],
generation[y+1][x-1], generation[y+1][x], generation[y+1][x+1] ]);
</code></pre>

<p>}</p>

<p>function firstLine(generation, x, y) {
  if(y &lt; 0)</p>

<pre><code>return [0, 0, 0];
</code></pre>

<p>  else</p>

<pre><code>return [generation[y][x-1], generation[y][x], generation[y][x+1]];
</code></pre>

<p>}
```</p>

<p>Puisqu'il passe les tests, je cherche à l'améliorer un peu.</p>

<p>``` javascript app/application.js
function extractNeighborhood(generation, x, y) {
  return firstLine(generation[y-1], x).concat(</p>

<pre><code>[generation[y][x-1], generation[y][x], generation[y][x+1],
generation[y+1][x-1], generation[y+1][x], generation[y+1][x+1] ]);
</code></pre>

<p>}</p>

<p>function firstLine(line, x) {
  if(line === void 0)</p>

<pre><code>return [0, 0, 0];
</code></pre>

<p>  else</p>

<pre><code>return [line[x-1], line[x], line[x+1]];
</code></pre>

<p>}
```</p>

<p>Cellule du bord en bas, maintenant.</p>

<p>``` javascript
  describe(&ldquo;returns the neighborhood of a border&rsquo;s cell&rdquo;, function() {</p>

<pre><code>it("x=2, y=0", function() {
  ...
});

it("x=2, y=2", function() {
  var x = 2,
      y = 2,
      result = extractNeighborhood(this.generation, x, y);
  expect(result).toEqual([0, 1, 0, 1, 1, 0, 0, 0, 0]);
});
</code></pre>

<p>  });
```</p>

<p>``` javascript app/application.js
function extractNeighborhood(generation, x, y) {
  return extractLine(generation[y-1], x).concat(</p>

<pre><code>[generation[y][x-1], generation[y][x], generation[y][x+1]],
extractLine(generation[y+1], x));
</code></pre>

<p>}</p>

<p>function extractLine(line, x) {
  if(line === void 0)</p>

<pre><code>return [0, 0, 0];
</code></pre>

<p>  else</p>

<pre><code>return [line[x-1], line[x], line[x+1]];
</code></pre>

<p>}
```</p>

<p>Puis refactoring.</p>

<p>``` javascript app/application.js
function extractNeighborhood(generation, x, y) {
  return extractLine(generation[y-1], x).concat(</p>

<pre><code>     extractLine(generation[y], x),
     extractLine(generation[y+1], x));
</code></pre>

<p>}
```</p>

<p>On passe au bord gauche.</p>

<p>``` javascript
  describe(&ldquo;returns the neighborhood of a border&rsquo;s cell&rdquo;, function() {</p>

<pre><code>it("x=2, y=0", function() {
  ...
});

it("x=2, y=2", function() {
  ...
});

it("x=0, y=1", function() {
  var x = 0,
      y = 1,
      result = extractNeighborhood(this.generation, x, y);
  expect(result).toEqual([0, 0, 1, 0, 1, 0, 0, 0, 1]);
});
</code></pre>

<p>  });
```</p>

<p>La réponse de Jasmine à ce test est:</p>

<pre><code>Expected [ undefined, 0, 1, undefined, 1, 0, undefined, 0, 1 ] to equal [ 0, 0, 1, 0, 1, 0, 0, 0, 1 ].
</code></pre>

<p>Si on suit les principes du TDD, il faut écrire le code tout juste suffisant
pour faire passer ce test. Je me contente donc de mapper les <code>undefined</code> en <code>0</code>.</p>

<p>``` javascript app/application.js
function extractNeighborhood(generation, x, y) {
  var cells = extractLine(generation[y-1], x).concat(</p>

<pre><code>          extractLine(generation[y], x),
          extractLine(generation[y+1], x));
</code></pre>

<p>  return cells.map(function(cell) {</p>

<pre><code>return cell === undefined ? 0 : cell;
</code></pre>

<p>  });
}
```</p>

<p>Si j'ajoute un test pour une cellule du bord droit, il passe.</p>

<p>``` javascript</p>

<pre><code>it("x=3, y=1", function() {
  var x = 3,
      y = 1,
      result = extractNeighborhood(this.generation, x, y);
  expect(result).toEqual([0, 1, 0, 1, 0, 0, 1, 0, 0]);
});
</code></pre>

<p>```</p>

<p>Très bien, il faut maintenant s'occuper des cellules de coins. Je me rends
compte que les quatres tests suivants passent sans que je n'ai rien à modifier
dans le code.</p>

<p>``` javascript
  describe(&ldquo;returns the neighborhood of a corner&rsquo;s cell&rdquo;, function() {</p>

<pre><code>it("x=0, y=0", function() {
  var x = 0,
      y = 0,
      result = extractNeighborhood(this.generation, x, y);
  expect(result).toEqual([0, 0, 0, 0, 0, 1, 0, 1, 0]);
});

it("x=3, y=0", function() {
  var x = 3,
      y = 0,
      result = extractNeighborhood(this.generation, x, y);
  expect(result).toEqual([0, 0, 0, 0, 1, 0, 1, 0, 0]);
});

it("x=0, y=2", function() {
  var x = 0,
      y = 2,
      result = extractNeighborhood(this.generation, x, y);
  expect(result).toEqual([0, 1, 0, 0, 0, 1, 0, 0, 0]);
});

it("x=3, y=2", function() {
  var x = 3,
      y = 2,
      result = extractNeighborhood(this.generation, x, y);
  expect(result).toEqual([1, 0, 0, 1, 0, 0, 0, 0, 0]);
});
</code></pre>

<p>  });
```</p>

<p>Je suis donc prêt à tout mettre ensemble. Ce sera pour le prochain article car
celui-ci est déjà bien long.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p></p>
]]></content>
  </entry>
  
</feed>
