<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : jeu de la vie | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/jeu-de-la-vie/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2014-10-25T18:37:48+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Le jeu de la vie en ruby (opal) - partie 1]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/10/25/le-jeu-de-la-vie-en-ruby-opal-partie-1/"/>
    <updated>2014-10-25T18:13:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/10/25/le-jeu-de-la-vie-en-ruby-opal-partie-1</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Après la <a href="http://lkdjiin.github.io/blog/2014/10/16/le-jeu-de-la-vie-en-javascript-partie-1/">version Javascript</a> du jeu de la vie, je débute la version
Ruby/Opal.</p>

<!-- more -->


<h2>Obtenir une première génération au hasard</h2>

<pre><code>$ touch app/generation.rb
$ touch spec/generation_spec.rb
$ tree
.
├── app
│   └── generation.rb
└── spec
    └── generation_spec.rb
</code></pre>

<p>Mon premier test consiste à spécifier l'interface publique.</p>

<p>``` ruby generation_spec.rb
require &lsquo;./app/generation.rb&rsquo;</p>

<p>describe Generation do</p>

<p>  before do</p>

<pre><code>@width = 4
@height = 3
</code></pre>

<p>  end</p>

<p>  specify { expect(Generation.new(@width, @height)).to respond_to :create }</p>

<p>end
```</p>

<p>Et on le fait passer facilement.</p>

<p>``` ruby generation.rb
class Generation</p>

<p>  def initialize(width, height)
  end</p>

<p>  def create
  end</p>

<p>end
```</p>

<p>Un test en plus pour s'assurer que le tableau possède le bon nombre de lignes.</p>

<p>``` ruby generation_spec.rb
  describe &lsquo;#create&rsquo; do</p>

<pre><code>it 'returns an array with the right height' do
  generation = Generation.new(@width, @height).create
  expect(generation.size).to eq @height
end
</code></pre>

<p>  end
```</p>

<p>Encore une fois, le code vient facilement.</p>

<p>``` ruby generation.rb
class Generation</p>

<p>  def initialize(width, height)</p>

<pre><code>@height = height
</code></pre>

<p>  end</p>

<p>  def create</p>

<pre><code>Array.new(@height)
</code></pre>

<p>  end
end
```</p>

<p>Même chose maintenant avec le nombre de colonnes.</p>

<p>``` ruby generation_spec.rb
  describe &lsquo;#create&rsquo; do</p>

<pre><code>...
it 'returns an array with the right width' do
  generation = Generation.new(@width, @height).create
  expect(generation.first.size).to eq @width
end
</code></pre>

<p>  end
```</p>

<p>Pour faire passer ce test, on crée un tableau à deux dimensions.</p>

<p>``` ruby generation.rb
class Generation</p>

<p>  def initialize(width, height)</p>

<pre><code>@height = height
@width = width
</code></pre>

<p>  end</p>

<p>  def create</p>

<pre><code>Array.new(@height) { Array.new(@width) }
</code></pre>

<p>  end
end
```</p>

<p>On remarque l'expression <code>Generation.new(@width, @height)</code>, en commun dans
chaque test. C'est notre premier refactoring.</p>

<p>``` ruby generation_spec.rb
require &lsquo;./app/generation.rb&rsquo;</p>

<p>describe Generation do</p>

<p>  before do</p>

<pre><code>@width = 4
@height = 3
@generation = Generation.new(@width, @height)
</code></pre>

<p>  end</p>

<p>  specify { expect(@generation).to respond_to :create }</p>

<p>  describe &lsquo;#create&rsquo; do</p>

<pre><code>it 'returns an array with the right height' do
  expect(@generation.create.size).to eq @height
end

it 'returns an array with the right width' do
  expect(@generation.create.first.size).to eq @width
end
</code></pre>

<p>  end</p>

<p>end
```</p>

<h3>Du hasard maitrisé</h3>

<p>Je veux être sûr que la méthode <code>create</code> remplit bien le tableau avec soit des
<code>0</code>, soit des <code>1</code>. Pour tester ça facilement, je vais <em>figer</em> le générateur de
nombre aléatoire à l'aide de <code>srand</code>.</p>

<p>``` ruby generation_spec.rb</p>

<pre><code>it 'creates random cells' do
  srand(0)
  expect(@generation.create.first).to eq [0, 1, 1, 0]
end
</code></pre>

<p>```</p>

<p>``` ruby app/generation.rb
  def create</p>

<pre><code>Array.new(@height) { Array.new(@width) { rand(2) } }
</code></pre>

<p>  end
```</p>

<h2>Afficher une génération</h2>

<p>C'est la partie que je crains le plus avec certains langages. Avec Javascript
par exemple, pas de problème, mais avec Haskell, Rust ou Julia je n'ai aucune
idée des bibliothèques/frameworks/wrappers à employer.</p>

<p>Avec Ruby le souci est ailleurs. Je considère que l'écosystème Ruby est
horrible dès qu'on touche de près ou de loin au GUI. Je vais donc tricher
quelque peu et utiliser <a href="http://opalrb.org/">opal.rb</a>.</p>

<p>La structure de l'application va bien changer :</p>

<pre><code>$ tree
.
├── app
│   ├── application.rb
│   ├── canvas.rb
│   └── generation.rb
├── build.js
├── Gemfile
├── index.html
├── Rakefile
└── spec
    └── generation_spec.rb
</code></pre>

<p><code>ruby Gemfile
gem "opal", "&gt;= 0.6.2"
</code></p>

<p>``` ruby Rakefile
require &lsquo;opal&rsquo;</p>

<p>desc &ldquo;Build our app to build.js&rdquo;
task :build do
  Opal::Processor.source_map_enabled = false
  env = Opal::Environment.new
  env.append_path &ldquo;app&rdquo;</p>

<p>  File.open(&ldquo;build.js&rdquo;, &ldquo;w+&rdquo;) do |out|</p>

<pre><code>out &lt;&lt; env["application"].to_s
</code></pre>

<p>  end
end
```</p>

<p>``` html index.html
&lt;!DOCTYPE html>
<html>
  <head></p>

<pre><code>&lt;meta charset="utf-8" /&gt;
&lt;title&gt;Game of Life&lt;/title&gt;
</code></pre>

<p>  </head>
  <body></p>

<pre><code>&lt;canvas width="100" height="100" id="canvas"&gt;&lt;/canvas&gt;
&lt;script src="build.js"&gt;&lt;/script&gt;
</code></pre>

<p>  </body>
</html>
```</p>

<p>Dans <code>Canvas</code> j'écris une sorte d'adaptateur pour utiliser un <code>canvas</code>
Javascript.</p>

<p>``` ruby app/canvas.rb
class Canvas</p>

<p>  attr_reader :width, :height</p>

<p>  def initialize</p>

<pre><code>@canvas  = `document.getElementById('canvas')`
@context = `#@canvas.getContext('2d')`
@height  = `#@canvas.height`
@width   = `#@canvas.width`
</code></pre>

<p>  end</p>

<p>  def clear</p>

<pre><code>draw_rect(0, 0, @width, @height, 'black')
</code></pre>

<p>  end</p>

<p>  def pixel(x, y)</p>

<pre><code>draw_rect(x, y, 1, 1, 'white')
</code></pre>

<p>  end</p>

<p>  private</p>

<p>  def draw_rect(x, y, w, h, color)</p>

<pre><code>`#@context.fillStyle = #{color}`
`#@context.fillRect(#{x}, #{y}, #{w}, #{h})`
</code></pre>

<p>  end</p>

<p>end
```</p>

<p>Dans <code>app/application.rb</code> je peux maintenant afficher une génération.</p>

<p>``` ruby app/application.rb
require &lsquo;opal&rsquo;
require &lsquo;canvas&rsquo;
require &lsquo;generation&rsquo;</p>

<p>canvas = Canvas.new
canvas.clear</p>

<p>generation = Generation.new(canvas.width, canvas.height)
cells = generation.create</p>

<p>cells.each_with_index do |line, y|
  line.each_with_index do |cell, x|</p>

<pre><code>canvas.pixel(x, y) if cell == 1
</code></pre>

<p>  end
end
```</p>

<p>Après un <code>rake build</code>, on peut lancer l'application avec <code>see index.html</code>.</p>

<p>La suite la prochaine fois.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Le jeu de la vie en javascript - partie 3]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/10/18/le-jeu-de-la-vie-en-javascript-partie-3/"/>
    <updated>2014-10-18T12:29:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/10/18/le-jeu-de-la-vie-en-javascript-partie-3</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>C'est le moment de mettre ensemble tous les éléments codés jusqu'ici pour
contempler le jeu de la vie s'épanouir devant nos yeux.
Seulement je n'ai pas d'idée claire sur la manière dont ça peut-être fait
en javascript, et même sur les problèmes que ça pourrait poser, et encore
moins sur la manière de tester ça avec Jasmine.</p>

<p>Le TDD n'est pas une religion ! Ce n'est pas un précepte qu'on suit
aveuglement. On peut, et on doit, le questionner. Comment écrire un test quand
on n'a pas la moindre idée du problème à résoudre ?</p>

<!-- more -->


<p>Quand cette situation m'arrive, j'expérimente. Et voilà le résultat de mon
expérimentation:</p>

<p>``` javascript app/application.js
&hellip;</p>

<p>function draw(context2d, generation, totalGeneration) {
  var height = generation.length;
  var width = generation[0].length;</p>

<p>  clearBackground(context2d, width, height);
  drawCells(context2d, generation, width, height);</p>

<p>  if(totalGeneration > 0)</p>

<pre><code>setTimeout(update, 500, context2d, generation, totalGeneration);
</code></pre>

<p>}</p>

<p>&hellip;</p>

<p>function update(context2d, generation, totalGeneration) {
  var height = generation.length,</p>

<pre><code>  width = generation[0].length;
</code></pre>

<p>  // Create an empty generation.
  var nextGeneration = new Array(height);
  for(var y = 0; y &lt; height; y++) {</p>

<pre><code>nextGeneration[y] = new Array(width);
</code></pre>

<p>  }</p>

<p>  // Fill the next generation.
  for(var y = 0; y &lt; height; y++) {</p>

<pre><code>for(var x = 0; x &lt; width; x++) {
  var neighborhood = extractNeighborhood(generation, x, y);
  var state = nextCellState(neighborhood);
  nextGeneration[y][x] = state;
}
</code></pre>

<p>  }</p>

<p>  setTimeout(draw, 500, context2d, nextGeneration, totalGeneration &ndash; 1);
}</p>

<p>(function() {
  var generation = createGeneration(100, 100);
  var c = document.getElementById(&lsquo;canvas&rsquo;);
  var context2d = c.getContext(&lsquo;2d&rsquo;);
  var totalGeneration = 100;</p>

<p>  draw(context2d, generation, totalGeneration);
})()
```</p>

<p>Maintenant que j'ai une meilleure connaissance du problème à résoudre, j'efface
toutes les modifications que je viens de faire et je recommence en TDD.</p>

<p>Enfin c'est ce que je ferais normalement sur un projet réèl. Là, j'ai la flemme.</p>

<h2>Un meilleur affichage</h2>

<p>Je vais simplement faire un zoom 4x. Repérez <code>scale</code> dans le code suivant pour
savoir ce que j'ai modifié.</p>

<p>``` javascript app/application.js
function draw(context2d, generation, totalGeneration) {
  var height = generation.length;
  var width = generation[0].length;
  var scale = 4;</p>

<p>  clearBackground(context2d, width, height, scale);
  drawCells(context2d, generation, width, height, scale);</p>

<p>  if(totalGeneration > 0)</p>

<pre><code>setTimeout(update, 500, context2d, generation, totalGeneration);
</code></pre>

<p>}</p>

<p>function clearBackground(context2d, width, height, scale) {
  context2d.fillStyle = &lsquo;black&rsquo;;
  context2d.fillRect(0, 0, width * scale, height * scale);
}</p>

<p>function drawCells(context2d, generation, width, height, scale) {
  context2d.fillStyle = &lsquo;white&rsquo;;
  for(var y = 0; y &lt; height; y++) {</p>

<pre><code>for(var x = 0; x &lt; width; x++) {
  if(generation[x][y] === 1) {
    context2d.fillRect(x * scale, y * scale, scale, scale);
  }
}
</code></pre>

<p>  }
}
```</p>

<h2>Une surface de jeu «sans bord»</h2>

<p>Autre amélioration, mais non des moindres, on va connecter les bords du
haut et du bas, ainsi que les bords de gauche et de droite. On aura ainsi un
<a href="http://fr.wikipedia.org/wiki/Tore">tore</a>.</p>

<p>Cette nouvelle fonctionnalité simule assez bien ce qu'il se passe dans le
boulot du monde réèl. Je pourrais modifier le code, le regarder fonctionner,
puis modifier les tests en conséquence. Je vois ça souvent. Seulement cette
façon de faire revient à écrire les tests <strong>après</strong> le code. Et ça, ça n'est
pas du TDD. Je vais d'abord modifier les test, quitte à en désactiver certains
temporairement, <strong>puis</strong> modifier le code pour faire passer les nouveaux tests.</p>

<p>C'est la fonction <code>extractNeighborhood</code> qui doit être modifée. Je vais donc
réécrire les <em>expect</em>s de:</p>

<pre><code>describe("returns the neighborhood of a border's cell", function() {
</code></pre>

<p>et de</p>

<pre><code>describe("returns the neighborhood of a corner's cell", function() {
</code></pre>

<p>Cela fait 8 tests à réécrire. Je les ai tous désactivés, sauf le premier.</p>

<p>``` javascript
  describe(&ldquo;returns the neighborhood of a border&rsquo;s cell&rdquo;, function() {</p>

<pre><code>it("x=2, y=0", function() {
  var x = 2,
      y = 0,
      result = extractNeighborhood(this.generation, x, y);
  expect(result).toEqual([1, 1, 0, 1, 0, 1, 0, 1, 0]);
});

xit("x=2, y=2", function() {
  var x = 2,
      y = 2,
      result = extractNeighborhood(this.generation, x, y);
  expect(result).toEqual([0, 1, 0, 1, 1, 0, 1, 0, 1]);
});

xit("x=0, y=1", function() {
  var x = 0,
      y = 1,
      result = extractNeighborhood(this.generation, x, y);
  expect(result).toEqual([1, 0, 1, 0, 1, 0, 0, 0, 1]);
});

xit("x=3, y=1", function() {
  var x = 3,
      y = 1,
      result = extractNeighborhood(this.generation, x, y);
  expect(result).toEqual([0, 1, 0, 1, 0, 1, 1, 0, 0]);
});
</code></pre>

<p>  });</p>

<p>  xdescribe(&ldquo;returns the neighborhood of a corner&rsquo;s cell&rdquo;, function() {</p>

<pre><code>it("x=0, y=0", function() {
  var x = 0,
      y = 0,
      result = extractNeighborhood(this.generation, x, y);
  expect(result).toEqual([0, 0, 1, 1, 0, 1, 0, 1, 0]);
});

it("x=3, y=0", function() {
  var x = 3,
      y = 0,
      result = extractNeighborhood(this.generation, x, y);
  expect(result).toEqual([1, 0, 0, 0, 1, 0, 1, 0, 1]);
});

it("x=0, y=2", function() {
  var x = 0,
      y = 2,
      result = extractNeighborhood(this.generation, x, y);
  expect(result).toEqual([0, 1, 0, 0, 0, 1, 1, 0, 1]);
});

it("x=3, y=2", function() {
  var x = 3,
      y = 2,
      result = extractNeighborhood(this.generation, x, y);
  expect(result).toEqual([1, 0, 1, 1, 0, 0, 0, 1, 0]);
});
</code></pre>

<p>  });
```</p>

<p>Je vais donc les refaire passer un par un. Pour mémoire, voici l'ancien code:</p>

<p>``` javascript app/application.js
function extractNeighborhood(generation, x, y) {
  var cells = extractLine(generation[y-1], x).concat(</p>

<pre><code>          extractLine(generation[y], x),
          extractLine(generation[y+1], x));
</code></pre>

<p>  return cells.map(function(cell) {</p>

<pre><code>return cell === undefined ? 0 : cell;
</code></pre>

<p>  });
}</p>

<p>function extractLine(line, x) {
  if(line === void 0)</p>

<pre><code>return [0, 0, 0];
</code></pre>

<p>  else</p>

<pre><code>return [line[x-1], line[x], line[x+1]];
</code></pre>

<p>}
```</p>

<p>Et voici le code réécrit pour faire passer ce premier test:</p>

<p>``` javascript app/application.js
function extractNeighborhood(generation, x, y) {
  var cells,</p>

<pre><code>  line1,
  line2,
  line3;
</code></pre>

<p>  if(y > 0)</p>

<pre><code>line1 = extractLine(generation[y-1], x);
</code></pre>

<p>  else</p>

<pre><code>line1 = extractLine(generation[generation.length-1], x);
</code></pre>

<p>  line2 = extractLine(generation[y], x);
  line3 = extractLine(generation[y+1], x);</p>

<p>  cells = line1.concat(line2, line3);</p>

<p>  return cells.map(function(cell) {</p>

<pre><code>return cell === undefined ? 0 : cell;
</code></pre>

<p>  });
}</p>

<p>function extractLine(line, x) {
  return [line[x-1], line[x], line[x+1]];
}
```</p>

<p>Je réactive le second test, lance la suite de test pour confirmer qu'il
échoue, et voici le nouveau code:</p>

<p>``` javascript app/application.js
function extractNeighborhood(generation, x, y) {</p>

<p>  &hellip;</p>

<p>  if(y > 0)</p>

<pre><code>line1 = extractLine(generation[y-1], x);
</code></pre>

<p>  else</p>

<pre><code>line1 = extractLine(generation[generation.length-1], x);
</code></pre>

<p>  line2 = extractLine(generation[y], x);</p>

<p>  if(y === generation.length &ndash; 1)</p>

<pre><code>line3 = extractLine(generation[0], x);
</code></pre>

<p>  else</p>

<pre><code>line3 = extractLine(generation[y+1], x);
</code></pre>

<p>  &hellip;
}
```</p>

<p>Au tour du 3ème test. Pour le faire passer c'est <code>extractLine</code> que je dois
modifier.</p>

<p>``` javascript app/application.js
function extractLine(line, x) {
  if(x === 0)</p>

<pre><code>return [line[line.length-1], line[x], line[x+1]];
</code></pre>

<p>  else</p>

<pre><code>return [line[x-1], line[x], line[x+1]];
</code></pre>

<p>}
```</p>

<p>Et enfin je réactive le 4ème test.</p>

<p>``` javascript app/application.js
function extractLine(line, x) {
  if(x === 0)</p>

<pre><code>return [line[line.length-1], line[x], line[x+1]];
</code></pre>

<p>  else if(x === line.length-1)</p>

<pre><code>return [line[x-1], line[x], line[0]];
</code></pre>

<p>  else</p>

<pre><code>return [line[x-1], line[x], line[x+1]];
</code></pre>

<p>}
```</p>

<p>Puis je réactive les 4 tests restants (ceux des coins) et je vérifie que tout
passe. C'est un bon moment pour lancer le programme et vérifier visuellement
que des objets <em>traversent</em> bien les bords.</p>

<p>J'ai ensuite fait un peu de refactoring:</p>

<p>``` javascript app/application.js
function extractNeighborhood(generation, x, y) {
  var cells = line1(generation, x, y)</p>

<pre><code>          .concat(line2(generation, x, y), line3(generation, x, y));
</code></pre>

<p>  return cells.map(function(cell) {</p>

<pre><code>return cell === undefined ? 0 : cell;
</code></pre>

<p>  });
}</p>

<p>function line1(generation, x, y) {
  if(y > 0)</p>

<pre><code>return extractLine(generation[y-1], x);
</code></pre>

<p>  else</p>

<pre><code>return extractLine(generation[generation.length - 1], x);
</code></pre>

<p>}</p>

<p>function line2(generation, x, y) {
  return extractLine(generation[y], x);
}</p>

<p>function line3(generation, x, y) {
  if(y === generation.length &ndash; 1)</p>

<pre><code>return extractLine(generation[0], x);
</code></pre>

<p>  else</p>

<pre><code>return extractLine(generation[y+1], x);
</code></pre>

<p>}</p>

<p>function extractLine(line, x) {
  var left = x &ndash; 1,</p>

<pre><code>  right = x + 1;
</code></pre>

<p>  if(x === 0)</p>

<pre><code>left = line.length - 1;
</code></pre>

<p>  else if(x === line.length-1)</p>

<pre><code>right = 0;
</code></pre>

<p>  return [line[left], line[x], line[right]];
}
```</p>

<p>J'avoue que je ne sais pas si c'est mieux. Quoiqu'il en soit, vous pouvez
trouver le <a href="https://github.com/lkdjiin/game-of-life-javascript">code complet sur Github</a>.</p>

<p>La prochaine fois je m'attaquerais à la version Ruby/Opal.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Le jeu de la vie en javascript - partie 2]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/10/17/le-jeu-de-la-vie-en-javascript-partie-2/"/>
    <updated>2014-10-17T21:12:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/10/17/le-jeu-de-la-vie-en-javascript-partie-2</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p><a href="http://lkdjiin.github.io/blog/2014/10/16/le-jeu-de-la-vie-en-javascript-partie-1/">Précédement</a> nous avons écrit une fonction pour produire une génération de
cellules au hasard. Nous allons aujourd'hui afficher une telle génération.
Je veux maintenant calculer le prochain état d'une cellule, en fonction de son
voisinage. Pour rappel:</p>

<ul>
<li>Si la somme des 9 cellules du voisinage est 3, le nouvel état est «vivant».</li>
<li>Si la somme des 9 cellules du voisinage est 4, le nouvel état est le même
que l'ancien.</li>
<li>Dans tous les autres cas, le nouvel état est «mort».</li>
</ul>


<!-- more -->


<h2>Calculer le prochain état d'une cellule</h2>

<p>Voici les différents tests qui m'ont conduits à l'écriture de la fonction
<code>nextCellState</code>. Notez bien que, selon les principes du TDD, je ne les ai pas
écrit tous d'un coup, mais bien un par un, en implémentant la fonction
minimale à chaque nouveau test.</p>

<p>``` javascript
describe(&ldquo;nextCellState&rdquo;, function() {</p>

<p>  it(&ldquo;returns an integer&rdquo;, function() {</p>

<pre><code>var cells = [1, 1, 1, 0, 0, 0, 0, 0, 0];
var result = nextCellState(cells);
expect(Number.isInteger(result)).toBe(true);
</code></pre>

<p>  });</p>

<p>  it(&ldquo;returns 1 when it&rsquo;ll be alive&rdquo;, function() {</p>

<pre><code>var cells = [
  [1, 1, 1, 0, 0, 0, 0, 0, 0],
  [0, 1, 1, 0, 0, 1, 0, 0, 0],
  [0, 1, 0, 0, 0, 1, 0, 1, 0]
];
for(var i = 0; i &lt; cells.length; i++) {
  expect(nextCellState(cells[i])).toBe(1);
}
</code></pre>

<p>  });</p>

<p>  it(&ldquo;returns 0 when it&rsquo;ll be dead&rdquo;, function() {</p>

<pre><code>var cells = [
  [1, 1, 1, 1, 1, 1, 1, 1, 1],
  [0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 1, 0, 0, 0, 0, 0, 0, 0]
];
for(var i = 0; i &lt; cells.length; i++) {
  expect(nextCellState(cells[i])).toBe(0);
}
</code></pre>

<p>  });</p>

<p>  it(&ldquo;returns current state as next state&rdquo;, function() {</p>

<pre><code>var cells = [
  [1, 1, 1, 1, 0, 0, 0, 0, 0],
  [0, 1, 0, 0, 1, 1, 1, 0, 0]
];
expect(nextCellState(cells[0])).toBe(0);
expect(nextCellState(cells[1])).toBe(1);
</code></pre>

<p>  });</p>

<p>});
```</p>

<p>Et voici cette fonction.</p>

<p>``` javascript app/application.js
function nextCellState(neighborhood) {
  var result = neighborhood.reduce(function(a, b) {</p>

<pre><code>return a + b
</code></pre>

<p>  }, 0);</p>

<p>  if(result === 3)</p>

<pre><code>return 1;
</code></pre>

<p>  else if(result === 4)</p>

<pre><code>return neighborhood[4];
</code></pre>

<p>  else</p>

<pre><code>return 0;
</code></pre>

<p>}
```</p>

<p>Maintenant il me faut une fonction qui extrait un <em>voisinage</em> à partir d'une
position dans une génération. C'est la partie la plus complexe. Comme toujours,
je commence doucement avec un test très simple et son code d'implémentation.</p>

<p>``` javascript
describe(&ldquo;extractNeighborhood&rdquo;, function() {</p>

<p>  it(&ldquo;returns an array&rdquo;, function() {</p>

<pre><code>var result = extractNeighborhood();
expect(Array.isArray(result)).toBe(true);
</code></pre>

<p>  });</p>

<p>});
```</p>

<p><code>javascript app/application.js
function extractNeighborhood() {
  return [];
}
</code></p>

<p>Je peux commencer à <em>specer</em> les choses sérieuses.</p>

<p>``` javascript
describe(&ldquo;extractNeighborhood&rdquo;, function() {</p>

<p>  beforeEach(function() {</p>

<pre><code>this.generation = [
  [0, 1, 0, 1],
  [1, 0, 1, 0],
  [0, 1, 1, 0]];
</code></pre>

<p>  });</p>

<p>  it(&ldquo;returns an array&rdquo;, function() {</p>

<pre><code>var result = extractNeighborhood(this.generation, 1, 1);
expect(Array.isArray(result)).toBe(true);
</code></pre>

<p>  });</p>

<p>  it(&ldquo;returns the neighborhood of a cell at x, y&rdquo;, function() {</p>

<pre><code>var x = 1,
    y = 1,
    result = extractNeighborhood(this.generation, x, y);

expect(result).toEqual([0, 1, 0, 1, 0, 1, 0, 1, 1]);
</code></pre>

<p>  });</p>

<p>});
```</p>

<p>On note l'utilisation de <code>toEqual</code> pour tester l'égalité de deux tableaux,
<code>toBe()</code> testant l'identité d'après ce que j'ai compris.
Et voici le code qui fait passer tout ça, moche mais pragmatique.</p>

<p>``` javascript app/application.js
function extractNeighborhood(generation, x, y) {
  return [</p>

<pre><code>generation[y-1][x-1], generation[y-1][x], generation[y-1][x+1],
generation[y][x-1], generation[y][x], generation[y][x+1],
generation[y+1][x-1], generation[y+1][x], generation[y+1][x+1] ];
</code></pre>

<p>}
```</p>

<p>C'est au tour des cellules du bord, d'abord en haut.</p>

<p>``` javascript
describe(&ldquo;extractNeighborhood&rdquo;, function() {</p>

<p>  &hellip;</p>

<p>  describe(&ldquo;returns the neighborhood of a border&rsquo;s cell&rdquo;, function() {</p>

<pre><code>it("x=2, y=0", function() {
  var x = 2,
      y = 0,
      result = extractNeighborhood(this.generation, x, y);
  expect(result).toEqual([0, 0, 0, 0, 0, 1, 0, 1, 0]);
});
</code></pre>

<p>  });</p>

<p>});
```</p>

<p>Le code devient de plus en plus moche.</p>

<p>``` javascript app/application.js
function extractNeighborhood(generation, x, y) {
  return firstLine(generation, x, y-1).concat(</p>

<pre><code>[generation[y][x-1], generation[y][x], generation[y][x+1],
generation[y+1][x-1], generation[y+1][x], generation[y+1][x+1] ]);
</code></pre>

<p>}</p>

<p>function firstLine(generation, x, y) {
  if(y &lt; 0)</p>

<pre><code>return [0, 0, 0];
</code></pre>

<p>  else</p>

<pre><code>return [generation[y][x-1], generation[y][x], generation[y][x+1]];
</code></pre>

<p>}
```</p>

<p>Puisqu'il passe les tests, je cherche à l'améliorer un peu.</p>

<p>``` javascript app/application.js
function extractNeighborhood(generation, x, y) {
  return firstLine(generation[y-1], x).concat(</p>

<pre><code>[generation[y][x-1], generation[y][x], generation[y][x+1],
generation[y+1][x-1], generation[y+1][x], generation[y+1][x+1] ]);
</code></pre>

<p>}</p>

<p>function firstLine(line, x) {
  if(line === void 0)</p>

<pre><code>return [0, 0, 0];
</code></pre>

<p>  else</p>

<pre><code>return [line[x-1], line[x], line[x+1]];
</code></pre>

<p>}
```</p>

<p>Cellule du bord en bas, maintenant.</p>

<p>``` javascript
  describe(&ldquo;returns the neighborhood of a border&rsquo;s cell&rdquo;, function() {</p>

<pre><code>it("x=2, y=0", function() {
  ...
});

it("x=2, y=2", function() {
  var x = 2,
      y = 2,
      result = extractNeighborhood(this.generation, x, y);
  expect(result).toEqual([0, 1, 0, 1, 1, 0, 0, 0, 0]);
});
</code></pre>

<p>  });
```</p>

<p>``` javascript app/application.js
function extractNeighborhood(generation, x, y) {
  return extractLine(generation[y-1], x).concat(</p>

<pre><code>[generation[y][x-1], generation[y][x], generation[y][x+1]],
extractLine(generation[y+1], x));
</code></pre>

<p>}</p>

<p>function extractLine(line, x) {
  if(line === void 0)</p>

<pre><code>return [0, 0, 0];
</code></pre>

<p>  else</p>

<pre><code>return [line[x-1], line[x], line[x+1]];
</code></pre>

<p>}
```</p>

<p>Puis refactoring.</p>

<p>``` javascript app/application.js
function extractNeighborhood(generation, x, y) {
  return extractLine(generation[y-1], x).concat(</p>

<pre><code>     extractLine(generation[y], x),
     extractLine(generation[y+1], x));
</code></pre>

<p>}
```</p>

<p>On passe au bord gauche.</p>

<p>``` javascript
  describe(&ldquo;returns the neighborhood of a border&rsquo;s cell&rdquo;, function() {</p>

<pre><code>it("x=2, y=0", function() {
  ...
});

it("x=2, y=2", function() {
  ...
});

it("x=0, y=1", function() {
  var x = 0,
      y = 1,
      result = extractNeighborhood(this.generation, x, y);
  expect(result).toEqual([0, 0, 1, 0, 1, 0, 0, 0, 1]);
});
</code></pre>

<p>  });
```</p>

<p>La réponse de Jasmine à ce test est:</p>

<pre><code>Expected [ undefined, 0, 1, undefined, 1, 0, undefined, 0, 1 ] to equal [ 0, 0, 1, 0, 1, 0, 0, 0, 1 ].
</code></pre>

<p>Si on suit les principes du TDD, il faut écrire le code tout juste suffisant
pour faire passer ce test. Je me contente donc de mapper les <code>undefined</code> en <code>0</code>.</p>

<p>``` javascript app/application.js
function extractNeighborhood(generation, x, y) {
  var cells = extractLine(generation[y-1], x).concat(</p>

<pre><code>          extractLine(generation[y], x),
          extractLine(generation[y+1], x));
</code></pre>

<p>  return cells.map(function(cell) {</p>

<pre><code>return cell === undefined ? 0 : cell;
</code></pre>

<p>  });
}
```</p>

<p>Si j'ajoute un test pour une cellule du bord droit, il passe.</p>

<p>``` javascript</p>

<pre><code>it("x=3, y=1", function() {
  var x = 3,
      y = 1,
      result = extractNeighborhood(this.generation, x, y);
  expect(result).toEqual([0, 1, 0, 1, 0, 0, 1, 0, 0]);
});
</code></pre>

<p>```</p>

<p>Très bien, il faut maintenant s'occuper des cellules de coins. Je me rends
compte que les quatres tests suivants passent sans que je n'ai rien à modifier
dans le code.</p>

<p>``` javascript
  describe(&ldquo;returns the neighborhood of a corner&rsquo;s cell&rdquo;, function() {</p>

<pre><code>it("x=0, y=0", function() {
  var x = 0,
      y = 0,
      result = extractNeighborhood(this.generation, x, y);
  expect(result).toEqual([0, 0, 0, 0, 0, 1, 0, 1, 0]);
});

it("x=3, y=0", function() {
  var x = 3,
      y = 0,
      result = extractNeighborhood(this.generation, x, y);
  expect(result).toEqual([0, 0, 0, 0, 1, 0, 1, 0, 0]);
});

it("x=0, y=2", function() {
  var x = 0,
      y = 2,
      result = extractNeighborhood(this.generation, x, y);
  expect(result).toEqual([0, 1, 0, 0, 0, 1, 0, 0, 0]);
});

it("x=3, y=2", function() {
  var x = 3,
      y = 2,
      result = extractNeighborhood(this.generation, x, y);
  expect(result).toEqual([1, 0, 0, 1, 0, 0, 0, 0, 0]);
});
</code></pre>

<p>  });
```</p>

<p>Je suis donc prêt à tout mettre ensemble. Ce sera pour le prochain article car
celui-ci est déjà bien long.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Le jeu de la vie en javascript - partie 1]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/10/16/le-jeu-de-la-vie-en-javascript-partie-1/"/>
    <updated>2014-10-16T22:27:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/10/16/le-jeu-de-la-vie-en-javascript-partie-1</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>C'est parti pour le jeu de la vie version Javascript. Dans ce premier article
nous allons créer une génération de cellules au hasard et l'afficher.</p>

<p><em>J'avais annoncé dans <a href="blog/2014/10/08/le-jeu-de-la-vie-dans-sept-langages-differents/">l'article précédent</a> que je commencerais par la
version Ruby/Opal. Je l'ai écrite mais je n'en suis pas satisfait. Les
performances sont très pauvres et j'ai écrit plus de code que nécessaire.
Je prendrais donc le temps de la nettoyer un peu avant de la publier.</em></p>

<!-- more -->


<p>Pour les tests, j'utiliserais <a href="http://jasmine.github.io/">Jasmine</a> et la structure du projet sera la
suivante:</p>

<pre><code>$ tree
.
├── app
│   └── application.js
├── index.html
├── jasmine
│   └── lib
│       └── jasmine-2.0.3
│           ├── boot.js
│           ├── console.js
│           ├── jasmine.css
│           ├── jasmine_favicon.png
│           ├── jasmine-html.js
│           └── jasmine.js
├── spec
│   └── test.js
└── test.html
</code></pre>

<p>Dans le fichier <code>test.html</code> on charge les dépendances de Jasmine, puis notre
application (<code>app/application.js</code>) et enfin nos tests (<code>spec/test.js</code>).</p>

<p>``` html test.html
&lt;!DOCTYPE html>
<html>
  <head></p>

<pre><code>&lt;meta charset="utf-8" /&gt;
&lt;title&gt;Test Game of Life&lt;/title&gt;
&lt;link rel="shortcut icon" type="image/png" href="jasmine/lib/jasmine-2.0.3/jasmine_favicon.png"&gt;
&lt;link rel="stylesheet" type="text/css" href="jasmine/lib/jasmine-2.0.3/jasmine.css"&gt;

&lt;script type="text/javascript" src="jasmine/lib/jasmine-2.0.3/jasmine.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="jasmine/lib/jasmine-2.0.3/jasmine-html.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="jasmine/lib/jasmine-2.0.3/boot.js"&gt;&lt;/script&gt;
</code></pre>

<p>  </head>
  <body></p>

<pre><code>&lt;script type="text/javascript" src="app/application.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="spec/test.js"&gt;&lt;/script&gt;
</code></pre>

<p>  </body>
</html>
```</p>

<h2>Créer une génération de cellules au hasard</h2>

<p>Nous allons écrire la fonction <code>createGeneration</code> qui
devra <em>fabriquer</em> un ensemble de cellules, mortes (<code>0</code>) ou vivantes (<code>1</code>), au
hasard. Mon premier test avec Jasmine est de m'assurer que cette fonction
renvoie un tableau (<code>Array</code>).</p>

<p>``` javascript spec/test.js
describe(&ldquo;createGeneration&rdquo;, function() {</p>

<p>  it(&ldquo;returns an array&rdquo;, function() {</p>

<pre><code>var result = createGeneration();
expect(Array.isArray(result)).toBe(true);
</code></pre>

<p>  });</p>

<p>});
```</p>

<p>Lorsqu'on lance <code>test.html</code> Jasmine nous dit que <code>createGeneration</code> n'existe
pas. Le code javascript permettant de faire passer ce test consiste donc à
renvoyer un tableau vide.</p>

<p><code>javascript app/application.js
function createGeneration(x, y) {
  return [];
}
</code></p>

<p>Maintenant il nous faut un tableau à 2 dimensions:</p>

<p>``` javascript spec/test.js
describe(&ldquo;createGeneration&rdquo;, function() {</p>

<p>  &hellip;</p>

<p>  it(&ldquo;creates a 2D array&rdquo;, function() {</p>

<pre><code>var result = createGeneration(3, 5);
expect(result.length).toBe(5);
expect(result[0].length).toBe(3);
</code></pre>

<p>  });</p>

<p>});
```</p>

<p>La fonction suivante est suffisante pour faire passer le test.</p>

<p>``` javascript app/application.js
function createGeneration(x, y) {
  var generation = new Array(y);</p>

<p>  for(var i = 0; i &lt; y; i++) {</p>

<pre><code>generation[i] = new Array(x);
</code></pre>

<p>  }
  return generation;
}
```</p>

<p>Et maintenant on rempli notre tableau 2D avec des <code>1</code> ou des <code>0</code>. D'abord un
test pour vérifier que chaque cellule du tableau contient <code>1</code> ou <code>0</code>.</p>

<p>``` javascript spec/test.js
describe(&ldquo;createGeneration&rdquo;, function() {</p>

<p>  &hellip;</p>

<p>  it(&ldquo;fills each room with 1 or 0&rdquo;, function() {</p>

<pre><code>var generation = createGeneration(2, 3);
for(var y = 0; y &lt; 3; y++) {
  for(var x = 0; x &lt; 2; x++) {
    var cell = generation[y][x];
    var result = cell === 0 || cell === 1;
    expect(result).toBe(true);
  }
}
</code></pre>

<p>  });</p>

<p>});
```</p>

<p>Puis l'implémentation.</p>

<p>``` javascript app/application.js
function createGeneration(x, y) {
  var generation = new Array(y);</p>

<p>  for(var i = 0; i &lt; y; i++) {</p>

<pre><code>generation[i] = [];
for(var j = 0; j &lt; x; j++) {
  generation[i][j] = Math.floor(Math.random() * 2);
}
</code></pre>

<p>  }
  return generation;
}
```</p>

<p>Voilà, cette première partie du jeu de la vie en Javascript était simple et
rapide à coder. Je vais maintenant mettre les tests de coté pour me
concentrer sur l'affichage d'une génération.</p>

<h2>Afficher une génération</h2>

<p>Voyons pour commencer le contenu du fichier <code>index.html</code>.</p>

<p>``` html index.html
&lt;!DOCTYPE html>
<html>
  <head></p>

<pre><code>&lt;meta charset="utf-8" /&gt;
&lt;title&gt;Game of Life&lt;/title&gt;
</code></pre>

<p>  </head>
  <body></p>

<pre><code>&lt;canvas width="100" height="100" id="canvas"&gt;&lt;/canvas&gt;
&lt;script src="app/application.js"&gt;&lt;/script&gt;
</code></pre>

<p>  </body>
</html>
```</p>

<p>Nous référençons bien entendu notre <code>application.js</code> et nous créons un
<code>canvas</code> de (petite) dimension 100x100. C'est dans ce <code>canvas</code> que nous allons
<em>dessiner</em> nos cellules.</p>

<p>Sans plus attendre, voici le contenu de <code>application.js</code>.</p>

<p>``` javascript app/application.js
function createGeneration(width, height) {
  var generation = new Array(height);</p>

<p>  for(var y = 0; y &lt; height; y++) {</p>

<pre><code>generation[y] = [];
for(var x = 0; x &lt; width; x++) {
  generation[y][x] = Math.floor(Math.random() * 2);
}
</code></pre>

<p>  }
  return generation;
}</p>

<p>function draw(context2d, generation) {
  var height = generation.length;
  var width = generation[0].length;</p>

<p>  clearBackground(context2d, width, height);
  drawCells(context2d, generation, width, height);
}</p>

<p>function clearBackground(context2d, width, height) {
  context2d.fillStyle = &lsquo;black&rsquo;;
  context2d.fillRect(0, 0, width, height);
}</p>

<p>function drawCells(context2d, generation, width, height) {
  context2d.fillStyle = &lsquo;white&rsquo;;
  for(var y = 0; y &lt; height; y++) {</p>

<pre><code>for(var x = 0; x &lt; width; x++) {
  if(generation[x][y] === 1) {
    context2d.fillRect(x, y, 1, 1);
  }
}
</code></pre>

<p>  }
}</p>

<p>(function() {
  var generation = createGeneration(100, 100);
  var c = document.getElementById(&lsquo;canvas&rsquo;);
  var ctx = c.getContext(&lsquo;2d&rsquo;);</p>

<p>  draw(ctx, generation);
})()
```</p>

<p>Ces quelques petites fonctions sont bien suffisantes pour afficher un
ensemble de cellules.</p>

<p>Dans le prochain article nous calculerons l'état des générations suivantes.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p></p>
]]></content>
  </entry>
  
</feed>
