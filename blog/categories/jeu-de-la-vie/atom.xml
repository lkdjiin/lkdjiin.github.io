<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : jeu de la vie | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/jeu-de-la-vie/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2014-12-23T15:17:12+01:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Le jeu de la vie en Julia - partie 1]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/12/23/le-jeu-de-la-vie-en-julia-partie-1/"/>
    <updated>2014-12-23T14:50:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/12/23/le-jeu-de-la-vie-en-julia-partie-1</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Voici la première partie du jeu de la vie en Julia.
Pour installer la dernière version stable (0.3.3), rendez-vous sur le
<a href="https://github.com/JuliaLang/julia">Github de Julia</a>.</p>

<p>Julia est un langage jeune et en pleine effervescence et plusieurs frameworks
de tests sont en cours de création. J'ai notamment remarqué:</p>

<ul>
<li><a href="https://github.com/JuliaLang/FactCheck.jl">FactCheck.jl</a></li>
<li><a href="https://github.com/arypurnomoz/JulieTest.jl">JulieTest.jl</a></li>
<li><a href="https://github.com/Veraticus/testfast.jl">testfast.jl</a></li>
</ul>


<h2>Création d'une génération</h2>

<p>Mais pour ce que je compte faire ici, Julia possède une macro très simple,
<a href="http://julia.readthedocs.org/en/latest/stdlib/test/">@test</a>. Même si <code>@test</code>
est très minimal, ça sera suffisant pour ce programme. Voici donc les
tests de la fonction <code>create</code> du module <code>Generation</code>:</p>

<p>``` julia test.jl
include(&ldquo;generation.jl&rdquo;)</p>

<p>using Base.Test</p>

<p>HEIGHT = 3
WIDTH = 4</p>

<p>created_generation = Generation.create(HEIGHT, WIDTH)
@test typeof(created_generation) == Array{Int,2}
@test size(created_generation) == (HEIGHT, WIDTH)
for i in 1:length(created_generation)</p>

<pre><code>@test created_generation[i] in 0:1
</code></pre>

<p>end
```</p>

<!-- more -->


<p>Et voici les explications ligne par ligne. D'abord je rends disponible le code du futur fichier <code>generation.jl</code>:</p>

<pre><code>include("generation.jl")
</code></pre>

<p>Ensuite je demande à utiliser le module <code>Test</code>, pour avoir accès à la macro <code>@test</code>:</p>

<pre><code>using Base.Test
</code></pre>

<p>Définition des <em>constantes</em> pour la hauteur et la largeur de la génération:</p>

<pre><code>HEIGHT = 3
WIDTH = 4
</code></pre>

<p>Création d'une génération, c'est cette fonction qu'il m'intéresse de tester:</p>

<pre><code>created_generation = Generation.create(HEIGHT, WIDTH)
</code></pre>

<p>Je m'assure que <code>create</code> renvoie un tableau d'entiers à 2 dimensions:</p>

<pre><code>@test typeof(created_generation) == Array{Int,2}
</code></pre>

<p>Je m'assure que le tableau renvoyé par <code>create</code> possède bien les dimensions
voulues:</p>

<pre><code>@test size(created_generation) == (HEIGHT, WIDTH)
</code></pre>

<p>Je m'assure enfin que chaque cellule du tableau est un 1 ou un 0:</p>

<pre><code>for i in 1:length(created_generation)
    @test created_generation[i] in 0:1
end
</code></pre>

<p>Pour lancer ces tests : <code>julia test.jl</code>.</p>

<p>Voici maintenant la fonction <code>create</code> qui fera passer les tests ci-dessus:</p>

<p>``` julia generation.jl
module Generation</p>

<p>create(height, width) = rand(0:1, height, width)</p>

<p>end
```</p>

<p>Notez l'efficacité de la fonction <code>rand</code>. Sans argument, elle produit
classiquement un nombre aléatoire entre 0 et 1:</p>

<pre><code>julia&gt; rand()
0.7084513868758786
</code></pre>

<p>Avec un <em>range</em>, elle sort un nombre compris dans ce <em>range</em>:</p>

<pre><code>julia&gt; rand(0:1)
1
</code></pre>

<p>Si j'ajoute en plus une dimension, elle renvoie un tableau:</p>

<pre><code>julia&gt; rand(0:1, 3)
3-element Array{Int32,1}:
 0
 0
 1
</code></pre>

<p>Avec deux dimensions:</p>

<pre><code>julia&gt; rand(0:1, 3, 4)
3x4 Array{Int32,2}:
 0  0  0  1
 1  1  1  1
 1  1  0  0
</code></pre>

<p>Et même pour le fun, avec 3 dimensions:</p>

<pre><code>julia&gt; rand(0:1, 3, 4, 3)
3x4x3 Array{Int32,3}:
[:, :, 1] =
 1  1  1  1
 0  1  0  0
 0  0  1  0

[:, :, 2] =
 1  1  0  1
 0  0  0  0
 1  1  1  1

[:, :, 3] =
 0  0  0  1
 1  0  0  1
 1  1  0  0
</code></pre>

<p>Vous pouvez aussi tester avec encore plus de dimensions, ça fonctionnera.</p>

<h2>Affichage d'une génération</h2>

<p>Bon, Julia est jeune, je l'ai déjà dit. Je n'ai rien trouvé de simple pour faire
un peu de graphisme, donc je vais faire les sorties dans la console.</p>

<p>``` julia display.jl
module Display</p>

<p>function draw(generation)</p>

<pre><code>run(`clear`)
println(replace(repr(generation)[2:end-1], " ", ""))
</code></pre>

<p>end</p>

<p>end
```</p>

<p>La première ligne de la fonction, <code>run</code>, appelle la commande système
<code>clear</code>, qui efface l'écran du terminal.</p>

<p>La seconde demande à être décomposée. Soit la génération suivante:</p>

<pre><code>julia&gt; generation = rand(0:1, 2, 3)
2x3 Array{Int32,2}:
 0  0  1
 0  1  0
</code></pre>

<p><code>repr</code> nous donne la représentation en chaîne de caractères:</p>

<pre><code>julia&gt; repr(generation)
"[0 0 1\n 0 1 0]"
</code></pre>

<p>On peut accéder à une chaîne comme un tableau, ici je conserve ce qui se trouve
entre le second et l'avant-dernier élément:</p>

<pre><code>julia&gt; repr(generation)[2:end-1]
"0 0 1\n 0 1 0"
</code></pre>

<p><strong>Je m'aperçois que j'ai oublié de parler d'un truc important: l'indexation les
tableaux en Julia commence à 1.</strong></p>

<p>Pour finir je supprime les espaces avec <code>replace</code>:</p>

<pre><code>julia&gt; replace(repr(generation)[2:end-1], " ", "")
"001\n010"
</code></pre>

<p>Et quand on combine tout ça dans un fichier <code>main.jl</code>, voici le résultat:</p>

<p>``` julia main.jl
include(&ldquo;generation.jl&rdquo;)
include(&ldquo;display.jl&rdquo;)</p>

<p>height = 20
width = 80</p>

<p>generation = Generation.create(height, width)
Display.draw(generation)
```</p>

<pre><code>$ julia main.jl
00010111100111000011100111001010001101000010110111000111101101110101000011100000
00001101010010101111001010110101100101001000001011010001010110010100011011011011
01001000011101000001101110010010110000100101011110001001110110101111010001001001
11111110011101100001111010110101110000101011011000000011110000010011011100111111
11100100000011100001111111101010011000110011010101011100011110101110111111001111
11110011000101101010110010110011101101000111000111111111001110010100011101010101
10011101010110011110100101110110111101111101100110011011011001011100000110110000
01001110010101111101110001000110110100001101100100000010011101111000001010111100
00011001011000000000000111010000100001100000001110101110000010100010101111011111
00101011011010000001111001001011111101101110111000101100000100001101110110101100
10000010100100011111111101010101001010001010111111001111100001010001011010000001
11000011000001001101011001111101111111111111011111100101100101010000101111101001
11010111011111101001111110100000001011100100010100100100000010001011000010101110
10011000100111111100011010010100110001101110001001100100100000010100111001111011
11110001001011000101100001001110010100010011100101001101010111111100011100111101
11001111000101101111001110010010101001110010101100010100101011101011000101000000
01001111111101010010001100010011000001110110001110110101010101010000111010111000
01101001011011011001110010010010000101000111111111010101001011101011111001101010
00101111001100011111110110000110011100001011011100101101011001111111111100011110
01110001110010001001011100100000100000010110001100011011101001010011111011110100
</code></pre>

<p>Pour rendre la sortie écran un peu plus présentable, <em>effaçons</em> les 0, en les
remplaçant par des espaces, et remplaçons les 1 par des @:</p>

<p>``` julia display.jl
module Display</p>

<p>function draw(generation)</p>

<pre><code>run(`clear`)
output = replace(repr(generation)[2:end-1], " ", "")
output = replace(output, "1", "@")
output = replace(output, "0", " ")

println(output)
</code></pre>

<p>end</p>

<p>end
```</p>

<p>Pour terminer, voici une petite boucle pour afficher une dizaine de générations:</p>

<p>``` julia main.jl
include(&ldquo;generation.jl&rdquo;)
include(&ldquo;display.jl&rdquo;)</p>

<p>height = 20
width = 80</p>

<p>for _ in 1:10</p>

<pre><code>generation = Generation.create(height, width)
sleep(0.8)
Display.draw(generation)
</code></pre>

<p>end
```</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Le jeu de la vie en logo - partie 3]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/12/20/le-jeu-de-la-vie-en-logo-partie-3/"/>
    <updated>2014-12-20T17:46:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/12/20/le-jeu-de-la-vie-en-logo-partie-3</id>
    <content type="html"><![CDATA[<p>Suite et fin du jeu de la vie en Logo.</p>

<p>Je ne montrerais pas d'extraits de code, pour la simple raison que
je n'en peux plus du langage Logo.  Ceci dit, pour les curieux, le code complet
se trouve sur <a href="https://github.com/lkdjiin/game-of-life-logo">Github</a>.</p>

<p> Je ne sais pas ce qui m'a pris de
ressortir Logo du placard. Les madeleines de Proust sont faites pour rester à
l'état de souvenirs. Écrire le jeu de la vie en Logo n'a jamais été fun. À
aucun moment.</p>

<!-- more -->


<p>Bref, j'oublie définitivement Logo. La prochaine version sera en Julia, ça
promet d'être bien plus intéressant.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Le jeu de la vie en logo - partie 2]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/12/17/le-jeu-de-la-vie-en-logo-partie-2/"/>
    <updated>2014-12-17T16:35:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/12/17/le-jeu-de-la-vie-en-logo-partie-2</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Cette fois, on affiche la génération de cellules crée la dernière fois.
J'ai déjà eu l'occasion de dire que Logo était spécial, on va voir avec
son système graphique que c'est bien le cas. Je ne vais pas parler de la
métaphore de la <em>tortue</em>, vous trouverez sûrement des ressources là-dessus.
Je voudrais plutôt parler du système de coordonnée. Alors que dans la plupart des
langages (tous ?) les systèmes graphiques proposent de placer le point d'origine (0, 0) en haut à
gauche, Logo le place au centre. En général, l'axe des y croit vers le bas,
en Logo il croit vers le haut.</p>

<p>Selon le manuel d'UCBLogo, voici à quoi s'attendre:</p>

<pre><code>(-100, 100)            (100, 100)

              (0, 0)

(-100, -100)           (100, -100)
</code></pre>

<!-- more -->


<p>Mais en fait, non. J'ai plutôt ça sur la machine où j'utilise Logo:</p>

<pre><code>(-250, 250)            (250, 250)

              (0, 0)

(-250, -250)           (250, -250)
</code></pre>

<p>Quoiqu'il en soit, voici comment ça marche.</p>

<p>``` raw drawing.lg
hideturtle</p>

<p>to draw.generation :generation :size
for [y 1 :size] [p.draw.line :y]
end</p>

<p>to p.draw.line :y
for [x 1 :size] [if (cell.alive? :generation :x :y) [p.draw.cell :x :y ] ]
end</p>

<p>to p.draw.cell :x :y
penup
setxy :x :y
setheading 90
pendown
forward 1
end
```</p>

<p><code>hideturtle</code> cache la tortue, comme son nom l'indique. Parce que, en plus
d'être moche, ça ralenti le dessin, qui n'est déjà pas très rapide.</p>

<p>La procédure <code>draw.generation</code> itère sur chaque ligne de <code>generation</code> et
appelle la procédure <em>privée</em> <code>p.draw.line</code>.</p>

<p><code>p.draw.line</code> itère sur chaque cellule de la ligne. On détermine, avec
<code>cell.alive?</code>, si la cellule est vivante. Si c'est le cas, on appelle
<code>p.draw.cell</code>.</p>

<p><code>p.draw.cell</code> affiche un pixel en (x, y).</p>

<p>Dans le fichier <code>generation.lg</code>, j'ajoute la procédure <code>cell.alive?</code>.</p>

<p><code>raw generation.lg
to cell.alive? :generation :x :y
localmake "line item :y :generation
ifelse (item :x :line) = 1 [output "true] [output "false]
end
</code></p>

<p>Puis on assemble le tout dans un fichier <code>application.lg</code>.</p>

<p>``` raw application.lg
load &ldquo;generation.lg
load "drawing.lg</p>

<p>make &ldquo;size 100</p>

<p>draw.generation create.generation :size :size :size
```</p>

<p>Et voici le résultat:</p>

<pre><code>$ tree
.
├── application.lg
├── drawing.lg
├── generation.lg
└── test.generation.lg

$ logo application.lg
</code></pre>

<p><img src="/images/game-of-life-logo.png"></p>

<p>Mouais, un peu moche, non ? J'avoue que je commence déjà à en avoir marre de
Logo.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Le jeu de la vie en logo - partie 1]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/12/16/le-jeu-de-la-vie-en-logo-partie-1/"/>
    <updated>2014-12-16T18:01:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/12/16/le-jeu-de-la-vie-en-logo-partie-1</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>C'est parti pour la version Logo du jeu de la vie. J'utiliserais
<a href="http://www.cs.berkeley.edu/~bh/logo.html">ucblogo</a> en version 5.5, qui est celle qu'on trouve dans les paquets Debian.
Sur leur site vous trouverez la version 6, si vous souhaitez la compiler.</p>

<pre><code>$ logo
Welcome to Berkeley Logo version 5.5
</code></pre>

<h2>Introduction</h2>

<p>Attention ! Le monde de Logo est autre. Je n'ai pas d'autres formules qui me
viennent à l'esprit.  Si vous utilisez Vim, j'ai écrit un fichier de
<a href="https://github.com/lkdjiin/logo.vim">coloration syntaxique pour Logo</a>,
minimal, mais toujours utile pour ne pas se sentir coincé dans les années 80.
Et comme il n'existe pas de frameworks de test (ou alors ils sont bien cachés),
j'en ai écrit un rudimentaire : <a href="https://github.com/lkdjiin/logo-unit">Logo unit test</a>.</p>

<p>Bref, vous aurez compris que l'éco-système Logo open source est assez pauvre,
voir inexistant.  Je crois qu'il n'y a même pas de tag <code>logo</code> sur
stackoverflow.</p>

<!-- more -->


<h2>Création d'une génération</h2>

<p>Créons un fichier pour les tests, et un fichier pour l'implémentation.</p>

<pre><code>$ tree
.
├── generation.lg
└── test.generation.lg
</code></pre>

<p>En avant pour le premier test, je veux m'assurer que la procédure
<code>create.generation</code> renvoie une liste.</p>

<p>``` raw test.generation.lg
load &ldquo;generation.lg</p>

<p>to t.create.generation.returns.a.list
assert.list create.generation
end
```</p>

<h3>Premières remarques sur Logo</h3>

<p>Tout d'abord, les points n'ont rien à voir avec des appels de
méthode/fonction/procédure.  C'est juste une manière de nommer les choses. En
Ruby on aurait <code>assert_list</code>, en Java <code>assertList</code>, en Racket <code>assert-list</code>, en
Logo c'est plutôt <code>assert.list</code>.</p>

<p>Ensuite, la première ligne <code>load "generation.lg</code>, qui charge le fichier
<code>generation.lg</code>, ne contient pas de faute de frappe ! Il y a bien un seul
guillement double (<code>"</code>). C'est la façon de dire que <code>generation.lg</code> doit être
pris dans son sens littéral, pas en tant que variable ou procédure, mais bien en
tant que nom.</p>

<h3>Lancer les tests</h3>

<p>On lance les tests en chargeant la procédure <code>tt</code>. Logo nous dit <em>je ne sais
pas comment faire pour create.generation</em>. Normal puisque cette procédure
n'existe pas encore.</p>

<pre><code>$ logo
Welcome to Berkeley Logo version 5.5
? tt "test.generation.lg
I don't know how  to create.generation  in t.create.generation.returns.a.list
[assert.list create.generation]
</code></pre>

<h3>Notre première procédure</h3>

<p>Il suffit de renvoyer une liste vide pour faire passer le test. Notez que
<code>output</code> est l'équivalent du plus commun <code>return</code>.</p>

<p><code>raw generation.lg
to create.generation
output []
end
</code></p>

<pre><code>? tt "test.generation.lg
.

1 tests. 0 fail.
</code></pre>

<h3>Une liste à plusieurs dimensions</h3>

<p>Notre liste devra avoir une largeur (x) et une hauteur (y), commençons par
tester la hauteur.</p>

<p>``` raw test.generation.lg
load &ldquo;generation.lg</p>

<p>to t.create.generation.returns.a.list
assert.list create.generation 3
end</p>

<p>to t.create.generation.have.a.height
assert.equal 3 count create.generation 3
end
```</p>

<p>Voici le code permettant de faire passer nos nouveaux tests.</p>

<p><code>raw generation.lg
to create.generation :height
output cascade :height [lput # ?] []
end
</code></p>

<p><code>cascade</code> prend un nombre d'itération, un template et une valeur de départ.
<code>lput</code> (pour <em>last put</em>) ajoute une valeur à la fin d'une liste. <code>#</code> dans le
template est remplacé par l'itération.</p>

<p>Ensuite, nouveaux tests pour s'assurer qu'on a aussi une largeur.</p>

<p>``` raw test.generation.lg
load &ldquo;generation.lg</p>

<p>to t.create.generation.returns.a.list
assert.list create.generation 4 3
end</p>

<p>to t.create.generation.have.a.height
assert.equal 3 count create.generation 4 3
end</p>

<p>to t.create.generation.have.a.width
assert.equal 4 count first create.generation 4 3
end
```</p>

<p>On implémente notre liste à 2 dimensions.</p>

<p>``` raw generation.lg
to create.generation :width :height
output cascade :height [lput (p.create.line :width) ?] []
end</p>

<p>to p.create.line :width
output cascade :width [lput 0 ?] []
end
```</p>

<p>Le <code>p.</code> en tête d'un nom de procédure est une convention que j'ai utilié pour
signifier que la procédure est privée.</p>

<p>Les tests passent.</p>

<pre><code>? tt "test.generation.lg
...

3 tests. 0 fail.
</code></pre>

<p>On peut regarder à quoi ressemble la sortie de notre procédure.</p>

<pre><code>? print create.generation 4 3
[0 0 0 0] [0 0 0 0] [0 0 0 0]
</code></pre>

<h3>Un peu de hasard</h3>

<p>Les cellules du jeu de la vie sont représentées soit par un 0 (cellule
morte), soit par un 1 (cellule vivante). Je teste que <code>create.generation</code>
produit bien une suite de 0 et de 1.</p>

<p><code>raw test.generation.lg
to t.create.generation.produces.0s.or.1s
rerandom
localmake "result create.generation 3 2
assert.equal :result [[1 0 1] [1 1 1]]
end
</code></p>

<p><code>rerandom</code> place le générateur de nombre aléatoire dans un état reproductible,
pour pouvoir tester facilement. <code>localmake</code> déclare une variable locale, ici
<code>result</code> qui va contenir la sortie de <code>create.generation 3 2</code>.</p>

<p>Et j'implémente avec la procédure <code>random</code> qui renvoie un nombre aléatoire.</p>

<p><code>raw generation.lg
to p.create.line :width
output cascade :width [lput (random 2) ?] []
end
</code></p>

<p>Et voilà, les tests passent.</p>

<pre><code>? tt "test.generation.lg
....

4 tests. 0 fail.
? print create.generation 9 3
[0 0 1 0 1 1 0 0 0] [1 1 1 1 0 0 0 1 1] [1 0 1 0 1 1 1 1 0]
</code></pre>

<h2>La portée des variables en Logo</h2>

<p>Le code précédent fonctionne très bien, par contre on peut faire un refactoring
intéressant qui va me permettre de parler d'un phénomène étrange en Logo.</p>

<p>``` raw generation.lg
to create.generation :width :height
output cascade :height [lput p.create.line ?] []
end</p>

<p>to p.create.line
output cascade :width [lput (random 2) ?] []
end
```</p>

<p>Vous remarquerez que j'ai enlevé le paramêtre <code>width</code> de la procédure
<code>p.create.line</code> et que ce <code>width</code> n'est plus passé par <code>create.generation</code>.
Pourtant le code continue de fonctionner comme un charme.</p>

<p>C'est que Logo a une notion toute particulière de la <em>localité</em> des variables.
Une variable locale à une procédure est connue dans cette même procédure
<strong>et aussi</strong> dans les sous-procédures appelées par cette même procédure.
Autrement dit, <code>p.create.line</code> connait les variables <code>width</code> et <code>height</code>
puisqu'elle est appelée par <code>create.generation</code>.</p>

<p>Ce n'est pas le seul langage à fonctionner comme ça (les premiers Lisp et
Perl, il me semble). Par contre je me demande toujours si c'est génial, ou
irresponsable.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Le jeu de la vie en racket - partie 3]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/11/09/le-jeu-de-la-vie-en-racket-partie-3/"/>
    <updated>2014-11-09T15:01:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/11/09/le-jeu-de-la-vie-en-racket-partie-3</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>C'est la troisième et dernière partie du jeu de la vie en Racket.</p>

<p><img src="/images/screenshot-game-of-life-racket.png"></p>

<!-- more -->


<h2>Trouver le prochain état d'une cellule</h2>

<p>Vous avez l'habitude maintenant, je commence par un test très simple.</p>

<p><code>racket game-of-life-test.rkt
(check-equal? (next-cell-state '(1 1 1 0 0 0 0 0 0)) 1)
</code></p>

<p>Et une implémentation minimale.</p>

<p>``` racket generation.rkt</p>

<h1>lang racket</h1>

<p>&hellip;</p>

<p>(define (next-cell-state neighborhood)
  1)</p>

<p>(provide create-generation</p>

<pre><code>     next-cell-state)
</code></pre>

<p>```</p>

<p>Puis je teste d'autres cas.</p>

<p>``` racket game-of-life-test.rkt
(check-equal? (next-cell-state &lsquo;(1 1 1 0 0 0 0 0 0)) 1)
(check-equal? (next-cell-state &rsquo;(1 0 0 1 0 0 1 0 0)) 1)</p>

<p>(check-equal? (next-cell-state &lsquo;(1 0 0 1 1 0 1 0 0)) 1)
(check-equal? (next-cell-state &rsquo;(1 0 0 1 0 0 1 0 1)) 0)
```</p>

<p>La fonction <code>for/sum</code> réduit une liste à la somme de ses éléments.</p>

<p>``` racket
(define (next-cell-state neighborhood)
  (define sum (for/sum ([i neighborhood]) i))
  (if (= 3 sum)</p>

<pre><code>1
(list-ref neighborhood 4)))
</code></pre>

<p>```</p>

<p>Je teste les derniers cas.</p>

<p>``` racket game-of-life-test.rkt
(check-equal? (next-cell-state &lsquo;(1 1 1 0 0 0 0 0 0)) 1)
(check-equal? (next-cell-state &rsquo;(1 0 0 1 0 0 1 0 0)) 1)</p>

<p>(check-equal? (next-cell-state &lsquo;(1 0 0 1 1 0 1 0 0)) 1)
(check-equal? (next-cell-state &rsquo;(1 0 0 1 0 0 1 0 1)) 0)</p>

<p>(check-equal? (next-cell-state &lsquo;(1 1 1 1 1 1 1 1 1)) 0)
(check-equal? (next-cell-state &rsquo;(0 0 0 0 0 0 0 0 0)) 0)
```</p>

<p>Comme il y a maintenant trois cas, j'utilise <code>cond</code> au lieu de <code>if</code>.</p>

<p>``` racket
(define (next-cell-state neighborhood)
  (define sum (for/sum ([i neighborhood]) i))
  (cond [(= 3 sum) 1]</p>

<pre><code>    [(= 4 sum) (list-ref neighborhood 4)]
    [else 0]))
</code></pre>

<p>```</p>

<p>On pourrait aussi utiliser <code>match</code> plutôt que <code>cond</code>:</p>

<p>``` racket
(define (next-cell-state neighborhood)
  (match (for/sum ([i neighborhood]) i)</p>

<pre><code>     [3 1]
     [4 (list-ref neighborhood 4)]
     [_ 0]))
</code></pre>

<p>```</p>

<p>Je n'ai aucune idée de laquelle est la plus performante, même si je peux
imaginer à priori que dans ce cas là c'est <code>cond</code>.</p>

<h2>test-case</h2>

<p>Je pense qu'il est temps de regrouper les tests en <code>test-case</code>. Rackunit, le
framework de test de Racket est assez évolutif.</p>

<p>``` racket game-of-life-test.rkt</p>

<h1>lang racket</h1>

<p>(require rackunit</p>

<pre><code>     "generation.rkt")
</code></pre>

<p>(test-case &ldquo;create-generation&rdquo;
  (check-pred list? (create-generation 3 4)</p>

<pre><code>        "It returns a list")
</code></pre>

<p>  (check-equal? (length (create-generation 3 4)) 4</p>

<pre><code>          "It builds a list with the right height")
</code></pre>

<p>  (check-equal? (length (first (create-generation 3 4))) 3</p>

<pre><code>          "It builds a list with the right width")
</code></pre>

<p>  (let ([cell (first (first (create-generation 3 4)))])
  (check-true (or (= cell 0) (= cell 1))</p>

<pre><code>          "It populates generation with 0s or 1s"))
</code></pre>

<p>  ((λ ()
   (random-seed 1)
   (check-equal? (create-generation 2 3) &lsquo;((1 1) (0 1) (1 1))</p>

<pre><code>             "It populates generation uniformly"))))
</code></pre>

<p>(test-case &ldquo;next-cell-state&rdquo;
  (check-equal? (next-cell-state &lsquo;(1 1 1 0 0 0 0 0 0)) 1)
  (check-equal? (next-cell-state &rsquo;(1 0 0 1 0 0 1 0 0)) 1)</p>

<p>  (check-equal? (next-cell-state &lsquo;(1 0 0 1 1 0 1 0 0)) 1)
  (check-equal? (next-cell-state &rsquo;(1 0 0 1 0 0 1 0 1)) 0)</p>

<p>  (check-equal? (next-cell-state &lsquo;(1 1 1 1 1 1 1 1 1)) 0)
  (check-equal? (next-cell-state &rsquo;(0 0 0 0 0 0 0 0 0)) 0))
```</p>

<h2>Extraire un voisinage de cellule</h2>

<p>Comme toujours je commence par un test simple. On peut noter les arguments
nommés de Racket (<code>#:</code>).</p>

<p>``` racket
(test-case &ldquo;extract-neighborhood&rdquo;
  (let ([game &lsquo;((1 0 1 0)</p>

<pre><code>            (0 1 0 1)
            (1 0 0 1))])
(check-equal? (extract-neighborhood game #:x 1 #:y 1) '(1 0 1 0 1 0 1 0 0))))
</code></pre>

<p>```</p>

<p>Et une implémentation encore plus simple.</p>

<p><code>racket
(define (extract-neighborhood generation #:x [x 0] #:y [y 0])
  '(1 0 1 0 1 0 1 0 0))
</code></p>

<p>La suite est classique, j'ajoute un nouveau test.</p>

<p>``` racket
(test-case &ldquo;extract-neighborhood&rdquo;
  (let ([game &lsquo;((1 0 1 0)</p>

<pre><code>            (0 1 0 1)
            (1 0 0 1))])
(check-equal? (extract-neighborhood game #:x 1 #:y 1) '(1 0 1 0 1 0 1 0 0))
(check-equal? (extract-neighborhood game #:x 2 #:y 1) '(0 1 0 1 0 1 0 0 1))))
</code></pre>

<p>```</p>

<p>Je regarde ce test échouer.</p>

<pre><code>$ racket game-of-life-test.rkt 
--------------------
extract-neighborhood
FAILURE
actual:     (1 0 1 0 1 0 1 0 0)
expected:   (0 1 0 1 0 1 0 0 1)
</code></pre>

<p>Et j'implémente le minimum de code pour faire passer ce nouveau test.
Je vous épargne ça dans l'article, si vous êtes curieux vous pouvez trouver
<a href="https://github.com/lkdjiin/game-of-life-racket">le code sur Github</a>.</p>

<h2>Une nouvelle génération</h2>

<p>J'écris un test pour la production d'une nouvelle génération.</p>

<p>``` racket
(test-case &ldquo;next-generation&rdquo;
  (let ([game &lsquo;((1 0 1 0)</p>

<pre><code>            (0 1 0 1)
            (1 0 0 1))])

(check-equal? (next-generation game) '((0 1 1 0) (1 1 0 1) (0 0 1 0)))))
</code></pre>

<p>```</p>

<p>Et voici le code qui fait passer ce test.</p>

<p>``` racket generation.rkt
(define (next-generation current)
  (for/list ([y (length current)])</p>

<pre><code>(for/list ([x (length (first current))])
  (define neighborhood (extract-neighborhood current #:x x #:y y))
  (next-cell-state neighborhood))))
</code></pre>

<p>```</p>

<p>On peut maintenant lancer le jeu de la vie.</p>

<p>``` racket game-of-life.rkt</p>

<h1>lang racket</h1>

<p>(require &ldquo;generation.rkt&rdquo;</p>

<pre><code>     "window.rkt")
</code></pre>

<p>(define size 100)
(define generation (create-generation size size))
(define canvas (create-window size size generation))</p>

<p>(define (loop n g)
  (send canvas change-generation g)
  (sleep 0.2)
  (when (> n 0)</p>

<pre><code>(loop (sub1 n) (next-generation g))))
</code></pre>

<p>(loop 30 generation)
```</p>

<h2>Mise à l'échelle</h2>

<p>Pour rendre les choses un peu plus intéressantes visuellement, on va faire un
zoom x4.</p>

<p>``` racket window.rkt</p>

<h1>lang racket/gui</h1>

<p>(define (create-window w h g)
  (define scale 4)</p>

<p>  (define frame (new frame%</p>

<pre><code>                 [label "Game of Life"]
                 [width (* w scale)]
                 [height (* h scale)]))
</code></pre>

<p>  (define canvas (new (class canvas%</p>

<pre><code>...

     (define/override (on-paint)
       (send dc set-brush (new brush% [color "black"]))
       (send dc draw-rectangle 0 0 (* w scale) (* h scale))
       (send dc set-brush (new brush% [color "white"]))
       (for ([y (length current-generation)])
         (for ([x (length (first current-generation))])
           (when (= 1 (list-ref (list-ref current-generation y) x))
             (send dc draw-rectangle (* x scale) (* y scale) scale scale))))))))
</code></pre>

<p>  &hellip;
```</p>

<h2>Une surface de jeu sans bordures</h2>

<p>Il reste à <em>retirer</em> les bordures du jeu. Le processus est exactement le même
que pour les versions <a href="http://lkdjiin.github.io/blog/2014/10/25/le-jeu-de-la-vie-en-ruby-opal-partie-1/">Javascript</a> et <a href="http://lkdjiin.github.io/blog/2014/10/16/le-jeu-de-la-vie-en-javascript-partie-1/">Ruby</a> et je n'ai pas envie de
réécrire les mêmes phrases. Au besoin, je vous rappelle que le
<a href="https://github.com/lkdjiin/game-of-life-racket">code complet du jeu de la vie en Racket</a> se trouve sur Github.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p></p>
]]></content>
  </entry>
  
</feed>
