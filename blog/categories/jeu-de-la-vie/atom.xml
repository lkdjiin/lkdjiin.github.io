<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : jeu de la vie | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/jeu-de-la-vie/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2014-12-24T10:16:34+01:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Le jeu de la vie en Julia - partie 2]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/12/24/le-jeu-de-la-vie-en-julia-partie-2/"/>
    <updated>2014-12-24T10:03:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/12/24/le-jeu-de-la-vie-en-julia-partie-2</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<h2>Calcul du prochain état d'un cellule</h2>

<p>Au départ je voulais écrire une fonction <code>nextcellstate</code>. C'est la convention
en Julia: séparer les mots par des underscores seulement si c'est
incompréhensible.  Je ne sais pas pour vous, mais moi je trouve <code>nextcellstate</code>
incompréhensible.  Donc ça devient <code>next_cell_state</code>. C'est mieux. Mais on te
dis aussi que si tu ressens le besoin de mettre des underscores, c'est
peut-être parce que ta fonction en fait trop. Bon conseil.</p>

<p>Alors, cette fonction pourrait appartenir à un module <code>Cell</code>. Elle devient donc
<code>Cell.nextstate</code>. Pardon, <code>Cell.next_state</code>, c'est mieux. Mais j'ai encore <code>next</code> et
<code>state</code>, qui font deux choses différentes.</p>

<p><code>state</code> calcule l'état d'un voisinage (<em>neighborhood</em>) de cellules, c'est à dire le
nombre de <code>1</code> (cellule vivante) parmi 9 cellules: celle qui nous intéresse et ses
8 voisines.</p>

<p><code>next</code> calcule le prochain état d'une cellule (1 ou 0, vivante ou morte) selon son
état actuel et l'état de son voisinage.</p>

<p>J'ai donc décidé d'avoir une fonction <code>Neighborhood.state</code> plus une fonction
<code>Cell.next</code>.  Voici le test pour <code>Neighborhood.state</code>, c'est loin d'être
exhaustif, mais j'ai envie d'avancer:</p>

<p>``` julia test.jl
include(&ldquo;generation.jl&rdquo;)
include(&ldquo;neighborhood.jl&rdquo;)</p>

<h1>&hellip;</h1>

<p>@test Neighborhood.state([ 0 1 1 0 0 0 1 1 1]) == 5
```</p>

<p>Et la fonction:</p>

<p>``` julia neighborhood.jl
module Neighborhood</p>

<p>state(cells) = countnz(cells)</p>

<p>end
```</p>

<!-- more -->


<p><code>countnz</code> compte tout simplement le nombre d'éléments différents de zéro.</p>

<p>Passons à <code>Cell.next</code>:</p>

<p>``` julia test.jl
include(&ldquo;generation.jl&rdquo;)
include(&ldquo;neighborhood.jl&rdquo;)
include(&ldquo;cell.jl&rdquo;)</p>

<h1>&hellip;</h1>

<p>ALIVE = 1
DEAD  = 0</p>

<p>@test Cell.next(ALIVE, 5) == 0
@test Cell.next(DEAD, 3) == 1
@test Cell.next(DEAD, 4) == 0
@test Cell.next(ALIVE, 4) == 1
```</p>

<p>``` julia cell.jl
module Cell</p>

<p>function next(cell, neighborhood)</p>

<pre><code>if neighborhood == 3
    1
elseif neighborhood == 4
    cell
else
    0
end
</code></pre>

<p>end</p>

<p>end
```</p>

<p>Il semble que Julia n'ai pas de switch/case, dommage.</p>

<p>Maintenant je passe à l'extraction d'une génération, c'est à dire les 9 cellules
composées de notre cellule cible et de ses 8 voisines.</p>

<p>``` julia test.jl</p>

<h1>&hellip;</h1>

<p>generation = [ 0 1 0 1 ;</p>

<pre><code>           1 1 1 1 ;
           0 0 0 0 ;
           1 0 1 0 ]
</code></pre>

<p>@test Neighborhood.extract(generation, 2, 3) == [ 1 0 1 ; 1 1 1 ; 0 0 0 ]
@test Neighborhood.extract(generation, 3, 2) == [ 1 1 1 ; 0 0 0 ; 1 0 1 ]
```</p>

<p><code>julia neighborhood.jl
extract(generation, y, x) = generation[y-1:y+1, x-1:x+1]
</code></p>

<p>C'est tellement simple à implémenter&hellip; J'aime de plus en plus Julia.</p>

<p>Ensuite viennent les tests des cas exceptionnels. Je ne vous en montre que 3:</p>

<p>``` julia test.jl
generation = [ 0 1 0 1 ;</p>

<pre><code>           1 1 1 1 ;
           0 0 0 0 ;
           1 0 1 0 ]
</code></pre>

<h1>&hellip;</h1>

<p>@test Neighborhood.extract(generation, 1, 2) == [ 0 1 0 ; 1 1 1 ]</p>

<p>@test Neighborhood.extract(generation, 3, 1) == [ 1 1 ; 0 0 ; 1 0 ]</p>

<p>@test Neighborhood.extract(generation, 1, 1) == [ 0 1 ; 1 1 ]
```</p>

<p>Là encore, l'implémentation est simple:</p>

<p>``` julia neighborhood.jl
function extract(generation, y, x)</p>

<pre><code>height, width = size(generation)
y_low = y == 1 ? 1 : y - 1
y_up  = y == height ? height : y + 1
x_low = x == 1 ? 1 : x - 1
x_up  = x == width ? width : x + 1
generation[y_low:y_up, x_low:x_up]
</code></pre>

<p>end
```</p>

<p>Ce qu'on peut ré-arrenger un peu, par exemple ainsi:</p>

<p>``` julia neighborhood.jl
function extract(generation, y, x)</p>

<pre><code>height, width = size(generation)
yrange = range_for(y, height)
xrange = range_for(x, width)
generation[yrange, xrange]
</code></pre>

<p>end</p>

<p>function range_for(coordinate, dimension)</p>

<pre><code>low = coordinate == 1 ? 1 : coordinate - 1
up  = coordinate == dimension ? dimension : coordinate + 1
low:up
</code></pre>

<p>end
```</p>

<p>Rendez-vous dans le prochain article pour la fin du jeu de la vie en Julia.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Le jeu de la vie en Julia - partie 1]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/12/23/le-jeu-de-la-vie-en-julia-partie-1/"/>
    <updated>2014-12-23T14:50:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/12/23/le-jeu-de-la-vie-en-julia-partie-1</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Voici la première partie du jeu de la vie en Julia.
Pour installer la dernière version stable (0.3.3), rendez-vous sur le
<a href="https://github.com/JuliaLang/julia">Github de Julia</a>.</p>

<p>Julia est un langage jeune et en pleine effervescence et plusieurs frameworks
de tests sont en cours de création. J'ai notamment remarqué:</p>

<ul>
<li><a href="https://github.com/JuliaLang/FactCheck.jl">FactCheck.jl</a></li>
<li><a href="https://github.com/arypurnomoz/JulieTest.jl">JulieTest.jl</a></li>
<li><a href="https://github.com/Veraticus/testfast.jl">testfast.jl</a></li>
</ul>


<h2>Création d'une génération</h2>

<p>Mais pour ce que je compte faire ici, Julia possède une macro très simple,
<a href="http://julia.readthedocs.org/en/latest/stdlib/test/">@test</a>. Même si <code>@test</code>
est très minimal, ça sera suffisant pour ce programme. Voici donc les
tests de la fonction <code>create</code> du module <code>Generation</code>:</p>

<p>``` julia test.jl
include(&ldquo;generation.jl&rdquo;)</p>

<p>using Base.Test</p>

<p>HEIGHT = 3
WIDTH = 4</p>

<p>created_generation = Generation.create(HEIGHT, WIDTH)
@test typeof(created_generation) == Array{Int,2}
@test size(created_generation) == (HEIGHT, WIDTH)
for i in 1:length(created_generation)</p>

<pre><code>@test created_generation[i] in 0:1
</code></pre>

<p>end
```</p>

<!-- more -->


<p>Et voici les explications ligne par ligne. D'abord je rends disponible le code du futur fichier <code>generation.jl</code>:</p>

<pre><code>include("generation.jl")
</code></pre>

<p>Ensuite je demande à utiliser le module <code>Test</code>, pour avoir accès à la macro <code>@test</code>:</p>

<pre><code>using Base.Test
</code></pre>

<p>Définition des <em>constantes</em> pour la hauteur et la largeur de la génération:</p>

<pre><code>HEIGHT = 3
WIDTH = 4
</code></pre>

<p>Création d'une génération, c'est cette fonction qu'il m'intéresse de tester:</p>

<pre><code>created_generation = Generation.create(HEIGHT, WIDTH)
</code></pre>

<p>Je m'assure que <code>create</code> renvoie un tableau d'entiers à 2 dimensions:</p>

<pre><code>@test typeof(created_generation) == Array{Int,2}
</code></pre>

<p>Je m'assure que le tableau renvoyé par <code>create</code> possède bien les dimensions
voulues:</p>

<pre><code>@test size(created_generation) == (HEIGHT, WIDTH)
</code></pre>

<p>Je m'assure enfin que chaque cellule du tableau est un 1 ou un 0:</p>

<pre><code>for i in 1:length(created_generation)
    @test created_generation[i] in 0:1
end
</code></pre>

<p>Pour lancer ces tests : <code>julia test.jl</code>.</p>

<p>Voici maintenant la fonction <code>create</code> qui fera passer les tests ci-dessus:</p>

<p>``` julia generation.jl
module Generation</p>

<p>create(height, width) = rand(0:1, height, width)</p>

<p>end
```</p>

<p>Notez l'efficacité de la fonction <code>rand</code>. Sans argument, elle produit
classiquement un nombre aléatoire entre 0 et 1:</p>

<pre><code>julia&gt; rand()
0.7084513868758786
</code></pre>

<p>Avec un <em>range</em>, elle sort un nombre compris dans ce <em>range</em>:</p>

<pre><code>julia&gt; rand(0:1)
1
</code></pre>

<p>Si j'ajoute en plus une dimension, elle renvoie un tableau:</p>

<pre><code>julia&gt; rand(0:1, 3)
3-element Array{Int32,1}:
 0
 0
 1
</code></pre>

<p>Avec deux dimensions:</p>

<pre><code>julia&gt; rand(0:1, 3, 4)
3x4 Array{Int32,2}:
 0  0  0  1
 1  1  1  1
 1  1  0  0
</code></pre>

<p>Et même pour le fun, avec 3 dimensions:</p>

<pre><code>julia&gt; rand(0:1, 3, 4, 3)
3x4x3 Array{Int32,3}:
[:, :, 1] =
 1  1  1  1
 0  1  0  0
 0  0  1  0

[:, :, 2] =
 1  1  0  1
 0  0  0  0
 1  1  1  1

[:, :, 3] =
 0  0  0  1
 1  0  0  1
 1  1  0  0
</code></pre>

<p>Vous pouvez aussi tester avec encore plus de dimensions, ça fonctionnera.</p>

<h2>Affichage d'une génération</h2>

<p>Bon, Julia est jeune, je l'ai déjà dit. Je n'ai rien trouvé de simple pour faire
un peu de graphisme, donc je vais faire les sorties dans la console.</p>

<p>``` julia display.jl
module Display</p>

<p>function draw(generation)</p>

<pre><code>run(`clear`)
println(replace(repr(generation)[2:end-1], " ", ""))
</code></pre>

<p>end</p>

<p>end
```</p>

<p>La première ligne de la fonction, <code>run</code>, appelle la commande système
<code>clear</code>, qui efface l'écran du terminal.</p>

<p>La seconde demande à être décomposée. Soit la génération suivante:</p>

<pre><code>julia&gt; generation = rand(0:1, 2, 3)
2x3 Array{Int32,2}:
 0  0  1
 0  1  0
</code></pre>

<p><code>repr</code> nous donne la représentation en chaîne de caractères:</p>

<pre><code>julia&gt; repr(generation)
"[0 0 1\n 0 1 0]"
</code></pre>

<p>On peut accéder à une chaîne comme un tableau, ici je conserve ce qui se trouve
entre le second et l'avant-dernier élément:</p>

<pre><code>julia&gt; repr(generation)[2:end-1]
"0 0 1\n 0 1 0"
</code></pre>

<p><strong>Je m'aperçois que j'ai oublié de parler d'un truc important: l'indexation les
tableaux en Julia commence à 1.</strong></p>

<p>Pour finir je supprime les espaces avec <code>replace</code>:</p>

<pre><code>julia&gt; replace(repr(generation)[2:end-1], " ", "")
"001\n010"
</code></pre>

<p>Et quand on combine tout ça dans un fichier <code>main.jl</code>, voici le résultat:</p>

<p>``` julia main.jl
include(&ldquo;generation.jl&rdquo;)
include(&ldquo;display.jl&rdquo;)</p>

<p>height = 20
width = 80</p>

<p>generation = Generation.create(height, width)
Display.draw(generation)
```</p>

<pre><code>$ julia main.jl
00010111100111000011100111001010001101000010110111000111101101110101000011100000
00001101010010101111001010110101100101001000001011010001010110010100011011011011
01001000011101000001101110010010110000100101011110001001110110101111010001001001
11111110011101100001111010110101110000101011011000000011110000010011011100111111
11100100000011100001111111101010011000110011010101011100011110101110111111001111
11110011000101101010110010110011101101000111000111111111001110010100011101010101
10011101010110011110100101110110111101111101100110011011011001011100000110110000
01001110010101111101110001000110110100001101100100000010011101111000001010111100
00011001011000000000000111010000100001100000001110101110000010100010101111011111
00101011011010000001111001001011111101101110111000101100000100001101110110101100
10000010100100011111111101010101001010001010111111001111100001010001011010000001
11000011000001001101011001111101111111111111011111100101100101010000101111101001
11010111011111101001111110100000001011100100010100100100000010001011000010101110
10011000100111111100011010010100110001101110001001100100100000010100111001111011
11110001001011000101100001001110010100010011100101001101010111111100011100111101
11001111000101101111001110010010101001110010101100010100101011101011000101000000
01001111111101010010001100010011000001110110001110110101010101010000111010111000
01101001011011011001110010010010000101000111111111010101001011101011111001101010
00101111001100011111110110000110011100001011011100101101011001111111111100011110
01110001110010001001011100100000100000010110001100011011101001010011111011110100
</code></pre>

<p>Pour rendre la sortie écran un peu plus présentable, <em>effaçons</em> les 0, en les
remplaçant par des espaces, et remplaçons les 1 par des @:</p>

<p>``` julia display.jl
module Display</p>

<p>function draw(generation)</p>

<pre><code>run(`clear`)
output = replace(repr(generation)[2:end-1], " ", "")
output = replace(output, "1", "@")
output = replace(output, "0", " ")

println(output)
</code></pre>

<p>end</p>

<p>end
```</p>

<p>Pour terminer, voici une petite boucle pour afficher une dizaine de générations:</p>

<p>``` julia main.jl
include(&ldquo;generation.jl&rdquo;)
include(&ldquo;display.jl&rdquo;)</p>

<p>height = 20
width = 80</p>

<p>for _ in 1:10</p>

<pre><code>generation = Generation.create(height, width)
sleep(0.8)
Display.draw(generation)
</code></pre>

<p>end
```</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Le jeu de la vie en logo - partie 3]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/12/20/le-jeu-de-la-vie-en-logo-partie-3/"/>
    <updated>2014-12-20T17:46:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/12/20/le-jeu-de-la-vie-en-logo-partie-3</id>
    <content type="html"><![CDATA[<p>Suite et fin du jeu de la vie en Logo.</p>

<p>Je ne montrerais pas d'extraits de code, pour la simple raison que
je n'en peux plus du langage Logo.  Ceci dit, pour les curieux, le code complet
se trouve sur <a href="https://github.com/lkdjiin/game-of-life-logo">Github</a>.</p>

<p> Je ne sais pas ce qui m'a pris de
ressortir Logo du placard. Les madeleines de Proust sont faites pour rester à
l'état de souvenirs. Écrire le jeu de la vie en Logo n'a jamais été fun. À
aucun moment.</p>

<!-- more -->


<p>Bref, j'oublie définitivement Logo. La prochaine version sera en Julia, ça
promet d'être bien plus intéressant.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Le jeu de la vie en logo - partie 2]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/12/17/le-jeu-de-la-vie-en-logo-partie-2/"/>
    <updated>2014-12-17T16:35:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/12/17/le-jeu-de-la-vie-en-logo-partie-2</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Cette fois, on affiche la génération de cellules crée la dernière fois.
J'ai déjà eu l'occasion de dire que Logo était spécial, on va voir avec
son système graphique que c'est bien le cas. Je ne vais pas parler de la
métaphore de la <em>tortue</em>, vous trouverez sûrement des ressources là-dessus.
Je voudrais plutôt parler du système de coordonnée. Alors que dans la plupart des
langages (tous ?) les systèmes graphiques proposent de placer le point d'origine (0, 0) en haut à
gauche, Logo le place au centre. En général, l'axe des y croit vers le bas,
en Logo il croit vers le haut.</p>

<p>Selon le manuel d'UCBLogo, voici à quoi s'attendre:</p>

<pre><code>(-100, 100)            (100, 100)

              (0, 0)

(-100, -100)           (100, -100)
</code></pre>

<!-- more -->


<p>Mais en fait, non. J'ai plutôt ça sur la machine où j'utilise Logo:</p>

<pre><code>(-250, 250)            (250, 250)

              (0, 0)

(-250, -250)           (250, -250)
</code></pre>

<p>Quoiqu'il en soit, voici comment ça marche.</p>

<p>``` raw drawing.lg
hideturtle</p>

<p>to draw.generation :generation :size
for [y 1 :size] [p.draw.line :y]
end</p>

<p>to p.draw.line :y
for [x 1 :size] [if (cell.alive? :generation :x :y) [p.draw.cell :x :y ] ]
end</p>

<p>to p.draw.cell :x :y
penup
setxy :x :y
setheading 90
pendown
forward 1
end
```</p>

<p><code>hideturtle</code> cache la tortue, comme son nom l'indique. Parce que, en plus
d'être moche, ça ralenti le dessin, qui n'est déjà pas très rapide.</p>

<p>La procédure <code>draw.generation</code> itère sur chaque ligne de <code>generation</code> et
appelle la procédure <em>privée</em> <code>p.draw.line</code>.</p>

<p><code>p.draw.line</code> itère sur chaque cellule de la ligne. On détermine, avec
<code>cell.alive?</code>, si la cellule est vivante. Si c'est le cas, on appelle
<code>p.draw.cell</code>.</p>

<p><code>p.draw.cell</code> affiche un pixel en (x, y).</p>

<p>Dans le fichier <code>generation.lg</code>, j'ajoute la procédure <code>cell.alive?</code>.</p>

<p><code>raw generation.lg
to cell.alive? :generation :x :y
localmake "line item :y :generation
ifelse (item :x :line) = 1 [output "true] [output "false]
end
</code></p>

<p>Puis on assemble le tout dans un fichier <code>application.lg</code>.</p>

<p>``` raw application.lg
load &ldquo;generation.lg
load "drawing.lg</p>

<p>make &ldquo;size 100</p>

<p>draw.generation create.generation :size :size :size
```</p>

<p>Et voici le résultat:</p>

<pre><code>$ tree
.
├── application.lg
├── drawing.lg
├── generation.lg
└── test.generation.lg

$ logo application.lg
</code></pre>

<p><img src="/images/game-of-life-logo.png"></p>

<p>Mouais, un peu moche, non ? J'avoue que je commence déjà à en avoir marre de
Logo.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Le jeu de la vie en logo - partie 1]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/12/16/le-jeu-de-la-vie-en-logo-partie-1/"/>
    <updated>2014-12-16T18:01:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/12/16/le-jeu-de-la-vie-en-logo-partie-1</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>C'est parti pour la version Logo du jeu de la vie. J'utiliserais
<a href="http://www.cs.berkeley.edu/~bh/logo.html">ucblogo</a> en version 5.5, qui est celle qu'on trouve dans les paquets Debian.
Sur leur site vous trouverez la version 6, si vous souhaitez la compiler.</p>

<pre><code>$ logo
Welcome to Berkeley Logo version 5.5
</code></pre>

<h2>Introduction</h2>

<p>Attention ! Le monde de Logo est autre. Je n'ai pas d'autres formules qui me
viennent à l'esprit.  Si vous utilisez Vim, j'ai écrit un fichier de
<a href="https://github.com/lkdjiin/logo.vim">coloration syntaxique pour Logo</a>,
minimal, mais toujours utile pour ne pas se sentir coincé dans les années 80.
Et comme il n'existe pas de frameworks de test (ou alors ils sont bien cachés),
j'en ai écrit un rudimentaire : <a href="https://github.com/lkdjiin/logo-unit">Logo unit test</a>.</p>

<p>Bref, vous aurez compris que l'éco-système Logo open source est assez pauvre,
voir inexistant.  Je crois qu'il n'y a même pas de tag <code>logo</code> sur
stackoverflow.</p>

<!-- more -->


<h2>Création d'une génération</h2>

<p>Créons un fichier pour les tests, et un fichier pour l'implémentation.</p>

<pre><code>$ tree
.
├── generation.lg
└── test.generation.lg
</code></pre>

<p>En avant pour le premier test, je veux m'assurer que la procédure
<code>create.generation</code> renvoie une liste.</p>

<p>``` raw test.generation.lg
load &ldquo;generation.lg</p>

<p>to t.create.generation.returns.a.list
assert.list create.generation
end
```</p>

<h3>Premières remarques sur Logo</h3>

<p>Tout d'abord, les points n'ont rien à voir avec des appels de
méthode/fonction/procédure.  C'est juste une manière de nommer les choses. En
Ruby on aurait <code>assert_list</code>, en Java <code>assertList</code>, en Racket <code>assert-list</code>, en
Logo c'est plutôt <code>assert.list</code>.</p>

<p>Ensuite, la première ligne <code>load "generation.lg</code>, qui charge le fichier
<code>generation.lg</code>, ne contient pas de faute de frappe ! Il y a bien un seul
guillement double (<code>"</code>). C'est la façon de dire que <code>generation.lg</code> doit être
pris dans son sens littéral, pas en tant que variable ou procédure, mais bien en
tant que nom.</p>

<h3>Lancer les tests</h3>

<p>On lance les tests en chargeant la procédure <code>tt</code>. Logo nous dit <em>je ne sais
pas comment faire pour create.generation</em>. Normal puisque cette procédure
n'existe pas encore.</p>

<pre><code>$ logo
Welcome to Berkeley Logo version 5.5
? tt "test.generation.lg
I don't know how  to create.generation  in t.create.generation.returns.a.list
[assert.list create.generation]
</code></pre>

<h3>Notre première procédure</h3>

<p>Il suffit de renvoyer une liste vide pour faire passer le test. Notez que
<code>output</code> est l'équivalent du plus commun <code>return</code>.</p>

<p><code>raw generation.lg
to create.generation
output []
end
</code></p>

<pre><code>? tt "test.generation.lg
.

1 tests. 0 fail.
</code></pre>

<h3>Une liste à plusieurs dimensions</h3>

<p>Notre liste devra avoir une largeur (x) et une hauteur (y), commençons par
tester la hauteur.</p>

<p>``` raw test.generation.lg
load &ldquo;generation.lg</p>

<p>to t.create.generation.returns.a.list
assert.list create.generation 3
end</p>

<p>to t.create.generation.have.a.height
assert.equal 3 count create.generation 3
end
```</p>

<p>Voici le code permettant de faire passer nos nouveaux tests.</p>

<p><code>raw generation.lg
to create.generation :height
output cascade :height [lput # ?] []
end
</code></p>

<p><code>cascade</code> prend un nombre d'itération, un template et une valeur de départ.
<code>lput</code> (pour <em>last put</em>) ajoute une valeur à la fin d'une liste. <code>#</code> dans le
template est remplacé par l'itération.</p>

<p>Ensuite, nouveaux tests pour s'assurer qu'on a aussi une largeur.</p>

<p>``` raw test.generation.lg
load &ldquo;generation.lg</p>

<p>to t.create.generation.returns.a.list
assert.list create.generation 4 3
end</p>

<p>to t.create.generation.have.a.height
assert.equal 3 count create.generation 4 3
end</p>

<p>to t.create.generation.have.a.width
assert.equal 4 count first create.generation 4 3
end
```</p>

<p>On implémente notre liste à 2 dimensions.</p>

<p>``` raw generation.lg
to create.generation :width :height
output cascade :height [lput (p.create.line :width) ?] []
end</p>

<p>to p.create.line :width
output cascade :width [lput 0 ?] []
end
```</p>

<p>Le <code>p.</code> en tête d'un nom de procédure est une convention que j'ai utilié pour
signifier que la procédure est privée.</p>

<p>Les tests passent.</p>

<pre><code>? tt "test.generation.lg
...

3 tests. 0 fail.
</code></pre>

<p>On peut regarder à quoi ressemble la sortie de notre procédure.</p>

<pre><code>? print create.generation 4 3
[0 0 0 0] [0 0 0 0] [0 0 0 0]
</code></pre>

<h3>Un peu de hasard</h3>

<p>Les cellules du jeu de la vie sont représentées soit par un 0 (cellule
morte), soit par un 1 (cellule vivante). Je teste que <code>create.generation</code>
produit bien une suite de 0 et de 1.</p>

<p><code>raw test.generation.lg
to t.create.generation.produces.0s.or.1s
rerandom
localmake "result create.generation 3 2
assert.equal :result [[1 0 1] [1 1 1]]
end
</code></p>

<p><code>rerandom</code> place le générateur de nombre aléatoire dans un état reproductible,
pour pouvoir tester facilement. <code>localmake</code> déclare une variable locale, ici
<code>result</code> qui va contenir la sortie de <code>create.generation 3 2</code>.</p>

<p>Et j'implémente avec la procédure <code>random</code> qui renvoie un nombre aléatoire.</p>

<p><code>raw generation.lg
to p.create.line :width
output cascade :width [lput (random 2) ?] []
end
</code></p>

<p>Et voilà, les tests passent.</p>

<pre><code>? tt "test.generation.lg
....

4 tests. 0 fail.
? print create.generation 9 3
[0 0 1 0 1 1 0 0 0] [1 1 1 1 0 0 0 1 1] [1 0 1 0 1 1 1 1 0]
</code></pre>

<h2>La portée des variables en Logo</h2>

<p>Le code précédent fonctionne très bien, par contre on peut faire un refactoring
intéressant qui va me permettre de parler d'un phénomène étrange en Logo.</p>

<p>``` raw generation.lg
to create.generation :width :height
output cascade :height [lput p.create.line ?] []
end</p>

<p>to p.create.line
output cascade :width [lput (random 2) ?] []
end
```</p>

<p>Vous remarquerez que j'ai enlevé le paramêtre <code>width</code> de la procédure
<code>p.create.line</code> et que ce <code>width</code> n'est plus passé par <code>create.generation</code>.
Pourtant le code continue de fonctionner comme un charme.</p>

<p>C'est que Logo a une notion toute particulière de la <em>localité</em> des variables.
Une variable locale à une procédure est connue dans cette même procédure
<strong>et aussi</strong> dans les sous-procédures appelées par cette même procédure.
Autrement dit, <code>p.create.line</code> connait les variables <code>width</code> et <code>height</code>
puisqu'elle est appelée par <code>create.generation</code>.</p>

<p>Ce n'est pas le seul langage à fonctionner comme ça (les premiers Lisp et
Perl, il me semble). Par contre je me demande toujours si c'est génial, ou
irresponsable.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p></p>
]]></content>
  </entry>
  
</feed>
