<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : jeu de la vie | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/jeu-de-la-vie/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2014-10-17T21:22:34+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Le jeu de la vie en javascript - partie 2]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/10/17/le-jeu-de-la-vie-en-javascript-partie-2/"/>
    <updated>2014-10-17T21:12:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/10/17/le-jeu-de-la-vie-en-javascript-partie-2</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p><a href="http://lkdjiin.github.io/blog/2014/10/16/le-jeu-de-la-vie-en-javascript-partie-1/">Précédement</a> nous avons écrit une fonction pour produire une génération de
cellules au hasard. Nous allons aujourd'hui afficher une telle génération.
Je veux maintenant calculer le prochain état d'une cellule, en fonction de son
voisinage. Pour rappel:</p>

<ul>
<li>Si la somme des 9 cellules du voisinage est 3, le nouvel état est «vivant».</li>
<li>Si la somme des 9 cellules du voisinage est 4, le nouvel état est le même
que l'ancien.</li>
<li>Dans tous les autres cas, le nouvel état est «mort».</li>
</ul>


<!-- more -->


<h2>Calculer le prochain état d'une cellule</h2>

<p>Voici les différents tests qui m'ont conduits à l'écriture de la fonction
<code>nextCellState</code>. Notez bien que, selon les principes du TDD, je ne les ai pas
écrit tous d'un coup, mais bien un par un, en implémentant la fonction
minimale à chaque nouveau test.</p>

<p>``` javascript
describe(&ldquo;nextCellState&rdquo;, function() {</p>

<p>  it(&ldquo;returns an integer&rdquo;, function() {</p>

<pre><code>var cells = [1, 1, 1, 0, 0, 0, 0, 0, 0];
var result = nextCellState(cells);
expect(Number.isInteger(result)).toBe(true);
</code></pre>

<p>  });</p>

<p>  it(&ldquo;returns 1 when it&rsquo;ll be alive&rdquo;, function() {</p>

<pre><code>var cells = [
  [1, 1, 1, 0, 0, 0, 0, 0, 0],
  [0, 1, 1, 0, 0, 1, 0, 0, 0],
  [0, 1, 0, 0, 0, 1, 0, 1, 0]
];
for(var i = 0; i &lt; cells.length; i++) {
  expect(nextCellState(cells[i])).toBe(1);
}
</code></pre>

<p>  });</p>

<p>  it(&ldquo;returns 0 when it&rsquo;ll be dead&rdquo;, function() {</p>

<pre><code>var cells = [
  [1, 1, 1, 1, 1, 1, 1, 1, 1],
  [0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 1, 0, 0, 0, 0, 0, 0, 0]
];
for(var i = 0; i &lt; cells.length; i++) {
  expect(nextCellState(cells[i])).toBe(0);
}
</code></pre>

<p>  });</p>

<p>  it(&ldquo;returns current state as next state&rdquo;, function() {</p>

<pre><code>var cells = [
  [1, 1, 1, 1, 0, 0, 0, 0, 0],
  [0, 1, 0, 0, 1, 1, 1, 0, 0]
];
expect(nextCellState(cells[0])).toBe(0);
expect(nextCellState(cells[1])).toBe(1);
</code></pre>

<p>  });</p>

<p>});
```</p>

<p>Et voici cette fonction.</p>

<p>``` javascript app/application.js
function nextCellState(neighborhood) {
  var result = neighborhood.reduce(function(a, b) {</p>

<pre><code>return a + b
</code></pre>

<p>  }, 0);</p>

<p>  if(result === 3)</p>

<pre><code>return 1;
</code></pre>

<p>  else if(result === 4)</p>

<pre><code>return neighborhood[4];
</code></pre>

<p>  else</p>

<pre><code>return 0;
</code></pre>

<p>}
```</p>

<p>Maintenant il me faut une fonction qui extrait un <em>voisinage</em> à partir d'une
position dans une génération. C'est la partie la plus complexe. Comme toujours,
je commence doucement avec un test très simple et son code d'implémentation.</p>

<p>``` javascript
describe(&ldquo;extractNeighborhood&rdquo;, function() {</p>

<p>  it(&ldquo;returns an array&rdquo;, function() {</p>

<pre><code>var result = extractNeighborhood();
expect(Array.isArray(result)).toBe(true);
</code></pre>

<p>  });</p>

<p>});
```</p>

<p><code>javascript app/application.js
function extractNeighborhood() {
  return [];
}
</code></p>

<p>Je peux commencer à <em>specer</em> les choses sérieuses.</p>

<p>``` javascript
describe(&ldquo;extractNeighborhood&rdquo;, function() {</p>

<p>  beforeEach(function() {</p>

<pre><code>this.generation = [
  [0, 1, 0, 1],
  [1, 0, 1, 0],
  [0, 1, 1, 0]];
</code></pre>

<p>  });</p>

<p>  it(&ldquo;returns an array&rdquo;, function() {</p>

<pre><code>var result = extractNeighborhood(this.generation, 1, 1);
expect(Array.isArray(result)).toBe(true);
</code></pre>

<p>  });</p>

<p>  it(&ldquo;returns the neighborhood of a cell at x, y&rdquo;, function() {</p>

<pre><code>var x = 1,
    y = 1,
    result = extractNeighborhood(this.generation, x, y);

expect(result).toEqual([0, 1, 0, 1, 0, 1, 0, 1, 1]);
</code></pre>

<p>  });</p>

<p>});
```</p>

<p>On note l'utilisation de <code>toEqual</code> pour tester l'égalité de deux tableaux,
<code>toBe()</code> testant l'identité d'après ce que j'ai compris.
Et voici le code qui fait passer tout ça, moche mais pragmatique.</p>

<p>``` javascript app/application.js
function extractNeighborhood(generation, x, y) {
  return [</p>

<pre><code>generation[y-1][x-1], generation[y-1][x], generation[y-1][x+1],
generation[y][x-1], generation[y][x], generation[y][x+1],
generation[y+1][x-1], generation[y+1][x], generation[y+1][x+1] ];
</code></pre>

<p>}
```</p>

<p>C'est au tour des cellules du bord, d'abord en haut.</p>

<p>``` javascript
describe(&ldquo;extractNeighborhood&rdquo;, function() {</p>

<p>  &hellip;</p>

<p>  describe(&ldquo;returns the neighborhood of a border&rsquo;s cell&rdquo;, function() {</p>

<pre><code>it("x=2, y=0", function() {
  var x = 2,
      y = 0,
      result = extractNeighborhood(this.generation, x, y);
  expect(result).toEqual([0, 0, 0, 0, 0, 1, 0, 1, 0]);
});
</code></pre>

<p>  });</p>

<p>});
```</p>

<p>Le code devient de plus en plus moche.</p>

<p>``` javascript app/application.js
function extractNeighborhood(generation, x, y) {
  return firstLine(generation, x, y-1).concat(</p>

<pre><code>[generation[y][x-1], generation[y][x], generation[y][x+1],
generation[y+1][x-1], generation[y+1][x], generation[y+1][x+1] ]);
</code></pre>

<p>}</p>

<p>function firstLine(generation, x, y) {
  if(y &lt; 0)</p>

<pre><code>return [0, 0, 0];
</code></pre>

<p>  else</p>

<pre><code>return [generation[y][x-1], generation[y][x], generation[y][x+1]];
</code></pre>

<p>}
```</p>

<p>Puisqu'il passe les tests, je cherche à l'améliorer un peu.</p>

<p>``` javascript app/application.js
function extractNeighborhood(generation, x, y) {
  return firstLine(generation[y-1], x).concat(</p>

<pre><code>[generation[y][x-1], generation[y][x], generation[y][x+1],
generation[y+1][x-1], generation[y+1][x], generation[y+1][x+1] ]);
</code></pre>

<p>}</p>

<p>function firstLine(line, x) {
  if(line === void 0)</p>

<pre><code>return [0, 0, 0];
</code></pre>

<p>  else</p>

<pre><code>return [line[x-1], line[x], line[x+1]];
</code></pre>

<p>}
```</p>

<p>Cellule du bord en bas, maintenant.</p>

<p>``` javascript
  describe(&ldquo;returns the neighborhood of a border&rsquo;s cell&rdquo;, function() {</p>

<pre><code>it("x=2, y=0", function() {
  ...
});

it("x=2, y=2", function() {
  var x = 2,
      y = 2,
      result = extractNeighborhood(this.generation, x, y);
  expect(result).toEqual([0, 1, 0, 1, 1, 0, 0, 0, 0]);
});
</code></pre>

<p>  });
```</p>

<p>``` javascript app/application.js
function extractNeighborhood(generation, x, y) {
  return extractLine(generation[y-1], x).concat(</p>

<pre><code>[generation[y][x-1], generation[y][x], generation[y][x+1]],
extractLine(generation[y+1], x));
</code></pre>

<p>}</p>

<p>function extractLine(line, x) {
  if(line === void 0)</p>

<pre><code>return [0, 0, 0];
</code></pre>

<p>  else</p>

<pre><code>return [line[x-1], line[x], line[x+1]];
</code></pre>

<p>}
```</p>

<p>Puis refactoring.</p>

<p>``` javascript app/application.js
function extractNeighborhood(generation, x, y) {
  return extractLine(generation[y-1], x).concat(</p>

<pre><code>     extractLine(generation[y], x),
     extractLine(generation[y+1], x));
</code></pre>

<p>}
```</p>

<p>On passe au bord gauche.</p>

<p>``` javascript
  describe(&ldquo;returns the neighborhood of a border&rsquo;s cell&rdquo;, function() {</p>

<pre><code>it("x=2, y=0", function() {
  ...
});

it("x=2, y=2", function() {
  ...
});

it("x=0, y=1", function() {
  var x = 0,
      y = 1,
      result = extractNeighborhood(this.generation, x, y);
  expect(result).toEqual([0, 0, 1, 0, 1, 0, 0, 0, 1]);
});
</code></pre>

<p>  });
```</p>

<p>La réponse de Jasmine à ce test est:</p>

<pre><code>Expected [ undefined, 0, 1, undefined, 1, 0, undefined, 0, 1 ] to equal [ 0, 0, 1, 0, 1, 0, 0, 0, 1 ].
</code></pre>

<p>Si on suit les principes du TDD, il faut écrire le code tout juste suffisant
pour faire passer ce test. Je me contente donc de mapper les <code>undefined</code> en <code>0</code>.</p>

<p>``` javascript app/application.js
function extractNeighborhood(generation, x, y) {
  var cells = extractLine(generation[y-1], x).concat(</p>

<pre><code>          extractLine(generation[y], x),
          extractLine(generation[y+1], x));
</code></pre>

<p>  return cells.map(function(cell) {</p>

<pre><code>return cell === undefined ? 0 : cell;
</code></pre>

<p>  });
}
```</p>

<p>Si j'ajoute un test pour une cellule du bord droit, il passe.</p>

<p>``` javascript</p>

<pre><code>it("x=3, y=1", function() {
  var x = 3,
      y = 1,
      result = extractNeighborhood(this.generation, x, y);
  expect(result).toEqual([0, 1, 0, 1, 0, 0, 1, 0, 0]);
});
</code></pre>

<p>```</p>

<p>Très bien, il faut maintenant s'occuper des cellules de coins. Je me rends
compte que les quatres tests suivants passent sans que je n'ai rien à modifier
dans le code.</p>

<p>``` javascript
  describe(&ldquo;returns the neighborhood of a corner&rsquo;s cell&rdquo;, function() {</p>

<pre><code>it("x=0, y=0", function() {
  var x = 0,
      y = 0,
      result = extractNeighborhood(this.generation, x, y);
  expect(result).toEqual([0, 0, 0, 0, 0, 1, 0, 1, 0]);
});

it("x=3, y=0", function() {
  var x = 3,
      y = 0,
      result = extractNeighborhood(this.generation, x, y);
  expect(result).toEqual([0, 0, 0, 0, 1, 0, 1, 0, 0]);
});

it("x=0, y=2", function() {
  var x = 0,
      y = 2,
      result = extractNeighborhood(this.generation, x, y);
  expect(result).toEqual([0, 1, 0, 0, 0, 1, 0, 0, 0]);
});

it("x=3, y=2", function() {
  var x = 3,
      y = 2,
      result = extractNeighborhood(this.generation, x, y);
  expect(result).toEqual([1, 0, 0, 1, 0, 0, 0, 0, 0]);
});
</code></pre>

<p>  });
```</p>

<p>Je suis donc prêt à tout mettre ensemble. Ce sera pour le prochain article car
celui-ci est déjà bien long.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Le jeu de la vie en javascript - partie 1]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/10/16/le-jeu-de-la-vie-en-javascript-partie-1/"/>
    <updated>2014-10-16T22:27:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/10/16/le-jeu-de-la-vie-en-javascript-partie-1</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>C'est parti pour le jeu de la vie version Javascript. Dans ce premier article
nous allons créer une génération de cellules au hasard et l'afficher.</p>

<p><em>J'avais annoncé dans <a href="blog/2014/10/08/le-jeu-de-la-vie-dans-sept-langages-differents/">l'article précédent</a> que je commencerais par la
version Ruby/Opal. Je l'ai écrite mais je n'en suis pas satisfait. Les
performances sont très pauvres et j'ai écrit plus de code que nécessaire.
Je prendrais donc le temps de la nettoyer un peu avant de la publier.</em></p>

<!-- more -->


<p>Pour les tests, j'utiliserais <a href="http://jasmine.github.io/">Jasmine</a> et la structure du projet sera la
suivante:</p>

<pre><code>$ tree
.
├── app
│   └── application.js
├── index.html
├── jasmine
│   └── lib
│       └── jasmine-2.0.3
│           ├── boot.js
│           ├── console.js
│           ├── jasmine.css
│           ├── jasmine_favicon.png
│           ├── jasmine-html.js
│           └── jasmine.js
├── spec
│   └── test.js
└── test.html
</code></pre>

<p>Dans le fichier <code>test.html</code> on charge les dépendances de Jasmine, puis notre
application (<code>app/application.js</code>) et enfin nos tests (<code>spec/test.js</code>).</p>

<p>``` html test.html
&lt;!DOCTYPE html>
<html>
  <head></p>

<pre><code>&lt;meta charset="utf-8" /&gt;
&lt;title&gt;Test Game of Life&lt;/title&gt;
&lt;link rel="shortcut icon" type="image/png" href="jasmine/lib/jasmine-2.0.3/jasmine_favicon.png"&gt;
&lt;link rel="stylesheet" type="text/css" href="jasmine/lib/jasmine-2.0.3/jasmine.css"&gt;

&lt;script type="text/javascript" src="jasmine/lib/jasmine-2.0.3/jasmine.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="jasmine/lib/jasmine-2.0.3/jasmine-html.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="jasmine/lib/jasmine-2.0.3/boot.js"&gt;&lt;/script&gt;
</code></pre>

<p>  </head>
  <body></p>

<pre><code>&lt;script type="text/javascript" src="app/application.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="spec/test.js"&gt;&lt;/script&gt;
</code></pre>

<p>  </body>
</html>
```</p>

<h2>Créer une génération de cellules au hasard</h2>

<p>Nous allons écrire la fonction <code>createGeneration</code> qui
devra <em>fabriquer</em> un ensemble de cellules, mortes (<code>0</code>) ou vivantes (<code>1</code>), au
hasard. Mon premier test avec Jasmine est de m'assurer que cette fonction
renvoie un tableau (<code>Array</code>).</p>

<p>``` javascript spec/test.js
describe(&ldquo;createGeneration&rdquo;, function() {</p>

<p>  it(&ldquo;returns an array&rdquo;, function() {</p>

<pre><code>var result = createGeneration();
expect(Array.isArray(result)).toBe(true);
</code></pre>

<p>  });</p>

<p>});
```</p>

<p>Lorsqu'on lance <code>test.html</code> Jasmine nous dit que <code>createGeneration</code> n'existe
pas. Le code javascript permettant de faire passer ce test consiste donc à
renvoyer un tableau vide.</p>

<p><code>javascript app/application.js
function createGeneration(x, y) {
  return [];
}
</code></p>

<p>Maintenant il nous faut un tableau à 2 dimensions:</p>

<p>``` javascript spec/test.js
describe(&ldquo;createGeneration&rdquo;, function() {</p>

<p>  &hellip;</p>

<p>  it(&ldquo;creates a 2D array&rdquo;, function() {</p>

<pre><code>var result = createGeneration(3, 5);
expect(result.length).toBe(5);
expect(result[0].length).toBe(3);
</code></pre>

<p>  });</p>

<p>});
```</p>

<p>La fonction suivante est suffisante pour faire passer le test.</p>

<p>``` javascript app/application.js
function createGeneration(x, y) {
  var generation = new Array(y);</p>

<p>  for(var i = 0; i &lt; y; i++) {</p>

<pre><code>generation[i] = new Array(x);
</code></pre>

<p>  }
  return generation;
}
```</p>

<p>Et maintenant on rempli notre tableau 2D avec des <code>1</code> ou des <code>0</code>. D'abord un
test pour vérifier que chaque cellule du tableau contient <code>1</code> ou <code>0</code>.</p>

<p>``` javascript spec/test.js
describe(&ldquo;createGeneration&rdquo;, function() {</p>

<p>  &hellip;</p>

<p>  it(&ldquo;fills each room with 1 or 0&rdquo;, function() {</p>

<pre><code>var generation = createGeneration(2, 3);
for(var y = 0; y &lt; 3; y++) {
  for(var x = 0; x &lt; 2; x++) {
    var cell = generation[y][x];
    var result = cell === 0 || cell === 1;
    expect(result).toBe(true);
  }
}
</code></pre>

<p>  });</p>

<p>});
```</p>

<p>Puis l'implémentation.</p>

<p>``` javascript app/application.js
function createGeneration(x, y) {
  var generation = new Array(y);</p>

<p>  for(var i = 0; i &lt; y; i++) {</p>

<pre><code>generation[i] = [];
for(var j = 0; j &lt; x; j++) {
  generation[i][j] = Math.floor(Math.random() * 2);
}
</code></pre>

<p>  }
  return generation;
}
```</p>

<p>Voilà, cette première partie du jeu de la vie en Javascript était simple et
rapide à coder. Je vais maintenant mettre les tests de coté pour me
concentrer sur l'affichage d'une génération.</p>

<h2>Afficher une génération</h2>

<p>Voyons pour commencer le contenu du fichier <code>index.html</code>.</p>

<p>``` html index.html
&lt;!DOCTYPE html>
<html>
  <head></p>

<pre><code>&lt;meta charset="utf-8" /&gt;
&lt;title&gt;Game of Life&lt;/title&gt;
</code></pre>

<p>  </head>
  <body></p>

<pre><code>&lt;canvas width="100" height="100" id="canvas"&gt;&lt;/canvas&gt;
&lt;script src="app/application.js"&gt;&lt;/script&gt;
</code></pre>

<p>  </body>
</html>
```</p>

<p>Nous référençons bien entendu notre <code>application.js</code> et nous créons un
<code>canvas</code> de (petite) dimension 100x100. C'est dans ce <code>canvas</code> que nous allons
<em>dessiner</em> nos cellules.</p>

<p>Sans plus attendre, voici le contenu de <code>application.js</code>.</p>

<p>``` javascript app/application.js
function createGeneration(width, height) {
  var generation = new Array(height);</p>

<p>  for(var y = 0; y &lt; height; y++) {</p>

<pre><code>generation[y] = [];
for(var x = 0; x &lt; width; x++) {
  generation[y][x] = Math.floor(Math.random() * 2);
}
</code></pre>

<p>  }
  return generation;
}</p>

<p>function draw(context2d, generation) {
  var height = generation.length;
  var width = generation[0].length;</p>

<p>  clearBackground(context2d, width, height);
  drawCells(context2d, generation, width, height);
}</p>

<p>function clearBackground(context2d, width, height) {
  context2d.fillStyle = &lsquo;black&rsquo;;
  context2d.fillRect(0, 0, width, height);
}</p>

<p>function drawCells(context2d, generation, width, height) {
  context2d.fillStyle = &lsquo;white&rsquo;;
  for(var y = 0; y &lt; height; y++) {</p>

<pre><code>for(var x = 0; x &lt; width; x++) {
  if(generation[x][y] === 1) {
    context2d.fillRect(x, y, 1, 1);
  }
}
</code></pre>

<p>  }
}</p>

<p>(function() {
  var generation = createGeneration(100, 100);
  var c = document.getElementById(&lsquo;canvas&rsquo;);
  var ctx = c.getContext(&lsquo;2d&rsquo;);</p>

<p>  draw(ctx, generation);
})()
```</p>

<p>Ces quelques petites fonctions sont bien suffisantes pour afficher un
ensemble de cellules.</p>

<p>Dans le prochain article nous calculerons l'état des générations suivantes.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p></p>
]]></content>
  </entry>
  
</feed>
