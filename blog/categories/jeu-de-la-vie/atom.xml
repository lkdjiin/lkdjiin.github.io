<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : jeu de la vie | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/jeu-de-la-vie/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2014-11-08T14:41:31+01:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Le jeu de la vie en racket - partie 2]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/11/08/le-jeu-de-la-vie-en-racket-partie-2/"/>
    <updated>2014-11-08T13:46:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/11/08/le-jeu-de-la-vie-en-racket-partie-2</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>C'est le moment d'afficher à l'écran notre génération créée au hasard
<a href="http://lkdjiin.github.io/blog/2014/11/01/le-jeu-de-la-vie-en-racket-partie-1/">la dernière fois</a>.
Je rappelle que je n'écris pas de tests pour cette partie.
Pour obtenir un affichage, je me contente de suivre les exemples donnés dans la
documentation
<a href="http://mirror.racket-lang.org/releases/6.1/doc/draw/overview.html">drawing overview</a>
et <a href="http://mirror.racket-lang.org/releases/6.1/doc/gui/windowing-overview.html">windowing overview</a>.</p>

<!-- more -->


<p>Ce qui donne la première experimentation suivante:</p>

<p>``` racket game-of-life.rkt</p>

<h1>lang racket/gui</h1>

<p>&hellip;</p>

<p>(define generation (create-generation 100 100))</p>

<p>(define frame (new frame%
  [label &ldquo;Example&rdquo;]
  [width 100]
  [height 100]))</p>

<p>(new canvas%</p>

<pre><code> [parent frame]
 [paint-callback
   (λ (canvas dc)
      (send dc set-brush (new brush% [color "black"]))
      (for ([y (length generation)])
        (for ([x (length (first generation))])
          (when (= 1 (list-ref (list-ref generation y) x))
            (send dc draw-rectangle x y 1 1)))))])
</code></pre>

<p>(send frame show #t)
```</p>

<p>Le truc marrant (une façon de voir comme une autre) est que si on
joue les tests, la fenêtre s'affiche. C'est pas très pratique.</p>

<p>Mais avant tout, ce code révèle une erreur précédente:</p>

<p><img src="/images/code-barre-2014-10-11.png"></p>

<p>On dirait un code barre ! Pas vraiment une distribution uniforme.</p>

<p>Alors le bug est simple à trouver, par contre je vais devoir écrire un ou
plusieurs nouveaux tests et je garde ça pour la fin de l'article.</p>

<p>Ensuite, je voudrais faire une boucle qui affiche une nouvelle génération au
hasard chaque seconde. Je dois avouer que cette histoire de canvas, je la sens
pas trop. Et le code que j'ai pondu s'en ressent. D'abord je mets ce qui a trait
à une génération dans un module à part:</p>

<p>``` racket generation.rkt</p>

<h1>lang racket</h1>

<p>(define (create-generation width height)
  (for/list ([i (make-list height 0)])</p>

<pre><code>        (make-list width (random 2))))
</code></pre>

<p>(provide create-generation)
```</p>

<p>Puis, tout le bazar de frame et de canvas, aussi dans un module:</p>

<p>``` racket window.rkt</p>

<h1>lang racket/gui</h1>

<p>(define (create-window w h g)
  (define frame (new frame%</p>

<pre><code>                 [label "Game of Life"]
                 [width w]
                 [height h]))
</code></pre>

<p>  (define canvas (new (class canvas%</p>

<pre><code>     (super-new [parent frame] [style '(no-autoclear)])
     (define current-generation g)
     (define dc (send this get-dc))
     (define/public (change-generation g)
       (set! current-generation g)
       (send this refresh-now))
     (define/override (on-paint)
       (send dc set-brush (new brush% [color "black"]))
       (send dc draw-rectangle 0 0 w h)
       (send dc set-brush (new brush% [color "white"]))
       (for ([y (length current-generation)])
         (for ([x (length (first current-generation))])
           (when (= 1 (list-ref (list-ref current-generation y) x))
             (send dc draw-rectangle x y 1 1))))))))
</code></pre>

<p>  (send frame show #t)
  canvas)</p>

<p>(provide create-window)
```</p>

<p>Moi qui suis habitué à des méthodes de 2 ou 3 lignes, c'est pas vraiment ça.
Et puis j'ai du mal à saisir le modèle objet de Racket.</p>

<p>Enfin le programme principal avec la boucle:</p>

<p>``` racket game-of-life.rkt</p>

<h1>lang racket</h1>

<p>(require &ldquo;generation.rkt&rdquo;</p>

<pre><code>     "window.rkt")
</code></pre>

<p>(define size 100)
(define generation (create-generation size size))
(define canvas (create-window size size generation))</p>

<p>(define (loop n)
  (send canvas change-generation (create-generation size size))
  (sleep 1)
  (when (> n 0)</p>

<pre><code>(loop (sub1 n))))
</code></pre>

<p>(loop 10)
```</p>

<p>Si j'ai le temps, j'essaierais d'utiliser la bibliothèque <code>2htdp/universe</code>,
qui me semble bien plus simple.</p>

<p>Maintenant le bug. Le problème est que je crée des lignes complètes de 0 ou de 1
dans la liste qui représente une génération, plutôt que de distribuer
uniformément ces 0 et ces 1. Je vais donc ajouter un test qui initialise le
générateur de nombres aléatoires toujours de la même manière.</p>

<p>``` racket game-of-life-test.rkt</p>

<h1>lang racket</h1>

<p>(require rackunit</p>

<pre><code>     "generation.rkt")
</code></pre>

<p>&hellip;</p>

<p>((λ ()
   (random-seed 1)
   (check-equal? (create-generation 2 3) &lsquo;((1 1) (0 1) (1 1))</p>

<pre><code>             "It populates generation uniformly")))
</code></pre>

<p>```</p>

<p>Sans surprise, le test échoue.</p>

<pre><code>$ racket game-of-life-test.rkt
--------------------
FAILURE
actual:     ((1 1) (1 1) (0 0))
expected:   ((1 0) (1 0) (1 0))
name:       check-equal?
location:   (#&lt;path:/home/xavier/code/game-of-life-racket/game-of-life-test.rkt&gt; 21 3 537 112)
expression: (check-equal? (create-generation 2 3) (quote ((1 0) (1 0) (1 0))))
message:    "It populates generation uniformly"
</code></pre>

<p>Et voici le fix.</p>

<p>``` racket generation.rkt</p>

<h1>lang racket</h1>

<p>(define (create-generation width height)
  (define (rnd _)</p>

<pre><code>(random 2))
</code></pre>

<p>  (for/list ([i (make-list height 0)])</p>

<pre><code>        (map rnd (make-list width 0))))
</code></pre>

<p>(provide create-generation)
```</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Le jeu de la vie en racket - partie 1]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/11/01/le-jeu-de-la-vie-en-racket-partie-1/"/>
    <updated>2014-11-01T12:22:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/11/01/le-jeu-de-la-vie-en-racket-partie-1</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Le troisième volet de cette série <a href="http://lkdjiin.github.io/blog/2014/10/08/le-jeu-de-la-vie-dans-sept-langages-differents/">le jeu de la vie en 7 langages</a>
sera consacré à <a href="http://racket-lang.org/">Racket</a>, un dialecte de Lisp.
Télécharger le ici: <a href="http://download.racket-lang.org/">http://download.racket-lang.org/</a>
et installez avec <code>bash ./nom-du-fichier.sh</code></p>

<!-- more -->


<p>On commence par un <em>smoke test</em> pour être sûr que Racket est bien installé et
accessible. Dans un fichier <code>game-of-life-test.rkt</code>, chargez le framework de
test et le futur fichier d'implémentation.</p>

<p>``` racket game-of-life-test.rkt</p>

<h1>lang racket</h1>

<p>(require rackunit</p>

<pre><code>     "game-of-life.rkt")
</code></pre>

<p>```</p>

<p>Puis executez le :</p>

<pre><code>$ racket game-of-life-test.rkt
game-of-life-test.rkt:4:9: cannot open module file
</code></pre>

<p>Cool, Racket est là et nous dit qu'il ne peut pas ouvrir le fichier
<code>game-of-life.rkt</code>. Créons le :</p>

<pre><code>touch game-of-life.rkt
</code></pre>

<p>``` racket game-of-life.rkt</p>

<h1>lang racket</h1>

<p>```</p>

<p>Premier test maintenant, la fonction <code>create-generation</code> doit renvoyer une
liste.</p>

<p>``` racket game-of-life-test.rkt</p>

<h1>lang racket</h1>

<p>(require rackunit</p>

<pre><code>     "game-of-life.rkt")
</code></pre>

<p>(check-pred list? (create-generation 3 4))
```</p>

<pre><code>$ racket game-of-life-test.rkt 
game-of-life-test.rkt:6:19: create-generation: unbound identifier in module
</code></pre>

<p>Ok, on renvoie donc une liste vide <code>'()</code>. Notez aussi <code>provide</code>, qui permet de
définir en quelque sorte les fonctions publiques du fichier.</p>

<p>``` racket game-of-life.rkt</p>

<h1>lang racket</h1>

<p>(define (create-generation width height)
  &lsquo;())</p>

<p>(provide create-generation)
```</p>

<p><code>rackunit</code>, le framework de test <em>shippé</em> avec Racket peut aussi documenter
les tests:</p>

<p>``` racket game-of-life-test.rkt
(check-equal? (length (create-generation 3 4)) 4</p>

<pre><code>          "It builds a list with the right height")
</code></pre>

<p>```</p>

<p>On crée une liste de la bonne taille, et comme on se fiche pour l'instant de ce
qu'elle contient, on peut l'initialiser avec des zéros.</p>

<p><code>racket game-of-life.rkt
(define (create-generation width height)
  (make-list height 0))
</code></p>

<p>Chaque élément de la liste doit aussi être une liste (la dimension <code>x</code>).</p>

<p>``` racket game-of-life-test.rkt
(check-equal? (length (first (create-generation 3 4))) 3</p>

<pre><code>          "It builds a list with the right width")
</code></pre>

<p>```</p>

<pre><code>$ racket game-of-life-test.rkt 
length: contract violation
  expected: list?
  given: 0
</code></pre>

<p>J'utilise <code>for/list</code> pour construire cette fameuse liste à deux dimensions. Les
différentes variantes de <code>for</code> me semble très utilisées en Racket.</p>

<p>``` racket game-of-life.rkt
(define (create-generation width height)
  (for/list ([i (make-list height 0)])</p>

<pre><code>        (make-list width 0)))
</code></pre>

<p>```</p>

<p>Finalement, je veux que ma liste contiennent des <code>0</code> (cellule morte) et des
<code>1</code> (cellule vivante).</p>

<p>``` racket game-of-life-test.rkt
(let ([cell (first (first (create-generation 3 4)))])
  (check-true (or (= cell 0) (= cell 1))</p>

<pre><code>          "It populates generation with 0s or 1s"))
</code></pre>

<p>```</p>

<p>``` racket game-of-life.rkt
(define (create-generation width height)
  (for/list ([i (make-list height 0)])</p>

<pre><code>        (make-list width (random 2))))
</code></pre>

<p>```</p>

<p>Ce dernier bout de code contient un bug qui n'est pas attrapé par les
tests (vous l'avez vu ?). Je <em>fixerais</em> ça dans le prochain article.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Le jeu de la vie en ruby (opal) - partie 3]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/10/29/le-jeu-de-la-vie-en-ruby-opal-partie-3/"/>
    <updated>2014-10-29T07:18:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/10/29/le-jeu-de-la-vie-en-ruby-opal-partie-3</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Il est temps de tout assembler, pour ça on va écrire une classe <code>Game</code> qui va
jouer le rôle de chef d'orchestre.</p>

<!-- more -->


<h2>La classe Game</h2>

<p>``` ruby
class Game</p>

<p>  def initialize(generation, canvas, iterations)</p>

<pre><code>@iterations = iterations
@height = generation.size
@width = generation.first.size
@generation = generation
@canvas = canvas
</code></pre>

<p>  end</p>

<p>  def start</p>

<pre><code>draw
@iterations -= 1
if @iterations &gt; 0
  update
  after_ms(500) { start }
end
</code></pre>

<p>  end</p>

<p>  def draw</p>

<pre><code>@canvas.clear
@generation.each_with_index do |line, y|
  line.each_with_index do |cell, x|
    @canvas.pixel(x, y) if cell == 1
  end
end
</code></pre>

<p>  end</p>

<p>  def update</p>

<pre><code>new_generation = (0...@height).map do |y|
  (0...@width).map do |x|
    extractor = NeighborhoodExtractor.new(@generation, x, y)
    Neighborhood.new(extractor.cells).next_state
  end
end
@generation = new_generation
</code></pre>

<p>  end</p>

<p>end
```</p>

<p>Rien d'exceptionnel dans ce code, à part la ligne suivante, extraite de la
méthode <code>start</code>:</p>

<p>``` ruby</p>

<pre><code>  after_ms(500) { start }
</code></pre>

<p>```</p>

<p>Qu'est-ce que c'est que cette méthode <code>after_ms</code> ?</p>

<p>Je ne peux pas faire une bête boucle <code>loop</code>, ou un appel récursif à <code>start</code>
puisqu'on est en Opal.rb, et pas <em>vraiment</em> en Ruby. Le code qui tourne, au
final, sera du Javascript. Et si on n'insère pas des petites pauses, le
navigateur ne va pas aimer du tout. Et puisqu'en Javascript il n'existe pas de
fonction <code>pause</code>, il n'y en a pas non plus en Opal.rb.</p>

<p>J'avoue que je me suis gratter un peu la tête avant de trouver une solution
toute simple. Il suffit d'écrire un <em>wrapper</em> autour de la fonction Javascript
<code>setTimeout</code>:</p>

<p>``` ruby app/kernel.rb
module Kernel</p>

<p>  def after_ms(n, &amp;block)</p>

<pre><code>`setTimeout(function() {`
  block.call
`}, n);`
</code></pre>

<p>  end</p>

<p>end
```</p>

<h2>Mise à l'échelle de l'affichage</h2>

<p>Ça, c'est très simple.</p>

<p>``` html index.html
&lt;!DOCTYPE html>
<html>
  &hellip;
  <body></p>

<pre><code>&lt;canvas width="400" height="400" id="canvas"&gt;&lt;/canvas&gt;
&lt;script src="build.js"&gt;&lt;/script&gt;
</code></pre>

<p>  </body>
</html>
```</p>

<p>``` ruby app/canvas.rb
class Canvas</p>

<p>  SCALE = 4</p>

<p>  def initialize</p>

<pre><code>@canvas  = `document.getElementById('canvas')`
@context = `#@canvas.getContext('2d')`
@height  = `#@canvas.height`
@width   = `#@canvas.width`
</code></pre>

<p>  end</p>

<p>  def clear</p>

<pre><code>draw_rect(0, 0, @width, @height, 'black')
</code></pre>

<p>  end</p>

<p>  def pixel(x, y)</p>

<pre><code>draw_rect(x * SCALE, y * SCALE, SCALE, SCALE, 'white')
</code></pre>

<p>  end</p>

<p>  private</p>

<p>  def draw_rect(x, y, w, h, color)</p>

<pre><code>`#@context.fillStyle = #{color}`
`#@context.fillRect(#{x}, #{y}, #{w}, #{h})`
</code></pre>

<p>  end</p>

<p>end
```</p>

<h2>Supprimer les bordures</h2>

<p>Ça, c'est très ennuyeux, vous pouvez sauter directement à la fin de l'article.</p>

<p>Je désactive les tests des bordures, puis je les réécrit un par un.</p>

<p>``` ruby spec/neighborhood_extractor_spec.rb
require &lsquo;./app/neighborhood_extractor.rb&rsquo;</p>

<p>describe NeighborhoodExtractor do</p>

<p>  let(:generation) do</p>

<pre><code>[
  [0, 1, 0, 1],
  [1, 0, 1, 0],
  [0, 1, 1, 0]
]
</code></pre>

<p>  end</p>

<p>  &hellip;</p>

<p>  describe &lsquo;borders&rsquo; do</p>

<pre><code>specify 'x=1 y=0' do
  extractor = NeighborhoodExtractor.new(generation, 1, 0)
  expect(extractor.cells).to eq [0, 1, 1, 0, 1, 0, 1, 0, 1]
end

# specify 'x=2 y=2' do
#   extractor = NeighborhoodExtractor.new(generation, 2, 2)
#   expect(extractor.cells).to eq [0, 1, 0, 1, 1, 0, 0, 0, 0]
# end

# specify 'x=0 y=1' do
#   extractor = NeighborhoodExtractor.new(generation, 0, 1)
#   expect(extractor.cells).to eq [0, 0, 1, 0, 1, 0, 0, 0, 1]
# end

# specify 'x=3 y=1' do
#   extractor = NeighborhoodExtractor.new(generation, 3, 1)
#   expect(extractor.cells).to eq [0, 1, 0, 1, 0, 0, 1, 0, 0]
# end
</code></pre>

<p>  end
end
```</p>

<p>``` ruby app/neighborhood_extractor.rb
  def group_of_tree(row_index)</p>

<pre><code>if row_index &lt; 0
  generation[generation.size-1][x-1..x+1]
elsif row_index == generation.size
  [0, 0, 0]
else
  if x == 0
    [ 0, *generation[row_index][x..x+1] ]
  elsif x == generation.first.size - 1
    [*generation[row_index][x-1..x], 0]
  else
    generation[row_index][x-1..x+1]
  end
end
</code></pre>

<p>  end
```</p>

<p>Après refactoring</p>

<p>``` ruby app/neighborhood_extractor.rb
class NeighborhoodExtractor &lt; Struct.new(:generation, :x, :y)</p>

<p>  def cells</p>

<pre><code>[ *extract(y - 1), *extract(y), *extract(y + 1) ]
</code></pre>

<p>  end</p>

<p>  private</p>

<p>  def extract(row_index)</p>

<pre><code>row_index = generation.size - 1 if row_index &lt; 0
group_of_tree(row_index)
</code></pre>

<p>  end</p>

<p>  def group_of_tree(row_index)</p>

<pre><code>if row_index == generation.size
  [0, 0, 0]
else
  if x == 0
    [ 0, *generation[row_index][x..x+1] ]
  elsif x == generation.first.size - 1
    [*generation[row_index][x-1..x], 0]
  else
    generation[row_index][x-1..x+1]
  end
end
</code></pre>

<p>  end</p>

<p>end
```</p>

<p>``` ruby spec/neighborhood_extractor_spec.rb
  describe &lsquo;borders&rsquo; do</p>

<pre><code>...

specify 'x=2 y=2' do
  extractor = NeighborhoodExtractor.new(generation, 2, 2)
  expect(extractor.cells).to eq [0, 1, 0, 1, 1, 0, 1, 0, 1]
end
</code></pre>

<p>```</p>

<p>``` ruby app/neighborhood_extractor.rb
class NeighborhoodExtractor &lt; Struct.new(:generation, :x, :y)</p>

<p>  def cells</p>

<pre><code>[ *extract(y - 1), *extract(y), *extract(y + 1) ]
</code></pre>

<p>  end</p>

<p>  private</p>

<p>  def extract(row_index)</p>

<pre><code>group_of_tree(ensure_overlapping(row_index))
</code></pre>

<p>  end</p>

<p>  def ensure_overlapping(index)</p>

<pre><code>if index &lt; 0
  generation.size - 1
elsif index == generation.size
  0
else
  index
end
</code></pre>

<p>  end</p>

<p>  def group_of_tree(row_index)</p>

<pre><code>if x == 0
  [ 0, *generation[row_index][x..x+1] ]
elsif x == generation.first.size - 1
  [*generation[row_index][x-1..x], 0]
else
  generation[row_index][x-1..x+1]
end
</code></pre>

<p>  end</p>

<p>end
```</p>

<p>``` ruby spec/neighborhood_extractor_spec.rb
  describe &lsquo;borders&rsquo; do</p>

<pre><code>...

specify 'x=0 y=1' do
  extractor = NeighborhoodExtractor.new(generation, 0, 1)
  expect(extractor.cells).to eq [1, 0, 1, 0, 1, 0, 0, 0, 1]
end

specify 'x=3 y=1' do
  extractor = NeighborhoodExtractor.new(generation, 3, 1)
  expect(extractor.cells).to eq [0, 1, 0, 1, 0, 1, 1, 0, 0]
end
</code></pre>

<p>```</p>

<p>Ça y est, on y voit plus clair.</p>

<p>``` ruby app/neighborhood_extractor.rb
class NeighborhoodExtractor &lt; Struct.new(:generation, :x, :y)</p>

<p>  def cells</p>

<pre><code>[ *extract(y - 1), *extract(y), *extract(y + 1) ]
</code></pre>

<p>  end</p>

<p>  private</p>

<p>  def extract(row_index)</p>

<pre><code>group_of_tree(ensure_overlapping(row_index))
</code></pre>

<p>  end</p>

<p>  def ensure_overlapping(index)</p>

<pre><code>if index &lt; 0
  generation.size - 1
elsif index == generation.size
  0
else
  index
end
</code></pre>

<p>  end</p>

<p>  def group_of_tree(row_index)</p>

<pre><code>row = generation[row_index]
if x == 0
  [row[-1], *row[x..x+1] ]
elsif x == generation.first.size - 1
  [*row[x-1..x], row[0]]
else
  row[x-1..x+1]
end
</code></pre>

<p>  end</p>

<p>end
```</p>

<p>Voilà, Ruby/Opal.rb c'est fait. Vous pouvez trouver le code sur Github si vous
êtes intéressés : <a href="https://github.com/lkdjiin/game-of-life-ruby">Le jeu de la vie en ruby/opal.rb</a>.</p>

<p>La prochaine version sera écrite en Racket, un dialecte de Lisp.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Le jeu de la vie en ruby (opal) - partie 2]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/10/27/le-jeu-de-la-vie-en-ruby-opal-partie-2/"/>
    <updated>2014-10-27T21:09:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/10/27/le-jeu-de-la-vie-en-ruby-opal-partie-2</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Deuxième partie du jeu de la vie en Ruby/Opal.rb, on va calculer le prochain
état d'une cellule, et extraire un <em>voisinage</em> de cellules d'une génération.
Après l'avoir écrit en Javascript, j'avoue que cette partie est quelque peu
ennuyeuse à reproduire. Je vais montrer du code, mais il y aura peu
d'explications, la logique étant la même qu'en Javascript (quoiqu'à base de
classes cette fois-ci).</p>

<!-- more -->


<p>Premier test et première classe pour spécifier une API.</p>

<p>``` ruby spec/neighborhood_spec.rb
require &lsquo;./app/neighborhood.rb&rsquo;</p>

<p>describe Neighborhood do</p>

<p>  let(:alive) { [1, 1, 1, 0, 0, 0, 0, 0, 0] }</p>

<p>  describe &lsquo;#next_state&rsquo; do</p>

<pre><code>it 'returns 1 when it will be alive' do
  neighborhood = Neighborhood.new(alive)
  expect(neighborhood.next_state).to eq 1
end
</code></pre>

<p>  end</p>

<p>end
```</p>

<p>``` ruby app/neighborhood.rb
class Neighborhood</p>

<p>  def initialize(cells)</p>

<pre><code>@cells = cells
</code></pre>

<p>  end</p>

<p>  def next_state</p>

<pre><code>1
</code></pre>

<p>  end
end
```</p>

<p><code>next_state</code> doit être capable de determiner que la cellule va mourrir.</p>

<p>``` ruby spec/neighborhood_spec.rb
require &lsquo;./app/neighborhood.rb&rsquo;</p>

<p>describe Neighborhood do</p>

<p>  let(:alive)       { [1, 1, 1, 0, 0, 0, 0, 0, 0] }
  let(:dead)        { [0, 0, 1, 0, 0, 0, 0, 0, 0] }
  let(:dead2)       { [1, 1, 1, 1, 1, 1, 1, 1, 1] }
  let(:dead3)       { [0, 0, 0, 0, 0, 0, 0, 0, 0] }</p>

<p>  describe &lsquo;#next_state&rsquo; do</p>

<pre><code>...

it 'returns 0 when it will be dead' do
  [dead, dead2, dead3].each do |cells|
    neighborhood = Neighborhood.new(cells)
    expect(neighborhood.next_state).to eq 0
  end
end
</code></pre>

<p>```</p>

<p>``` ruby app/neighborhood.rb
class Neighborhood</p>

<p>  ALIVE = 3</p>

<p>  def initialize(cells)</p>

<pre><code>@sum = cells.reduce(:+)
</code></pre>

<p>  end</p>

<p>  def next_state</p>

<pre><code>@sum == ALIVE ? 1 : 0
</code></pre>

<p>  end
end
```</p>

<p>Quand le nombre de cellules vivantes du voisinage est 4, le prochain état de
la cellule est le même que l'état actuel.</p>

<p>``` ruby spec/neighborhood_spec.rb
require &lsquo;./app/neighborhood.rb&rsquo;</p>

<p>describe Neighborhood do</p>

<p>  &hellip;</p>

<p>  let(:status_quo1) { [1, 1, 1, 1, 0, 0, 0, 0, 0] }
  let(:status_quo2) { [0, 1, 1, 1, 1, 0, 0, 0, 0] }</p>

<p>  describe &lsquo;#next_state&rsquo; do</p>

<pre><code>...

it 'returns old state in other cases' do
  neighborhood = Neighborhood.new(status_quo1)
  expect(neighborhood.next_state).to eq 0

  neighborhood = Neighborhood.new(status_quo2)
  expect(neighborhood.next_state).to eq 1
end
</code></pre>

<p>  end</p>

<p>end
```</p>

<p>``` ruby app/neighborhood.rb
class Neighborhood</p>

<p>  ALIVE = 3
  STATUS_QUO = 4</p>

<p>  def initialize(cells)</p>

<pre><code>@subject = cells[4]
@sum = cells.reduce(:+)
</code></pre>

<p>  end</p>

<p>  def next_state</p>

<pre><code>case @sum
when ALIVE then 1
when STATUS_QUO then @subject
else
  0
end
</code></pre>

<p>  end
end
```</p>

<h2>Extraire un voisinage de cellules</h2>

<p>Il faut pouvoir extraire un ensemble de 9 cellules (le <em>voisinage</em>) d'une
génération.</p>

<p>``` ruby spec/neighborhood_extractor_spec.rb
require &lsquo;./app/neighborhood_extractor.rb&rsquo;</p>

<p>describe NeighborhoodExtractor do</p>

<p>  let(:generation) do</p>

<pre><code>[
  [0, 1, 0, 1],
  [1, 0, 1, 0],
  [0, 1, 1, 0]
]
</code></pre>

<p>  end</p>

<p>  it &lsquo;returns 9 cells&rsquo; do</p>

<pre><code>x, y = 1, 1
extractor = NeighborhoodExtractor.new(generation, x, y)
expect(extractor.cells.size).to eq 9
</code></pre>

<p>  end</p>

<p>end
```</p>

<p>Ça, c'est juste la mise en train.</p>

<p>``` ruby app/neighborhood_extractor.rb
class NeighborhoodExtractor</p>

<p>  def initialize(generation, x, y)
  end</p>

<p>  def cells</p>

<pre><code>Array.new(9)
</code></pre>

<p>  end
end
```</p>

<p>Là, on commence à faire quelque chose d'utile.</p>

<p>``` ruby spec/neighborhood_extractor_spec.rb
describe NeighborhoodExtractor do</p>

<p>  let(:generation) do</p>

<pre><code>[
  [0, 1, 0, 1],
  [1, 0, 1, 0],
  [0, 1, 1, 0]
]
</code></pre>

<p>  end</p>

<p>  &hellip;</p>

<p>  describe &lsquo;inner position&rsquo; do</p>

<pre><code>specify 'x=1 y=1' do
  extractor = NeighborhoodExtractor.new(generation, 1, 1)
  expect(extractor.cells).to eq [0, 1, 0, 1, 0, 1, 0, 1, 1]
end
</code></pre>

<p>  end
end
```</p>

<p>``` ruby app/neighborhood_extractor.rb
class NeighborhoodExtractor &lt; Struct.new(:generation, :x, :y)</p>

<p>  def cells</p>

<pre><code>[
  *generation[y-1][x-1..x+1],
  *generation[y][x-1..x+1],
  *generation[y+1][x-1..x+1],
]
</code></pre>

<p>  end
end
```</p>

<p>Maintenant, voyons le problème des bordures.</p>

<p>``` ruby spec/neighborhood_extractor_spec.rb
  describe &lsquo;borders&rsquo; do</p>

<pre><code>specify 'x=1 y=0' do
  extractor = NeighborhoodExtractor.new(generation, 1, 0)
  expect(extractor.cells).to eq [0, 0, 0, 0, 1, 0, 1, 0, 1]
end
</code></pre>

<p>  end
```</p>

<p>La manière dont le test échoue est intéressante. C'est du à la façon dont Ruby
gère les indexs négatifs pour les tableaux, ceux-cis sont parfaitement
autorisés.</p>

<pre><code>Failures:

  1) NeighborhoodExtractor borders x=1 y=0
     Failure/Error: expect(extractor.cells).to eq [0, 0, 0, 0, 1, 0, 1, 0, 1]

       expected: [0, 0, 0, 0, 1, 0, 1, 0, 1]
            got: [0, 1, 1, 0, 1, 0, 1, 0, 1]

       (compared using ==)
     # ./spec/neighborhood_extractor_spec.rb:29:in `block (3 levels) in &lt;top (required)&gt;'
</code></pre>

<p>``` ruby app/neighborhood_extractor.rb
class NeighborhoodExtractor &lt; Struct.new(:generation, :x, :y)</p>

<p>  def cells</p>

<pre><code>[
  *row1,
  *generation[y][x-1..x+1],
  *generation[y+1][x-1..x+1],
]
</code></pre>

<p>  end</p>

<p>  def row1</p>

<pre><code>if y == 0
  [0, 0, 0]
else
  generation[y-1][x-1..x+1]
end
</code></pre>

<p>  end
end
```</p>

<p>Testons avec la bordure du bas.</p>

<p>``` ruby spec/neighborhood_extractor_spec.rb</p>

<pre><code>specify 'x=2 y=2' do
  extractor = NeighborhoodExtractor.new(generation, 2, 2)
  expect(extractor.cells).to eq [0, 1, 0, 1, 1, 0, 0, 0, 0]
end
</code></pre>

<p>```</p>

<p>``` ruby app/neighborhood_extractor.rb
class NeighborhoodExtractor &lt; Struct.new(:generation, :x, :y)</p>

<p>  &hellip;</p>

<p>  def row3</p>

<pre><code>if y == generation.size - 1
  [0, 0, 0]
else
  generation[y+1][x-1..x+1]
end
</code></pre>

<p>  end
end
```</p>

<p>Un peu de refactoring.</p>

<p>``` ruby app/neighborhood_extractor.rb
class NeighborhoodExtractor &lt; Struct.new(:generation, :x, :y)</p>

<p>  def cells</p>

<pre><code>[ *group_of_tree(y - 1), *group_of_tree(y), *group_of_tree(y + 1) ]
</code></pre>

<p>  end</p>

<p>  def group_of_tree(row)</p>

<pre><code>if row &lt; 0 || row == generation.size
  [0, 0, 0]
else
  generation[row][x-1..x+1]
end
</code></pre>

<p>  end</p>

<p>end
```</p>

<p>La bordure de gauche.</p>

<p>``` ruby spec/neighborhood_extractor_spec.rb</p>

<pre><code>specify 'x=0 y=1' do
  extractor = NeighborhoodExtractor.new(generation, 0, 1)
  expect(extractor.cells).to eq [0, 0, 1, 0, 1, 0, 0, 0, 1]
end
</code></pre>

<p>```</p>

<p>``` ruby app/neighborhood_extractor.rb
class NeighborhoodExtractor &lt; Struct.new(:generation, :x, :y)</p>

<p>  def cells</p>

<pre><code>[ *group_of_tree(y - 1), *group_of_tree(y), *group_of_tree(y + 1) ]
</code></pre>

<p>  end</p>

<p>  def group_of_tree(row)</p>

<pre><code>if row &lt; 0 || row == generation.size
  [0, 0, 0]
else
  if x == 0
    [ 0, *generation[row][x..x+1] ]
  else
    generation[row][x-1..x+1]
  end
end
</code></pre>

<p>  end</p>

<p>end
```</p>

<p>Et enfin celle de droite.</p>

<p>``` ruby spec/neighborhood_extractor_spec.rb</p>

<pre><code>specify 'x=3 y=1' do
  extractor = NeighborhoodExtractor.new(generation, 3, 1)
  expect(extractor.cells).to eq [0, 1, 0, 1, 0, 0, 1, 0, 0]
end
</code></pre>

<p>```</p>

<p>Ok, c'est moche, mais ça fonctionne.</p>

<p>``` ruby app/neighborhood_extractor.rb
class NeighborhoodExtractor &lt; Struct.new(:generation, :x, :y)</p>

<p>  def cells</p>

<pre><code>[ *group_of_tree(y - 1), *group_of_tree(y), *group_of_tree(y + 1) ]
</code></pre>

<p>  end</p>

<p>  def group_of_tree(row_index)</p>

<pre><code>if row_index &lt; 0 || row_index == generation.size
  [0, 0, 0]
else
  if x == 0
    [ 0, *generation[row_index][x..x+1] ]
  elsif x == generation.first.size - 1
    [*generation[row_index][x-1..x], 0]
  else
    generation[row_index][x-1..x+1]
  end
end
</code></pre>

<p>  end</p>

<p>end
```</p>

<p>Je devrais <em>refactorer</em> ce code, mais comme je sais qu'il va bientôt changer
(quand on va supprimer les bordures de la surface de jeu) je me dis qu'on verra
bien à ce moment là.</p>

<p>À noter pour finir que je ne teste pas les cas des cellules de coin. Nous avons
vu dans la version Javascript que si les cellules des bords droits, gauches,
hauts et bas fonctionnent, alors les coins fonctionnent aussi.</p>

<p>La prochaine fois on verra la classe <code>Game</code> et une petite astuce pour faire
un <code>sleep</code> like en Opal.rb.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Le jeu de la vie en ruby (opal) - partie 1]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/10/25/le-jeu-de-la-vie-en-ruby-opal-partie-1/"/>
    <updated>2014-10-25T18:13:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/10/25/le-jeu-de-la-vie-en-ruby-opal-partie-1</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Après la <a href="http://lkdjiin.github.io/blog/2014/10/16/le-jeu-de-la-vie-en-javascript-partie-1/">version Javascript</a> du jeu de la vie, je débute la version
Ruby/Opal.</p>

<!-- more -->


<h2>Obtenir une première génération au hasard</h2>

<pre><code>$ touch app/generation.rb
$ touch spec/generation_spec.rb
$ tree
.
├── app
│   └── generation.rb
└── spec
    └── generation_spec.rb
</code></pre>

<p>Mon premier test consiste à spécifier l'interface publique.</p>

<p>``` ruby generation_spec.rb
require &lsquo;./app/generation.rb&rsquo;</p>

<p>describe Generation do</p>

<p>  before do</p>

<pre><code>@width = 4
@height = 3
</code></pre>

<p>  end</p>

<p>  specify { expect(Generation.new(@width, @height)).to respond_to :create }</p>

<p>end
```</p>

<p>Et on le fait passer facilement.</p>

<p>``` ruby generation.rb
class Generation</p>

<p>  def initialize(width, height)
  end</p>

<p>  def create
  end</p>

<p>end
```</p>

<p>Un test en plus pour s'assurer que le tableau possède le bon nombre de lignes.</p>

<p>``` ruby generation_spec.rb
  describe &lsquo;#create&rsquo; do</p>

<pre><code>it 'returns an array with the right height' do
  generation = Generation.new(@width, @height).create
  expect(generation.size).to eq @height
end
</code></pre>

<p>  end
```</p>

<p>Encore une fois, le code vient facilement.</p>

<p>``` ruby generation.rb
class Generation</p>

<p>  def initialize(width, height)</p>

<pre><code>@height = height
</code></pre>

<p>  end</p>

<p>  def create</p>

<pre><code>Array.new(@height)
</code></pre>

<p>  end
end
```</p>

<p>Même chose maintenant avec le nombre de colonnes.</p>

<p>``` ruby generation_spec.rb
  describe &lsquo;#create&rsquo; do</p>

<pre><code>...
it 'returns an array with the right width' do
  generation = Generation.new(@width, @height).create
  expect(generation.first.size).to eq @width
end
</code></pre>

<p>  end
```</p>

<p>Pour faire passer ce test, on crée un tableau à deux dimensions.</p>

<p>``` ruby generation.rb
class Generation</p>

<p>  def initialize(width, height)</p>

<pre><code>@height = height
@width = width
</code></pre>

<p>  end</p>

<p>  def create</p>

<pre><code>Array.new(@height) { Array.new(@width) }
</code></pre>

<p>  end
end
```</p>

<p>On remarque l'expression <code>Generation.new(@width, @height)</code>, en commun dans
chaque test. C'est notre premier refactoring.</p>

<p>``` ruby generation_spec.rb
require &lsquo;./app/generation.rb&rsquo;</p>

<p>describe Generation do</p>

<p>  before do</p>

<pre><code>@width = 4
@height = 3
@generation = Generation.new(@width, @height)
</code></pre>

<p>  end</p>

<p>  specify { expect(@generation).to respond_to :create }</p>

<p>  describe &lsquo;#create&rsquo; do</p>

<pre><code>it 'returns an array with the right height' do
  expect(@generation.create.size).to eq @height
end

it 'returns an array with the right width' do
  expect(@generation.create.first.size).to eq @width
end
</code></pre>

<p>  end</p>

<p>end
```</p>

<h3>Du hasard maitrisé</h3>

<p>Je veux être sûr que la méthode <code>create</code> remplit bien le tableau avec soit des
<code>0</code>, soit des <code>1</code>. Pour tester ça facilement, je vais <em>figer</em> le générateur de
nombre aléatoire à l'aide de <code>srand</code>.</p>

<p>``` ruby generation_spec.rb</p>

<pre><code>it 'creates random cells' do
  srand(0)
  expect(@generation.create.first).to eq [0, 1, 1, 0]
end
</code></pre>

<p>```</p>

<p>``` ruby app/generation.rb
  def create</p>

<pre><code>Array.new(@height) { Array.new(@width) { rand(2) } }
</code></pre>

<p>  end
```</p>

<h2>Afficher une génération</h2>

<p>C'est la partie que je crains le plus avec certains langages. Avec Javascript
par exemple, pas de problème, mais avec Haskell, Rust ou Julia je n'ai aucune
idée des bibliothèques/frameworks/wrappers à employer.</p>

<p>Avec Ruby le souci est ailleurs. Je considère que l'écosystème Ruby est
horrible dès qu'on touche de près ou de loin au GUI. Je vais donc tricher
quelque peu et utiliser <a href="http://opalrb.org/">opal.rb</a>.</p>

<p>La structure de l'application va bien changer :</p>

<pre><code>$ tree
.
├── app
│   ├── application.rb
│   ├── canvas.rb
│   └── generation.rb
├── build.js
├── Gemfile
├── index.html
├── Rakefile
└── spec
    └── generation_spec.rb
</code></pre>

<p><code>ruby Gemfile
gem "opal", "&gt;= 0.6.2"
</code></p>

<p>``` ruby Rakefile
require &lsquo;opal&rsquo;</p>

<p>desc &ldquo;Build our app to build.js&rdquo;
task :build do
  Opal::Processor.source_map_enabled = false
  env = Opal::Environment.new
  env.append_path &ldquo;app&rdquo;</p>

<p>  File.open(&ldquo;build.js&rdquo;, &ldquo;w+&rdquo;) do |out|</p>

<pre><code>out &lt;&lt; env["application"].to_s
</code></pre>

<p>  end
end
```</p>

<p>``` html index.html
&lt;!DOCTYPE html>
<html>
  <head></p>

<pre><code>&lt;meta charset="utf-8" /&gt;
&lt;title&gt;Game of Life&lt;/title&gt;
</code></pre>

<p>  </head>
  <body></p>

<pre><code>&lt;canvas width="100" height="100" id="canvas"&gt;&lt;/canvas&gt;
&lt;script src="build.js"&gt;&lt;/script&gt;
</code></pre>

<p>  </body>
</html>
```</p>

<p>Dans <code>Canvas</code> j'écris une sorte d'adaptateur pour utiliser un <code>canvas</code>
Javascript.</p>

<p>``` ruby app/canvas.rb
class Canvas</p>

<p>  attr_reader :width, :height</p>

<p>  def initialize</p>

<pre><code>@canvas  = `document.getElementById('canvas')`
@context = `#@canvas.getContext('2d')`
@height  = `#@canvas.height`
@width   = `#@canvas.width`
</code></pre>

<p>  end</p>

<p>  def clear</p>

<pre><code>draw_rect(0, 0, @width, @height, 'black')
</code></pre>

<p>  end</p>

<p>  def pixel(x, y)</p>

<pre><code>draw_rect(x, y, 1, 1, 'white')
</code></pre>

<p>  end</p>

<p>  private</p>

<p>  def draw_rect(x, y, w, h, color)</p>

<pre><code>`#@context.fillStyle = #{color}`
`#@context.fillRect(#{x}, #{y}, #{w}, #{h})`
</code></pre>

<p>  end</p>

<p>end
```</p>

<p>Dans <code>app/application.rb</code> je peux maintenant afficher une génération.</p>

<p>``` ruby app/application.rb
require &lsquo;opal&rsquo;
require &lsquo;canvas&rsquo;
require &lsquo;generation&rsquo;</p>

<p>canvas = Canvas.new
canvas.clear</p>

<p>generation = Generation.new(canvas.width, canvas.height)
cells = generation.create</p>

<p>cells.each_with_index do |line, y|
  line.each_with_index do |cell, x|</p>

<pre><code>canvas.pixel(x, y) if cell == 1
</code></pre>

<p>  end
end
```</p>

<p>Après un <code>rake build</code>, on peut lancer l'application avec <code>see index.html</code>.</p>

<p>La suite la prochaine fois.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p></p>
]]></content>
  </entry>
  
</feed>
