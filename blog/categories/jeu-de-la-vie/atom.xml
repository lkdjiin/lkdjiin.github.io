<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : jeu de la vie | Xavier Nayrac]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/jeu-de-la-vie/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2015-07-29T11:20:22+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Je ne vais pas terminer le jeu de la vie en Rust]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/01/22/je-ne-vais-pas-terminer-le-jeu-de-la-vie-en-rust/"/>
    <updated>2015-01-22T17:05:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/01/22/je-ne-vais-pas-terminer-le-jeu-de-la-vie-en-rust</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Je ne vais pas terminer le jeu de la vie en Rust. Si vous voulez vraiment savoir
pourquoi, continuez à lire cet article. Sinon passez au suivant qui devrait
être plus intéressant :-)</p>

<!-- more -->

<pre><code>$ rustc --version
rustc 1.0.0-nightly (29bd9a06e 2015-01-20 23:03:09 +0000)
</code></pre>

<p>Après avoir procédé à la mise à jour de Rust, j’ai commencé à vouloir régler
les conflits :/ Parce que oui, même avec le petit bout de code que j’ai obtenu
jusqu’ici il y a déjà plusieurs conflits après le changement de version.  Pour
les plus simples, il suffit de renommer <code>uint</code> en <code>usize</code> et les suffixes <code>u</code>
sur les nombres entiers en <code>us</code>.</p>

<p>Par contre il y a d’autres erreurs qui me donnent mal à la tête d’avance, comme
par exemple:</p>

<pre><code>   Compiling game_of_life v0.0.1 (file:///home/xavier/code/rust/game_of_life)
src/main.rs:13:20: 13:39 error: unresolved name `std::rand::task_rng`
src/main.rs:13         let cell = std::rand::task_rng().gen_range(0us, 2us);
                                  ^~~~~~~~~~~~~~~~~~~ et aussi:

src/main.rs:7:20: 7:23 error: the trait `core::fmt::String` is not implemented for the type `collections::vec::Vec&lt;usize&gt;`
src/main.rs:7     println!("{}", gen);
</code></pre>

<p>Comme j’ai plusieurs projets, grands et petits, en cours en ce moment, je
préfère me concentrer sur ceux qui ont une chance d’aboutir, et le jeu de la vie
en Rust ne fait clairement pas partie de mes priorités.</p>

<p>Je reviendrais (peut-être) à Rust après la version 1.0 finale, quand
le langage et la documentation seront suffisamment stables.</p>

<p>À bientôt.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Le jeu de la vie en Rust - partie 2]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/01/13/le-jeu-de-la-vie-en-rust-partie-2/"/>
    <updated>2015-01-13T10:14:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/01/13/le-jeu-de-la-vie-en-rust-partie-2</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<h2 id="tests-unitaires-avec-rust">Tests unitaires avec Rust</h2>

<p>Je vais ajouter des tests unitaires au code du dernier article. Il s’agissait
simplement d’une seule fonction pour créer une génération aléatoire de cellule.
Voici tout le code, l’implémentation et les tests dans le même fichier <code>src/main.rs</code>.</p>

<p>``` rust src/main.rs
use std::rand::Rng;</p>

<h1 id="cfgnottest">[cfg(not(test))]</h1>
<p>fn main() {
    let gen = create_generation(3, 4);
    println!(“{}”, gen);
}</p>

<p>fn create_generation(width: uint, height: uint) -&gt; Vec<uint> {
    let size = width * height;
    let mut result = Vec::new();
    for _ in range(0u, size) {
        let cell = std::rand::task_rng().gen_range(0u, 2u);
        result.push(cell);
    }
    result
}</uint></p>

<h1 id="cfgtest">[cfg(test)]</h1>
<p>mod tests {
    use super::create_generation;</p>

<pre><code>#[test]
fn test_create_generation_length() {
    let result = create_generation(4, 3);
    assert_eq!(12, result.len());
}

#[test]
fn test_create_generation_has_1_and_0() {
    let gen = create_generation(2, 3);
    for i in range(0u, gen.len()) {
        assert!(gen[i] &lt; 2);
    }
} } ```
</code></pre>

<!-- more -->

<p>On lance les tests grâce à l’outil à tout faire, Cargo:</p>

<pre><code>$ cargo test
   Compiling game_of_life v0.0.1 (file:///home/xavier/code/rust/game_of_life)
     Running target/game_of_life-f45ebd9dc330e3e4

running 2 tests
test test::test_create_generation_has_1_and_0 ... ok
test test::test_create_generation_length ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured
</code></pre>

<p>Concernant le code, il se comprend assez facilement de lui-même, voici tout de même quelques
éclaircissements:</p>

<p><code>rust
#[cfg(not(test))]
fn main() {
</code></p>

<p>Sans cette annotation (pardon, attribut en langage Rust) <code>cargo test</code> produirait
un avertissement assez ennuyeux, car la fonction <code>main</code> n’est pas utilisé par
les tests:</p>

<pre><code>$ cargo test
   Compiling game_of_life v0.0.1 (file:///home/xavier/code/rust/game_of_life)
/home/.../main.rs:3:1: 6:2 warning: function is never used: `main`, #[warn(dead_code)] on by default
/home/.../main.rs:3 fn main() {
/home/.../main.rs:4     let gen = create_generation(3, 4);
/home/.../main.rs:5     println!("{}", gen);
/home/.../main.rs:6 }
</code></pre>

<p><code>rust
#[cfg(test)]
mod tests
</code></p>

<p>C’est la déclaration d’un <strong>mod</strong>ule nommé <code>tests</code>, avec un attribut permettant
à Rust de savoir que ce qui suit concerne des tests et ne devra pas être compilé
dans le programme final.</p>

<p><code>rust
use super::create_generation;
</code></p>

<p>On va utiliser la fonction <code>create_generation</code>, définie dans le parent du
module courant. <code>tests</code> est le module courant, le parent est créé automatiquement.</p>

<p><code>rust
#[test]
</code></p>

<p>Ceci n’est pas un commentaire, vous l’avez compris, on appelle ça un attribut. C’est une sorte d’annotation.
Ça dit à Rust que la prochaine fonction est un test et ça nous permet d’écrire des fonctions utilitaires
dans le module <code>tests</code>.</p>

<h2 id="tests-unitaires-et-implmentation-dans-le-mme-fichier">Tests unitaires et implémentation dans le même fichier</h2>

<p>C’est la recommendation de Rust : placer les tests unitaires dans le même fichier
que l’implémentation. Bien sûr, les tests d’intégration ont un dossier et des
fichiers bien à eux.
L’idée est originale même si elle ne doit pas être nouvelle. Je dis que
l’idée n’est pas nouvelle parce que je l’ai environ deux ou trois fois par an.
Par contre je n’y ai jamais cru suffisamment pour tenter de l’implémenter. Rust
l’a fait et je suis très curieux de voir ce que cela va donner.</p>

<p>Cette façon de faire a des avantages, comme ne pas perdre de temps à
trouver les tests unitaires ou aider à rester <em>focus</em> sur ce qui doit être
testé. Mais je m’interroge quand même sur ce que cela peut poser comme problèmes à l’usage.</p>

<p>Ma première interrogation concerne la taille des fichiers.
Le code Rust, sans être le plus verbeux qui soit, est quand même loin de la concision.
Un exemple simple, en Rust:</p>

<p><code>rust
let cell = std::rand::task_rng().gen_range(0u, 2u);
result.push(cell);
</code></p>

<p>Le même en Ruby:</p>

<p><code>ruby
result &lt;&lt; rand(2)
</code></p>

<p>Je ne serais pas étonné de trouver des fichiers Rust avec 200 lignes de code
d’implémentation (je vois ça régulièrement en Ruby).
Et si on respecte la <a href="http://martinfowler.com/bliki/TestPyramid.html">pyramide des tests</a> on se retrouve
vite avec 3 ou 4 tests par fonction, d’où des fichiers assez imposants,
d’un bon millier de lignes.
En fouillant un peu dans le code de Rust, par exemple le fichier <a href="https://github.com/rust-lang/rust/blob/master/src/libserialize/json.rs">json.rs</a>,
on peut voir que je suis encore loin de la réalité (presque 4000 lignes).</p>

<p>Une autre interrogation concerne le refactoring. Il faut pouvoir facilement casser
un fichier en plusieurs autres, plus petits. Dans quelle mesure ce type de
«couplage» entre test et implémentation va faciliter, ou au contraire compliquer,
cette tâche ?</p>

<p>Bref, je trouve l’idée très séduisante en théorie, et j’attend de voir si sa mise
en pratique fonctionne. Il y a encore d’autres choses à dire sur les tests avec
Rust, et j’y reviendrais certainement dans un prochain article.</p>

<p>N’oubliez pas que votre opinion m’intéresse, alors si vous pensez quelque chose
de ces tests unitaires à même le code, laissez donc un commentaire.</p>

<p>À bientôt.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Le jeu de la vie en Rust - partie 1]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/01/04/le-jeu-de-la-vie-en-rust-partie-1/"/>
    <updated>2015-01-04T18:04:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/01/04/le-jeu-de-la-vie-en-rust-partie-1</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<h2 id="premiers-pas-avec-rust">Premiers pas avec Rust</h2>

<p>On va écrire une version simple du jeu de la vie en Rust.</p>

<h3 id="installer-rust">Installer Rust</h3>

<p>Rendez-vous <a href="http://www.rust-lang.org/install.html">sur cette page</a> pour trouver
le type d’installation qui vous convient. Même si on peut trouver que cela pose
des problèmes, j’ai opté pour la méthode la plus simple:</p>

<pre><code>$ curl -s https://static.rust-lang.org/rustup.sh | sudo sh
</code></pre>

<p>Cela installe la version <em>nightly</em> et le gestionnaire de paquet <code>Cargo</code>.
L’installation est très rapide.</p>

<p>Pour information, voici la version que j’ai installé:</p>

<pre><code>$ rustc --version
rustc 0.13.0-nightly (636663172 2014-12-28 16:21:58 +0000)
</code></pre>

<!-- more -->

<h3 id="cargo">Cargo</h3>

<p>Rust fournit un outil très proche du Bundler des rubyistes, il s’agit
de Cargo. On s’en sert pour la création d’un projet, faire les builds,
lancer les tests, gérer les dépendances, etc…</p>

<p>Je crée le projet <code>game_of_life</code>:</p>

<pre><code>$ cargo new game_of_life --bin
$ cd game_of_life
</code></pre>

<p>Ça donne ceci:</p>

<pre><code>$ tree
.
├── Cargo.toml
└── src
    └── main.rs
</code></pre>

<p>Le fichier <code>Cargo.toml</code> est un manifeste et ne nous intéresse pas trop pour
l’instant.</p>

<h3 id="cration-dune-gnration-de-cellules">Création d’une génération de cellules</h3>

<p>Je ne vais pas parler de test aujourd’hui, ça sera pour plus tard. Je vais seulement écrire une
fonction <code>create_generation</code> (ma toute première fonction Rust !) qui va produire un tableau de
cellules, c’est à dire un tableau de 0 et de 1.</p>

<p>Pour représenter une génération, j’ai déjà utilisé dans les articles précédents des tableaux de
tableaux et des tableaux à 2 dimensions. C’est ma dernière chance d’utiliser des tableaux plats.
Voici le code complet du fichier <code>main.rs</code>.</p>

<p>``` rust src/main.rs
use std::rand::Rng;</p>

<p>fn main() {
    let gen = create_generation(3, 4);
    println!(“{}”, gen);
}</p>

<p>fn create_generation(width: uint, height: uint) -&gt; Vec<uint> {
    let size = width * height;
    let mut result = Vec::new();
    for _ in range(0u, size) {
        let cell = std::rand::task_rng().gen_range(0u, 2u);
        result.push(cell);
    }
    result
}
```</uint></p>

<p>Pour le compiler et le lancer, on peut utiliser Cargo:</p>

<pre><code>$ cargo run
     Running `target/game_of_life`
[1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0]
</code></pre>

<p>Je ne suis pas très content de cette fonction <code>create_generation</code>, j’ai bien
conscience qu’elle est maladroite, mais elle a
au moins un mérite: elle fonctionne ! Alors, place aux explications.</p>

<pre><code>fn create_generation(width: uint, height: uint) -&gt; Vec&lt;uint&gt; {
</code></pre>

<p>Rust est statiquement typé, le compilateur doit connaître la signature d’une
fonction. Donc on déclare le type des paramêtres (ici <code>uint</code> pour <em>unsigned int</em>)
et le type de la valeur de retour (ici un <code>Vec</code>teur).</p>

<pre><code>let size = width * height;
</code></pre>

<p>On déclare une variable avec <code>let</code>. Pas besoin de préciser le type de <code>size</code>
puisque le compilateur peut l’inférer.</p>

<pre><code>let mut result = Vec::new();
</code></pre>

<p>Par défaut, une variable ne peut pas être modifiée, comme je désire ajouter des
éléments à <code>result</code>, je dois spécifier <code>mut</code> (pour <em>mutable</em>).</p>

<pre><code>for _ in range(0u, size) {
    let cell = std::rand::task_rng().gen_range(0u, 2u);
    result.push(cell);
}
</code></pre>

<p><code>0u</code> est une autre manière de préciser le type. Ici c’est <code>0</code> de type <code>uint</code>.
Dans la boucle on génère un nombre aléatoire et on l’ajoute dans <code>result</code>.</p>

<pre><code>result
</code></pre>

<p>Finalement on renvoie <code>result</code>. Notez qu’il n’y a pas de point-virgule après
<code>result</code>, c’est voulu, ça ne fonctionnerait pas avec. Par contre j’aurais pu
écrire <code>return result;</code>, et là il faudrait le point-virgule. Je n’ai pas encore
très bien compris le pourquoi du comment, donc je ne vais pas me risquer à vous
fournir une explication foireuse.</p>

<p>Voilà, c’est tout pour ma première approche de Rust. La prochaine fois je
parlerais des tests unitaires.</p>

<script id="fb33k8u">(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Le jeu de la vie en Haskell - partie 4]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/12/30/le-jeu-de-la-vie-en-haskell-partie-4/"/>
    <updated>2014-12-30T21:09:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/12/30/le-jeu-de-la-vie-en-haskell-partie-4</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Je dois maintenant pouvoir extraire 9 cellules d’une génération (la cellule
cible et ses 8 voisines). Pour cela, je vais avoir besoin de la fonction
suivante:</p>

<p><code>haskell
extractNeighborhood :: Generation -&gt; Int -&gt; Int -&gt; [Cell]
</code></p>

<p>Elle prendra en entrée la génération, l’index de la rangée et l’index de la
colonne. Mais pour simplifier l’implémentation de <code>extractNeighborhood</code> j’ai
ressenti le besoin d’une fonction utilitaire <code>sliceAround</code> qui ferait ça:</p>

<pre><code>$ ghci
&gt; :load Slice.hs 
&gt; let list = [0,1,2,3,4,5]
&gt; sliceAround 1 list
[0,1,2]
&gt; sliceAround 4 list
[3,4,5]
&gt; sliceAround 0 list
[0,1]
&gt; sliceAround 5 list
[4,5]
</code></pre>

<!-- more -->

<p>J’ai donc écrit les tests (que vous pouvez trouvez sur <a href="https://github.com/lkdjiin/game-of-life-haskell">Github</a>) et le module
<code>Slice</code> qui en découle:</p>

<p>``` haskell Slice.hs
module Slice (sliceAround) where</p>

<p>sliceAround :: Int -&gt; [a] -&gt; [a]
sliceAround 0 list = take 2 list
sliceAround n list = take 3 $ drop (n-1) list
```</p>

<p>C’était facile. J’ai quand même été étonné de ne pas trouver une fonction
<code>slice</code> de base (ou j’ai mal cherché, c’est toujours possible ;) ). Même s’il
est vrai qu’avec <code>take</code> et <code>drop</code> c’est très simple à obtenir.
Ensuite j’utilise <code>sliceAround</code> pour écrire <code>extractNeighborhood</code>:</p>

<p><code>haskell GameOfLife.hs
extractNeighborhood :: Generation -&gt; Int -&gt; Int -&gt; [Cell]
extractNeighborhood generation row column
  | row == 0 = row1 ++ row2
  | row == (length generation) - 1 = row0 ++ row1
  | otherwise = row0 ++ row1 ++ row2
    where row0 = getRow $ row - 1
          row1 = getRow row
          row2 = getRow $ row + 1
          getRow r = sliceAround column $ generation !! r
</code></p>

<p>Je n’arrive pas à simplifier plus cette fonction, mais il doit y avoir moyen.
Si vous connaissez Haskell, j’aimerais beaucoup avoir votre avis.</p>

<p>Avant de pouvoir en terminé avec ce jeu de la vie en Haskell, il me faut une
fonction <code>nextGeneration</code>, et j’ai eu bien peur que celle-ci me fasse mal à la
tête.</p>

<p>En fait ça n’a pas été si violent que ça. En décomposant, j’y suis arrivé
rapidement:</p>

<p>``` haskell
nextGeneration :: Generation -&gt; Generation
nextGeneration generation = [(nextRow y generation) | y &lt;- [0..height]]
  where height = (length generation) - 1</p>

<p>nextRow :: Int -&gt; Generation -&gt; [Cell]
nextRow y generation = [(nextCell y x generation) | x &lt;- [0..width]]
  where row = generation !! y
        width = (length row) - 1</p>

<p>nextCell :: Int -&gt; Int -&gt; Generation -&gt; Cell
nextCell y x generation = cellNextState cell neighborhood
  where neighborhood = extractNeighborhood generation y x
        cell = (generation !! y) !! x
```</p>

<p>Mais là encore, j’ai l’impression qu’il y a moyen de simplifier…</p>

<p>Il ne me reste plus qu’à faire une boucle:</p>

<p>``` haskell gol.hs
import System.Random
import GameOfLife
import Control.Concurrent</p>

<p>loop 0 _ = return ()
loop n g =
 do
   displayGeneration g
   threadDelay 1000000
   loop (n-1) (nextGeneration g)</p>

<p>main :: IO()
main =
  let width = 80
      height = 23
      cells = randomCells (width * height) (mkStdGen 1234)
      generation = createGeneration width cells
   in loop 40 generation
```</p>

<p>Notez <code>threadDelay</code>, pour faire une pause, qui prend un
nombre de micro-secondes ! Je ne sais pas si ça fonctionne à ce niveau de
granularité, mais ça m’impressionne.</p>

<p>Finalement, on peut compiler et lancer le programme \o/</p>

<pre><code>$ ghc -o gol Slice.hs GameOfLife.hs gol.hs
$ ./gol
</code></pre>

<p>Je vous rappelle que le code se trouve sur <a href="https://github.com/lkdjiin/game-of-life-haskell">Github</a> et que tous vos
commentaires sur ce code seront les bienvenus.</p>

<p>Voilà, j’en ai terminé avec Haskell. Je suis à la fois content, parce que
impatient de commencer la version Rust, et à la fois un peu triste parce que
je commence à peine à entrevoir les possibilités de Haskell. J’espère être en
mesure de me dégager un peu de temps pour continuer à étudier ce langage.</p>

<script id="fb33k8u">(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Le jeu de la vie en Haskell - partie 3]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/12/30/le-jeu-de-la-vie-en-haskell-partie-3/"/>
    <updated>2014-12-30T08:53:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/12/30/le-jeu-de-la-vie-en-haskell-partie-3</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Cette fois je met des tests en place avec <a href="https://www.haskell.org/haskellwiki/HUnit_1.0_User%27s_Guide">HUnit</a>.
Pour cela, je dois d’abord <em>modulariser</em> mon code. J’ai donc déplacé le code
de la dernière fois, sans la fonction <code>main</code>, dans un fichier <code>GameOfLife</code>.
Puis j’ai ajouté la déclaration du module.</p>

<!-- more -->

<p>``` haskell GameOfLife.hs
module GameOfLife
( randomCells
, createGeneration
, formatGeneration
) where</p>

<p>import System.Random
import Data.List</p>

<p>type Cell = Int
type Generation = [[Cell]]</p>

<p>randomCells :: Int -&gt; StdGen -&gt; [Cell]
randomCells size gen = take size $ randomRs (0, 1) gen</p>

<p>createGeneration :: Int -&gt; [Cell] -&gt; Generation
createGeneration _ [] = []
createGeneration width cells = line:(createGeneration width rest)
  where (line, rest) = splitAt width cells</p>

<p>formatGeneration :: Generation -&gt; String
formatGeneration generation =
  let rows = intercalate “\n” (map (concatMap show) generation)
   in map replaceChar rows</p>

<p>replaceChar :: Char -&gt; Char
replaceChar ‘1’ = ‘@’
replaceChar ‘0’ = ‘ ‘
replaceChar c   = c
```</p>

<p>Une déclaration de module, c’est ça:</p>

<p><code>haskell
module GameOfLife
( randomCells
, createGeneration
, formatGeneration
) where
</code></p>

<p>J’ai donc un module <code>GameOfLife</code> qui exporte, pour l’instant, trois fonctions.
Au fait, le code est sur <a href="https://github.com/lkdjiin/game-of-life-haskell">Github</a>.</p>

<p>Je vais créer la fonction <code>cellNextState</code>, je la rajoute donc dans les exports
du module:</p>

<p><code>haskell
module GameOfLife
( randomCells
, createGeneration
, formatGeneration
, cellNextState
) where
</code></p>

<p>Et j’en crée une version qui ne fonctionne pas ;)</p>

<p><code>haskell
cellNextState :: Cell -&gt; [Cell] -&gt; Cell
cellNextState cell neighborhood = undefined
</code></p>

<p>C’est parti pour mon premier test en Haskell. Je crée un fichier
<code>GameOfLife_Test.hs</code>:</p>

<p>``` haskell GameOfLife_Test.hs
module GameOfLife_Test where</p>

<p>import GameOfLife(cellNextState)
import Test.HUnit</p>

<p>testCellNextState3 = TestCase $ assertEqual
  “Gets live cell when neighborhood’sum is 3” 1 (cellNextState 0 [1,1,1,0])</p>

<p>main = runTestTT testCellNextState3
```</p>

<p>C’est du bon vieux test unitaire à l’ancienne. Je mentirais en disant que
je trouve la syntaxe sexy.</p>

<pre><code>$ runhaskell GameOfLife_Test.hs 
### Error:                                
Prelude.undefined
Cases: 1  Tried: 1  Errors: 1  Failures: 0
Counts {cases = 1, tried = 1, errors = 1, failures = 0}
</code></pre>

<p>Bon, si maintenant ma fonction renvoie 1, le test devrait passer.</p>

<p><code>haskell
cellNextState cell neighborhood = 1
</code></p>

<pre><code>$ runhaskell GameOfLife_Test.hs 
Cases: 1  Tried: 1  Errors: 0  Failures: 0
Counts {cases = 1, tried = 1, errors = 0, failures = 0}
</code></pre>

<p>J’aimerais bien avoir une sortie en couleur. Si il y a moyen, je n’ai pas
encore trouvé…</p>

<p>Quoiqu’il en soit, je peux tester mon code Haskell, et ça c’est cool. Je vais
donc en finir avec <code>cellNextState</code> en faisant quelques tests de plus:</p>

<p>``` haskell GameOfLife_Test.hs
module GameOfLife_Test where</p>

<p>import GameOfLife(cellNextState)
import Test.HUnit</p>

<p>testCellNextState3 = TestCase $ assertEqual
  “Gets 1 when neighborhood’s sum is 3”
  1 (cellNextState 0 [1,1,1,0])</p>

<p>testCellNextState4AndAlive = TestCase $ assertEqual
  “Gets 1 when neighborhood’s sum is 4 and cell is alive”
  1 (cellNextState 1 [1,1,1,0,1])</p>

<p>testCellNextState4AndDead = TestCase $ assertEqual
  “Gets 0 when neighborhood’s sum is 4 and cell is dead”
  0 (cellNextState 0 [1,1,1,0,1])</p>

<p>testCellNextState6 = TestCase $ assertEqual
  “Gets 0 when neighborhood’s sum is 6”
  0 (cellNextState 1 [1,1,1,0,1,1,1])</p>

<p>main = runTestTT $ TestList [testCellNextState3,
                            testCellNextState4AndAlive,
                            testCellNextState4AndDead,
                            testCellNextState6]
```</p>

<pre><code>$ runhaskell GameOfLife_Test.hs 
### Failure in: 2                         
Gets 0 when neighborhood's sum is 4 and cell is dead
expected: 0
 but got: 1
### Failure in: 3                         
Gets 0 when neighborhood's sum is 6
expected: 0
 but got: 1
Cases: 4  Tried: 4  Errors: 0  Failures: 2
Counts {cases = 4, tried = 4, errors = 0, failures = 2}
</code></pre>

<p><code>haskell GameOfLife.hs
cellNextState :: Cell -&gt; [Cell] -&gt; Cell
cellNextState cell neighborhood
  | total == 4 = cell
  | total == 3 = 1
  | otherwise = 0
    where total = sum neighborhood
</code></p>

<pre><code>$ runhaskell GameOfLife_Test.hs 
Cases: 4  Tried: 4  Errors: 0  Failures: 0
Counts {cases = 4, tried = 4, errors = 0, failures = 0}
</code></pre>

<script id="fb33k8u">(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>

<p></p>
]]></content>
  </entry>
  
</feed>
