<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : jeu de la vie | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/jeu-de-la-vie/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2014-12-16T18:12:41+01:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Le jeu de la vie en logo - partie 1]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/12/16/le-jeu-de-la-vie-en-logo-partie-1/"/>
    <updated>2014-12-16T18:01:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/12/16/le-jeu-de-la-vie-en-logo-partie-1</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>C'est parti pour la version Logo du jeu de la vie. J'utiliserais
<a href="http://www.cs.berkeley.edu/~bh/logo.html">ucblogo</a> en version 5.5, qui est celle qu'on trouve dans les paquets Debian.
Sur leur site vous trouverez la version 6, si vous souhaitez la compiler.</p>

<pre><code>$ logo
Welcome to Berkeley Logo version 5.5
</code></pre>

<h2>Introduction</h2>

<p>Attention ! Le monde de Logo est autre. Je n'ai pas d'autres formules qui me
viennent à l'esprit.  Si vous utilisez Vim, j'ai écrit un fichier de
<a href="https://github.com/lkdjiin/logo.vim">coloration syntaxique pour Logo</a>,
minimal, mais toujours utile pour ne pas se sentir coincé dans les années 80.
Et comme il n'existe pas de frameworks de test (ou alors ils sont bien cachés),
j'en ai écrit un rudimentaire : <a href="https://github.com/lkdjiin/logo-unit">Logo unit test</a>.</p>

<p>Bref, vous aurez compris que l'éco-système Logo open source est assez pauvre,
voir inexistant.  Je crois qu'il n'y a même pas de tag <code>logo</code> sur
stackoverflow.</p>

<!-- more -->


<h2>Création d'une génération</h2>

<p>Créons un fichier pour les tests, et un fichier pour l'implémentation.</p>

<pre><code>$ tree
.
├── generation.lg
└── test.generation.lg
</code></pre>

<p>En avant pour le premier test, je veux m'assurer que la procédure
<code>create.generation</code> renvoie une liste.</p>

<p>``` raw test.generation.lg
load &ldquo;generation.lg</p>

<p>to t.create.generation.returns.a.list
assert.list create.generation
end
```</p>

<h3>Premières remarques sur Logo</h3>

<p>Tout d'abord, les points n'ont rien à voir avec des appels de
méthode/fonction/procédure.  C'est juste une manière de nommer les choses. En
Ruby on aurait <code>assert_list</code>, en Java <code>assertList</code>, en Racket <code>assert-list</code>, en
Logo c'est plutôt <code>assert.list</code>.</p>

<p>Ensuite, la première ligne <code>load "generation.lg</code>, qui charge le fichier
<code>generation.lg</code>, ne contient pas de faute de frappe ! Il y a bien un seul
guillement double (<code>"</code>). C'est la façon de dire que <code>generation.lg</code> doit être
pris dans son sens littéral, pas en tant que variable ou procédure, mais bien en
tant que nom.</p>

<h3>Lancer les tests</h3>

<p>On lance les tests en chargeant la procédure <code>tt</code>. Logo nous dit <em>je ne sais
pas comment faire pour create.generation</em>. Normal puisque cette procédure
n'existe pas encore.</p>

<pre><code>$ logo
Welcome to Berkeley Logo version 5.5
? tt "test.generation.lg
I don't know how  to create.generation  in t.create.generation.returns.a.list
[assert.list create.generation]
</code></pre>

<h3>Notre première procédure</h3>

<p>Il suffit de renvoyer une liste vide pour faire passer le test. Notez que
<code>output</code> est l'équivalent du plus commun <code>return</code>.</p>

<p><code>raw generation.lg
to create.generation
output []
end
</code></p>

<pre><code>? tt "test.generation.lg
.

1 tests. 0 fail.
</code></pre>

<h3>Une liste à plusieurs dimensions</h3>

<p>Notre liste devra avoir une largeur (x) et une hauteur (y), commençons par
tester la hauteur.</p>

<p>``` raw test.generation.lg
load &ldquo;generation.lg</p>

<p>to t.create.generation.returns.a.list
assert.list create.generation 3
end</p>

<p>to t.create.generation.have.a.height
assert.equal 3 count create.generation 3
end
```</p>

<p>Voici le code permettant de faire passer nos nouveaux tests.</p>

<p><code>raw generation.lg
to create.generation :height
output cascade :height [lput # ?] []
end
</code></p>

<p><code>cascade</code> prend un nombre d'itération, un template et une valeur de départ.
<code>lput</code> (pour <em>last put</em>) ajoute une valeur à la fin d'une liste. <code>#</code> dans le
template est remplacé par l'itération.</p>

<p>Ensuite, nouveaux tests pour s'assurer qu'on a aussi une largeur.</p>

<p>``` raw test.generation.lg
load &ldquo;generation.lg</p>

<p>to t.create.generation.returns.a.list
assert.list create.generation 4 3
end</p>

<p>to t.create.generation.have.a.height
assert.equal 3 count create.generation 4 3
end</p>

<p>to t.create.generation.have.a.width
assert.equal 4 count first create.generation 4 3
end
```</p>

<p>On implémente notre liste à 2 dimensions.</p>

<p>``` raw generation.lg
to create.generation :width :height
output cascade :height [lput (p.create.line :width) ?] []
end</p>

<p>to p.create.line :width
output cascade :width [lput 0 ?] []
end
```</p>

<p>Le <code>p.</code> en tête d'un nom de procédure est une convention que j'ai utilié pour
signifier que la procédure est privée.</p>

<p>Les tests passent.</p>

<pre><code>? tt "test.generation.lg
...

3 tests. 0 fail.
</code></pre>

<p>On peut regarder à quoi ressemble la sortie de notre procédure.</p>

<pre><code>? print create.generation 4 3
[0 0 0 0] [0 0 0 0] [0 0 0 0]
</code></pre>

<h3>Un peu de hasard</h3>

<p>Les cellules du jeu de la vie sont représentées soit par un 0 (cellule
morte), soit par un 1 (cellule vivante). Je teste que <code>create.generation</code>
produit bien une suite de 0 et de 1.</p>

<p><code>raw test.generation.lg
to t.create.generation.produces.0s.or.1s
rerandom
localmake "result create.generation 3 2
assert.equal :result [[1 0 1] [1 1 1]]
end
</code></p>

<p><code>rerandom</code> place le générateur de nombre aléatoire dans un état reproductible,
pour pouvoir tester facilement. <code>localmake</code> déclare une variable locale, ici
<code>result</code> qui va contenir la sortie de <code>create.generation 3 2</code>.</p>

<p>Et j'implémente avec la procédure <code>random</code> qui renvoie un nombre aléatoire.</p>

<p><code>raw generation.lg
to p.create.line :width
output cascade :width [lput (random 2) ?] []
end
</code></p>

<p>Et voilà, les tests passent.</p>

<pre><code>? tt "test.generation.lg
....

4 tests. 0 fail.
? print create.generation 9 3
[0 0 1 0 1 1 0 0 0] [1 1 1 1 0 0 0 1 1] [1 0 1 0 1 1 1 1 0]
</code></pre>

<h2>La portée des variables en Logo</h2>

<p>Le code précédent fonctionne très bien, par contre on peut faire un refactoring
intéressant qui va me permettre de parler d'un phénomène étrange en Logo.</p>

<p>``` raw generation.lg
to create.generation :width :height
output cascade :height [lput p.create.line ?] []
end</p>

<p>to p.create.line
output cascade :width [lput (random 2) ?] []
end
```</p>

<p>Vous remarquerez que j'ai enlevé le paramêtre <code>width</code> de la procédure
<code>p.create.line</code> et que ce <code>width</code> n'est plus passé par <code>create.generation</code>.
Pourtant le code continue de fonctionner comme un charme.</p>

<p>C'est que Logo a une notion toute particulière de la <em>localité</em> des variables.
Une variable locale à une procédure est connue dans cette même procédure
<strong>et aussi</strong> dans les sous-procédures appelées par cette même procédure.
Autrement dit, <code>p.create.line</code> connait les variables <code>width</code> et <code>height</code>
puisqu'elle est appelée par <code>create.generation</code>.</p>

<p>Ce n'est pas le seul langage à fonctionner comme ça (les premiers Lisp et
Perl, il me semble). Par contre je me demande toujours si c'est génial, ou
irresponsable.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Le jeu de la vie en racket - partie 3]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/11/09/le-jeu-de-la-vie-en-racket-partie-3/"/>
    <updated>2014-11-09T15:01:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/11/09/le-jeu-de-la-vie-en-racket-partie-3</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>C'est la troisième et dernière partie du jeu de la vie en Racket.</p>

<p><img src="/images/screenshot-game-of-life-racket.png"></p>

<!-- more -->


<h2>Trouver le prochain état d'une cellule</h2>

<p>Vous avez l'habitude maintenant, je commence par un test très simple.</p>

<p><code>racket game-of-life-test.rkt
(check-equal? (next-cell-state '(1 1 1 0 0 0 0 0 0)) 1)
</code></p>

<p>Et une implémentation minimale.</p>

<p>``` racket generation.rkt</p>

<h1>lang racket</h1>

<p>&hellip;</p>

<p>(define (next-cell-state neighborhood)
  1)</p>

<p>(provide create-generation</p>

<pre><code>     next-cell-state)
</code></pre>

<p>```</p>

<p>Puis je teste d'autres cas.</p>

<p>``` racket game-of-life-test.rkt
(check-equal? (next-cell-state &lsquo;(1 1 1 0 0 0 0 0 0)) 1)
(check-equal? (next-cell-state &rsquo;(1 0 0 1 0 0 1 0 0)) 1)</p>

<p>(check-equal? (next-cell-state &lsquo;(1 0 0 1 1 0 1 0 0)) 1)
(check-equal? (next-cell-state &rsquo;(1 0 0 1 0 0 1 0 1)) 0)
```</p>

<p>La fonction <code>for/sum</code> réduit une liste à la somme de ses éléments.</p>

<p>``` racket
(define (next-cell-state neighborhood)
  (define sum (for/sum ([i neighborhood]) i))
  (if (= 3 sum)</p>

<pre><code>1
(list-ref neighborhood 4)))
</code></pre>

<p>```</p>

<p>Je teste les derniers cas.</p>

<p>``` racket game-of-life-test.rkt
(check-equal? (next-cell-state &lsquo;(1 1 1 0 0 0 0 0 0)) 1)
(check-equal? (next-cell-state &rsquo;(1 0 0 1 0 0 1 0 0)) 1)</p>

<p>(check-equal? (next-cell-state &lsquo;(1 0 0 1 1 0 1 0 0)) 1)
(check-equal? (next-cell-state &rsquo;(1 0 0 1 0 0 1 0 1)) 0)</p>

<p>(check-equal? (next-cell-state &lsquo;(1 1 1 1 1 1 1 1 1)) 0)
(check-equal? (next-cell-state &rsquo;(0 0 0 0 0 0 0 0 0)) 0)
```</p>

<p>Comme il y a maintenant trois cas, j'utilise <code>cond</code> au lieu de <code>if</code>.</p>

<p>``` racket
(define (next-cell-state neighborhood)
  (define sum (for/sum ([i neighborhood]) i))
  (cond [(= 3 sum) 1]</p>

<pre><code>    [(= 4 sum) (list-ref neighborhood 4)]
    [else 0]))
</code></pre>

<p>```</p>

<p>On pourrait aussi utiliser <code>match</code> plutôt que <code>cond</code>:</p>

<p>``` racket
(define (next-cell-state neighborhood)
  (match (for/sum ([i neighborhood]) i)</p>

<pre><code>     [3 1]
     [4 (list-ref neighborhood 4)]
     [_ 0]))
</code></pre>

<p>```</p>

<p>Je n'ai aucune idée de laquelle est la plus performante, même si je peux
imaginer à priori que dans ce cas là c'est <code>cond</code>.</p>

<h2>test-case</h2>

<p>Je pense qu'il est temps de regrouper les tests en <code>test-case</code>. Rackunit, le
framework de test de Racket est assez évolutif.</p>

<p>``` racket game-of-life-test.rkt</p>

<h1>lang racket</h1>

<p>(require rackunit</p>

<pre><code>     "generation.rkt")
</code></pre>

<p>(test-case &ldquo;create-generation&rdquo;
  (check-pred list? (create-generation 3 4)</p>

<pre><code>        "It returns a list")
</code></pre>

<p>  (check-equal? (length (create-generation 3 4)) 4</p>

<pre><code>          "It builds a list with the right height")
</code></pre>

<p>  (check-equal? (length (first (create-generation 3 4))) 3</p>

<pre><code>          "It builds a list with the right width")
</code></pre>

<p>  (let ([cell (first (first (create-generation 3 4)))])
  (check-true (or (= cell 0) (= cell 1))</p>

<pre><code>          "It populates generation with 0s or 1s"))
</code></pre>

<p>  ((λ ()
   (random-seed 1)
   (check-equal? (create-generation 2 3) &lsquo;((1 1) (0 1) (1 1))</p>

<pre><code>             "It populates generation uniformly"))))
</code></pre>

<p>(test-case &ldquo;next-cell-state&rdquo;
  (check-equal? (next-cell-state &lsquo;(1 1 1 0 0 0 0 0 0)) 1)
  (check-equal? (next-cell-state &rsquo;(1 0 0 1 0 0 1 0 0)) 1)</p>

<p>  (check-equal? (next-cell-state &lsquo;(1 0 0 1 1 0 1 0 0)) 1)
  (check-equal? (next-cell-state &rsquo;(1 0 0 1 0 0 1 0 1)) 0)</p>

<p>  (check-equal? (next-cell-state &lsquo;(1 1 1 1 1 1 1 1 1)) 0)
  (check-equal? (next-cell-state &rsquo;(0 0 0 0 0 0 0 0 0)) 0))
```</p>

<h2>Extraire un voisinage de cellule</h2>

<p>Comme toujours je commence par un test simple. On peut noter les arguments
nommés de Racket (<code>#:</code>).</p>

<p>``` racket
(test-case &ldquo;extract-neighborhood&rdquo;
  (let ([game &lsquo;((1 0 1 0)</p>

<pre><code>            (0 1 0 1)
            (1 0 0 1))])
(check-equal? (extract-neighborhood game #:x 1 #:y 1) '(1 0 1 0 1 0 1 0 0))))
</code></pre>

<p>```</p>

<p>Et une implémentation encore plus simple.</p>

<p><code>racket
(define (extract-neighborhood generation #:x [x 0] #:y [y 0])
  '(1 0 1 0 1 0 1 0 0))
</code></p>

<p>La suite est classique, j'ajoute un nouveau test.</p>

<p>``` racket
(test-case &ldquo;extract-neighborhood&rdquo;
  (let ([game &lsquo;((1 0 1 0)</p>

<pre><code>            (0 1 0 1)
            (1 0 0 1))])
(check-equal? (extract-neighborhood game #:x 1 #:y 1) '(1 0 1 0 1 0 1 0 0))
(check-equal? (extract-neighborhood game #:x 2 #:y 1) '(0 1 0 1 0 1 0 0 1))))
</code></pre>

<p>```</p>

<p>Je regarde ce test échouer.</p>

<pre><code>$ racket game-of-life-test.rkt 
--------------------
extract-neighborhood
FAILURE
actual:     (1 0 1 0 1 0 1 0 0)
expected:   (0 1 0 1 0 1 0 0 1)
</code></pre>

<p>Et j'implémente le minimum de code pour faire passer ce nouveau test.
Je vous épargne ça dans l'article, si vous êtes curieux vous pouvez trouver
<a href="https://github.com/lkdjiin/game-of-life-racket">le code sur Github</a>.</p>

<h2>Une nouvelle génération</h2>

<p>J'écris un test pour la production d'une nouvelle génération.</p>

<p>``` racket
(test-case &ldquo;next-generation&rdquo;
  (let ([game &lsquo;((1 0 1 0)</p>

<pre><code>            (0 1 0 1)
            (1 0 0 1))])

(check-equal? (next-generation game) '((0 1 1 0) (1 1 0 1) (0 0 1 0)))))
</code></pre>

<p>```</p>

<p>Et voici le code qui fait passer ce test.</p>

<p>``` racket generation.rkt
(define (next-generation current)
  (for/list ([y (length current)])</p>

<pre><code>(for/list ([x (length (first current))])
  (define neighborhood (extract-neighborhood current #:x x #:y y))
  (next-cell-state neighborhood))))
</code></pre>

<p>```</p>

<p>On peut maintenant lancer le jeu de la vie.</p>

<p>``` racket game-of-life.rkt</p>

<h1>lang racket</h1>

<p>(require &ldquo;generation.rkt&rdquo;</p>

<pre><code>     "window.rkt")
</code></pre>

<p>(define size 100)
(define generation (create-generation size size))
(define canvas (create-window size size generation))</p>

<p>(define (loop n g)
  (send canvas change-generation g)
  (sleep 0.2)
  (when (> n 0)</p>

<pre><code>(loop (sub1 n) (next-generation g))))
</code></pre>

<p>(loop 30 generation)
```</p>

<h2>Mise à l'échelle</h2>

<p>Pour rendre les choses un peu plus intéressantes visuellement, on va faire un
zoom x4.</p>

<p>``` racket window.rkt</p>

<h1>lang racket/gui</h1>

<p>(define (create-window w h g)
  (define scale 4)</p>

<p>  (define frame (new frame%</p>

<pre><code>                 [label "Game of Life"]
                 [width (* w scale)]
                 [height (* h scale)]))
</code></pre>

<p>  (define canvas (new (class canvas%</p>

<pre><code>...

     (define/override (on-paint)
       (send dc set-brush (new brush% [color "black"]))
       (send dc draw-rectangle 0 0 (* w scale) (* h scale))
       (send dc set-brush (new brush% [color "white"]))
       (for ([y (length current-generation)])
         (for ([x (length (first current-generation))])
           (when (= 1 (list-ref (list-ref current-generation y) x))
             (send dc draw-rectangle (* x scale) (* y scale) scale scale))))))))
</code></pre>

<p>  &hellip;
```</p>

<h2>Une surface de jeu sans bordures</h2>

<p>Il reste à <em>retirer</em> les bordures du jeu. Le processus est exactement le même
que pour les versions <a href="http://lkdjiin.github.io/blog/2014/10/25/le-jeu-de-la-vie-en-ruby-opal-partie-1/">Javascript</a> et <a href="http://lkdjiin.github.io/blog/2014/10/16/le-jeu-de-la-vie-en-javascript-partie-1/">Ruby</a> et je n'ai pas envie de
réécrire les mêmes phrases. Au besoin, je vous rappelle que le
<a href="https://github.com/lkdjiin/game-of-life-racket">code complet du jeu de la vie en Racket</a> se trouve sur Github.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Le jeu de la vie en racket - partie 2]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/11/08/le-jeu-de-la-vie-en-racket-partie-2/"/>
    <updated>2014-11-08T13:46:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/11/08/le-jeu-de-la-vie-en-racket-partie-2</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>C'est le moment d'afficher à l'écran notre génération créée au hasard
<a href="http://lkdjiin.github.io/blog/2014/11/01/le-jeu-de-la-vie-en-racket-partie-1/">la dernière fois</a>.
Je rappelle que je n'écris pas de tests pour cette partie.
Pour obtenir un affichage, je me contente de suivre les exemples donnés dans la
documentation
<a href="http://mirror.racket-lang.org/releases/6.1/doc/draw/overview.html">drawing overview</a>
et <a href="http://mirror.racket-lang.org/releases/6.1/doc/gui/windowing-overview.html">windowing overview</a>.</p>

<!-- more -->


<p>Ce qui donne la première experimentation suivante:</p>

<p>``` racket game-of-life.rkt</p>

<h1>lang racket/gui</h1>

<p>&hellip;</p>

<p>(define generation (create-generation 100 100))</p>

<p>(define frame (new frame%
  [label &ldquo;Example&rdquo;]
  [width 100]
  [height 100]))</p>

<p>(new canvas%</p>

<pre><code> [parent frame]
 [paint-callback
   (λ (canvas dc)
      (send dc set-brush (new brush% [color "black"]))
      (for ([y (length generation)])
        (for ([x (length (first generation))])
          (when (= 1 (list-ref (list-ref generation y) x))
            (send dc draw-rectangle x y 1 1)))))])
</code></pre>

<p>(send frame show #t)
```</p>

<p>Le truc marrant (une façon de voir comme une autre) est que si on
joue les tests, la fenêtre s'affiche. C'est pas très pratique.</p>

<p>Mais avant tout, ce code révèle une erreur précédente:</p>

<p><img src="/images/code-barre-2014-10-11.png"></p>

<p>On dirait un code barre ! Pas vraiment une distribution uniforme.</p>

<p>Alors le bug est simple à trouver, par contre je vais devoir écrire un ou
plusieurs nouveaux tests et je garde ça pour la fin de l'article.</p>

<p>Ensuite, je voudrais faire une boucle qui affiche une nouvelle génération au
hasard chaque seconde. Je dois avouer que cette histoire de canvas, je la sens
pas trop. Et le code que j'ai pondu s'en ressent. D'abord je mets ce qui a trait
à une génération dans un module à part:</p>

<p>``` racket generation.rkt</p>

<h1>lang racket</h1>

<p>(define (create-generation width height)
  (for/list ([i (make-list height 0)])</p>

<pre><code>        (make-list width (random 2))))
</code></pre>

<p>(provide create-generation)
```</p>

<p>Puis, tout le bazar de frame et de canvas, aussi dans un module:</p>

<p>``` racket window.rkt</p>

<h1>lang racket/gui</h1>

<p>(define (create-window w h g)
  (define frame (new frame%</p>

<pre><code>                 [label "Game of Life"]
                 [width w]
                 [height h]))
</code></pre>

<p>  (define canvas (new (class canvas%</p>

<pre><code>     (super-new [parent frame] [style '(no-autoclear)])
     (define current-generation g)
     (define dc (send this get-dc))
     (define/public (change-generation g)
       (set! current-generation g)
       (send this refresh-now))
     (define/override (on-paint)
       (send dc set-brush (new brush% [color "black"]))
       (send dc draw-rectangle 0 0 w h)
       (send dc set-brush (new brush% [color "white"]))
       (for ([y (length current-generation)])
         (for ([x (length (first current-generation))])
           (when (= 1 (list-ref (list-ref current-generation y) x))
             (send dc draw-rectangle x y 1 1))))))))
</code></pre>

<p>  (send frame show #t)
  canvas)</p>

<p>(provide create-window)
```</p>

<p>Moi qui suis habitué à des méthodes de 2 ou 3 lignes, c'est pas vraiment ça.
Et puis j'ai du mal à saisir le modèle objet de Racket.</p>

<p>Enfin le programme principal avec la boucle:</p>

<p>``` racket game-of-life.rkt</p>

<h1>lang racket</h1>

<p>(require &ldquo;generation.rkt&rdquo;</p>

<pre><code>     "window.rkt")
</code></pre>

<p>(define size 100)
(define generation (create-generation size size))
(define canvas (create-window size size generation))</p>

<p>(define (loop n)
  (send canvas change-generation (create-generation size size))
  (sleep 1)
  (when (> n 0)</p>

<pre><code>(loop (sub1 n))))
</code></pre>

<p>(loop 10)
```</p>

<p>Si j'ai le temps, j'essaierais d'utiliser la bibliothèque <code>2htdp/universe</code>,
qui me semble bien plus simple.</p>

<p>Maintenant le bug. Le problème est que je crée des lignes complètes de 0 ou de 1
dans la liste qui représente une génération, plutôt que de distribuer
uniformément ces 0 et ces 1. Je vais donc ajouter un test qui initialise le
générateur de nombres aléatoires toujours de la même manière.</p>

<p>``` racket game-of-life-test.rkt</p>

<h1>lang racket</h1>

<p>(require rackunit</p>

<pre><code>     "generation.rkt")
</code></pre>

<p>&hellip;</p>

<p>((λ ()
   (random-seed 1)
   (check-equal? (create-generation 2 3) &lsquo;((1 1) (0 1) (1 1))</p>

<pre><code>             "It populates generation uniformly")))
</code></pre>

<p>```</p>

<p>Sans surprise, le test échoue.</p>

<pre><code>$ racket game-of-life-test.rkt
--------------------
FAILURE
actual:     ((1 1) (1 1) (0 0))
expected:   ((1 0) (1 0) (1 0))
name:       check-equal?
location:   (#&lt;path:/home/xavier/code/game-of-life-racket/game-of-life-test.rkt&gt; 21 3 537 112)
expression: (check-equal? (create-generation 2 3) (quote ((1 0) (1 0) (1 0))))
message:    "It populates generation uniformly"
</code></pre>

<p>Et voici le fix.</p>

<p>``` racket generation.rkt</p>

<h1>lang racket</h1>

<p>(define (create-generation width height)
  (define (rnd _)</p>

<pre><code>(random 2))
</code></pre>

<p>  (for/list ([i (make-list height 0)])</p>

<pre><code>        (map rnd (make-list width 0))))
</code></pre>

<p>(provide create-generation)
```</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Le jeu de la vie en racket - partie 1]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/11/01/le-jeu-de-la-vie-en-racket-partie-1/"/>
    <updated>2014-11-01T12:22:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/11/01/le-jeu-de-la-vie-en-racket-partie-1</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Le troisième volet de cette série <a href="http://lkdjiin.github.io/blog/2014/10/08/le-jeu-de-la-vie-dans-sept-langages-differents/">le jeu de la vie en 7 langages</a>
sera consacré à <a href="http://racket-lang.org/">Racket</a>, un dialecte de Lisp.
Télécharger le ici: <a href="http://download.racket-lang.org/">http://download.racket-lang.org/</a>
et installez avec <code>bash ./nom-du-fichier.sh</code></p>

<!-- more -->


<p>On commence par un <em>smoke test</em> pour être sûr que Racket est bien installé et
accessible. Dans un fichier <code>game-of-life-test.rkt</code>, chargez le framework de
test et le futur fichier d'implémentation.</p>

<p>``` racket game-of-life-test.rkt</p>

<h1>lang racket</h1>

<p>(require rackunit</p>

<pre><code>     "game-of-life.rkt")
</code></pre>

<p>```</p>

<p>Puis executez le :</p>

<pre><code>$ racket game-of-life-test.rkt
game-of-life-test.rkt:4:9: cannot open module file
</code></pre>

<p>Cool, Racket est là et nous dit qu'il ne peut pas ouvrir le fichier
<code>game-of-life.rkt</code>. Créons le :</p>

<pre><code>touch game-of-life.rkt
</code></pre>

<p>``` racket game-of-life.rkt</p>

<h1>lang racket</h1>

<p>```</p>

<p>Premier test maintenant, la fonction <code>create-generation</code> doit renvoyer une
liste.</p>

<p>``` racket game-of-life-test.rkt</p>

<h1>lang racket</h1>

<p>(require rackunit</p>

<pre><code>     "game-of-life.rkt")
</code></pre>

<p>(check-pred list? (create-generation 3 4))
```</p>

<pre><code>$ racket game-of-life-test.rkt 
game-of-life-test.rkt:6:19: create-generation: unbound identifier in module
</code></pre>

<p>Ok, on renvoie donc une liste vide <code>'()</code>. Notez aussi <code>provide</code>, qui permet de
définir en quelque sorte les fonctions publiques du fichier.</p>

<p>``` racket game-of-life.rkt</p>

<h1>lang racket</h1>

<p>(define (create-generation width height)
  &lsquo;())</p>

<p>(provide create-generation)
```</p>

<p><code>rackunit</code>, le framework de test <em>shippé</em> avec Racket peut aussi documenter
les tests:</p>

<p>``` racket game-of-life-test.rkt
(check-equal? (length (create-generation 3 4)) 4</p>

<pre><code>          "It builds a list with the right height")
</code></pre>

<p>```</p>

<p>On crée une liste de la bonne taille, et comme on se fiche pour l'instant de ce
qu'elle contient, on peut l'initialiser avec des zéros.</p>

<p><code>racket game-of-life.rkt
(define (create-generation width height)
  (make-list height 0))
</code></p>

<p>Chaque élément de la liste doit aussi être une liste (la dimension <code>x</code>).</p>

<p>``` racket game-of-life-test.rkt
(check-equal? (length (first (create-generation 3 4))) 3</p>

<pre><code>          "It builds a list with the right width")
</code></pre>

<p>```</p>

<pre><code>$ racket game-of-life-test.rkt 
length: contract violation
  expected: list?
  given: 0
</code></pre>

<p>J'utilise <code>for/list</code> pour construire cette fameuse liste à deux dimensions. Les
différentes variantes de <code>for</code> me semble très utilisées en Racket.</p>

<p>``` racket game-of-life.rkt
(define (create-generation width height)
  (for/list ([i (make-list height 0)])</p>

<pre><code>        (make-list width 0)))
</code></pre>

<p>```</p>

<p>Finalement, je veux que ma liste contiennent des <code>0</code> (cellule morte) et des
<code>1</code> (cellule vivante).</p>

<p>``` racket game-of-life-test.rkt
(let ([cell (first (first (create-generation 3 4)))])
  (check-true (or (= cell 0) (= cell 1))</p>

<pre><code>          "It populates generation with 0s or 1s"))
</code></pre>

<p>```</p>

<p>``` racket game-of-life.rkt
(define (create-generation width height)
  (for/list ([i (make-list height 0)])</p>

<pre><code>        (make-list width (random 2))))
</code></pre>

<p>```</p>

<p>Ce dernier bout de code contient un bug qui n'est pas attrapé par les
tests (vous l'avez vu ?). Je <em>fixerais</em> ça dans le prochain article.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Le jeu de la vie en ruby (opal) - partie 3]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/10/29/le-jeu-de-la-vie-en-ruby-opal-partie-3/"/>
    <updated>2014-10-29T07:18:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/10/29/le-jeu-de-la-vie-en-ruby-opal-partie-3</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Il est temps de tout assembler, pour ça on va écrire une classe <code>Game</code> qui va
jouer le rôle de chef d'orchestre.</p>

<!-- more -->


<h2>La classe Game</h2>

<p>``` ruby
class Game</p>

<p>  def initialize(generation, canvas, iterations)</p>

<pre><code>@iterations = iterations
@height = generation.size
@width = generation.first.size
@generation = generation
@canvas = canvas
</code></pre>

<p>  end</p>

<p>  def start</p>

<pre><code>draw
@iterations -= 1
if @iterations &gt; 0
  update
  after_ms(500) { start }
end
</code></pre>

<p>  end</p>

<p>  def draw</p>

<pre><code>@canvas.clear
@generation.each_with_index do |line, y|
  line.each_with_index do |cell, x|
    @canvas.pixel(x, y) if cell == 1
  end
end
</code></pre>

<p>  end</p>

<p>  def update</p>

<pre><code>new_generation = (0...@height).map do |y|
  (0...@width).map do |x|
    extractor = NeighborhoodExtractor.new(@generation, x, y)
    Neighborhood.new(extractor.cells).next_state
  end
end
@generation = new_generation
</code></pre>

<p>  end</p>

<p>end
```</p>

<p>Rien d'exceptionnel dans ce code, à part la ligne suivante, extraite de la
méthode <code>start</code>:</p>

<p>``` ruby</p>

<pre><code>  after_ms(500) { start }
</code></pre>

<p>```</p>

<p>Qu'est-ce que c'est que cette méthode <code>after_ms</code> ?</p>

<p>Je ne peux pas faire une bête boucle <code>loop</code>, ou un appel récursif à <code>start</code>
puisqu'on est en Opal.rb, et pas <em>vraiment</em> en Ruby. Le code qui tourne, au
final, sera du Javascript. Et si on n'insère pas des petites pauses, le
navigateur ne va pas aimer du tout. Et puisqu'en Javascript il n'existe pas de
fonction <code>pause</code>, il n'y en a pas non plus en Opal.rb.</p>

<p>J'avoue que je me suis gratter un peu la tête avant de trouver une solution
toute simple. Il suffit d'écrire un <em>wrapper</em> autour de la fonction Javascript
<code>setTimeout</code>:</p>

<p>``` ruby app/kernel.rb
module Kernel</p>

<p>  def after_ms(n, &amp;block)</p>

<pre><code>`setTimeout(function() {`
  block.call
`}, n);`
</code></pre>

<p>  end</p>

<p>end
```</p>

<h2>Mise à l'échelle de l'affichage</h2>

<p>Ça, c'est très simple.</p>

<p>``` html index.html
&lt;!DOCTYPE html>
<html>
  &hellip;
  <body></p>

<pre><code>&lt;canvas width="400" height="400" id="canvas"&gt;&lt;/canvas&gt;
&lt;script src="build.js"&gt;&lt;/script&gt;
</code></pre>

<p>  </body>
</html>
```</p>

<p>``` ruby app/canvas.rb
class Canvas</p>

<p>  SCALE = 4</p>

<p>  def initialize</p>

<pre><code>@canvas  = `document.getElementById('canvas')`
@context = `#@canvas.getContext('2d')`
@height  = `#@canvas.height`
@width   = `#@canvas.width`
</code></pre>

<p>  end</p>

<p>  def clear</p>

<pre><code>draw_rect(0, 0, @width, @height, 'black')
</code></pre>

<p>  end</p>

<p>  def pixel(x, y)</p>

<pre><code>draw_rect(x * SCALE, y * SCALE, SCALE, SCALE, 'white')
</code></pre>

<p>  end</p>

<p>  private</p>

<p>  def draw_rect(x, y, w, h, color)</p>

<pre><code>`#@context.fillStyle = #{color}`
`#@context.fillRect(#{x}, #{y}, #{w}, #{h})`
</code></pre>

<p>  end</p>

<p>end
```</p>

<h2>Supprimer les bordures</h2>

<p>Ça, c'est très ennuyeux, vous pouvez sauter directement à la fin de l'article.</p>

<p>Je désactive les tests des bordures, puis je les réécrit un par un.</p>

<p>``` ruby spec/neighborhood_extractor_spec.rb
require &lsquo;./app/neighborhood_extractor.rb&rsquo;</p>

<p>describe NeighborhoodExtractor do</p>

<p>  let(:generation) do</p>

<pre><code>[
  [0, 1, 0, 1],
  [1, 0, 1, 0],
  [0, 1, 1, 0]
]
</code></pre>

<p>  end</p>

<p>  &hellip;</p>

<p>  describe &lsquo;borders&rsquo; do</p>

<pre><code>specify 'x=1 y=0' do
  extractor = NeighborhoodExtractor.new(generation, 1, 0)
  expect(extractor.cells).to eq [0, 1, 1, 0, 1, 0, 1, 0, 1]
end

# specify 'x=2 y=2' do
#   extractor = NeighborhoodExtractor.new(generation, 2, 2)
#   expect(extractor.cells).to eq [0, 1, 0, 1, 1, 0, 0, 0, 0]
# end

# specify 'x=0 y=1' do
#   extractor = NeighborhoodExtractor.new(generation, 0, 1)
#   expect(extractor.cells).to eq [0, 0, 1, 0, 1, 0, 0, 0, 1]
# end

# specify 'x=3 y=1' do
#   extractor = NeighborhoodExtractor.new(generation, 3, 1)
#   expect(extractor.cells).to eq [0, 1, 0, 1, 0, 0, 1, 0, 0]
# end
</code></pre>

<p>  end
end
```</p>

<p>``` ruby app/neighborhood_extractor.rb
  def group_of_tree(row_index)</p>

<pre><code>if row_index &lt; 0
  generation[generation.size-1][x-1..x+1]
elsif row_index == generation.size
  [0, 0, 0]
else
  if x == 0
    [ 0, *generation[row_index][x..x+1] ]
  elsif x == generation.first.size - 1
    [*generation[row_index][x-1..x], 0]
  else
    generation[row_index][x-1..x+1]
  end
end
</code></pre>

<p>  end
```</p>

<p>Après refactoring</p>

<p>``` ruby app/neighborhood_extractor.rb
class NeighborhoodExtractor &lt; Struct.new(:generation, :x, :y)</p>

<p>  def cells</p>

<pre><code>[ *extract(y - 1), *extract(y), *extract(y + 1) ]
</code></pre>

<p>  end</p>

<p>  private</p>

<p>  def extract(row_index)</p>

<pre><code>row_index = generation.size - 1 if row_index &lt; 0
group_of_tree(row_index)
</code></pre>

<p>  end</p>

<p>  def group_of_tree(row_index)</p>

<pre><code>if row_index == generation.size
  [0, 0, 0]
else
  if x == 0
    [ 0, *generation[row_index][x..x+1] ]
  elsif x == generation.first.size - 1
    [*generation[row_index][x-1..x], 0]
  else
    generation[row_index][x-1..x+1]
  end
end
</code></pre>

<p>  end</p>

<p>end
```</p>

<p>``` ruby spec/neighborhood_extractor_spec.rb
  describe &lsquo;borders&rsquo; do</p>

<pre><code>...

specify 'x=2 y=2' do
  extractor = NeighborhoodExtractor.new(generation, 2, 2)
  expect(extractor.cells).to eq [0, 1, 0, 1, 1, 0, 1, 0, 1]
end
</code></pre>

<p>```</p>

<p>``` ruby app/neighborhood_extractor.rb
class NeighborhoodExtractor &lt; Struct.new(:generation, :x, :y)</p>

<p>  def cells</p>

<pre><code>[ *extract(y - 1), *extract(y), *extract(y + 1) ]
</code></pre>

<p>  end</p>

<p>  private</p>

<p>  def extract(row_index)</p>

<pre><code>group_of_tree(ensure_overlapping(row_index))
</code></pre>

<p>  end</p>

<p>  def ensure_overlapping(index)</p>

<pre><code>if index &lt; 0
  generation.size - 1
elsif index == generation.size
  0
else
  index
end
</code></pre>

<p>  end</p>

<p>  def group_of_tree(row_index)</p>

<pre><code>if x == 0
  [ 0, *generation[row_index][x..x+1] ]
elsif x == generation.first.size - 1
  [*generation[row_index][x-1..x], 0]
else
  generation[row_index][x-1..x+1]
end
</code></pre>

<p>  end</p>

<p>end
```</p>

<p>``` ruby spec/neighborhood_extractor_spec.rb
  describe &lsquo;borders&rsquo; do</p>

<pre><code>...

specify 'x=0 y=1' do
  extractor = NeighborhoodExtractor.new(generation, 0, 1)
  expect(extractor.cells).to eq [1, 0, 1, 0, 1, 0, 0, 0, 1]
end

specify 'x=3 y=1' do
  extractor = NeighborhoodExtractor.new(generation, 3, 1)
  expect(extractor.cells).to eq [0, 1, 0, 1, 0, 1, 1, 0, 0]
end
</code></pre>

<p>```</p>

<p>Ça y est, on y voit plus clair.</p>

<p>``` ruby app/neighborhood_extractor.rb
class NeighborhoodExtractor &lt; Struct.new(:generation, :x, :y)</p>

<p>  def cells</p>

<pre><code>[ *extract(y - 1), *extract(y), *extract(y + 1) ]
</code></pre>

<p>  end</p>

<p>  private</p>

<p>  def extract(row_index)</p>

<pre><code>group_of_tree(ensure_overlapping(row_index))
</code></pre>

<p>  end</p>

<p>  def ensure_overlapping(index)</p>

<pre><code>if index &lt; 0
  generation.size - 1
elsif index == generation.size
  0
else
  index
end
</code></pre>

<p>  end</p>

<p>  def group_of_tree(row_index)</p>

<pre><code>row = generation[row_index]
if x == 0
  [row[-1], *row[x..x+1] ]
elsif x == generation.first.size - 1
  [*row[x-1..x], row[0]]
else
  row[x-1..x+1]
end
</code></pre>

<p>  end</p>

<p>end
```</p>

<p>Voilà, Ruby/Opal.rb c'est fait. Vous pouvez trouver le code sur Github si vous
êtes intéressés : <a href="https://github.com/lkdjiin/game-of-life-ruby">Le jeu de la vie en ruby/opal.rb</a>.</p>

<p>La prochaine version sera écrite en Racket, un dialecte de Lisp.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p></p>
]]></content>
  </entry>
  
</feed>
