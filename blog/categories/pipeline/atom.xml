<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : pipeline | Xavier Nayrac]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/pipeline/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2015-10-10T18:48:44+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Extraction des tags de mon blog en ligne de commande]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/07/11/extraction-des-tags-de-mon-blog-en-ligne-de-commande/"/>
    <updated>2015-07-11T17:08:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/07/11/extraction-des-tags-de-mon-blog-en-ligne-de-commande</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>J’aimerais savoir quels sont les tags que j’ai le plus employé sur ce blog.
Pour cela il va d’abord falloir les extraire, si possible dans un fichier csv.</p>

<p>Comment ? En Ruby ? En R ? Non non, en Bash, ça va être beaucoup plus drôle.</p>

<p>Petite étude de cas pour découvrir la puissance de la ligne de commande, ou
pour rafraichir ses connaissances ;)</p>

<p><img class="center" src="/images/tags-cloud.png"></p>

<!-- more -->

<p>Si vous voulez reproduire l’analyse en même temps que moi, les
<a href="https://github.com/lkdjiin/lkdjiin.github.io/tree/source/source/_posts">articles sont ici</a>.</p>

<p>Voyons à quoi ressemble le début d’un article au hasard avec <code>head</code>.
Octopress, le framework que j’utilise pour ce blog, appelle les tags des
<em>categories</em>. Mais c’est pareil.</p>

<p><code>bash
$ head 2013-10-20-les-algorithmes-genetiques-demystifies-35.markdown
---
layout: post
title: "Les algorithmes génétiques démystifiés 35"
date: 2013-10-20 21:21
comments: true
categories: [imagerie, algorithme génétique, intermédiaire, javascript]
#...
</code></p>

<p>L’entête d’un article a toujours la même structure. Avec <code>head *.markdown</code>
j’affiche le début de tous les articles, les uns à la suite des autres.
Avec <code>sed</code> je peux extraire uniquement les lignes qui commencent par <code>cat</code> :</p>

<p><code>bash
$ head *.markdown | sed -n '/^cat/p'
categories: [annonce, défi]
categories: [vim, conseil, débutant]
categories: [ruby, code propre, intermédiaire]
categories: [ruby, eigenclass, object, intermédiaire]
#...
</code></p>

<p>Gardons seulement les tableaux. <code>cut -f1</code> <em>découpe</em> le premier champ, <code>-d' '</code>
indique que le séparateur de champ est l’espace, et <code>--complement</code> indique
qu’on veut conserver le complément. Autrement dit tout sauf la première
colonne.</p>

<p><code>bash
$ head *.markdown | sed -n '/^cat/p' |
&gt; cut -f1 -d' ' --complement
[annonce, défi]
[vim, conseil, débutant]
[ruby, code propre, intermédiaire]
[ruby, eigenclass, object, intermédiaire]
#...
</code></p>

<p>Supprimons les crochets à l’aide de <code>sed</code> et d’une regex rigolote.</p>

<p><code>bash
$ head *.markdown | sed -n '/^cat/p' | cut -f1 -d' ' --complement |
&gt; sed 's/[][]//g'
annonce, défi
vim, conseil, débutant
ruby, code propre, intermédiaire
ruby, eigenclass, object, intermédiaire
#...
</code></p>

<p>Supprimons les espaces inutiles. Attention, certains tags contiennent des
espaces.</p>

<p><code>bash
$ head *.markdown | sed -n '/^cat/p' | cut -f1 -d' ' --complement |
&gt; sed 's/[][]//g' |
&gt; sed 's/, /,/g'
annonce,défi
vim,conseil,débutant
ruby,code propre,intermédiaire
ruby,eigenclass,object,intermédiaire
#...
</code></p>

<p>Grâce à <code>tr</code>, je remplace chaque virgule par un retour à la ligne. Ça
commence à prendre forme.</p>

<p><code>bash
$ head *.markdown | sed -n '/^cat/p' | cut -f1 -d' ' --complement |
&gt; sed 's/[][]//g' | sed 's/, /,/g' |
&gt; tr ',' '\n'
annonce
défi
vim
conseil
débutant
ruby
code propre
intermédiaire
ruby
eigenclass
#...
</code></p>

<p>Trions par ordre alphabétique.</p>

<p>``` bash
$ head *.markdown | sed -n ‘/^cat/p’ | cut -f1 -d’ ‘ –complement |
&gt; sed ‘s/[][]//g’ | sed ‘s/, /,/g’ | tr ‘,’ ‘\n’ |
&gt; sort</p>

<p>ack
activerecord
activerecord
ag
airline
airline
airline
airline
algorithme génétique
#…
```</p>

<p>Réduisons les occurrences et comptons les avec <code>uniq -c</code>.</p>

<p><code>bash
$ head *.markdown | sed -n '/^cat/p' | cut -f1 -d' ' --complement |
&gt; sed 's/[][]//g' | sed 's/, /,/g' | tr ',' '\n' | sort |
&gt; uniq -c
      1 
      1 ack
      2 activerecord
      1 ag
      4 airline
     70 algorithme génétique
      1 alias
     16 annonce
      3 app
      1 application
#...
</code></p>

<p>Trions à nouveau, cette fois sur le nombre et du plus grand au plus petit.</p>

<p><code>bash
$ head *.markdown | sed -n '/^cat/p' | cut -f1 -d' ' --complement |
&gt; sed 's/[][]//g' | sed 's/, /,/g' | tr ',' '\n' | sort | uniq -c |
&gt; sort -nr
    213 ruby
    176 intermédiaire
    171 débutant
     70 algorithme génétique
     55 vim
     26 tutoriel
     26 julia
     26 javascript
#...
      1 application
      1 alias
      1 ag
      1 ack
      1 
</code></p>

<p>Vous avez remarquez ? Un tag est vide. Ça pourrait poser problème pour la
suite. Avec <code>sed</code> on peut facilement supprimer la dernière ligne.</p>

<p><code>bash
$ head *.markdown | sed -n '/^cat/p' | cut -f1 -d' ' --complement |
&gt; sed 's/[][]//g' | sed 's/, /,/g' | tr ',' '\n' | sort | uniq -c |
&gt; sort -nr | sed '$d'
    213 ruby
    176 intermédiaire
    171 débutant
#...
      1 alias
      1 ag
      1 ack
</code></p>

<p>À la réflexion je préfère faire comme si il y avait plusieurs lignes vides et
les supprimer toutes. Ça pourrait être plus réutilisable.</p>

<p><code>bash
$ head *.markdown | sed -n '/^cat/p' | cut -f1 -d' ' --complement |
&gt; sed 's/[][]//g' | sed 's/, /,/g' | tr ',' '\n' |
&gt; sed '/^$/d' |
&gt; sort | uniq -c | sort -nr
</code></p>

<p>Il est temps de sortir une regex un peu plus complexe pour inverser les deux
champs et ajouter une virgule entre eux.</p>

<p><code>bash
$ head *.markdown | sed -n '/^cat/p' | cut -f1 -d' ' --complement |
&gt; sed 's/[][]//g' | sed 's/, /,/g' | tr ',' '\n' | sed '/^$/d' |
&gt; sort | uniq -c | sort -nr |
&gt; sed -r 's/\s+([0-9]+) (.*)/\2,\1/'
ruby,213
intermédiaire,176
débutant,171
algorithme génétique,70
#...
</code></p>

<p>C’est quasiment terminé. Il reste à ajouter l’entête du fichier csv. Pour cela
je vais utiliser une commande non standard mais bien pratique, <code>header</code>.</p>

<p><code>bash
$ head *.markdown | sed -n '/^cat/p' | cut -f1 -d' ' --complement |
&gt;  sed 's/[][]//g' | sed 's/, /,/g' | tr ',' '\n' | sed '/^$/d' |
&gt; sort | uniq -c | sort -nr | sed -r 's/\s+([0-9]+) (.*)/\2,\1/' |
&gt; header -a tag,frequency
tag,frequency
ruby,213
intermédiaire,176
débutant,171
algorithme génétique,70
#...
</code></p>

<p>On a terminé. C’est un beau pipeline, non ? Enregistrons le résultat dans un
fichier.</p>

<p><code>bash
$ head *.markdown | sed -n '/^cat/p' | cut -f1 -d' ' --complement |
&gt;  sed 's/[][]//g' | sed 's/, /,/g' | tr ',' '\n' | sed '/^$/d' |
&gt; sort | uniq -c | sort -nr | sed -r 's/\s+([0-9]+) (.*)/\2,\1/' |
&gt; header -a tag,frequency &gt; tags.csv
</code></p>

<p>En bonus, voici le code R qui produit l’image qui illustre cet article.</p>

<p>``` r
library(wordcloud)</p>

<p>d &lt;- read.csv(‘tags.csv’)</p>

<p>colors &lt;- brewer.pal(12, ‘Paired’)
colors &lt;- colors[seq(2, 10, by=2)]</p>

<p>wordcloud(d$tag, d$frequency, colors=colors, min.freq=1, scale=c(5, .6),
          rot.per=.25, random.order=FALSE, random.color=TRUE)
```</p>

<p></p>
]]></content>
  </entry>
  
</feed>
