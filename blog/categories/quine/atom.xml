<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : quine | Xavier Nayrac]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/quine/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2017-02-26T11:13:08+01:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Un quine en R - Le retour]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/10/13/un-quine-en-r-le-retour/"/>
    <updated>2015-10-13T14:19:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/10/13/un-quine-en-r-le-retour</id>
    <content type="html"><![CDATA[<p>Dans l’article précédent <a href="http://lkdjiin.github.io/blog/2015/10/10/un-quine-en-r/">Un quine en R</a>
je présentais un <a href="https://fr.wikipedia.org/wiki/Quine_%28informatique%29">quine</a> en langage R. Le code était un peu long, 19 lignes,
surtout comparé au code Ruby de l’article original:</p>

<p><code>ruby
src = "\nputs \"src = \" + src.inspect + src"
puts "src = " + src.inspect + src
</code></p>

<p>En Ruby, c’est court en partie grâce à la méthode <code>inspect</code> qui <em>échappe</em>
automatiquement les caractères non imprimables et les guillemets:</p>

<!-- more -->

<p><code>irb
&gt;&gt; foo = "\nputs \"src\""
"\nputs \"src\""
&gt;&gt; foo.inspect
"\"\\nputs \\\"src\\\"\""
</code></p>

<p>Bien entendu j’ai cherché une fonction similaire en R, du moins pour les
chaînes de caractères. J’ai laissé tombé après un quart d’heure de recherches
infructueuses, et j’ai pondu <a href="http://lkdjiin.github.io/blog/2015/10/10/un-quine-en-r/">le code</a> de l’article précédent.</p>

<p>C’est là que Hadley Wickham <em>himself</em> m’a suggéré l’utilisation de la fonction
<code>encodeString</code>. C’est ce que j’avais cherché sans le trouver. Du coup, un
quine en R prends beaucoup moins de place et deviens plus compréhensible:</p>

<p>``` r quine2.r
src &lt;- “\nwriteLines(c(paste("src &lt;-", encodeString(src, quote=’"’)), src))”</p>

<p>writeLines(c(paste(“src &lt;-“, encodeString(src, quote=’”’)), src))
```</p>

<p>Cette version me plait bien, je l’ai donc ajouté sur le <a href="http://rosettacode.org/wiki/Quine#R">rosettacode.org</a>.</p>

<p>Comme dit la dernière fois, il est bon d’utiliser <code>diff</code> pour s’assurer qu’on
a bien écrit un quine:</p>

<p><code>bash
diff -u quine2.r &lt;(Rscript quine2.r)
</code></p>

<p>Et voilà le résultat:</p>

<p>```
$ Rscript quine3.r
src &lt;- “\nwriteLines(c(paste("src &lt;-", encodeString(src, quote=’"’)), src))”</p>

<p>writeLines(c(paste(“src &lt;-“, encodeString(src, quote=’”’)), src))
```</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Un quine en R]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/10/10/un-quine-en-r/"/>
    <updated>2015-10-10T18:11:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/10/10/un-quine-en-r</id>
    <content type="html"><![CDATA[<p>J’ai lu récemment l’article <a href="http://blog.chaps.io/2015/10/01/generating-quines-in-ruby.html">generating Quines in Ruby</a> qui m’a beaucoup plu. Et j’ai eu envie d’en faire un dans le langage R.</p>

<p>Alors c’est quoi un quine ? Un quine est un programme informatique
auto répliquant (<em>self-reproducing</em>).  Il doit satisfaire à deux conditions:</p>

<ol>
  <li>Il produit son code source en tant que unique sortie.</li>
  <li>Il ne prend aucune entrée, ce qui exclus par exemple de lire un fichier.</li>
</ol>

<!-- more -->

<p>Voici ma solution en R, elle affiche son code source sur la sortie standard
quand on l’exécute. Je me suis beaucoup inspiré de la solution en C de l’article
original:</p>

<p><code>r quine.r
src &lt;-"\nescape &lt;- function(x) {\n    cat('\"')\n    for(e in strsplit(x, '')[[1]]) {\n        if(e == '\\n') {\n            cat('\\\\n')\n        } else if(e == '\\\\') {\n            cat('\\\\\\\\')\n        } else if(e == '\"') {\n            cat('\\\\\"')\n        } else {\n            cat(e)\n        }\n    }\n    cat('\"')\n}\ncat(\"src &lt;-\")\nescape(src)\nwriteLines(src)"
escape &lt;- function(x) {
    cat('"')
    for(e in strsplit(x, '')[[1]]) {
        if(e == '\n') {
            cat('\\n')
        } else if(e == '\\') {
            cat('\\\\')
        } else if(e == '"') {
            cat('\\"')
        } else {
            cat(e)
        }
    }
    cat('"')
}
cat("src &lt;-")
escape(src)
writeLines(src)
</code></p>

<p>Comme il est noté dans l’article original, il est bon de tester sa solution à
l’aide de <code>diff</code>. Si la sortie de votre programme et le source sont identiques,
<code>diff</code> ne produira aucune sortie, sinon bon débogage ;)</p>

<p><code>bash
$ diff -u quine.r &lt;(Rscript quine.r)
</code></p>

<p>Ma solution est beaucoup plus longue que celle qui se trouve sur le <a href="http://rosettacode.org/wiki/Quine#R">rosetta code</a> par exemple. Mais c’est pas grave, c’était marrant à faire, c’était un bon petit casse-tête qui m’a bien fait réfléchir. Et j’ai même appris une fonction R qui m’était inconnue (<code>writeLines</code>).</p>

<p>À vous de jouer maintenant ; tenez moi au courant si vous écrivez un quine, quel
que soit le langage ;)</p>

<p></p>
]]></content>
  </entry>
  
</feed>
