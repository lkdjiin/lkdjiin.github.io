<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : data science | Xavier Nayrac]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/data-science/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2015-08-20T17:00:56+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Extraction des tags de mon blog en ligne de commande]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/07/11/extraction-des-tags-de-mon-blog-en-ligne-de-commande/"/>
    <updated>2015-07-11T17:08:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/07/11/extraction-des-tags-de-mon-blog-en-ligne-de-commande</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>J’aimerais savoir quels sont les tags que j’ai le plus employé sur ce blog.
Pour cela il va d’abord falloir les extraire, si possible dans un fichier csv.</p>

<p>Comment ? En Ruby ? En R ? Non non, en Bash, ça va être beaucoup plus drôle.</p>

<p>Petite étude de cas pour découvrir la puissance de la ligne de commande, ou
pour rafraichir ses connaissances ;)</p>

<p><img class="center" src="/images/tags-cloud.png"></p>

<!-- more -->

<p>Si vous voulez reproduire l’analyse en même temps que moi, les
<a href="https://github.com/lkdjiin/lkdjiin.github.io/tree/source/source/_posts">articles sont ici</a>.</p>

<p>Voyons à quoi ressemble le début d’un article au hasard avec <code>head</code>.
Octopress, le framework que j’utilise pour ce blog, appelle les tags des
<em>categories</em>. Mais c’est pareil.</p>

<p><code>bash
$ head 2013-10-20-les-algorithmes-genetiques-demystifies-35.markdown
---
layout: post
title: "Les algorithmes génétiques démystifiés 35"
date: 2013-10-20 21:21
comments: true
categories: [imagerie, algorithme génétique, intermédiaire, javascript]
#...
</code></p>

<p>L’entête d’un article a toujours la même structure. Avec <code>head *.markdown</code>
j’affiche le début de tous les articles, les uns à la suite des autres.
Avec <code>sed</code> je peux extraire uniquement les lignes qui commencent par <code>cat</code> :</p>

<p><code>bash
$ head *.markdown | sed -n '/^cat/p'
categories: [annonce, défi]
categories: [vim, conseil, débutant]
categories: [ruby, code propre, intermédiaire]
categories: [ruby, eigenclass, object, intermédiaire]
#...
</code></p>

<p>Gardons seulement les tableaux. <code>cut -f1</code> <em>découpe</em> le premier champ, <code>-d' '</code>
indique que le séparateur de champ est l’espace, et <code>--complement</code> indique
qu’on veut conserver le complément. Autrement dit tout sauf la première
colonne.</p>

<p><code>bash
$ head *.markdown | sed -n '/^cat/p' |
&gt; cut -f1 -d' ' --complement
[annonce, défi]
[vim, conseil, débutant]
[ruby, code propre, intermédiaire]
[ruby, eigenclass, object, intermédiaire]
#...
</code></p>

<p>Supprimons les crochets à l’aide de <code>sed</code> et d’une regex rigolote.</p>

<p><code>bash
$ head *.markdown | sed -n '/^cat/p' | cut -f1 -d' ' --complement |
&gt; sed 's/[][]//g'
annonce, défi
vim, conseil, débutant
ruby, code propre, intermédiaire
ruby, eigenclass, object, intermédiaire
#...
</code></p>

<p>Supprimons les espaces inutiles. Attention, certains tags contiennent des
espaces.</p>

<p><code>bash
$ head *.markdown | sed -n '/^cat/p' | cut -f1 -d' ' --complement |
&gt; sed 's/[][]//g' |
&gt; sed 's/, /,/g'
annonce,défi
vim,conseil,débutant
ruby,code propre,intermédiaire
ruby,eigenclass,object,intermédiaire
#...
</code></p>

<p>Grâce à <code>tr</code>, je remplace chaque virgule par un retour à la ligne. Ça
commence à prendre forme.</p>

<p><code>bash
$ head *.markdown | sed -n '/^cat/p' | cut -f1 -d' ' --complement |
&gt; sed 's/[][]//g' | sed 's/, /,/g' |
&gt; tr ',' '\n'
annonce
défi
vim
conseil
débutant
ruby
code propre
intermédiaire
ruby
eigenclass
#...
</code></p>

<p>Trions par ordre alphabétique.</p>

<p>``` bash
$ head *.markdown | sed -n ‘/^cat/p’ | cut -f1 -d’ ‘ –complement |
&gt; sed ‘s/[][]//g’ | sed ‘s/, /,/g’ | tr ‘,’ ‘\n’ |
&gt; sort</p>

<p>ack
activerecord
activerecord
ag
airline
airline
airline
airline
algorithme génétique
#…
```</p>

<p>Réduisons les occurrences et comptons les avec <code>uniq -c</code>.</p>

<p><code>bash
$ head *.markdown | sed -n '/^cat/p' | cut -f1 -d' ' --complement |
&gt; sed 's/[][]//g' | sed 's/, /,/g' | tr ',' '\n' | sort |
&gt; uniq -c
      1 
      1 ack
      2 activerecord
      1 ag
      4 airline
     70 algorithme génétique
      1 alias
     16 annonce
      3 app
      1 application
#...
</code></p>

<p>Trions à nouveau, cette fois sur le nombre et du plus grand au plus petit.</p>

<p><code>bash
$ head *.markdown | sed -n '/^cat/p' | cut -f1 -d' ' --complement |
&gt; sed 's/[][]//g' | sed 's/, /,/g' | tr ',' '\n' | sort | uniq -c |
&gt; sort -nr
    213 ruby
    176 intermédiaire
    171 débutant
     70 algorithme génétique
     55 vim
     26 tutoriel
     26 julia
     26 javascript
#...
      1 application
      1 alias
      1 ag
      1 ack
      1 
</code></p>

<p>Vous avez remarquez ? Un tag est vide. Ça pourrait poser problème pour la
suite. Avec <code>sed</code> on peut facilement supprimer la dernière ligne.</p>

<p><code>bash
$ head *.markdown | sed -n '/^cat/p' | cut -f1 -d' ' --complement |
&gt; sed 's/[][]//g' | sed 's/, /,/g' | tr ',' '\n' | sort | uniq -c |
&gt; sort -nr | sed '$d'
    213 ruby
    176 intermédiaire
    171 débutant
#...
      1 alias
      1 ag
      1 ack
</code></p>

<p>À la réflexion je préfère faire comme si il y avait plusieurs lignes vides et
les supprimer toutes. Ça pourrait être plus réutilisable.</p>

<p><code>bash
$ head *.markdown | sed -n '/^cat/p' | cut -f1 -d' ' --complement |
&gt; sed 's/[][]//g' | sed 's/, /,/g' | tr ',' '\n' |
&gt; sed '/^$/d' |
&gt; sort | uniq -c | sort -nr
</code></p>

<p>Il est temps de sortir une regex un peu plus complexe pour inverser les deux
champs et ajouter une virgule entre eux.</p>

<p><code>bash
$ head *.markdown | sed -n '/^cat/p' | cut -f1 -d' ' --complement |
&gt; sed 's/[][]//g' | sed 's/, /,/g' | tr ',' '\n' | sed '/^$/d' |
&gt; sort | uniq -c | sort -nr |
&gt; sed -r 's/\s+([0-9]+) (.*)/\2,\1/'
ruby,213
intermédiaire,176
débutant,171
algorithme génétique,70
#...
</code></p>

<p>C’est quasiment terminé. Il reste à ajouter l’entête du fichier csv. Pour cela
je vais utiliser une commande non standard mais bien pratique, <code>header</code>.</p>

<p><code>bash
$ head *.markdown | sed -n '/^cat/p' | cut -f1 -d' ' --complement |
&gt;  sed 's/[][]//g' | sed 's/, /,/g' | tr ',' '\n' | sed '/^$/d' |
&gt; sort | uniq -c | sort -nr | sed -r 's/\s+([0-9]+) (.*)/\2,\1/' |
&gt; header -a tag,frequency
tag,frequency
ruby,213
intermédiaire,176
débutant,171
algorithme génétique,70
#...
</code></p>

<p>On a terminé. C’est un beau pipeline, non ? Enregistrons le résultat dans un
fichier.</p>

<p><code>bash
$ head *.markdown | sed -n '/^cat/p' | cut -f1 -d' ' --complement |
&gt;  sed 's/[][]//g' | sed 's/, /,/g' | tr ',' '\n' | sed '/^$/d' |
&gt; sort | uniq -c | sort -nr | sed -r 's/\s+([0-9]+) (.*)/\2,\1/' |
&gt; header -a tag,frequency &gt; tags.csv
</code></p>

<p>En bonus, voici le code R qui produit l’image qui illustre cet article.</p>

<p>``` r
library(wordcloud)</p>

<p>d &lt;- read.csv(‘tags.csv’)</p>

<p>colors &lt;- brewer.pal(12, ‘Paired’)
colors &lt;- colors[seq(2, 10, by=2)]</p>

<p>wordcloud(d$tag, d$frequency, colors=colors, min.freq=1, scale=c(5, .6),
          rot.per=.25, random.order=FALSE, random.color=TRUE)
```</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[R : rep vs replicate]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/06/08/r-rep-vs-replicate/"/>
    <updated>2015-06-08T15:45:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/06/08/r-rep-vs-replicate</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Nouveau venu en R, je découvre régulièrement des nouvelles fonctions qui me
simplifient la vie. Comme par exemple la fonction <code>replicate</code> dont je vais
parler aujourd’hui.</p>

<p>Partons de l’hypothèse que je veuille générer plusieurs nombres aléatoires de
1 à 10. Pour ceci je dispose de la fonction <code>random</code> suivante, qui produit
justement un nombre aléatoire entre 1 et 10 :</p>

<!-- more -->

<p>``` r
random &lt;- function() {
  sample(1:10, size=1)
}</p>

<p>random()
[1] 5</p>

<p>random()
[1] 1
```</p>

<p>Comment faire pour obtenir <em>n</em> nombres aléatoires en utilisant cette fonction ?
Mettons quatre nombres. Si je me sers de <code>rep</code>, je vais avoir quelques
surprises :</p>

<p>``` r
rep(random(), 4)
[1] 8 8 8 8</p>

<p>rep(random(), 4)
[1] 2 2 2 2
```</p>

<p>En effet, l’appel à <code>random()</code> est fait avant la répétition, j’obtiens donc
quatre fois la même valeur.</p>

<p>Pour résoudre ce problème, je peux utiliser la fonction <code>replicate</code> :</p>

<p><code>r
replicate(4, random())
[1]  3  6 10  3
</code></p>

<p>Ça fonctionne car cette fois <code>random()</code> est appelé pour chacune des
répétitions.</p>

<p>Pour la petite histoire, <code>replicate</code> est un cas spécial de la fonction plus
générale <code>sapply</code> :</p>

<p><code>r
sapply(1:4, function(x) random())
[1] 10  4  2  1
</code></p>

<p>Dans ce cas d’utilisation précis <code>replicate</code> est plus confortable à utiliser,
puisque cette méthode évite de générer un vecteur inutile (<code>1:4</code>) et de passer par une fonction anonyme qui n’utilise pas son argument.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
