<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : sorm | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/sorm/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2014-04-30T21:46:30+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ruby - Et si on écrivait un ORM ? - partie 11]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/04/30/ruby-et-si-on-ecrivait-un-orm-partie-11/"/>
    <updated>2014-04-30T21:39:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/04/30/ruby-et-si-on-ecrivait-un-orm-partie-11</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>On a dit qu'il était temps de <em>splitter</em> les fichiers, aussi bien pour
les tests que pour le code d'implémentation.</p>

<!-- more -->


<p>On commence par créer un dossier spec avec à l'intérieur le fichier
<code>database_spec.rb</code>:</p>

<p>``` ruby spec/database_spec.rb
require &lsquo;./sorm&rsquo;</p>

<p>describe SORM::Database do
  describe &lsquo;connection&rsquo; do</p>

<pre><code>it 'is not connected' do
  expect(SORM::Database.connected?).to be false
end

describe 'after connection' do
  it 'is connected' do
    SORM::Database.connect('test.db')
    expect(SORM::Database.connected?).to be true
  end
end
</code></pre>

<p>  end
end
```</p>

<p>Puis on vérifie que tout va bien:</p>

<pre><code>$ rspec spec/database_spec.rb 
..
Finished in 0.00267 seconds
2 examples, 0 failures
</code></pre>

<p>Au tour de la classe <code>Base</code> d'avoir son propre fichier de tests. Je vous
épargne le contenu des méthodes <code>it</code>, il n'a pas changé:</p>

<p>``` ruby spec/base_spec.rb
require &lsquo;./sorm&rsquo;</p>

<p>describe SORM::Base do
  class Article &lt; SORM::Base ; end</p>

<p>  describe &lsquo;.execute&rsquo; do</p>

<pre><code>before do
  SORM::Database.execute("INSERT INTO article VALUES(1, 'Foo');")
  SORM::Database.execute("INSERT INTO article VALUES(2, 'Bar');")
end

after do
  SORM::Database.execute("DELETE FROM article;")
end

it 'returns the correct number of rows' do
  #
end

it 'returns correct values' do
  #
end
</code></pre>

<p>  end</p>

<p>  describe &lsquo;object creation&rsquo; do</p>

<pre><code>after { SORM::Database.execute("DELETE FROM article;") }

it 'creates a record' do
  #
end

it 'returns an object with correct class' do
  #
end

it 'returns an object with correct attributes' do
  #
end
</code></pre>

<p>  end
end
```</p>

<p>Place à la vérification:</p>

<pre><code>$ rspec spec/base_spec.rb 
An error occurred in an after hook
  NoMethodError: undefined method `execute' for false:FalseClass
[...]
5 examples, 5 failures
</code></pre>

<p>Bah oui, ça ne devrait pas nous surprendre. Notre ancien fichier de
test <em>global</em> était mal conçu. On n'est plus connecté à la base de
données. Et là se pose la question de savoir si on doit se connecter
avant chaque test, dans un <code>before :each</code> ou bien une fois pour toute
au début du fichier, dans un <code>before :all</code> ? La seconde solution me parait
la plus adaptée, mais on pourra toujours en changer par la suite si besoin
est:</p>

<p>``` ruby
describe SORM::Base do
  class Article &lt; SORM::Base ; end</p>

<p>  before :all do</p>

<pre><code>SORM::Database.connect('test.db')
</code></pre>

<p>  end</p>

<p>[&hellip;]
```</p>

<p>Or relance les tests:</p>

<pre><code>$ rspec spec/base_spec.rb 
.....
Finished in 0.10185 seconds
5 examples, 0 failures
</code></pre>

<p>Ok, cool. Reste encore à lancer les tests <strong>au complet</strong> avant de crier
victoire:</p>

<pre><code>$ rspec
.....F.

Failures:

  1) SORM::Database connection is not connected
     Failure/Error: expect(SORM::Database.connected?).to be false

       expected #&lt;FalseClass:0&gt; =&gt; false
            got #&lt;TrueClass:2&gt; =&gt; true

       Compared using equal?, which compares object identity,
       but expected and actual are not the same object. Use
       `expect(actual).to eq(expected)` if you don't care about
       object identity in this example.
     # ./spec/database_spec.rb:6:in `block (3 levels) in &lt;top (required)&gt;'

Finished in 0.03452 seconds
7 examples, 1 failure

Failed examples:

rspec ./spec/database_spec.rb:5 # SORM::Database connection is not connected
</code></pre>

<p>Et oui, on ne maitrise plus l'ordre des tests ! <code>base_spec.rb</code>, premier
dans l'ordre alphabétique a été joué avant, et donc <code>database_spec.rb</code> se
retrouve avec une base de données connectée.</p>

<p>On ajoutera donc la prochaine fois une méthode <code>disconnect</code>. Et ça me
fait penser aussi qu'il faudra configurer Rspec pour jouer les tests dans
un ordre aléatoire.</p>

<p><em>To be continued</em></p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby - Et si on écrivait un ORM ? - partie 10]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/04/27/ruby-et-si-on-ecrivait-un-orm-partie-10/"/>
    <updated>2014-04-27T18:07:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/04/27/ruby-et-si-on-ecrivait-un-orm-partie-10</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Je continue toujours le refactoring de SORM, cette fois je veux supprimer
le paramêtre <code>connection</code> dans l'initialisation de <code>Recorder</code>:</p>

<p>``` ruby
  class Recorder</p>

<pre><code>def initialize(connection, table, parameters)
  @connection = connection
  @table = table
  @parameters = parameters
end

def save
  @connection.execute(query)
end
</code></pre>

<p>```</p>

<!-- more -->


<p>Bon, c'est tout simple, on utilise directement la classe <code>Database</code>:</p>

<p>``` ruby
  class Recorder</p>

<pre><code>def initialize(table, parameters)
  @table = table
  @parameters = parameters
end

def save
  Database.execute(query)
end
</code></pre>

<p>```</p>

<p>``` ruby
  class Base</p>

<pre><code># ...

def self.save(parameters)
  Recorder.new(self.to_s.downcase, parameters).save
  self.new(parameters)
end
</code></pre>

<p>```</p>

<p>Ok, c'est trop court comme article, non ? Alors je continue. Comme dit la
dernière fois, la méthode <code>Base.sql</code> me semble inutile. Je la supprime donc,
ce qui conduit à ce code:</p>

<p>``` ruby sorm.rb
require &lsquo;sqlite3&rsquo;</p>

<p>module SORM</p>

<p>  class Database</p>

<pre><code>@@connection = false

def self.connect(database_filename)
  @@connection = SQLite3::Database.open(database_filename)
end

def self.connected?
  !!@@connection
end

def self.execute(sql)
  @@connection.execute(sql)
end
</code></pre>

<p>  end</p>

<p>  class Base</p>

<pre><code>def self.save(parameters)
  Recorder.new(self.to_s.downcase, parameters).save
  self.new(parameters)
end

def initialize(attributes)
  attributes.each do |name, value|
    instance_variable_set("@#{name}", value)
    singleton_class.class_eval{attr_reader name.to_sym}
  end
end
</code></pre>

<p>  end</p>

<p>  class Recorder</p>

<pre><code>def initialize(table, parameters)
  @table = table
  @parameters = parameters
end

def save
  Database.execute(query)
end

def query
  "INSERT INTO #@table (#{columns}) VALUES(#{values});"
end

def columns
  @parameters.keys.join(',')
end

def values
  @parameters.values.map do |item|
    item.class == String ? "'#{item}'" : item
  end.join(',')
end
</code></pre>

<p>  end
end
```</p>

<p>Mais maintenant ce sont les tests qui sont dans les choux ! Il faut
remplacer toutes les occurences de <code>Article.sql</code> par
<code>SORM::Database.execute</code>. Ce qui donne:</p>

<p>``` ruby sorm_spec.rb
require &lsquo;./sorm&rsquo;</p>

<p>describe SORM::Database do
  describe &lsquo;connection&rsquo; do</p>

<pre><code>it 'is not connected' do
  expect(SORM::Database.connected?).to be false
end

describe 'after connection' do
  it 'is connected' do
    SORM::Database.connect('test.db')
    expect(SORM::Database.connected?).to be true
  end
end
</code></pre>

<p>  end
end</p>

<p>describe SORM::Base do
  class Article &lt; SORM::Base ; end</p>

<p>  describe &lsquo;.sql&rsquo; do</p>

<pre><code>before do
  SORM::Database.execute("INSERT INTO article VALUES(1, 'Foo');")
  SORM::Database.execute("INSERT INTO article VALUES(2, 'Bar');")
end

after do
  SORM::Database.execute("DELETE FROM article;")
end

it 'returns the correct number of rows' do
  rows = SORM::Database.execute("SELECT * FROM article;")
  expect(rows.size).to eq 2
end

it 'returns correct values' do
  rows = SORM::Database.execute("SELECT * FROM article;")
  expect(rows[0][0]).to eq 1
  expect(rows[0][1]).to eq 'Foo'
  expect(rows[1][0]).to eq 2
  expect(rows[1][1]).to eq 'Bar'
end
</code></pre>

<p>  end</p>

<p>  describe &lsquo;object creation&rsquo; do</p>

<pre><code>after { SORM::Database.execute("DELETE FROM article;") }

it 'creates a record' do
  Article.save(id: 1, name: 'bépo')
  rows = SORM::Database.execute("SELECT * FROM article WHERE id = 1;")
  expect(rows[0][0]).to eq 1
  expect(rows[0][1]).to eq 'bépo'
end

it 'returns an object with correct class' do
  article = Article.save(id: 1, name: 'bépo')
  expect(article.class).to eq Article
end

it 'returns an object with correct attributes' do
  article = Article.save(id: 1, name: 'bépo')
  expect(article.id).to eq 1
  expect(article.name).to eq 'bépo'
end
</code></pre>

<p>  end
end
```</p>

<p>Et les tests passent de nouveau. Mais on a un nouveau problème !
Le bloc <code>describe '.sql'</code> suivant est devenu ridicule:</p>

<p>``` ruby
describe SORM::Base do
  class Article &lt; SORM::Base ; end</p>

<p>  describe &lsquo;.sql&rsquo; do</p>

<pre><code>before do
  SORM::Database.execute("INSERT INTO article VALUES(1, 'Foo');")
  SORM::Database.execute("INSERT INTO article VALUES(2, 'Bar');")
end

after do
  SORM::Database.execute("DELETE FROM article;")
end

it 'returns the correct number of rows' do
  rows = SORM::Database.execute("SELECT * FROM article;")
  expect(rows.size).to eq 2
end

it 'returns correct values' do
  rows = SORM::Database.execute("SELECT * FROM article;")
  expect(rows[0][0]).to eq 1
  expect(rows[0][1]).to eq 'Foo'
  expect(rows[1][0]).to eq 2
  expect(rows[1][1]).to eq 'Bar'
end
</code></pre>

<p>  end
```</p>

<p>1) Il n'y a plus de méthode <code>sql</code> et 2) il teste <code>Database.execute</code> et
n'a donc rien à faire ici. Je corrigerais ça la prochaine fois, et je pense
qu'il est temps aussi de <em>splitter</em> les fichiers tests et sources…</p>

<p><em>To be continued</em></p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby - Et si on écrivait un ORM ? - partie 9]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/04/26/ruby-et-si-on-ecrivait-un-orm-partie-9/"/>
    <updated>2014-04-26T14:23:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/04/26/ruby-et-si-on-ecrivait-un-orm-partie-9</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Encore du refactoring, cette fois ci dans la classe <code>Base</code>. Regardons le
code suivant:</p>

<p>``` ruby
  class Base</p>

<pre><code>def self.sql(raw_query)
  Database.connection.execute(raw_query)
end
</code></pre>

<p>```</p>

<p>Le <code>Database.connection.execute</code> me dérange. Il viole
<a href="http://fr.wikipedia.org/wiki/Loi_de_D%C3%A9m%C3%A9ter">la loi de Demeter</a>.</p>

<!-- more -->


<p>À bien y réfléchir, je n'ai tout simplement pas envie d'exposer la méthode
<code>connection</code>, qu'on trouve aussi un peu plus loin dans la class <code>Base</code>:</p>

<p>``` ruby</p>

<pre><code>def self.save(parameters)
  Recorder.new(Database.connection, self.to_s.downcase, parameters).save
  self.new(parameters)
end
</code></pre>

<p>```</p>

<p>La classe <code>Database</code> est actuellement comme ça:</p>

<p>``` ruby
  class Database</p>

<pre><code>@@connection = false

def self.connect(database_filename)
  @@connection = SQLite3::Database.open(database_filename)
end

def self.connected?
  !!@@connection
end

def self.connection
  @@connection
end
</code></pre>

<p>  end
```</p>

<p>Je supprime purement et simplement la méthode <code>connection</code>:</p>

<p>``` ruby
  class Database</p>

<pre><code>@@connection = false

def self.connect(database_filename)
  @@connection = SQLite3::Database.open(database_filename)
end

def self.connected?
  !!@@connection
end
</code></pre>

<p>  end
```</p>

<p>Maintenant, on rejoue les tests, qui vont nous indiquer ce qui doit être
réécrit:</p>

<pre><code>$ rspec sorm_spec.rb 
[...]
     NoMethodError:
       undefined method `connection' for SORM::Database:Class
     # ./sorm.rb:19:in `sql'
[...]
     NoMethodError:
       undefined method `connection' for SORM::Database:Class
     # ./sorm.rb:23:in `save'
[...]
7 examples, 5 failures
</code></pre>

<p>On va simplement créer une méthode <code>Database.execute</code>, qui elle, pourra
utiliser l'objet <code>connection</code>:</p>

<p>``` ruby
  class Database</p>

<pre><code>@@connection = false

def self.connect(database_filename)
  @@connection = SQLite3::Database.open(database_filename)
end

def self.connected?
  !!@@connection
end

def self.execute(sql)
  @@connection.execute(sql)
end
</code></pre>

<p>  end</p>

<p>  class Base</p>

<pre><code>def self.sql(raw_query)
  Database.execute(raw_query)
end
</code></pre>

<p>  # &hellip;
```</p>

<p>À y regarder de près, je ne suis plus certain de trouver un intérêt à
<code>Base.sql</code>. Il faudrait la supprimer puisqu'elle peut être remplacée par
<code>Database.execute</code>. Mais il faudra attendre car il y a encore des tests qui ne
passent plus, à cause de ce code:</p>

<p>``` ruby</p>

<pre><code>def self.save(parameters)
  Recorder.new(Database.connection, self.to_s.downcase, parameters).save
  self.new(parameters)
end
</code></pre>

<p>```</p>

<p>On s'en occupera la prochaine fois.</p>

<p><em>To be continued</em></p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby - Et si on écrivait un ORM ? - partie 8]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/04/25/ruby-et-si-on-ecrivait-un-orm-partie-8/"/>
    <updated>2014-04-25T21:17:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/04/25/ruby-et-si-on-ecrivait-un-orm-partie-8</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Je continue le refactoring de SORM. Voici la classe <code>Database</code> dans son
état actuel:</p>

<p>``` ruby sorm.rb
require &lsquo;sqlite3&rsquo;</p>

<p>module SORM</p>

<p>  class Database</p>

<pre><code>@@db = false

def self.connect(database_filename)
  @@db = SQLite3::Database.open(database_filename)
end

def self.connected?
  @@db ? true : false
end

def self.connection
  @@db
end
</code></pre>

<p>  end</p>

<h1>&hellip;</h1>

<p>end
```</p>

<!-- more -->


<p>La première chose que j'ai envie de faire, c'est de supprimer l'abbréviation
<code>db</code>. De plus, comme il s'agit plutôt d'établir une <em>connexion</em>, je change
pour <code>connection</code>:</p>

<p>``` ruby
  class Database</p>

<pre><code>@@connection = false

def self.connect(database_filename)
  @@connection = SQLite3::Database.open(database_filename)
end

def self.connected?
  @@connection ? true : false
end

def self.connection
  @@connection
end
</code></pre>

<p>  end
```</p>

<p>À ce sujet, j'applique <a href="http://lkdjiin.github.io/blog/2013/08/21/code-propre-non-aux-abreviations/">mes propres principes</a> ;)</p>

<p>Ensuite je vais modifier l'implémentation de la méthode <code>.connected?</code>. Elle
va passer de:</p>

<p>``` ruby</p>

<pre><code>def self.connected?
  @@db ? true : false
end
</code></pre>

<p>```</p>

<p>À quelque chose de plus expressif:</p>

<p>``` ruby</p>

<pre><code>def self.connected?
  !!@@connection
end
</code></pre>

<p>```</p>

<p>J'ai écris récemment un article sur <a href="http://lkdjiin.github.io/blog/2014/04/23/le-double-bang-en-ruby/">le double bang</a> si vous vous
demandez ce que c'est ;)</p>

<p>La prochaine fois, on <em>refactorera</em> un peu plus la classe <code>Base</code>.</p>

<p><em>To be continued</em></p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby - Et si on écrivait un ORM ? - partie 7]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/04/24/ruby-et-si-on-ecrivait-un-orm-partie-7/"/>
    <updated>2014-04-24T21:01:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/04/24/ruby-et-si-on-ecrivait-un-orm-partie-7</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Seconde partie du refactoring de SORM, mon <em>toy ORM</em> qui me sert de
prétexte pour quelques articles ;)</p>

<!-- more -->


<p>Parce que j'espère que vous avez compris que je n'était pas sérieusement
en train d'écrire un nouvel ORM pour Ruby, hein ? C'est juste pour étudier
un peu ensemble comment ça fonctionne…</p>

<p>Bref, il est temps je pense d'utiliser quelques namespace. <code>SORM::Database</code>
pour gérer la connexion et <code>SORM::Base</code> comme modèle de base. Voici donc les
tests remaniés:</p>

<p>``` ruby sorm_spec.rb
require &lsquo;./sorm&rsquo;</p>

<p>describe SORM::Database do
  describe &lsquo;connection&rsquo; do</p>

<pre><code>it 'is not connected' do
  expect(SORM::Database.connected?).to be false
end

describe 'after connection' do
  it 'is connected' do
    SORM::Database.connect('test.db')
    expect(SORM::Database.connected?).to be true
  end
end
</code></pre>

<p>  end
end</p>

<p>describe SORM::Base do
  class Article &lt; SORM::Base ; end</p>

<p>  describe &lsquo;.sql&rsquo; do</p>

<pre><code>before do
  Article.sql("INSERT INTO article VALUES(1, 'Foo');")
  Article.sql("INSERT INTO article VALUES(2, 'Bar');")
end

after do
  Article.sql("DELETE FROM article;")
end

it 'returns the correct number of rows' do
  rows = Article.sql("SELECT * FROM article;")
  expect(rows.size).to eq 2
end

it 'returns correct values' do
  rows = Article.sql("SELECT * FROM article;")
  expect(rows[0][0]).to eq 1
  expect(rows[0][1]).to eq 'Foo'
  expect(rows[1][0]).to eq 2
  expect(rows[1][1]).to eq 'Bar'
end
</code></pre>

<p>  end</p>

<p>  describe &lsquo;object creation&rsquo; do</p>

<pre><code>after { Article.sql("DELETE FROM article;") }

it 'creates a record' do
  Article.save(id: 1, name: 'bépo')
  rows = Article.sql("SELECT * FROM article WHERE id = 1;")
  expect(rows[0][0]).to eq 1
  expect(rows[0][1]).to eq 'bépo'
end

it 'returns an object with correct class' do
  article = Article.save(id: 1, name: 'bépo')
  expect(article.class).to eq Article
end

it 'returns an object with correct attributes' do
  article = Article.save(id: 1, name: 'bépo')
  expect(article.id).to eq 1
  expect(article.name).to eq 'bépo'
end
</code></pre>

<p>  end
end
```</p>

<p>Et bien sûr la nouvelle implémentation qui va avec:</p>

<p>``` ruby sorm.rb
require &lsquo;sqlite3&rsquo;</p>

<p>module SORM</p>

<p>  class Database</p>

<pre><code>@@db = false

def self.connect(database_filename)
  @@db = SQLite3::Database.open(database_filename)
end

def self.connected?
  @@db ? true : false
end

def self.connection
  @@db
end
</code></pre>

<p>  end</p>

<p>  class Base</p>

<pre><code>def self.sql(raw_query)
  Database.connection.execute(raw_query)
end

def self.save(parameters)
  Recorder.new(Database.connection, self.to_s.downcase, parameters).save
  self.new(parameters)
end

def initialize(attributes)
  attributes.each do |name, value|
    instance_variable_set("@#{name}", value)
    singleton_class.class_eval{attr_reader name.to_sym}
  end
end
</code></pre>

<p>  end</p>

<p>  class Recorder</p>

<pre><code>def initialize(connection, table, parameters)
  @connection = connection
  @table = table
  @parameters = parameters
end

def save
  @connection.execute(query)
end

def query
  "INSERT INTO #@table (#{columns}) VALUES(#{values});"
end

def columns
  @parameters.keys.join(',')
end

def values
  @parameters.values.map do |item|
    item.class == String ? "'#{item}'" : item
  end.join(',')
end
</code></pre>

<p>  end
end
```</p>

<p>Voilà, ça fait pas mal de code sans explication :( mais j'ai peu de temps
aujourd'hui. La prochaine on fera… je sais pas… on verra bien ;)</p>

<p><em>To be continued</em></p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
