<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : shell | Xavier Nayrac]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/shell/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2018-08-30T19:20:31+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Lister un dossier tout en nettoyant l'écran]]></title>
    <link href="http://lkdjiin.github.io/blog/2018/02/14/lister-un-dossier-tout-en-nettoyant-lecran/"/>
    <updated>2018-02-14T10:28:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2018/02/14/lister-un-dossier-tout-en-nettoyant-lecran</id>
    <content type="html"><![CDATA[<p>Deux ou trois fois dans l’année j’analyse mon usage du clavier pour tenter
d’augmenter mon confort quotidien. Lisez : Je regarde de près ce que je
tape pour faire en sorte de taper toujours moins.</p>

<p>J’ai remarqué récemment que j’aimais de plus en plus avoir un écran vide avant
d’entreprendre une série de commande. Pour effacer l’écran, on utilise la commande
<code>clear</code> ou son raccourci <code>Ctrl+L</code>. Et depuis quelques temps je me suis habitué
à systématiquement vider l’écran avant de lister le contenu d’un répertoire.
Autrement dit je répète très souvent la séquence de touche suivante :</p>

<center><b>Ctrl + l + l + s + Enter</b></center>

<p>Soit 5 touches.</p>

<p>Donc, beaucoup trop.</p>

<!-- more -->

<h2 id="alias-s">Alias S</h2>

<p>Un petit alias sera la solution pour prendre soin de mes poignets fragiles ;)
Je vais utiliser la lettre <code>s</code> parce que sa touche tombe particulièrement bien
sous mes doigts.</p>

<center><b>s + Enter</b></center>

<p>Soit 2 touches.</p>

<p>Donc, je suis content :)</p>

<h2 id="bash">Bash</h2>

<p>Avec Bash, que j’utilise essentiellement sur serveurs distants, voici comment
procéder :</p>

<p><code>bash
alias s='clear;ls' # List directory on a clean screen
</code></p>

<p>Je place mes alias Bash dans un fichier <code>~/.bash_aliases</code> que j’inclus depuis
le fichier <code>~/.bashrc</code> comme ceci :</p>

<p>```bash
# Alias definitions.
# You may want to put all your additions into a separate file like
# ~/.bash_aliases, instead of adding them here directly.
# See /usr/share/doc/bash-doc/examples in the bash-doc package.</p>

<p>if [ -f ~/.bash_aliases ]; then
    . ~/.bash_aliases
fi
```</p>

<h2 id="fish">Fish</h2>

<p>Avec Fish, que j’utilise sur mes machines perso, c’est un peu différent. Fish
n’a pas de commande <code>alias</code>, il suffit d’écrire une fonction au bon endroit.</p>

<p><code>
# Fichier ~/.config/fish/functions/s.fish
function s --description 'List directory on a clean, cleared screen'
  	clear
    ls
end
</code></p>

<h2 id="conclusion">Conclusion</h2>

<p>Je ne sais pas si je vais beaucoup me servir de cette commande <code>s</code>.
J’ai toujours eu du mal à m’habituer aux commandes d’une seule lettre, je sais
pas pourquoi. On verra bien…</p>

<p>Si vous avez des astuces dans le même genre, faites moi en part dans un
commentaire, ça pourrait servir ;)</p>

<p>À bientôt.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Fish : complétion puis exécution en une seule fois]]></title>
    <link href="http://lkdjiin.github.io/blog/2017/02/28/fish-completion-puis-execution-en-une-seule-fois/"/>
    <updated>2017-02-28T14:46:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2017/02/28/fish-completion-puis-execution-en-une-seule-fois</id>
    <content type="html"><![CDATA[<p>Voici une astuce pour le <a href="https://fishshell.com/">shell Fish</a>, qui vous
permettra de compléter une commande et de la lancer en même temps.</p>

<h2 id="comportement-par-dfaut--compltion-puis-excution">Comportement par défaut : complétion puis exécution</h2>

<p>Fish propose une complétion automatique au fur et à mesure que vous saisissez
une commande. Dans la capture d’écran qui suit, la partie en grisée n’a pas
été saisie, elle est seulement proposée par Fish.</p>

<p><img class="center" src="/images/fish-shell-before-completion.png"></p>

<!-- more -->

<p>Pour accepter la complétion proposée il faut utiliser le raccourci clavier <code>Ctrl+F</code>.
Le curseur se déplace à la fin de la ligne.</p>

<p><img class="center" src="/images/fish-shell-after-completion.png"></p>

<p>On peut alors appuyer sur la touche <code>Entrée</code> pour exécuter la commande.</p>

<h2 id="et-maintenant-tout-en-un-seul-raccourci">Et maintenant tout en un seul raccourci</h2>

<p>La complétion automatique de Fish est vraiment très bonne. Mais ce comportement
en deux temps, <code>Ctrl+F</code> suivi de <code>Entrée</code>, m’a rapidement exaspéré. J’ai
donc voulu le réduire à un seul raccourci : <code>Ctrl+G</code>. Vous pouvez bien sûr choisir celui
qui vous plaira le plus (j’ai choisi <code>G</code> parce que ça me fait penser à <strong>Go !</strong>).</p>

<p>Il vous faut créer une fonction <code>fish_user_key_bindings</code>, ou bien lui ajouter le
code suivant si elle existe déjà. Placez là dans le fichier
<code>~/.config/fish/functions/fish_user_key_bindings.fish</code>.</p>

<p>```
function fish_user_key_bindings</p>

<pre><code># Ctrl+g (Go!). Like Ctrl+f Enter in one go.
bind \cg accept-autosuggestion execute
</code></pre>

<p>end
```</p>

<p>Voilà, ça n’est qu’une ligne de code mais je ne pourrais plus m’en passer.</p>

<p>Si vous aussi vous avez une astuce sur Fish, n’hésitez pas à la partager dans
un commentaire, et merci d’avance.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Changer de shell, de Bash à Fish]]></title>
    <link href="http://lkdjiin.github.io/blog/2016/12/13/changer-de-shell-de-bash-a-fish/"/>
    <updated>2016-12-13T19:34:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2016/12/13/changer-de-shell-de-bash-a-fish</id>
    <content type="html"><![CDATA[<p>J’avais remarqué le shell Fish il y a plusieurs années. Mais l’accroche de son
site web m’avais plutôt fait penser à une blague :</p>

<blockquote>
  <p>Finally, a command line shell for the 90s</p>
</blockquote>

<p>Heureusement pour moi, j’y suis repassé il y a quelques mois. Et cette fois
j’ai compris que c’était du sérieux. Je me suis promis de revenir dès que
possible pour essayer ce shell.</p>

<p>On est le week end. J’ai quelques heures devant moi. C’est parti pour
un test. Et comme directement c’est l’effet WAO, je me dis que je
vais y aller <em>à la dure</em>, en l’installant sur l’ordinateur du boulot.</p>

<p>Voici mes premières impressions après deux jours d’utilisation.</p>

<!-- more -->

<h2 id="auto-compltion">Auto complétion</h2>

<p>La première chose qui me saute aux yeux, c’est l’auto complétion, qui va de pair
avec les suggestions faites par le shell.</p>

<p>L’auto complétion par la touche TAB semble bien plus performante qu’en Bash. Un
coup d’œil dans la doc me dit qu’il sera aussi plus simple de fournir les
auto complétions pour mes propres programmes.</p>

<p>Ensuite, des suggestions apparaissent au fur et à mesure que l’on entre des
caractères et c’est puissant. Ça n’existe tout simplement pas dans Bash. Ctrl+F
permet d’accepter toute la ligne, alors que Alt+F accepte un seul mot.</p>

<h2 id="coloration-syntaxique">Coloration syntaxique</h2>

<p>Fish colore votre ligne de commande en temps réel. Y a pas à dire, ça change de
Bash. Et c’est utile : une commande inconnue ou mal orthographiée apparait en
rouge, on repère une variable au milieu d’une chaîne de caractères, etc.</p>

<h2 id="retrouver-les-anciennes-commandes">Retrouver les anciennes commandes</h2>

<p>Avec Bash, j’ai une configuration qui me permet de taper les premières lettres
d’une commande, et de faire défiler (avec les touches fléchées) toutes les
commandes historiques qui commencent par ces quelques lettres.</p>

<p>Avec Fish, pas besoin de configurer quoi que ce soit. Ça existe d’emblée, mais
en plus puissant.</p>

<h2 id="raccourcis-clavier">Raccourcis clavier</h2>

<p>Pour l’instant je ne retrouve pas tous mes raccourcis (ou astuces).
<del>Par exemple avec Bash <code>Esc+.</code> affiche l’argument de la dernière commande. Ça
me manque avec Fish.</del> (Edit: à partir de la version 2.3 <code>Esc+.</code> fonctionne)
Mais comme un principe de Fish est «<em>on peut faire tous ce que peuvent faire
les autres shells</em>», j’attends de voir.</p>

<h2 id="ruby"> Ruby</h2>

<p>J’utilise <code>chruby</code> depuis un certain temps comme <em>version manager</em> et j’ai eu
une petite frayeur en constatant que plus rien ne fonctionnait avec Fish.
Pour mon premier jour sous Fish au boulot, ça a donc été mitigé, même si j’utilise
moins Ruby ces temps ci. Je repassais sous Bash quand il fallait faire du Ruby.</p>

<p>Dans l’après midi je me suis décidé à chercher, et j’ai trouvé ça:
<a href="https://github.com/JeanMertz/chruby-fish">chruby-fish</a>. Sans ce projet j’aurais
certainement cesser là mon utilisation de Fish. Donc un grand merci à son
créateur.</p>

<p>Ça fait très bien le boulot, avec un petit bug tout de même:</p>

<p><code>
$ chruby 2.3.1
mkdir: cannot create directory ‘/opt/rubies/ruby-2.3.1/lib/ruby/gems/2.3.0/bin’: Permission denied
</code></p>

<p>Pour chaque version de Ruby, il faudra donc créer ce dossier à la main:</p>

<pre><code>sudo mkdir /opt/rubies/ruby-2.3.1/lib/ruby/gems/2.3.0/bin
</code></pre>

<h2 id="prompt-thmes">Prompt, thèmes</h2>

<p>Je ne vais pas m’étendre sur le sujet, y a tout ce qu’il faut pour
personnaliser son terminal à grands coups de variables et de fonctions.</p>

<h2 id="alias-et-fonctions">Alias et fonctions</h2>

<p>Un truc qui m’a fort surpris au tout début : Fish n’a pas d’alias, il faut
utiliser des fonctions à la place. À la fin du deuxième jour d’utilisation
c’était adopté et validé. Voici un classique pour l’exemple, je veux pouvoir
taper <code>la</code> à la place de <code>ls -A</code> :</p>

<p><code>
function la --description 'Like ls with hidden file'
    ls -A $argv
end
</code></p>

<p>Un excellent point à propos des fonctions dans Fish : elles sont chargées
<em>paresseusement</em>. C’est à dire qu’une fonction est chargée automatiquement la
première fois qu’on l’utilise.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Le truc avec Fish, c’est que <em>ça juste marche</em> ™. Avec Bash, il faut des
années de configuration pour obtenir quelque chose de valable. Avec Fish, ton
premier fichier de configuration est vide, inexistant, parce que pas besoin. Et
pourtant ça fonctionne, tout simplement.</p>

<p>Maintenant ça ne fait que deux jours que je suis dessus… C’est le début, tout
est beau. Je verrai à l’usage.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[De meilleurs alias avec zsh]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/07/20/de-meilleurs-alias-avec-zsh/"/>
    <updated>2015-07-20T13:12:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/07/20/de-meilleurs-alias-avec-zsh</id>
    <content type="html"><![CDATA[<h2 id="guest-post-"><code>{ Guest Post }</code></h2>

<p>Pour m’améliorer en tant que dev, j’essaye au maximum de simplifier et d’automatiser mon workflow. L’idée est de passer moins de temps à faire des choses qu’un ordinateur peut faire à ma place, et plus de temps à réfléchir aux problèmes que je cherche à résoudre.</p>

<p>C’est dans cette optique que je me suis mis à ajouter énormément d’alias très courts à mon shell. Un alias revient à automatiser l’action de taper sur les touches pour des commandes fréquentes. Malheureusement, les alias sont sous-utilisés pour plusieurs raisons : on a peur d’oublier la commande qui se cache derrière, un autre dev avec qui on est en train de faire du pair programming aura du mal à comprendre quelles commandes sont exécutées, et souvent on oublie tout simplement qu’on a un alias pour la commande qu’on est en train de taper.</p>

<p>Pour remédier à ces problèmes, j’ai trouvé des solutions que des fonctions avancées de zsh permettent d’implémenter : les alias explicites, et les alias obligatoires.</p>

<!-- more -->

<h2 id="zsh">zsh</h2>

<p>zsh est un shell Unix similaire à bash, mais en mieux. On cite souvent son autocompletion et la quantité de plugins disponibles, notamment ceux de <a href="https://github.com/robbyrussell/oh-my-zsh">oh-my-zsh</a>, comme les principales raisons de passer de bash à zsh.</p>

<p>zsh est installé par défaut sur la plupart des distributions linux et OSX. Si vous ne l’utilisez pas encore, vous pouvez en faire votre shell par défaut avec cette commande :</p>

<p><code>
chsh -s $(which zsh)
</code></p>

<h2 id="les-alias-explicites">Les alias explicites</h2>

<p>C’est une fonction que @lkdjiin connait bien puisque c’est une des premières améliorations que j’ai apporté à mes alias quand j’ai commencé à travailler avec lui.
Voilà à quoi ça ressemble:</p>

<p><img src="https://cloud.githubusercontent.com/assets/1840367/8545448/16b25cfc-24af-11e5-85ab-69f77424b532.gif" alt="explicit_aliases" /></p>

<p>Afin de ne pas oublier la commande qui se cache derrière un alias, les alias explicite la font s’afficher comme si elle avait été entrée juste après l’alias.
Voici le code à rajouter dans votre .zshrc (le fichier de config que zsh charge avant chaque session) pour activer les alias explicites:</p>

<p>```
preexec_functions=()</p>

<p>function expand_aliases {
  input_command=$1
  expanded_command=$2
  if [ $input_command != $expanded_command ]; then
    print -nP $PROMPT
    echo $expanded_command
  fi
}</p>

<p>preexec_functions+=expand_aliases
```</p>

<p>Les preexec functions de zsh sont des fonctions qui sont appelées après qu’une commande soit lue, et avant qu’elle ne soit exécutée. zsh leur donne comme argument la commande telle qu’elle est entrée par l’utilisateur, et la même commande après l’expansion des alias.</p>

<p>Cette fonction vérifie donc que la version étendue est différente de la version entrée par l’utilisateur (c’est à dire qu’un alias a été utilisé), et le cas échéant affiche un prompt en utilisant la variable <code>$PROMPT</code> suivi de la commande.</p>

<h2 id="les-alias-obligatoires">Les alias obligatoires</h2>

<p>Cette idée plaît parfois un peu moins : pour ne pas oublier l’existence d’un alias, j’ai modifié mon setup pour que zsh refuse d’exécuter une commande si je la tape en entier plutôt que de me servir d’un alias.</p>

<p><img src="https://cloud.githubusercontent.com/assets/1840367/7302861/9e437a96-e9ec-11e4-9978-9f33f21bd7d9.gif" alt="mandatory_alias" /></p>

<p>Et voici l’implémentation dans le .zshrc:</p>

<p>```
function check-alias-and-accept {
  if [ $BUFFER ]; then</p>

<pre><code>ALIAS=`alias -L | grep -e "=[\'\"]\?${BUFFER}[\'\"]\?$"`

if [ $ALIAS ]; then
  echo
  echo "You have this alias:"
  echo
  echo $ALIAS
  echo
  echo "Use it!"

  zle kill-whole-line
  zle reset-prompt
else
  zle accept-line
fi   else
zle accept-line   fi }
</code></pre>

<p>zle -N check-alias-and-accept
bindkey ‘^J’ check-alias-and-accept
bindkey ‘^M’ check-alias-and-accept
```</p>

<p>J’utilise ici une fonction peu connue de zsh: le Zsh Line Editor, ou zle. Il s’agit du programme que zsh execute pendant qu’il lit les évènements clavier de l’utilisateur (alors que les precommand functions sont exécutées après que l’utilisateur ai fini d’entrer la commande). C’est ce programme qui lance l’autocomplétion lorsque qu’on appuie sur TAB par exemple.</p>

<p>L’implémentation est un peu plus compliquée que pour les alias explicites. Regardons un peu plus en détails ce qui se passe:</p>

<ul>
  <li>Les trois dernières lignes sont pour enregistrer la fonction <code>check-alias-and-accept</code> à la liste des fonctions que zle peut appeler, et binder la touche Entrée à l’appel de cette fonction.</li>
  <li>A l’intérieur de <code>check-alias-and-accept</code>, on commence par vérifier que l’utilisateur a entré quelque chose, ce qui est indiqué par la variable <code>$BUFFER</code> initialisée par zle. Si rien n’a été entré (dans la branche du else), on appelle tout simplement la fonction <code>zle accept-line</code>, qui est celle que zle executerait normalement à l’appui sur la touche Entrée.</li>
  <li>Si il y a une commande, on cherche parmis tous les alias si il y en a un qui correspond. <code>alias -L</code> permet d’obtenir la liste de tous les alias de la config, et un grep avec une regexp un peu sauvage permet de les filtrer.</li>
  <li>Si un alias correspond, les fonctions <code>zle kill-whole-line</code> et <code>zle reset-prompt</code> permettent de revenir à un prompt vide. La commande est donc effacée et n’apparaitra même pas dans l’historique.</li>
</ul>

<h2 id="et-bien-plus-encore">Et bien plus encore</h2>

<p>zsh est un shell très puissant lorsqu’on a le courage de lire son manuel, et permet de customizer votre setup de manière très poussée. Pour plus de customization zsh et vim, jetez un coup d’oeil à mes <a href="https://github.com/victormours/dotfiles">dotfiles</a>, et si vous avez des idées pour d’autres améliorations à base de zsh, <a href="http://twitter.com/victormours">envoyez-les moi sur twitter</a> !</p>

<h1 id="qui-a-crit-cet-article-">Qui a écrit cet article ?</h1>

<p><img src="https://avatars3.githubusercontent.com/u/1840367?v=3&amp;s=200"></p>

<p><strong>Victor Mours</strong><br />
Lead developer chez sleekapp.io, obsessionnel des dotfiles</p>
]]></content>
  </entry>
  
</feed>
