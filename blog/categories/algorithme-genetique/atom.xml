<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : algorithme génétique | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/algorithme-genetique/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2014-05-15T22:01:16+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Un algorithme génétique en Julia - partie 3]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/05/15/un-algorithme-genetique-en-julia-partie-3/"/>
    <updated>2014-05-15T21:28:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/05/15/un-algorithme-genetique-en-julia-partie-3</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Aujourd'hui j'essaye de faire la sélection en vue de la reprodution ;)
Si vous aviez suivi ma série d'articles
<a href="http://lkdjiin.github.io/blog/categories/algorithme-genetique/">les algorithmes génétiques démystifiés</a> vous savez de quoi je parle…</p>

<!-- more -->


<p>Voici d'abord les fonctions que j'ai jusqu'à présent :</p>

<p>``` julia main.jl
create_chromosome(size) = rand(0:1, size)</p>

<p>function create_population(size, chromosome_size)
  [ create_chromosome(chromosome_size) for _ in 1:size ]
end</p>

<p>score(population) = map(sum, population)
```</p>

<p>Alors j'ai remis des <code>_</code>, parce que sans j'y arrivais vraiment pas ;)
J'ai aussi ajouté l'argument <code>size</code> à la fonction de création d'un
chromosome pour éviter les nombres magiques.</p>

<p>Je veux opérer une sélection très simple : un tournoi. Pour ça, je
commence avec une fonction <code>fight</code> qui va renvoyer le meilleur chromosome
parmi deux:</p>

<p><code>julia
function fight(scores, index1, index2)
  scores[index1] &gt; scores[index2] ? index1 : index2
end
</code></p>

<p>En fait je ne passe pas de chromosome à cette fonction mais le tableau des
scores de la population, obtenu avec <code>score</code> et deux indexs.</p>

<pre><code>julia&gt; include("main.jl")

julia&gt; pop = create_population(8, 20)
8-element Array{Array{Int32,1},1}:
 [1,0,1,1,1,1,1,0,1,0,1,1,1,0,1,0,1,1,1,1]
 [1,1,0,0,0,1,0,1,0,1,0,0,0,0,0,1,0,1,1,1]
 [0,0,1,0,1,0,0,1,0,1,0,0,1,1,1,0,0,1,0,1]
 [1,1,0,1,1,1,0,1,1,0,0,1,1,1,0,1,0,1,1,1]
 [0,1,0,0,1,1,1,1,0,1,0,1,1,0,0,1,0,0,0,1]
 [1,1,0,0,0,1,0,0,1,0,1,1,1,0,1,1,1,0,1,0]
 [1,1,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,1]
 [0,0,0,1,0,1,0,0,0,1,1,1,0,1,0,1,1,1,1,1]

julia&gt; scores = score(pop)
8-element Array{Int32,1}:
 15
  9
  9
 14
 10
 11
 10
 11
</code></pre>

<p>Et la fonction <code>fight</code> renvoit l'index du meilleur des deux chromosomes
du <em>combat</em>:</p>

<pre><code>julia&gt; fight(scores, 1, 2)
1

julia&gt; fight(scores, 7, 8)
8
</code></pre>

<p>La prochaine fois je pourrais organiser le tournoi proprement dit.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Un algorithme génétique en Julia - partie 2]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/05/14/un-algorithme-genetique-en-julia-partie-2/"/>
    <updated>2014-05-14T21:04:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/05/14/un-algorithme-genetique-en-julia-partie-2</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Je continue l'algorithme génétique en Julia que j'ai commencé hier, en
cherchant la manière de calculer le score d'un chromosome.</p>

<!-- more -->


<p>Tout d'abord, je met les fonctions créées hier dans un fichier <code>main.jl</code>.
J'en profite pour les renommer. La convention en Julia veut qu'on accolle
les mots, sans séparation. Bien que je trouve ça curieux et illisible, je
vais m'y plier, après tout j'apprends…</p>

<p>``` julia main.jl
createchromosome() = rand(0:1, 10)</p>

<p>createpopulation(size) = [ createchromosome() for _ in 1:size ]
```</p>

<p>Une fois l'interpréteur Julia lancé, je charge les définitions de fonctions
du fichier <code>main.jl</code>:</p>

<pre><code>julia&gt; include("main.jl")
</code></pre>

<p>Puis je crée un chromosome:</p>

<pre><code>julia&gt; chromosome = createchromosome()
10-element Array{Int32,1}:
 1
 0
 0
 1
 1
 0
 0
 0
 1
 1
</code></pre>

<p>L'algorithme génétique que je veux mettre en place est le plus simple qui
existe. Je cherche à maximiser les chromosomes, c'est à dire que je veux
obtenir un chromosome qui ne comporte que des 1. Pour calculer son score,
il suffit donc de faire la somme de ses gènes. Très facile, puisque Julia
fournit la fonction <code>sum</code>:</p>

<pre><code>julia&gt; sum(chromosome)
5
</code></pre>

<p>Maintenant je dois trouver comment calculer le score de chaque chromosome.
Je crée donc une population:</p>

<pre><code>julia&gt; population = createpopulation(8)
8-element Array{Array{Int32,1},1}:
 [0,0,1,1,1,0,0,0,0,1]
 [1,0,0,0,1,0,1,1,0,0]
 [0,0,1,1,0,0,0,1,0,1]
 [1,0,0,1,1,0,0,0,0,0]
 [1,0,1,0,1,0,1,0,0,1]
 [0,1,1,1,1,1,0,1,0,0]
 [0,1,1,0,1,0,1,0,1,1]
 [0,1,1,1,1,1,0,1,0,0]
</code></pre>

<p>Et j'utilise <code>map</code>, qui va <em>mapper</em> la fonction <code>sum</code> sur chaque élément
de la population:</p>

<pre><code>julia&gt; map(sum, population)
8-element Array{Int32,1}:
 4
 4
 4
 3
 5
 6
 6
 6
</code></pre>

<p>Voilà, si on veut, on peut aussi créer une fonction <code>score</code>:</p>

<pre><code>julia&gt; score(population) = map(sum, population)

julia&gt; score(population)
8-element Array{Int32,1}:
 4
 4
 4
 3
 5
 6
 6
 6
</code></pre>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Un algorithme génétique en Julia - partie 1]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/05/13/un-algorithme-genetique-en-julia-partie-1/"/>
    <updated>2014-05-13T21:09:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/05/13/un-algorithme-genetique-en-julia-partie-1</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Pour continuer d'apprendre le langage Julia, je vais coder un algorithme
génétique simple.</p>

<!-- more -->


<p>Tout d'abord un chromosome, qui va contenir 10 valeurs, chaque valeur pouvant
être soit zéro, soit un:</p>

<pre><code>julia&gt; chromosome() = rand(0:1, 10)
</code></pre>

<p>La fonction <code>rand</code> prend un <em>range</em> en premier paramêtre.</p>

<p>On teste cette fonction:</p>

<pre><code>julia&gt; chromosome()
10-element Array{Int32,1}:
 0
 1
 1
 1
 1
 1
 1
 0
 1
 1
</code></pre>

<p>Maintenant je veux une population:</p>

<pre><code>julia&gt; population(size) = [ chromosome() for _ in 1:size ]
</code></pre>

<p>Il s'agit d'une <em>compréhension de liste</em>. Pour chaque valeur (symbolisée
par le <code>_</code>) du <em>range</em> de 1 à <code>size</code>, on applique la fonction <code>chromosome</code>.
Je peux donc avoir une population:</p>

<pre><code>julia&gt; population(8)
8-element Array{Array{Int32,1},1}:
 [1,0,1,0,1,0,0,1,1,0]
 [1,1,0,1,0,1,0,1,0,0]
 [1,0,1,1,0,1,1,1,1,1]
 [0,0,1,0,0,1,0,0,1,1]
 [1,0,0,1,0,1,1,1,1,0]
 [0,1,0,0,1,1,1,0,1,1]
 [0,0,0,1,0,1,0,1,1,1]
 [0,1,0,0,0,1,0,1,1,0]
</code></pre>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les algorithmes génétiques démystifiés 48: Économie - Résolution du problème]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/12/26/les-algorithmes-genetiques-demystifies-48-economie-resolution-du-probleme/"/>
    <updated>2013-12-26T20:41:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/12/26/les-algorithmes-genetiques-demystifies-48-economie-resolution-du-probleme</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>On termine le problème d'investissement, qui je le rappelle est basiquement
un problème de sac à dos avec des objets multiples.</p>

<!-- more -->


<p>Le code complet sur trouve sur Github: <a href="https://github.com/lkdjiin/knapsack_genetic_algorithm/blob/master/invest.rb">invest.rb</a>.</p>

<p>Il restait à voir la classe <code>Mutator</code>:</p>

<p>``` ruby
class Mutator
  def initialize(mutation_rate:, items:)</p>

<pre><code>@rate = mutation_rate
@items = items
</code></pre>

<p>  end</p>

<p>  def mutate(chromosome)</p>

<pre><code>chromosome.map.with_index do |gene, index|
  if rand &lt; @rate
    rand(0..@items[index].number)
  else
    gene
  end
end
</code></pre>

<p>  end
end
```</p>

<p>La formule pour muter un gène est basique, on crée aléatoirement un
nombre compris entre 0 et le nombre d'actions maximum pour cette
action particulière:</p>

<p>``` ruby</p>

<pre><code>  if rand &lt; @rate
    rand(0..@items[index].number)
</code></pre>

<p>```</p>

<p>Il reste à initialiser l'algorithme et à le lancer:</p>

<p><code>ruby
population = Population.new(Knapsack::ITEMS, 1000)
puts "Initialized!"
GeneticAlgorithm.new(
  generations: 1_000,
  population: population,
  capacity: 15_000,
  mutation_rate: 1.0 / 1000,
  items: Knapsack::ITEMS).run
</code></p>

<p>On dispose de 1 000 individus dans la population. On s'arrête
à la 1 000ème génération. Notre capacité d'investissement est
de 15 000 €. Et le taux de mutation est fixé classiquement
comme étant l'inverse du nombre d'individus.</p>

<p>Et c'est parti:</p>

<p>``` bash
[~]⇒ ruby invest.rb
Initialized!
<invalid> Gen: 0 Profit: 4202 Cost: 35599
<invalid> Gen: 1 Profit: 3567 Cost: 34133
.
.
.</p>

<h2>VALID     Gen: 999 Profit: 3430 Cost: 14067</h2>

<h2>Best ever</h2>

<p>Profit: 3430
Cost:   14067
Listing:
49 ACCOR
0 AIR_LIQUIDE
5 ALSTOM
42 ARCELORMITTAL_REG
1 AXA
3 BNP_PARIBAS
37 BOUYGUES
0 CAP_GEMINI
7 CARREFOUR
94 CREDIT_AGRICOLE_SA
0 DANONE
7 EADS
70 EDF
1 ESSILOR_INTERNATIONAL
6 GDF_SUEZ
2 GEMALTO
1 KERING
2 L'OREAL
0 LAFARGE
0 LEGRAND_SA
1 LVMH_MOET_VUITTON
2 MICHELIN
1 ORANGE
1 PERNOD_RICARD
1 PUBLICIS_GROUPE
0 RENAULT
1 SAFRAN
21 SAINT_GOBAIN
0 SANOFI
1 SCHNEIDER_ELECTRIC
7 SOCIETE_GENERALE
0 SOLVAY
73 STMICROELECTRONICS
1 TECHNIP
90 TOTAL
1 UNIBAIL-RODAMCO
8 VALLOUREC
0 VEOLIA_ENVIRONNEMENT
1 VINCI
36 VIVENDI
```</p>

<p>Si vous pensez à quelques améliorations, et il y en a,
n'hésitez pas à les tester et/ou à m'en faire part dans un
commentaire.</p>

<p>La prochaine fois, on s'attaquera sûrement à un problème de
sac à dos multiple. C'est à dire plusieurs objets de chaque
sortes et plusieurs sacs à dos.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les algorithmes génétiques démystifiés 47: Économie]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/12/23/les-algorithmes-genetiques-demystifies-47-economie/"/>
    <updated>2013-12-23T16:13:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/12/23/les-algorithmes-genetiques-demystifies-47-economie</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>La dernière fois on a vu <a href="http://lkdjiin.github.io/blog/2013/12/19/les-algorithmes-genetiques-demystifies-46-economie-la-boucle-principale/">la classe GeneticAlgorithm</a>, qui faisait usage
d'une classe IndividualFormatter. Cette classe est le sujet de l'article
d'aujourd'hui.</p>

<!-- more -->


<p>Cette classe, <code>IndividualFormatter</code>, est responsable de la transformation
d'un individu de la population en une chaîne de caractères qui véhicule
des informations <em>affichables</em> sur cet individu:</p>

<p>``` ruby
class IndividualFormatter</p>

<p>  def self.display(individual:, generation:, items:, capacity:)</p>

<pre><code>profit, cost = Score.profit_and_cost individual, items
if cost &gt; capacity
  "&lt;invalid&gt; Gen: #{generation} Profit: #{profit} Cost: #{cost}"
else
  "VALID     Gen: #{generation} Profit: #{profit} Cost: #{cost}"
end
</code></pre>

<p>  end</p>

<p>  def self.display_best_ever(individual:, items:)</p>

<pre><code>profit, cost = Score.profit_and_cost individual, items
"----------------------\n"\
"Best ever\n"\
"----------------------\n"\
"Profit: #{profit}\n"\
"Cost:   #{cost}\n"\
"Listing:\n"\
"#{Individual.listing(chromosome: individual.chromosome, items: items)}"
</code></pre>

<p>  end
end
```</p>

<p>La méthode <code>display</code> est utilisée à chaque génération, pour afficher succintement
le meilleur individu trouvé jusqu'ici.</p>

<p>La méthode <code>display_best_ever</code> est elle, utilisée à la fin de l'algorithme,
pour afficher la meilleure solution avec plus de détails.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
