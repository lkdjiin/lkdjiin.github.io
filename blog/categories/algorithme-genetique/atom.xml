<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : algorithme génétique | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/algorithme-genetique/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2014-07-04T21:50:15+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Un algorithme génétique pour les tours de Hanoi avec Opal.rb]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/07/04/un-algorithme-genetique-pour-les-tours-de-hanoi-avec-opal-dot-rb/"/>
    <updated>2014-07-04T21:07:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/07/04/un-algorithme-genetique-pour-les-tours-de-hanoi-avec-opal-dot-rb</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Pour débuter la résolution du jeu des tours de Hanoi à l'aide d'un algorithme
génétique, j'ai envie de commencer par réfléchir à la représentation des
chromosomes, aux règles de mouvement, à la fonction d'évaluation, sans
forcément commencer à coder.</p>

<!-- more -->


<p>Les règles sont sur <a href="http://fr.wikipedia.org/wiki/Tours_de_Hano%C3%AF">wikipédia</a>.</p>

<p>J'apprend un truc qui va me servir, il faut 2<sup>n</sup> &ndash; 1 coups au minimum pour
solutionner le problème (n est le nombre de disques). Du coup, mes chromosomes
devront posséder 2<sup>n</sup> &ndash; 1 gènes. Ce qui ira sans trop de soucis jusqu'à une
dizaines de disques, mais au delà c'est pas gagné.</p>

<p>Pour faire simple, un gène va représenter un mouvement à l'aide d'un nombre:</p>

<pre><code>0 -&gt; du 1er poteau au 2ème poteau
1 -&gt; du 1er poteau au 3ème poteau
2 -&gt; du 2ème poteau au 1er poteau
3 -&gt; du 2ème poteau au 3ème poteau
4 -&gt; du 3ème poteau au 1er poteau
5 -&gt; du 3ème poteau au 2ème poteau
</code></pre>

<p>Que faire quand un mouvement est illégal ? Le plus simple est de l'ignorer,
c'est donc ce que je vais faire.</p>

<p>La fonction d'évaluation, maintenant ? J'ai envie de donner un <em>poids</em> à
chaque disque suivant le poteau où il se trouve. Sur le premier poteau, un
disque vaut 0 point. Sur le second poteau, il vaut 1 point, et sur le
troisième, il vaut 2 points.</p>

<p>Par exemple, si je commence avec seulement 3 disques, la position suivante
vaut 0 point:</p>

<pre><code>  x|x      |       |   
 xx|xx     |       |   
xxx|xxx    |       |    
</code></pre>

<p>Alors que la suivante vaut 6 points:</p>

<pre><code>   |       |      x|x   
   |       |     xx|xx 
   |       |    xxx|xxx
</code></pre>

<p>C'est pas suffisant pour différencier certaines solutions, donc on appliquera
un multiplicateur suivant la taille du disque, 1 pour le plus petit, 2 pour
le suivant et 3 pour le plus grand. Je vous laisse faire les calculs, ça me
prend trop de temps de faire les petits dessins ;)</p>

<p>Allez, la prochaine fois on code…</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Un algorithme génétique avec Opal.rb ?]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/06/29/un-algorithme-genetique-avec-opal-dot-rb/"/>
    <updated>2014-06-29T20:59:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/06/29/un-algorithme-genetique-avec-opal-dot-rb</id>
    <content type="html"><![CDATA[<p>Aujourd'hui c'est dimanche, pas d'article technique. Par contre une idée
pour la suite. Un algorithme génétique pour résoudre le jeu des tours de
Hanoi.</p>

<!-- more -->


<p>Ça fait longtemps que j'ai envie de faire un algorithme génétique en rapport
avec un jeu, où on pourrait visualiser de manière graphique et ludique
l'avancée de l'algorithme. J'ai déjà fait une tentative <em>graphique</em> en
utilisant javascript, mais le résultat n'a pas été à la hauteur de mes
espérances, même si ça fonctionnait. Avec Opal, je pourrais utiliser un
langage que je connais bien.</p>

<p>Je suis pressé de commencer ;)</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Un algorithme génétique en Julia - partie 17]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/06/04/un-algorithme-genetique-en-julia-partie-17/"/>
    <updated>2014-06-04T21:59:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/06/04/un-algorithme-genetique-en-julia-partie-17</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Aujourd'hui j'ai envie de faire une version récursive de la fonction
<code>run</code>. Voici la version actuelle:</p>

<p>``` julia
function run(population_size, genes_size, generations, fight_rate)
  current = create_population(population_size, genes_size)
  for i in 1:generations</p>

<pre><code>scores = score(current)
best = maximum(scores)
println("Generation $i Best $best")
selection = tournament(scores, fight_rate)
current = reproduction([], current, selection, population_size)
</code></pre>

<p>  end
end
```</p>

<!-- more -->


<p>Et en voici une version récursive (avec un <em>helper</em>):</p>

<p>``` julia
function run(population_size, genes_size, generations, fight_rate)
  current = create_population(population_size, genes_size)
  run_helper(current, population_size, fight_rate, generations)
end</p>

<p>function run_helper(current, population_size, fight_rate, generations,</p>

<pre><code>                generation = 1)
</code></pre>

<p>  scores = score(current)
  best = maximum(scores)
  println(&ldquo;Generation $generation Best $best&rdquo;)
  if generation &lt; generations</p>

<pre><code>selection = tournament(scores, fight_rate)
current = reproduction([], current, selection, population_size)
run_helper(current, population_size, fight_rate, generations, generation + 1)
</code></pre>

<p>  end
end
```</p>

<p>Alors je me doute que je suis sûrement assez maladroit avec Julia, que
j'apprend, et avec le style récursif, qui ne coule pas de source chez moi,
mais j'ai quand même l'impression que ça n'apporte rien du tout au
programme !</p>

<p>Pour l'instant, je pense que je vais me limiter souvent à des boucles
<code>for</code> ;)</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Un algorithme génétique en Julia - partie 16]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/06/03/un-algorithme-genetique-en-julia-partie-16/"/>
    <updated>2014-06-03T21:02:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/06/03/un-algorithme-genetique-en-julia-partie-16</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>J'ai retiré les nombres magiques et renommé les quelques variables qui étaient
abrégées. Puis j'ai voulu commencer à documenter le code. Là je me suis
aperçu que le <em>typage</em> était une bonne façon de documenter Julia. Par
exemple:</p>

<p><code>julia
type Chromosome
  genes::Array{Int}
end
</code></p>

<p>m'apparait quasiment comme étant <em>auto-documenté</em>, comparé à la version
précédente:</p>

<p><code>julia
type Chromosome
  genes
end
</code></p>

<!-- more -->


<p>Plus de documentation plus tard, quand j'aurais trouvé si il y a un
<em>standard</em> en Julia (j'ai bien l'impression qu'il n'y en a pas :( ).</p>

<p>Pour l'instant, voici le code après son enième remaniement:</p>

<p>``` julia main.jl
type Chromosome
  genes::Array{Int}
end</p>

<p>create_genes(size) = rand(0:1, size)</p>

<p>function create_population(size, chromosome_size)
  [ Chromosome(create_genes(chromosome_size)) for _ in 1:size ]
end</p>

<p>score(population) = map(chromosome &ndash;> sum(chromosome.genes), population)</p>

<p>function fight(scores, index1, index2, rate)
  if rand() &lt; rate</p>

<pre><code>scores[index1] &gt; scores[index2] ? index1 : index2
</code></pre>

<p>  else</p>

<pre><code>scores[index1] &gt; scores[index2] ? index2 : index1
</code></pre>

<p>  end
end</p>

<p>function tournament(scores, rate)
  population_size = length(scores)
  selection_size = population_size * 2
  [ fight(scores, rand(1:population_size), rand(1:population_size), rate)</p>

<pre><code>for _ in 1:selection_size ]
</code></pre>

<p>end</p>

<p>function crossover(chromosome1, chromosome2, population_size)
  cut_point = rand(1:length(chromosome1.genes))
  first_part = chromosome1.genes[1:cut_point]
  second_part = chromosome2.genes[cut_point + 1:end]
  mutate(Chromosome([ first_part, second_part]), population_size)
end</p>

<p>function reproduction(new_population, current_population, selection,</p>

<pre><code>                  population_size)
</code></pre>

<p>  if selection == []</p>

<pre><code>return new_population
</code></pre>

<p>  else</p>

<pre><code>father = current_population[selection[1]]
mother = current_population[selection[2]]
child = crossover(father, mother, population_size)
reproduction([new_population, child], current_population, selection[3:end],
             population_size)
</code></pre>

<p>  end
end</p>

<p>function mutate(chromosome, population_size)
  mutator(gene) = if rand(1:population_size) == 1</p>

<pre><code>gene == 1 ? 0 : 1
</code></pre>

<p>  else</p>

<pre><code>gene
</code></pre>

<p>  end
  Chromosome([ mutator(gene) for gene in chromosome.genes ])
end</p>

<p>function run(population_size, genes_size, generations, fight_rate)
  current = create_population(population_size, genes_size)
  for i in 1:generations</p>

<pre><code>scores = score(current)
best = maximum(scores)
println("Generation $i Best $best")
selection = tournament(scores, fight_rate)
current = reproduction([], current, selection, population_size)
</code></pre>

<p>  end
end
```</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Un algorithme génétique en Julia - partie 15]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/06/02/un-algorithme-genetique-en-julia-partie-15/"/>
    <updated>2014-06-02T21:02:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/06/02/un-algorithme-genetique-en-julia-partie-15</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Après avoir pondu <a href="blog/2014/06/01/un-algorithme-genetique-en-julia-partie-14/">une première version</a>
de l'algorithme hier, je me demande ce que je pourrais améliorer. C'était
un programme sympa pour découvrir Julia, mais je n'ai fait que gratter la
surface de ce langage.</p>

<!-- more -->


<p>Donc, voici ce que je compte/espère faire encore avec ce programme pour
comprendre un peu mieux Julia:</p>

<ul>
<li>Retirer les nombres magiques restants.</li>
<li>Retirer les abbreviations restantes.</li>
<li>Documenter les fonctions, sinon dans un mois, j'aurais tout oublié !</li>
<li>Essayer une version récursive de la fonction <code>run</code>.</li>
<li>Lire quelques tutos pour voir ce que je peux en tirer.</li>
<li>Lire du code julia pour mieux <em>sentir</em> (le code source de Julia <em>itself</em>
serait un bon début).</li>
<li>Mettre le code sur github et le donner à lire/critiquer à des développeurs qui
connaissent le langage.</li>
<li>Comprendre pourquoi avec 10.000 individus de 100 gènes, l'empreinte
mémoire est de 800 Mo ! Ça me semble beaucoup…</li>
<li>Écrire le même en Ruby et comparer le temps d'exécution.</li>
</ul>


<p>Voilà, il devrait donc y avoir encore pas mal d'articles sur le langage
Julia ;)</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
