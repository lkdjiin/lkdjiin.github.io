<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : algorithme génétique | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/algorithme-genetique/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2014-07-05T15:45:26+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Les tours de Hanoi - partie 1]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/07/05/les-tours-de-hanoi-partie-1/"/>
    <updated>2014-07-05T15:25:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/07/05/les-tours-de-hanoi-partie-1</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Je vais commencer par implémenter une classe <code>Board</code>, dont la tâche est
de retenir l'état du plateau de jeu, c'est à dire la position des pièces.
J'ai envie de faire des tests avec Rspec, donc voici les premiers fichiers:</p>

<pre><code>$ tree
.
├── board.rb
└── spec
    └── board_spec.rb
</code></pre>

<!-- more -->


<p>Voici les tests de <code>Board</code>, qui décrivent ce que j'attend de cette classe:</p>

<p>``` ruby spec/board_spec.rb
require &lsquo;./board&rsquo;</p>

<p>describe Board do</p>

<p>  before { @board = Board.new(3) }</p>

<p>  it &lsquo;has a position&rsquo; do</p>

<pre><code>expect(@board.position).to eq [ [3, 2, 1], [], [] ]
</code></pre>

<p>  end</p>

<p>  it &lsquo;accepts a position&rsquo; do</p>

<pre><code>@board.position = [ [], [3], [2, 1] ]
expect(@board.position).to eq [ [], [3], [2, 1] ]
</code></pre>

<p>  end</p>

<p>  describe &lsquo;position evalution&rsquo; do</p>

<pre><code>specify { expect(@board.eval).to eq 0 }

specify do
  @board.position = [ [], [3], [2, 1] ]
  expect(@board.eval).to eq 9
end

specify do
  @board.position = [ [], [], [3, 2, 1] ]
  expect(@board.eval).to eq 12
end
</code></pre>

<p>  end</p>

<p>end
```</p>

<p>On doit pouvoir l'initialiser avec un nombre de pièces:</p>

<pre><code>before { @board = Board.new(3) }
</code></pre>

<p>À l'initialisation, les pièces sont en position de départ:</p>

<pre><code>it 'has a position' do
  expect(@board.position).to eq [ [3, 2, 1], [], [] ]
end
</code></pre>

<p>On peut modifier la position à volonté:</p>

<pre><code>it 'accepts a position' do
  @board.position = [ [], [3], [2, 1] ]
  expect(@board.position).to eq [ [], [3], [2, 1] ]
end
</code></pre>

<p>Enfin, la position actuelle peut être évaluée:</p>

<pre><code>describe 'position evalution' do

  specify { expect(@board.eval).to eq 0 }

  specify do
    @board.position = [ [], [3], [2, 1] ]
    expect(@board.eval).to eq 9
  end

  specify do
    @board.position = [ [], [], [3, 2, 1] ]
    expect(@board.eval).to eq 12
  end

end
</code></pre>

<p>Pour finir, l'implémentation minimum:</p>

<p>``` ruby board.rb
class Board</p>

<p>  def initialize(number_of_pieces)</p>

<pre><code>@pegs = [ (1..number_of_pieces).to_a.reverse, [], [] ]
</code></pre>

<p>  end</p>

<p>  def position</p>

<pre><code>@pegs
</code></pre>

<p>  end</p>

<p>  def position=(pegs)</p>

<pre><code>@pegs = pegs
</code></pre>

<p>  end</p>

<p>  def eval</p>

<pre><code>@pegs[1].reduce(0, :+) + 2 * @pegs[2].reduce(0, :+)
</code></pre>

<p>  end</p>

<p>end
```</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Un algorithme génétique pour les tours de Hanoi avec Opal.rb]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/07/04/un-algorithme-genetique-pour-les-tours-de-hanoi-avec-opal-dot-rb/"/>
    <updated>2014-07-04T21:07:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/07/04/un-algorithme-genetique-pour-les-tours-de-hanoi-avec-opal-dot-rb</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Pour débuter la résolution du jeu des tours de Hanoi à l'aide d'un algorithme
génétique, j'ai envie de commencer par réfléchir à la représentation des
chromosomes, aux règles de mouvement, à la fonction d'évaluation, sans
forcément commencer à coder.</p>

<!-- more -->


<p>Les règles sont sur <a href="http://fr.wikipedia.org/wiki/Tours_de_Hano%C3%AF">wikipédia</a>.</p>

<p>J'apprend un truc qui va me servir, il faut 2<sup>n</sup> &ndash; 1 coups au minimum pour
solutionner le problème (n est le nombre de disques). Du coup, mes chromosomes
devront posséder 2<sup>n</sup> &ndash; 1 gènes. Ce qui ira sans trop de soucis jusqu'à une
dizaines de disques, mais au delà c'est pas gagné.</p>

<p>Pour faire simple, un gène va représenter un mouvement à l'aide d'un nombre:</p>

<pre><code>0 -&gt; du 1er poteau au 2ème poteau
1 -&gt; du 1er poteau au 3ème poteau
2 -&gt; du 2ème poteau au 1er poteau
3 -&gt; du 2ème poteau au 3ème poteau
4 -&gt; du 3ème poteau au 1er poteau
5 -&gt; du 3ème poteau au 2ème poteau
</code></pre>

<p>Que faire quand un mouvement est illégal ? Le plus simple est de l'ignorer,
c'est donc ce que je vais faire.</p>

<p>La fonction d'évaluation, maintenant ? J'ai envie de donner un <em>poids</em> à
chaque disque suivant le poteau où il se trouve. Sur le premier poteau, un
disque vaut 0 point. Sur le second poteau, il vaut 1 point, et sur le
troisième, il vaut 2 points.</p>

<p>Par exemple, si je commence avec seulement 3 disques, la position suivante
vaut 0 point:</p>

<pre><code>  x|x      |       |   
 xx|xx     |       |   
xxx|xxx    |       |    
</code></pre>

<p>Alors que la suivante vaut 6 points:</p>

<pre><code>   |       |      x|x   
   |       |     xx|xx 
   |       |    xxx|xxx
</code></pre>

<p>C'est pas suffisant pour différencier certaines solutions, donc on appliquera
un multiplicateur suivant la taille du disque, 1 pour le plus petit, 2 pour
le suivant et 3 pour le plus grand. Je vous laisse faire les calculs, ça me
prend trop de temps de faire les petits dessins ;)</p>

<p>Allez, la prochaine fois on code…</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Un algorithme génétique avec Opal.rb ?]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/06/29/un-algorithme-genetique-avec-opal-dot-rb/"/>
    <updated>2014-06-29T20:59:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/06/29/un-algorithme-genetique-avec-opal-dot-rb</id>
    <content type="html"><![CDATA[<p>Aujourd'hui c'est dimanche, pas d'article technique. Par contre une idée
pour la suite. Un algorithme génétique pour résoudre le jeu des tours de
Hanoi.</p>

<!-- more -->


<p>Ça fait longtemps que j'ai envie de faire un algorithme génétique en rapport
avec un jeu, où on pourrait visualiser de manière graphique et ludique
l'avancée de l'algorithme. J'ai déjà fait une tentative <em>graphique</em> en
utilisant javascript, mais le résultat n'a pas été à la hauteur de mes
espérances, même si ça fonctionnait. Avec Opal, je pourrais utiliser un
langage que je connais bien.</p>

<p>Je suis pressé de commencer ;)</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Un algorithme génétique en Julia - partie 17]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/06/04/un-algorithme-genetique-en-julia-partie-17/"/>
    <updated>2014-06-04T21:59:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/06/04/un-algorithme-genetique-en-julia-partie-17</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Aujourd'hui j'ai envie de faire une version récursive de la fonction
<code>run</code>. Voici la version actuelle:</p>

<p>``` julia
function run(population_size, genes_size, generations, fight_rate)
  current = create_population(population_size, genes_size)
  for i in 1:generations</p>

<pre><code>scores = score(current)
best = maximum(scores)
println("Generation $i Best $best")
selection = tournament(scores, fight_rate)
current = reproduction([], current, selection, population_size)
</code></pre>

<p>  end
end
```</p>

<!-- more -->


<p>Et en voici une version récursive (avec un <em>helper</em>):</p>

<p>``` julia
function run(population_size, genes_size, generations, fight_rate)
  current = create_population(population_size, genes_size)
  run_helper(current, population_size, fight_rate, generations)
end</p>

<p>function run_helper(current, population_size, fight_rate, generations,</p>

<pre><code>                generation = 1)
</code></pre>

<p>  scores = score(current)
  best = maximum(scores)
  println(&ldquo;Generation $generation Best $best&rdquo;)
  if generation &lt; generations</p>

<pre><code>selection = tournament(scores, fight_rate)
current = reproduction([], current, selection, population_size)
run_helper(current, population_size, fight_rate, generations, generation + 1)
</code></pre>

<p>  end
end
```</p>

<p>Alors je me doute que je suis sûrement assez maladroit avec Julia, que
j'apprend, et avec le style récursif, qui ne coule pas de source chez moi,
mais j'ai quand même l'impression que ça n'apporte rien du tout au
programme !</p>

<p>Pour l'instant, je pense que je vais me limiter souvent à des boucles
<code>for</code> ;)</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Un algorithme génétique en Julia - partie 16]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/06/03/un-algorithme-genetique-en-julia-partie-16/"/>
    <updated>2014-06-03T21:02:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/06/03/un-algorithme-genetique-en-julia-partie-16</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>J'ai retiré les nombres magiques et renommé les quelques variables qui étaient
abrégées. Puis j'ai voulu commencer à documenter le code. Là je me suis
aperçu que le <em>typage</em> était une bonne façon de documenter Julia. Par
exemple:</p>

<p><code>julia
type Chromosome
  genes::Array{Int}
end
</code></p>

<p>m'apparait quasiment comme étant <em>auto-documenté</em>, comparé à la version
précédente:</p>

<p><code>julia
type Chromosome
  genes
end
</code></p>

<!-- more -->


<p>Plus de documentation plus tard, quand j'aurais trouvé si il y a un
<em>standard</em> en Julia (j'ai bien l'impression qu'il n'y en a pas :( ).</p>

<p>Pour l'instant, voici le code après son enième remaniement:</p>

<p>``` julia main.jl
type Chromosome
  genes::Array{Int}
end</p>

<p>create_genes(size) = rand(0:1, size)</p>

<p>function create_population(size, chromosome_size)
  [ Chromosome(create_genes(chromosome_size)) for _ in 1:size ]
end</p>

<p>score(population) = map(chromosome &ndash;> sum(chromosome.genes), population)</p>

<p>function fight(scores, index1, index2, rate)
  if rand() &lt; rate</p>

<pre><code>scores[index1] &gt; scores[index2] ? index1 : index2
</code></pre>

<p>  else</p>

<pre><code>scores[index1] &gt; scores[index2] ? index2 : index1
</code></pre>

<p>  end
end</p>

<p>function tournament(scores, rate)
  population_size = length(scores)
  selection_size = population_size * 2
  [ fight(scores, rand(1:population_size), rand(1:population_size), rate)</p>

<pre><code>for _ in 1:selection_size ]
</code></pre>

<p>end</p>

<p>function crossover(chromosome1, chromosome2, population_size)
  cut_point = rand(1:length(chromosome1.genes))
  first_part = chromosome1.genes[1:cut_point]
  second_part = chromosome2.genes[cut_point + 1:end]
  mutate(Chromosome([ first_part, second_part]), population_size)
end</p>

<p>function reproduction(new_population, current_population, selection,</p>

<pre><code>                  population_size)
</code></pre>

<p>  if selection == []</p>

<pre><code>return new_population
</code></pre>

<p>  else</p>

<pre><code>father = current_population[selection[1]]
mother = current_population[selection[2]]
child = crossover(father, mother, population_size)
reproduction([new_population, child], current_population, selection[3:end],
             population_size)
</code></pre>

<p>  end
end</p>

<p>function mutate(chromosome, population_size)
  mutator(gene) = if rand(1:population_size) == 1</p>

<pre><code>gene == 1 ? 0 : 1
</code></pre>

<p>  else</p>

<pre><code>gene
</code></pre>

<p>  end
  Chromosome([ mutator(gene) for gene in chromosome.genes ])
end</p>

<p>function run(population_size, genes_size, generations, fight_rate)
  current = create_population(population_size, genes_size)
  for i in 1:generations</p>

<pre><code>scores = score(current)
best = maximum(scores)
println("Generation $i Best $best")
selection = tournament(scores, fight_rate)
current = reproduction([], current, selection, population_size)
</code></pre>

<p>  end
end
```</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
