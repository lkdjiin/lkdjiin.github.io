<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : algorithme génétique | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/algorithme-genetique/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2013-12-12T21:11:35+01:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Les algorithmes génétiques démystifiés 42: Un problème d'économie]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/12/11/les-algorithmes-genetiques-demystifies-42-un-probleme-deconomie/"/>
    <updated>2013-12-11T20:56:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/12/11/les-algorithmes-genetiques-demystifies-42-un-probleme-deconomie</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Jusqu'ici les problèmes abordés dans cette série d'articles ont été très
<em>théoriques</em>.  Le dernier algorithme génétique qu'on a exploré a permis de
résoudre
<a href="http://lkdjiin.github.io/blog/2013/11/12/les-algorithmes-genetiques-demystifies-37-le-probleme-du-sac-a-dos/">le problème du sac à dos</a>. Ce problème du sac à dos est une bonne base
<em>théorique</em> pour aborder certains problèmes plus <em>concrets</em>. On va justement
se rapprocher un peu du monde réel en tentant de résoudre un problème
d'économie: optimiser un investissement.</p>

<!-- more -->


<p>Voici l'énoncé du problème: Vous êtes un investisseur et vous disposez
d'une somme de 15 000 € pour acheter des actions du CAC 40.
Vous connaissez le coût
d'une action (son prix), vous savez combien elle rapportera dans, disons un
an, et vous connaissez le nombre d'actions disponibles (combien vous pouvez
en acheter). L'objectif est de savoir combien d'actions acheter pour chaque
entreprise du CAC 40, histoire de faire un maximum de profit.</p>

<p>Alors si on se rapproche du monde réel, on est encore dans un monde
fantastique, puisque pour savoir combien rapportera
une action, soit vous avez un super-pouvoir, soit vous connaissez un
ami médium. Quoiqu'il en soit, il me semble que c'est un problème intéressant,
donc c'est parti.</p>

<p>Ce problème est très proche du problème du sac à dos, je vais donc me baser
sur le code développé dans les derniers articles, et qui est
<a href="https://github.com/lkdjiin/knapsack_genetic_algorithm/blob/master/knapsack3.rb">disponible sur Github</a>.</p>

<p>Dans le problème du sac à dos, on devait choisir des objets ; ici les actions
remplacent les objets. Les objets avaient un poid ; ici les actions ont un
coût. Les objets avaient une valeur ; ici aussi les actions ont une
valeur, qu'on nommera «profit». La différence, c'est qu'ici on va pouvoir
choisir plusieurs actions de même type.</p>

<p>Voici comment on peut représenter une action:</p>

<p><code>ruby
KnapsackItem = Struct.new(:name, :cost, :profit, :number)
</code></p>

<p>On a le nom de l'action (<code>name</code>), son coût en euros (<code>cost</code>), le profit
attendu en euros (<code>profit</code>) et le nombre d'actions disponibles (<code>number</code>).</p>

<p>Pour le stock d'actions dans lequel on va puiser, j'ai été voir le CAC 40,
j'ai pris la valeur réelle des actions (arrondi à l'entier) et j'ai
généré aléatoirement les champs profit et number:</p>

<p>``` ruby
module Knapsack
  ITEMS = [</p>

<pre><code>KnapsackItem.new('ACCOR', 32, 9, 60),
KnapsackItem.new('AIR_LIQUIDE', 97, 7, 32),
KnapsackItem.new('ALSTOM', 25, 5, 6),
KnapsackItem.new('ARCELORMITTAL_REG', 12, 9, 43),
KnapsackItem.new('AXA', 18, 2, 65),
KnapsackItem.new('BNP_PARIBAS', 53, 3, 24),
KnapsackItem.new('BOUYGUES', 25, 9, 38),
KnapsackItem.new('CAP_GEMINI', 46, 1, 47),
KnapsackItem.new('CARREFOUR', 27, 3, 37),
KnapsackItem.new('CREDIT_AGRICOLE_SA', 8, 4, 99),
KnapsackItem.new('DANONE', 51, 1, 43),
KnapsackItem.new('EADS', 49, 6, 63),
KnapsackItem.new('EDF', 26, 5, 87),
KnapsackItem.new('ESSILOR_INTERNATIONAL', 73, 6, 49),
KnapsackItem.new('GDF_SUEZ', 16, 1, 42),
KnapsackItem.new('GEMALTO', 76, 2, 53),
KnapsackItem.new('KERING', 150, 5, 97),
KnapsackItem.new("L'OREAL", 126, 7, 100),
KnapsackItem.new('LAFARGE', 49, 3, 93),
KnapsackItem.new('LEGRAND_SA', 39, 2, 49),
KnapsackItem.new('LVMH_MOET_VUITTON', 129, 9, 8),
KnapsackItem.new('MICHELIN', 75, 4, 43),
KnapsackItem.new('ORANGE', 8, 7, 1),
KnapsackItem.new('PERNOD_RICARD', 80, 4, 53),
KnapsackItem.new('PUBLICIS_GROUPE', 63, 11, 49),
KnapsackItem.new('RENAULT', 58, 4, 32),
KnapsackItem.new('SAFRAN', 47, 2, 61),
KnapsackItem.new('SAINT_GOBAIN', 36, 7, 33),
KnapsackItem.new('SANOFI', 73, 9, 70),
KnapsackItem.new('SCHNEIDER_ELECTRIC', 58, 6, 21),
KnapsackItem.new('SOCIETE_GENERALE', 40, 3, 93),
KnapsackItem.new('SOLVAY', 108, 5, 33),
KnapsackItem.new('STMICROELECTRONICS', 5, 1, 75),
KnapsackItem.new('TECHNIP', 72, 3, 47),
KnapsackItem.new('TOTAL', 42, 10, 95),
KnapsackItem.new('UNIBAIL-RODAMCO', 184, 9, 82),
KnapsackItem.new('VALLOUREC', 39, 4, 51),
KnapsackItem.new('VEOLIA_ENVIRONNEMENT', 11, 10, 2),
KnapsackItem.new('VINCI', 45, 6, 53),
KnapsackItem.new('VIVENDI', 17, 5, 38)
</code></pre>

<p>  ]
end
```</p>

<p>La prochaine fois on s'occupera de générer la population initiale.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les algorithmes génétiques démystifiés 41: Les individus invalides]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/11/19/les-algorithmes-genetiques-demystifies-41-les-individus-invalides/"/>
    <updated>2013-11-19T20:56:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/11/19/les-algorithmes-genetiques-demystifies-41-les-individus-invalides</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>La dernière fois on a vu comment l'introduction d'une petite dose
d'élitisme augmentait légèrement les performances d'un algorithme
génétique (<a href="http://lkdjiin.github.io/blog/2013/11/18/les-algorithmes-genetiques-demystifies-40-ajout-delitisme/">lire l'article</a>).
Aujourd'hui on va <em>véritablement booster</em> ces performances
dans le cadre du problème du sac à dos, en tenant compte des individus
invalides.</p>

<!-- more -->


<h2>Bref rappel du problème</h2>

<p>La capacité du sac à dos est de 400 (grammes, kilos, unités, etc…) et on ne
doit pas la dépasser. Autrement dit, un couple {<em>poids</em>, <em>valeur</em>} de
{401, 1000} est bien plus proche de la solution idéale que le couple
{399, 500}. Pourtant, d'après les règles qu'on a utilisées jusqu'ici, la
solution {401, 1000} est purement et simplement éliminée puisque jugée
invalide.</p>

<p>Il est légitime de se demander ici si on ne perd pas des gènes précieux en
éliminant de telles solutions ?</p>

<h2>Prise en compte des solutions invalides</h2>

<p>L'idée est donc de permettre aux solutions qui dépassent un peu le poids
d'être prise en considération, sans pour autant mettre les solutions
invalides à égalité avec les solutions valides.</p>

<p>Pour cela, on va appliquer une pénalité, une sanction, aux solutions
invalides. Tout se passe dans la méthode <code>score</code> de la classe
<code>Evaluator</code>. Vous pouvez trouver le code complet de cette troisième
version du programme sur Github: <a href="https://github.com/lkdjiin/knapsack_genetic_algorithm/blob/master/knapsack3.rb">knapsack3.rb</a>.
Voici ce qui change:</p>

<p>``` ruby
  def score(individual)</p>

<pre><code># [...]
if weight &gt; @capacity
  value -= 2 * (weight - @capacity)
  value = 0 if value &lt; 0
end
individual.score = value
</code></pre>

<p>  end
```</p>

<p>La pénalité appliquée à une sanction invalide est ici: 2 fois la différence
entre le poids du sac et sa capacité. C'est une valeur obtenue par
tatonnement, il n'y a rien de magique et vous devriez faire d'autres
essais… Je m'assure ensuite que la valeur n'est pas négative puisque la
méthode <code>fitness</code> attend une valeur positive.</p>

<h2>Les performances</h2>

<p>J'ai fait tourner chaque programme 200 fois et fait la moyenne de la
génération où la meilleure solution (score de 1030) est trouvée:</p>

<pre><code>Programme    | Génération moyenne | Remarques
=========================================================
knapsack.rb  |              72.06 | algo original
---------------------------------------------------------
knapsack2.rb |              67.61 | + élite
---------------------------------------------------------
knapsack3.rb |              22.55 | + élite + invalides
</code></pre>

<p>Le gain de performance est remarquable ! Moralité de cette affaire:
Pensez y à deux fois avant de jeter un chromosome invalide à la poubelle,
il contient peut-être des gènes importants.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les algorithmes génétiques démystifiés 40: Ajout d'élitisme]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/11/18/les-algorithmes-genetiques-demystifies-40-ajout-delitisme/"/>
    <updated>2013-11-18T17:39:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/11/18/les-algorithmes-genetiques-demystifies-40-ajout-delitisme</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Dans la plupart des ouvrages, thèses ou mémoires consacrés aux algorithmes
génétiques il est dit:</p>

<p><blockquote><p>Un peu d'élitisme améliore les performances des algorithmes génétiques.</p></blockquote></p>

<p>Voyons voir si c'est vrai.</p>

<!-- more -->


<h2>Une petite analyse</h2>

<p>En lançant la première version du programme
(<a href="https://github.com/lkdjiin/knapsack_genetic_algorithm/blob/master/knapsack.rb">voir le code</a> et/ou
<a href="http://lkdjiin.github.io/blog/2013/11/16/les-algorithmes-genetiques-39-resolution-du-sac-a-dos/">voir l'article</a>)
on s'aperçoit qu'une génération <em>n</em>+1 n'améliore pas forcement le score du
meilleur individu:</p>

<pre><code>[~]⇒ ruby knapsack.rb 
Gen: 0 Best score: 867
Gen: 1 Best score: 895
Gen: 2 Best score: 920
Gen: 3 Best score: 877
Gen: 4 Best score: 887
Gen: 5 Best score: 925
Gen: 6 Best score: 927
Gen: 7 Best score: 960
Gen: 8 Best score: 960
Gen: 9 Best score: 915
Gen: 10 Best score: 950
Gen: 11 Best score: 925
</code></pre>

<p>Dans l'extrait ci-dessus, le meilleur individu de la génération n° 8
possède un score de 960, alors qu'à la génération suivante, le meilleur
individu retombe à un score de 915.</p>

<h2>Mise en place de l'élite</h2>

<p>Je vais donc mettre en place une seconde version de ce programme où je
vais conserver les quatre meilleurs individus de chaque génération pour la
génération suivante. Le code complet de cette seconde version se trouve
sur Github: <a href="https://github.com/lkdjiin/knapsack_genetic_algorithm/blob/master/knapsack2.rb">knapsack2.rb</a>.
Seule la méthode <code>next_generation</code>, de la classe <code>GeneticAlgorithm</code>, change:</p>

<p>``` ruby
def next_generation
  @population.sort_by! {|i| i.score}
  elite = @population.pop(4)
  pool = MatingPool.new(@population)
  population_size = @population.size
  @population.clear
  population_size.times do</p>

<pre><code>@population &lt;&lt; @crossover.two_point(pool.random, pool.random)
</code></pre>

<p>  end
  @population.concat elite
end
```</p>

<p>Voici quelques explications. Tout d'abord la population est triée sur le
score, du plus faible au plus important:</p>

<pre><code>@population.sort_by! {|i| i.score}
</code></pre>

<p>Puis on retire les quatre meilleurs individus de la population et on les
conserve dans <code>elite</code>:</p>

<pre><code>elite = @population.pop(4)
</code></pre>

<p>À la fin de la sélection/croisement/mutation, on réintroduit l'élite dans
la nouvelle population:</p>

<pre><code>@population.concat elite
</code></pre>

<h2>Les performances</h2>

<p>J'ai fait tourner chaque programme 200 fois et fait la moyenne de la
génération où la meilleure solution (score de 1030) est trouvée:</p>

<pre><code>Programme    | Génération moyenne
=================================
knapsack.rb  |              72.06
---------------------------------
knapsack2.rb |              67.61
</code></pre>

<p>Les performances sont bien améliorées. Pas d'une manière spectaculaire, mais
c'est toujours bon à prendre.</p>

<p>La prochaine fois on verra si on peut encore améliorer les performances en
tenant compte des solutions invalides.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les algorithmes génétiques 39: Resolution du sac à dos]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/11/16/les-algorithmes-genetiques-39-resolution-du-sac-a-dos/"/>
    <updated>2013-11-16T10:06:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/11/16/les-algorithmes-genetiques-39-resolution-du-sac-a-dos</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>La dernière fois on a vu une façon simplement
<a href="http://lkdjiin.github.io/blog/2013/11/13/les-algorithmes-genetiques-demystifies-38-evaluation-du-sac-a-dos/">d'évaluer le contenu</a>
du sac à dos.
Aujourd'hui on met en place l'algorithme génétique proprement dit:
sélection, croisement, mutation, etc.</p>

<!-- more -->


<p>J'ai mis le <a href="https://github.com/lkdjiin/knapsack_genetic_algorithm/blob/master/knapsack.rb">code complet de l'algorithme sur Github</a>.
Celui-ci est basé sur ce qu'on a fait jusqu'ici pour
<a href="http://lkdjiin.github.io/blog/2013/09/08/les-algorithmes-genetiques-demystifies-8-le-paradoxe-du-singe-savant/">le paradoxe du singe savant</a>
et pour <a href="http://lkdjiin.github.io/blog/2013/09/24/les-algorithmes-genetiques-demystifies-21-probleme-des-8-dames/">le problème des 8 dames</a>.
Je vais donc commenter les parties qui changent.</p>

<h2>La classe GeneticAlgorithm</h2>

<p>``` ruby
class GeneticAlgorithm
  # &hellip;</p>

<p>  def run</p>

<pre><code>best_ever = nil
@generations.times do |generation|
  Evaluator.new(@capacity, @population).evaluate
  best = @population.best
  best_ever = best if best &gt; best_ever
  display(generation, best)
  next_generation
end
display_best_ever(best_ever)
</code></pre>

<p>  end</p>

<p>  private</p>

<p>  # &hellip;</p>

<p>  def display_best_ever(individual)</p>

<pre><code>puts "----------------------"
puts "Best ever"
puts "----------------------"
puts "score:      #{individual.score}"
puts "chromosome: #{individual.chromosome_as_list}"
</code></pre>

<p>  end</p>

<p>  # &hellip;
end
```</p>

<p>Voyons la méthode <code>run</code>. La variable <code>best_ever</code> va contenir le meilleur
individu, toutes générations confondues. À chaque itération, on compare
ce «meilleur de tout les temps» avec le meilleur individu de la génération:</p>

<pre><code>best_ever = best if best &gt; best_ever
</code></pre>

<p>C'est pour ça qu'on avait besoin d'une méthode <code>&gt;</code> dans la classe <code>Individual</code>
(voir <a href="http://lkdjiin.github.io/blog/2013/11/12/les-algorithmes-genetiques-demystifies-37-le-probleme-du-sac-a-dos/">cet article</a>).</p>

<p>À la fin de la méthode <code>run</code> on utilise la nouvelle méthode <code>display_best_ever</code>
pour afficher notre meilleure solution.</p>

<h2>La classe Mutator</h2>

<p>La seconde classe qui change un peu est la classe <code>Mutator</code>:</p>

<p>``` ruby
class Mutator
  def initialize(chromosome_size, mutation_rate)</p>

<pre><code>@size = chromosome_size
@rate = mutation_rate
</code></pre>

<p>  end</p>

<p>  def mutate(chromosome)</p>

<pre><code>@size.times do |index|
  chromosome[index] = ! chromosome[index] if rand &lt; @rate
end
chromosome
</code></pre>

<p>  end
end
```</p>

<p>Un chromosome étant une liste (un Array) de booléens, la mutation consiste
à <em>inverser</em> un élément, true devient false et inversement:</p>

<pre><code>chromosome[index] = ! chromosome[index] if rand &lt; @rate
</code></pre>

<h2>Le lancement du programme</h2>

<p>Le problème n'a pas l'air trop complexe, je me dis donc que 100 générations
devraient suffire. La population compte 1 000 individus, ce qui est
classique et le taux de mutation est assez élevé (1%):</p>

<p><code>ruby
knapsack_capacity = 400
generations = 100
population = Population.new(Knapsack::ITEMS.size, 1000)
mutation = 0.01
GeneticAlgorithm.new(generations, population, knapsack_capacity, mutation).run
</code></p>

<p>Et voici le moment de vérité:</p>

<pre><code>[~]⇒ ruby knapsack.rb 
Gen: 0 Best score: 922
Gen: 1 Best score: 950
.
.
.
Gen: 57 Best score: 1010
Gen: 58 Best score: 957
Gen: 59 Best score: 1030
.
.
.
Gen: 99 Best score: 957
----------------------
Best ever
----------------------
score:      1030
chromosome: map, compass, water, sandwich, glucose, banana, suntan cream,
waterproof trousers, waterproof overclothes, note-case, sunglasses, socks
</code></pre>

<p>La prochaine fois on va analyser ce résultat et faire en sorte de
l'améliorer.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les algorithmes génétiques démystifiés 38: Évaluation du sac à dos]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/11/13/les-algorithmes-genetiques-demystifies-38-evaluation-du-sac-a-dos/"/>
    <updated>2013-11-13T09:32:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/11/13/les-algorithmes-genetiques-demystifies-38-evaluation-du-sac-a-dos</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Comment évaluer le contenu du sac à dos ? C'est à cette question qu'on
répond aujourd'hui, après avoir vu hier la
<a href="http://lkdjiin.github.io/blog/2013/11/12/les-algorithmes-genetiques-demystifies-37-le-probleme-du-sac-a-dos/">création de la population</a>.</p>

<!-- more -->


<h2>La fonction d'évaluation</h2>

<p>Évaluer le contenu du sac à dos est trivial, on calcule sa valeur en
ajoutant la valeur de tout les objets, et on calcule son poids en ajoutant
le poids de tout les objets. Si le poids total dépasse la capacité du
sac à dos, on va considèrer <em>pour l'instant</em> que la solution est invalide, et
on ne lui permettra pas de se reproduire. Autrement dit, plus la valeur est
importante sans que le poids ne dépasse la capacité, meilleure est
l'individu.</p>

<h2>La classe Evaluator</h2>

<p>Voici le code complet de la classe <code>Evaluator</code>:</p>

<p>``` ruby
class Evaluator
  def initialize(capacity, population)</p>

<pre><code>@capacity = capacity
@population = population
</code></pre>

<p>  end</p>

<p>  def evaluate</p>

<pre><code>@population.each {|individual| score(individual) }
fitness
</code></pre>

<p>  end</p>

<p>  private</p>

<p>  def score(individual)</p>

<pre><code>value = 0
weight = 0
individual.chromosome.each_with_index do |item, index|
  if item
    value += Knapsack::ITEMS[index].value
    weight += Knapsack::ITEMS[index].weight
  end
end
if weight &gt; @capacity
  individual.score = 0
else
  individual.score = value
end
</code></pre>

<p>  end</p>

<p>  def fitness</p>

<pre><code>total = @population.inject(0) {|sum, individual| sum + individual.score }
size = @population.size
@population.each do |individual|
  individual.fitness = individual.score.to_f / total * size
end
</code></pre>

<p>  end
end
```</p>

<h2>Explication du code</h2>

<p>Ce qui nous intéresse se passe dans la méthode <code>score</code>. Tout d'abord on
calcule la valeur totale et le poids total du sac à dos:</p>

<p>``` ruby</p>

<pre><code>individual.chromosome.each_with_index do |item, index|
  if item
    value += Knapsack::ITEMS[index].value
    weight += Knapsack::ITEMS[index].weight
  end
end
</code></pre>

<p>```</p>

<p>Je rappelle qu'un chromosome est ici un Array de booléens, d'où la ligne
<code>if item</code> pour savoir si l'objet est présent ou non.</p>

<p>Une fois valeur et poids calculés, on peut donner un score:</p>

<p>``` ruby</p>

<pre><code>if weight &gt; @capacity
  individual.score = 0
else
  individual.score = value
end
</code></pre>

<p>```</p>

<p>Si le poids du sac à dos dépasse sa capacité, on invalide l'individu en
mettant son score à zéro, ce qui lui interdira par la suite de se reproduire.
Sinon, le score est simplement la valeur totale du sac à dos.</p>

<p>La prochaine fois on mettra en place la sélection, le croisement, la mutation,
etc…</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
