<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : algorithme génétique | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/algorithme-genetique/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2014-05-17T21:34:53+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Un algorithme génétique en Julia - partie 5]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/05/17/un-algorithme-genetique-en-julia-partie-5/"/>
    <updated>2014-05-17T15:38:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/05/17/un-algorithme-genetique-en-julia-partie-5</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Aujourd'hui je cherche à faire une fonction <code>crossover</code>, pour effectuer un
croisement entre deux chromosomes.</p>

<p>Soit les deux chromosomes suivants:</p>

<pre><code>julia&gt; a = [1, 2, 3, 4, 5]

julia&gt; b = [6, 7, 8, 9, 0]
</code></pre>

<!-- more -->


<p>Pour obtenir la taille d'un tableau:</p>

<pre><code>julia&gt; length(a)
5
</code></pre>

<p>Pour obtenir le <em>point de croisement</em>, on tire au hasard:</p>

<pre><code>julia&gt; cut_point = rand(1:length(a))
4
</code></pre>

<p>Le nouveau chromosome sera composé du début du premier, jusqu'au point de
croisement:</p>

<pre><code>julia&gt; cut_point = 3
3
julia&gt; a[1:cut_point]
3-element Array{Int32,1}:
 1
 2
 3
</code></pre>

<p>Puis de la fin du second chromosome:</p>

<pre><code>julia&gt; a[cut_point + 1:end]
2-element Array{Int32,1}:
 4
 5
</code></pre>

<p>Si on rassemble tout ça dans un tableau, on obtient notre nouveau
chromosome:</p>

<pre><code>julia&gt; [ a[1:cut_point], b[cut_point + 1:end] ]
5-element Array{Int32,1}:
 1
 2
 3
 9
 0
</code></pre>

<p>Il ne reste plus qu'à en faire une fonction:</p>

<p><code>julia
function crossover(chromosome1, chromosome2)
  cut_point = rand(1:length(chromosome1))
  [ chromosome1[1:cut_point], chromosome2[cut_point + 1:end] ]
end
</code></p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Un algorithme génétique en Julia - partie 4]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/05/16/un-algorithme-genetique-en-julia-partie-4/"/>
    <updated>2014-05-16T21:00:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/05/16/un-algorithme-genetique-en-julia-partie-4</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Voici le fichier actuel:</p>

<p>``` julia main.jl
create_chromosome(size) = rand(0:1, size)</p>

<p>function create_population(size, chromosome_size)
  [ create_chromosome(chromosome_size) for _ in 1:size ]
end</p>

<p>score(population) = map(sum, population)</p>

<p>function fight(scores, index1, index2)
  scores[index1] > scores[index2] ? index1 : index2
end
```</p>

<p>Aujourd'hui on ajoute la fonction <code>tournament</code>.</p>

<!-- more -->


<p>La voilà:</p>

<p>``` julia
function tournament(scores)
  population_size = length(scores)
  selection_size = population_size * 2
  [ fight(scores, rand(1:population_size), rand(1:population_size))</p>

<pre><code>for _ in 1:selection_size ]
</code></pre>

<p>end
```</p>

<p>On voit que pour connaître la taille d'un tableau, on utilise la fonction
<code>length</code> et que je me sers encore d'une compréhension de liste pour produire
un tableau qui contiendra les index (sur la population) de mes reproducteurs.</p>

<pre><code>julia&gt; include("main.jl")
tournament (generic function with 1 method)

julia&gt; pop = create_population(8, 20)
8-element Array{Array{Int32,1},1}:
 [0,0,0,0,1,1,0,0,0,0,0,1,0,1,1,0,0,1,1,0]
 [1,0,1,1,1,0,1,1,0,0,1,1,1,0,1,1,1,1,0,0]
 [1,0,1,1,0,1,0,0,1,0,0,1,0,0,0,0,1,1,0,1]
 [1,1,1,0,1,0,1,0,1,0,0,1,0,1,1,1,0,0,0,1]
 [1,1,1,1,0,1,0,0,0,1,0,0,1,0,1,0,1,1,0,1]
 [1,1,1,1,1,1,1,0,0,1,0,0,0,1,1,1,0,1,1,0]
 [0,1,1,1,1,1,1,0,1,1,1,1,0,1,0,0,0,1,1,0]
 [0,0,1,1,1,0,1,0,0,1,1,1,0,0,0,1,0,1,0,0]

julia&gt; scores = score(pop)
8-element Array{Int32,1}:
  7
 13
  9
 11
 11
 13
 13
  9

julia&gt; tournament(scores)
16-element Array{Int32,1}:
 5
 6
 6
 4
 4
 6
 7
 2
 6
 6
 3
 7
 2
 2
 6
 3
</code></pre>

<p>À plus tard pour la suite…</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Un algorithme génétique en Julia - partie 3]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/05/15/un-algorithme-genetique-en-julia-partie-3/"/>
    <updated>2014-05-15T21:28:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/05/15/un-algorithme-genetique-en-julia-partie-3</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Aujourd'hui j'essaye de faire la sélection en vue de la reprodution ;)
Si vous aviez suivi ma série d'articles
<a href="http://lkdjiin.github.io/blog/categories/algorithme-genetique/">les algorithmes génétiques démystifiés</a> vous savez de quoi je parle…</p>

<!-- more -->


<p>Voici d'abord les fonctions que j'ai jusqu'à présent :</p>

<p>``` julia main.jl
create_chromosome(size) = rand(0:1, size)</p>

<p>function create_population(size, chromosome_size)
  [ create_chromosome(chromosome_size) for _ in 1:size ]
end</p>

<p>score(population) = map(sum, population)
```</p>

<p>Alors j'ai remis des <code>_</code>, parce que sans j'y arrivais vraiment pas ;)
J'ai aussi ajouté l'argument <code>size</code> à la fonction de création d'un
chromosome pour éviter les nombres magiques.</p>

<p>Je veux opérer une sélection très simple : un tournoi. Pour ça, je
commence avec une fonction <code>fight</code> qui va renvoyer le meilleur chromosome
parmi deux:</p>

<p><code>julia
function fight(scores, index1, index2)
  scores[index1] &gt; scores[index2] ? index1 : index2
end
</code></p>

<p>En fait je ne passe pas de chromosome à cette fonction mais le tableau des
scores de la population, obtenu avec <code>score</code> et deux indexs.</p>

<pre><code>julia&gt; include("main.jl")

julia&gt; pop = create_population(8, 20)
8-element Array{Array{Int32,1},1}:
 [1,0,1,1,1,1,1,0,1,0,1,1,1,0,1,0,1,1,1,1]
 [1,1,0,0,0,1,0,1,0,1,0,0,0,0,0,1,0,1,1,1]
 [0,0,1,0,1,0,0,1,0,1,0,0,1,1,1,0,0,1,0,1]
 [1,1,0,1,1,1,0,1,1,0,0,1,1,1,0,1,0,1,1,1]
 [0,1,0,0,1,1,1,1,0,1,0,1,1,0,0,1,0,0,0,1]
 [1,1,0,0,0,1,0,0,1,0,1,1,1,0,1,1,1,0,1,0]
 [1,1,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,1]
 [0,0,0,1,0,1,0,0,0,1,1,1,0,1,0,1,1,1,1,1]

julia&gt; scores = score(pop)
8-element Array{Int32,1}:
 15
  9
  9
 14
 10
 11
 10
 11
</code></pre>

<p>Et la fonction <code>fight</code> renvoit l'index du meilleur des deux chromosomes
du <em>combat</em>:</p>

<pre><code>julia&gt; fight(scores, 1, 2)
1

julia&gt; fight(scores, 7, 8)
8
</code></pre>

<p>La prochaine fois je pourrais organiser le tournoi proprement dit.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Un algorithme génétique en Julia - partie 2]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/05/14/un-algorithme-genetique-en-julia-partie-2/"/>
    <updated>2014-05-14T21:04:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/05/14/un-algorithme-genetique-en-julia-partie-2</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Je continue l'algorithme génétique en Julia que j'ai commencé hier, en
cherchant la manière de calculer le score d'un chromosome.</p>

<!-- more -->


<p>Tout d'abord, je met les fonctions créées hier dans un fichier <code>main.jl</code>.
J'en profite pour les renommer. La convention en Julia veut qu'on accolle
les mots, sans séparation. Bien que je trouve ça curieux et illisible, je
vais m'y plier, après tout j'apprends…</p>

<p>``` julia main.jl
createchromosome() = rand(0:1, 10)</p>

<p>createpopulation(size) = [ createchromosome() for _ in 1:size ]
```</p>

<p>Une fois l'interpréteur Julia lancé, je charge les définitions de fonctions
du fichier <code>main.jl</code>:</p>

<pre><code>julia&gt; include("main.jl")
</code></pre>

<p>Puis je crée un chromosome:</p>

<pre><code>julia&gt; chromosome = createchromosome()
10-element Array{Int32,1}:
 1
 0
 0
 1
 1
 0
 0
 0
 1
 1
</code></pre>

<p>L'algorithme génétique que je veux mettre en place est le plus simple qui
existe. Je cherche à maximiser les chromosomes, c'est à dire que je veux
obtenir un chromosome qui ne comporte que des 1. Pour calculer son score,
il suffit donc de faire la somme de ses gènes. Très facile, puisque Julia
fournit la fonction <code>sum</code>:</p>

<pre><code>julia&gt; sum(chromosome)
5
</code></pre>

<p>Maintenant je dois trouver comment calculer le score de chaque chromosome.
Je crée donc une population:</p>

<pre><code>julia&gt; population = createpopulation(8)
8-element Array{Array{Int32,1},1}:
 [0,0,1,1,1,0,0,0,0,1]
 [1,0,0,0,1,0,1,1,0,0]
 [0,0,1,1,0,0,0,1,0,1]
 [1,0,0,1,1,0,0,0,0,0]
 [1,0,1,0,1,0,1,0,0,1]
 [0,1,1,1,1,1,0,1,0,0]
 [0,1,1,0,1,0,1,0,1,1]
 [0,1,1,1,1,1,0,1,0,0]
</code></pre>

<p>Et j'utilise <code>map</code>, qui va <em>mapper</em> la fonction <code>sum</code> sur chaque élément
de la population:</p>

<pre><code>julia&gt; map(sum, population)
8-element Array{Int32,1}:
 4
 4
 4
 3
 5
 6
 6
 6
</code></pre>

<p>Voilà, si on veut, on peut aussi créer une fonction <code>score</code>:</p>

<pre><code>julia&gt; score(population) = map(sum, population)

julia&gt; score(population)
8-element Array{Int32,1}:
 4
 4
 4
 3
 5
 6
 6
 6
</code></pre>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Un algorithme génétique en Julia - partie 1]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/05/13/un-algorithme-genetique-en-julia-partie-1/"/>
    <updated>2014-05-13T21:09:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/05/13/un-algorithme-genetique-en-julia-partie-1</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Pour continuer d'apprendre le langage Julia, je vais coder un algorithme
génétique simple.</p>

<!-- more -->


<p>Tout d'abord un chromosome, qui va contenir 10 valeurs, chaque valeur pouvant
être soit zéro, soit un:</p>

<pre><code>julia&gt; chromosome() = rand(0:1, 10)
</code></pre>

<p>La fonction <code>rand</code> prend un <em>range</em> en premier paramêtre.</p>

<p>On teste cette fonction:</p>

<pre><code>julia&gt; chromosome()
10-element Array{Int32,1}:
 0
 1
 1
 1
 1
 1
 1
 0
 1
 1
</code></pre>

<p>Maintenant je veux une population:</p>

<pre><code>julia&gt; population(size) = [ chromosome() for _ in 1:size ]
</code></pre>

<p>Il s'agit d'une <em>compréhension de liste</em>. Pour chaque valeur (symbolisée
par le <code>_</code>) du <em>range</em> de 1 à <code>size</code>, on applique la fonction <code>chromosome</code>.
Je peux donc avoir une population:</p>

<pre><code>julia&gt; population(8)
8-element Array{Array{Int32,1},1}:
 [1,0,1,0,1,0,0,1,1,0]
 [1,1,0,1,0,1,0,1,0,0]
 [1,0,1,1,0,1,1,1,1,1]
 [0,0,1,0,0,1,0,0,1,1]
 [1,0,0,1,0,1,1,1,1,0]
 [0,1,0,0,1,1,1,0,1,1]
 [0,0,0,1,0,1,0,1,1,1]
 [0,1,0,0,0,1,0,1,1,0]
</code></pre>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
