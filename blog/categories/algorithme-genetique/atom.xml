<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : algorithme génétique | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/algorithme-genetique/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2013-11-15T18:54:35+01:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Les algorithmes génétiques démystifiés 38: Évaluation du sac à dos]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/11/13/les-algorithmes-genetiques-demystifies-38-evaluation-du-sac-a-dos/"/>
    <updated>2013-11-13T09:32:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/11/13/les-algorithmes-genetiques-demystifies-38-evaluation-du-sac-a-dos</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Comment évaluer le contenu du sac à dos ? C'est à cette question qu'on
répond aujourd'hui, après avoir vu hier la
<a href="http://lkdjiin.github.io/blog/2013/11/12/les-algorithmes-genetiques-demystifies-37-le-probleme-du-sac-a-dos/">création de la population</a>.</p>

<!-- more -->


<h2>La fonction d'évaluation</h2>

<p>Évaluer le contenu du sac à dos est trivial, on calcule sa valeur en
ajoutant la valeur de tout les objets, et on calcule son poids en ajoutant
le poids de tout les objets. Si le poids total dépasse la capacité du
sac à dos, on va considèrer <em>pour l'instant</em> que la solution est invalide, et
on ne lui permettra pas de se reproduire. Autrement dit, plus la valeur est
importante sans que le poids ne dépasse la capacité, meilleure est
l'individu.</p>

<h2>La classe Evaluator</h2>

<p>Voici le code complet de la classe <code>Evaluator</code>:</p>

<p>``` ruby
class Evaluator
  def initialize(capacity, population)</p>

<pre><code>@capacity = capacity
@population = population
</code></pre>

<p>  end</p>

<p>  def evaluate</p>

<pre><code>@population.each {|individual| score(individual) }
fitness
</code></pre>

<p>  end</p>

<p>  private</p>

<p>  def score(individual)</p>

<pre><code>value = 0
weight = 0
individual.chromosome.each_with_index do |item, index|
  if item
    value += Knapsack::ITEMS[index].value
    weight += Knapsack::ITEMS[index].weight
  end
end
if weight &gt; @capacity
  individual.score = 0
else
  individual.score = value
end
</code></pre>

<p>  end</p>

<p>  def fitness</p>

<pre><code>total = @population.inject(0) {|sum, individual| sum + individual.score }
size = @population.size
@population.each do |individual|
  individual.fitness = individual.score.to_f / total * size
end
</code></pre>

<p>  end
end
```</p>

<h2>Explication du code</h2>

<p>Ce qui nous intéresse se passe dans la méthode <code>score</code>. Tout d'abord on
calcule la valeur totale et le poids total du sac à dos:</p>

<p>``` ruby</p>

<pre><code>individual.chromosome.each_with_index do |item, index|
  if item
    value += Knapsack::ITEMS[index].value
    weight += Knapsack::ITEMS[index].weight
  end
end
</code></pre>

<p>```</p>

<p>Je rappelle qu'un chromosome est ici un Array de booléens, d'où la ligne
<code>if item</code> pour savoir si l'objet est présent ou non.</p>

<p>Une fois valeur et poids calculés, on peut donner un score:</p>

<p>``` ruby</p>

<pre><code>if weight &gt; @capacity
  individual.score = 0
else
  individual.score = value
end
</code></pre>

<p>```</p>

<p>Si le poids du sac à dos dépasse sa capacité, on invalide l'individu en
mettant son score à zéro, ce qui lui interdira par la suite de se reproduire.
Sinon, le score est simplement la valeur totale du sac à dos.</p>

<p>La prochaine fois on mettra en place la sélection, le croisement, la mutation,
etc…</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les algorithmes génétiques démystifiés 37: Le problème du sac à dos]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/11/12/les-algorithmes-genetiques-demystifies-37-le-probleme-du-sac-a-dos/"/>
    <updated>2013-11-12T13:02:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/11/12/les-algorithmes-genetiques-demystifies-37-le-probleme-du-sac-a-dos</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Pour continuer notre exploration des algorithmes génétiques, on va
s'intéresser maintenant au problème du sac à dos:</p>

<p><blockquote><p>En algorithmique, le problème du sac à dos, noté également KP (en anglais,<br/>Knapsack Problem) est un problème d'optimisation combinatoire. Il modélise une<br/>situation analogue au remplissage d'un sac à dos, ne pouvant supporter plus<br/>d'un certain poids, avec tout ou partie d'un ensemble donné d'objets ayant<br/>chacun un poids et une valeur. Les objets mis dans le sac à dos doivent<br/>maximiser la valeur totale, sans dépasser le poids maximum.</p><footer><strong>Wikipédia <a href="http://fr.wikipedia.org/wiki/Probl%C3%A8me_du_sac_%C3%A0_dos">http://fr.wikipedia.org/wiki/Probl%C3%A8me_du_sac_%C3%A0_dos</a></strong></footer></blockquote></p>

<!-- more -->


<p>Un des intéret de ce problème est que certaines solutions <em>invalides</em> sont
plus proches de la meilleure solution que nombres de solutions <em>valides</em>.</p>

<p>De même, c'est un problème <em>théorique</em> qui peut être vu comme une
simplification de problèmes <em>pratiques</em>. Par exemple: «Mon bateau peut
transporter 100 containers, pour un poids de X tonnes. Je gagne plus ou
moins d'argent selon les containers transportés. Quels containers je dois
embarquer parmi un choix de 300 containers ?»</p>

<p>La liste des objets que je vais utiliser se trouve sur le
<a href="http://rosettacode.org/wiki/Knapsack_problem/0-1">projet RosettaCode</a>.</p>

<p>On commence tout de suite avec la création de la population:</p>

<p>``` ruby
KnapsackItem = Struct.new(:name, :weight, :value)</p>

<p>module Knapsack
  ITEMS = [</p>

<pre><code>KnapsackItem.new('map', 9, 150),
KnapsackItem.new('compass', 13, 35),
KnapsackItem.new('water', 153, 200),
KnapsackItem.new('sandwich', 50, 160),
KnapsackItem.new('glucose', 15, 60),
KnapsackItem.new('tin', 68, 45),
KnapsackItem.new('banana', 27, 60),
KnapsackItem.new('apple', 39, 40),
KnapsackItem.new('cheese', 23, 30),
KnapsackItem.new('beer', 52, 10),
KnapsackItem.new('suntan cream', 11, 70),
KnapsackItem.new('camera', 32, 30),
KnapsackItem.new('t-shirt', 24, 15),
KnapsackItem.new('trousers', 48, 10),
KnapsackItem.new('umbrella', 73, 40),
KnapsackItem.new('waterproof trousers', 42, 70),
KnapsackItem.new('waterproof overclothes', 43, 75),
KnapsackItem.new('note-case', 22, 80),
KnapsackItem.new('sunglasses', 7, 20),
KnapsackItem.new('towel', 18, 12),
KnapsackItem.new('socks', 4, 50),
KnapsackItem.new('book', 30, 10),
</code></pre>

<p>  ]
end
```</p>

<p>Pour ceux qui ne connaissent pas Ruby, <code>Struct</code> permet de définir rapidement
une classe simpliste, une espèce de POxO (Plain Old &ldquo;insérez votre langage&rdquo;
Object). La classe <code>KnapsackItem</code> aura donc 3 accesseurs: <code>name</code>, <code>weight</code> et
<code>value</code>. On pourra accéder à la liste des objets avec <code>Knapsack::ITEMS</code>.</p>

<p>Maintenant la classe <code>Individual</code>:</p>

<p>``` ruby
class Individual
  def self.random(chromosome_size)</p>

<pre><code>new(nil, chromosome_size)
</code></pre>

<p>  end</p>

<p>  def self.from_chromosome(chromosome)</p>

<pre><code>new(chromosome)
</code></pre>

<p>  end</p>

<p>  attr_accessor :score, :fitness
  attr_reader :chromosome</p>

<p>  def initialize(chromosome = nil, chromosome_size = nil)</p>

<pre><code>if chromosome
  @chromosome = chromosome
else
  @chromosome = []
  chromosome_size.times { @chromosome &lt;&lt; (rand(0..1) == 1) }
end
</code></pre>

<p>  end
  private_class_method :new</p>

<p>  def chromosome_as_list</p>

<pre><code>list = []
@chromosome.each_with_index do |gene, index|
  list &lt;&lt; Knapsack::ITEMS[index].name if gene
end
list.join(', ')
</code></pre>

<p>  end</p>

<p>  def >(other)</p>

<pre><code>return true if other.nil?
score &gt; other.score
</code></pre>

<p>  end
end
```</p>

<p>Un chromosome est défini comme un Array de booléens:</p>

<p>``` ruby</p>

<pre><code>  chromosome_size.times { @chromosome &lt;&lt; (rand(0..1) == 1) }
</code></pre>

<p>```</p>

<p>Chaque case de l'Array nous indique si un objet est sélectionné (true) ou
non (false).</p>

<p>J'ai aussi ajouté 2 nouvelles méthodes à cette classe. Tout d'abord
<code>chromosome_as_list</code> produit une chaîne de caractères avec la liste
des objets sélectionnés dans le chromosome. Puis la méthode <code>&gt;</code> nous
sera utile pour comparer deux chromosomes.</p>

<p>Reste la classe <code>Population</code>, qui est identique à ce que nous avons
déjà écrit avec d'autres algorithmes génétiques:</p>

<p>``` ruby
class Population &lt; Array
  def initialize(chromosome_size, population_size)</p>

<pre><code>population_size.times { self &lt;&lt; Individual.random(chromosome_size) }
</code></pre>

<p>  end</p>

<p>  def best</p>

<pre><code>self.sort_by{|individual| individual.score}.last
</code></pre>

<p>  end
end
```</p>

<p>La prochaine fois on verra une première version de la méthode d'évaluation.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les algorithmes génétiques démystifiés 36]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/10/22/les-algorithmes-genetiques-demystifies-36/"/>
    <updated>2013-10-22T08:25:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/10/22/les-algorithmes-genetiques-demystifies-36</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Il reste à voir deux fonctions <em>techniques</em> pour faire tourner notre
programme: la copie d'un individu et le rendu d'une image. Je les appelle
<em>techniques</em> car elles n'ont rien à voir avec l'algorithme lui-même. La
copie d'un individu est rendue nécessaire par le langage utilisé, Javascript,
et le rendu d'une image est nécessaire puisqu'on veut …et bien… afficher
des images, quoi…</p>

<!-- more -->


<p>Voyons d'abord la copie d'un individu:</p>

<p>``` javascript
function copy(individual) {
  var indiCopy = [];
  for(var i = 0; i &lt; TOTAL_SQUARES; i++) {</p>

<pre><code>var objectCopy = {},
    prop;
for(prop in individual[i]) {
  objectCopy[prop] = individual[i][prop];
}
indiCopy.push(objectCopy);
</code></pre>

<p>  }
  return indiCopy;
}
```</p>

<p>Un individu est un tableau, contenant des objets, chaque objets contenants
des propriétés… <em>Là, je m'interroge et je demande l'avis de spécialistes:
est-ce-qu'il ne vaudrait pas mieux utiliser une librairie pour faire ça,
comme jQuery ou Underscore.js ?</em></p>

<p>Maintenant le rendu d'une image:</p>

<p>``` javascript
function renderIndividual(individual, ctx) {
  ctx.fillStyle = &ldquo;white&rdquo;;
  ctx.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);
  for (var i = 0; i &lt; TOTAL_SQUARES; i++) {</p>

<pre><code>ctx.globalAlpha = individual[i].alpha;
ctx.fillStyle = 'rgb(' + individual[i].red + ',' +
  individual[i].green + ',' + individual[i].blue + ')';
ctx.fillRect(individual[i].x, individual[i].y,
  individual[i].size, individual[i].size);
</code></pre>

<p>  }
}
```</p>

<p><code>ctx</code> est un contexte de Canvas. Je vois ça tout simplement comme un objet
dans lequel on peut dessiner. Tout d'abord on <em>efface</em> l'image en la
remplissant de blanc:</p>

<pre><code>ctx.fillStyle = "white";
ctx.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);
</code></pre>

<p>Puis on dessine chacuns des carrés:</p>

<pre><code>for (var i = 0; i &lt; TOTAL_SQUARES; i++) {
</code></pre>

<p>Pour chaque carré il faut sélectionner sa transparence:</p>

<pre><code>ctx.globalAlpha = individual[i].alpha;
</code></pre>

<p>Puis sa couleur:</p>

<pre><code>ctx.fillStyle = 'rgb(' + individual[i].red + ',' +
  individual[i].green + ',' + individual[i].blue + ')';
</code></pre>

<p>On peut alors dessiner un carré:</p>

<pre><code>ctx.fillRect(individual[i].x, individual[i].y,
  individual[i].size, individual[i].size);
</code></pre>

<p>Voilà. Reste à voir maintenant le programme dans son ensemble. Voici les
fichiers HTML et CSS:</p>

<p>``` html
&lt;!DOCTYPE html>
<html lang="fr">
  <head></p>

<pre><code>&lt;meta charset="utf-8" /&gt;
&lt;link rel="stylesheet" type="text/css" href="picture.css" /&gt; 
</code></pre>

<p>  </head>
  <body></p>

<pre><code>&lt;canvas width="400" height="400" id="canvas1"&gt;&lt;/canvas&gt;
&lt;canvas width="400" height="400" id="canvas2"&gt;&lt;/canvas&gt;
&lt;p id="generation"&gt;0&lt;/p&gt;
&lt;p id="quality"&gt;0&lt;/p&gt;
&lt;script src="picture.js"&gt;&lt;/script&gt;
</code></pre>

<p>  </body>
</html>
```</p>

<p>``` css
body {
  background-color: #222;
}</p>

<p>p {
  color: #ccc;
}
```</p>

<p>Et voici le programme Javascript complet:</p>

<p>``` javascript
var canvasImgOrigin = document.getElementById(&lsquo;canvas1&rsquo;);
var canvasGenetic = document.getElementById(&lsquo;canvas2&rsquo;);
var ctxOrigin = canvas1.getContext(&lsquo;2d&rsquo;);
var ctx = canvas2.getContext(&lsquo;2d&rsquo;);
var TOTAL_SQUARES = 400;
var IMAGE_WIDTH = 400;
var IMAGE_HEIGHT = 400;
var SQUARE_MAX_SIZE = 40;
var img = new Image();
var generation = 0;
var htmlGeneration = document.getElementById(&ldquo;generation&rdquo;);
var htmlQuality = document.getElementById(&ldquo;quality&rdquo;);
var solution = [];
var canvasBuffer = document.createElement(&lsquo;canvas&rsquo;);
canvasBuffer.width = IMAGE_WIDTH;
canvasBuffer.height = IMAGE_HEIGHT;
var ctxBuffer = canvasBuffer.getContext(&lsquo;2d&rsquo;);</p>

<p>img.onload = function() { ctxOrigin.drawImage(img, 0, 0); };
img.src = &lsquo;photo.jpg&rsquo;;
solution = makeIndividual();</p>

<p>var interval = setInterval(hillClimb, 150);</p>

<p>function makeIndividual() {
  var individual = [];
  for (var i = 0; i &lt; TOTAL_SQUARES; i++) {</p>

<pre><code>individual.push({
  x: Math.floor(Math.random() * IMAGE_WIDTH),
  y: Math.floor(Math.random() * IMAGE_HEIGHT),
  size: Math.floor(Math.random() * SQUARE_MAX_SIZE),
  red: Math.floor(Math.random() * 256),
  green: Math.floor(Math.random() * 256),
  blue: Math.floor(Math.random() * 256),
  alpha: Math.random()
});
</code></pre>

<p>  }
  return individual;
}</p>

<p>function renderIndividual(individual, ctx) {
  ctx.fillStyle = &ldquo;white&rdquo;;
  ctx.fillRect(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);
  for (var i = 0; i &lt; TOTAL_SQUARES; i++) {</p>

<pre><code>ctx.globalAlpha = individual[i].alpha;
ctx.fillStyle = 'rgb(' + individual[i].red + ',' +
  individual[i].green + ',' + individual[i].blue + ')';
ctx.fillRect(individual[i].x, individual[i].y,
  individual[i].size, individual[i].size);
</code></pre>

<p>  }
}</p>

<p>function quality(individual) {
  var imgOrigin = ctxOrigin.getImageData(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);
  var pixelArrayOrigin = imgOrigin.data;
  var score = 0;
  renderIndividual(individual, ctxBuffer);
  var imgBuffer = ctxBuffer.getImageData(0, 0, 400, 400);
  var pixelArrayCandidate = imgBuffer.data;
  for (var i = 0, n = pixelArrayOrigin.length; i &lt; n; i += 4) {</p>

<pre><code>score += Math.abs(pixelArrayOrigin[i] - pixelArrayCandidate[i]);
score += Math.abs(pixelArrayOrigin[i+1] - pixelArrayCandidate[i+1]);
score += Math.abs(pixelArrayOrigin[i+2] - pixelArrayCandidate[i+2]);
</code></pre>

<p>  }
  return 1 / score;
}</p>

<p>function hillClimb() {
  var opponent = mutate(copy(solution));
  var score_opponent = quality(opponent);
  var score_solution = quality(solution);
  if (score_opponent > score_solution) {</p>

<pre><code>solution = opponent;
</code></pre>

<p>  }
  generation++;
  if (generation % 100 == 0) renderIndividual(solution, ctx);
  htmlGeneration.innerHTML = generation;
  htmlQuality.innerHTML = score_solution;
  if (generation >= 100000) {</p>

<pre><code>clearInterval(interval);
</code></pre>

<p>  }
}</p>

<p>function copy(individual) {
  var indiCopy = [];
  for(var i = 0; i &lt; TOTAL_SQUARES; i++) {</p>

<pre><code>var objectCopy = {},
    prop;
for(prop in individual[i]) {
  objectCopy[prop] = individual[i][prop];
}
indiCopy.push(objectCopy);
</code></pre>

<p>  }
  return indiCopy;
}</p>

<p>function mutate(individual) {
  var gene = Math.floor(Math.random() * TOTAL_SQUARES),</p>

<pre><code>  squareProperty = Math.floor(Math.random() * 7);
</code></pre>

<p>  switch (squareProperty) {</p>

<pre><code>case 0:
  individual[gene].x = Math.floor(Math.random() * IMAGE_WIDTH);
  break;
case 1:
  individual[gene].y = Math.floor(Math.random() * IMAGE_HEIGHT);
  break;
case 2:
  individual[gene].size = Math.floor(Math.random() * SQUARE_MAX_SIZE);
  break;
case 3:
  individual[gene].red = Math.floor(Math.random() * 256);
  break;
case 4:
  individual[gene].green = Math.floor(Math.random() * 256);
  break;
case 5:
  individual[gene].blue = Math.floor(Math.random() * 256);
  break;
case 6:
  individual[gene].alpha = Math.random();
  break;
</code></pre>

<p>  }
  return individual;
}
```</p>

<p>Pour le faire tourner vous aurez besoin d'une photo de 400x400 pixels et
de beaucoup de patience… Avec Firefox, ça marche tout seul mais avec
Chrome il faudra passer par un serveur Web. Si Ruby est installé sur
votre machine, vous pouvez démarrer un serveur en entrant ceci dans un
terminal (même répertoire que votre fichier HTML):</p>

<pre><code>ruby -rwebrick -e'WEBrick::HTTPServer.new(:Port =&gt; 3000, :DocumentRoot =&gt; Dir.pwd).start'
</code></pre>

<p>Le code se trouve aussi sur Github: <a href="https://github.com/lkdjiin/picture_genetic_algorithm">github.com/lkdjiin/picture_genetic_algorithm</a>.
Je suis sûr que certains d'entre-vous connaissent Javascript bien mieux que
moi et peuvent l'améliorer, alors n'hésitez pas.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les algorithmes génétiques démystifiés 35]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/10/20/les-algorithmes-genetiques-demystifies-35/"/>
    <updated>2013-10-20T21:21:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/10/20/les-algorithmes-genetiques-demystifies-35</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>On continue aujourd'hui avec la mise en place de l'algorithme de <em>Hill-climbing</em>
pour s'assurer que la fonction d'évaluation de nos images est pertinente.</p>

<!-- more -->


<p>J'ai déjà parlé du <em>Hill-climbing</em> dans
<a href="http://lkdjiin.github.io/blog/2013/09/17/les-algorithmes-genetiques-demystifies-16-le-hill-climbing/">cet article</a>.
On peut le considérer comme une version très basique d'un algorithme
génétique, sans population et sans reproduction. Utile donc, pour
tester rapidement et facilement l'évaluation:</p>

<p>``` javascript
var solution = makeIndividual();
var generation = 0;
var htmlGeneration = document.getElementById(&ldquo;generation&rdquo;);
var htmlQuality = document.getElementById(&ldquo;quality&rdquo;);
var interval = setInterval(hillClimb, 150);</p>

<p>function hillClimb() {
  var opponent = mutate(copy(solution));
  var score_opponent = quality(opponent);
  var score_solution = quality(solution);
  if (score_opponent > score_solution) {</p>

<pre><code>solution = opponent;
</code></pre>

<p>  }
  generation++;
  if (generation % 100 == 0) renderIndividual(solution, ctx);
  htmlGeneration.innerHTML = generation;
  htmlQuality.innerHTML = score_solution;
  if (generation >= 100000) {</p>

<pre><code>clearInterval(interval);
</code></pre>

<p>  }
}
```</p>

<p>Les explications maintenant. À chaque tour on compare les scores obtenus
par la solution courante (la meilleure jusqu'ici) avec une version mutée
de lui-même (<code>opponent</code>). Si l'opposant est meilleur, il prend la place
de la solution:</p>

<pre><code>var opponent = mutate(copy(solution));
var score_opponent = quality(opponent);
var score_solution = quality(solution);
if (score_opponent &gt; score_solution) {
  solution = opponent;
}
</code></pre>

<p>J'affiche ensuite la solution courante, toutes les 100 générations:</p>

<pre><code>generation++;
if (generation % 100 == 0) renderIndividual(solution, ctx);
</code></pre>

<p>À chaque tour, j'affiche la génération courante et son score:</p>

<pre><code>htmlGeneration.innerHTML = generation;
htmlQuality.innerHTML = score_solution;
</code></pre>

<p>Enfin, on stoppe tout au bout de 100.000 essais:</p>

<pre><code>if (generation &gt;= 100000) {
  clearInterval(interval);
}
</code></pre>

<p>La fonction de mutation est longue, mais simple. On sélectionne au hasard
un carré et une de ses propriétés puis on la modifie:</p>

<p>``` javascript
function mutate(individual) {
  var gene = Math.floor(Math.random() * TOTAL_SQUARES),</p>

<pre><code>  squareProperty = Math.floor(Math.random() * 7);
</code></pre>

<p>  switch (squareProperty) {</p>

<pre><code>case 0:
  individual[gene].x = Math.floor(Math.random() * IMAGE_WIDTH);
  break;
case 1:
  individual[gene].y = Math.floor(Math.random() * IMAGE_HEIGHT);
  break;
case 2:
  individual[gene].size = Math.floor(Math.random() * SQUARE_MAX_SIZE);
  break;
case 3:
  individual[gene].red = Math.floor(Math.random() * 256);
  break;
case 4:
  individual[gene].green = Math.floor(Math.random() * 256);
  break;
case 5:
  individual[gene].blue = Math.floor(Math.random() * 256);
  break;
case 6:
  individual[gene].alpha = Math.random();
  break;
</code></pre>

<p>  }
  return individual;
}
```</p>

<p>La prochaine fois on verra deux dernières fonctions <em>techniques</em>:
<code>copy</code> et <code>renderIndividual</code> et on sera près à faire tourner
notre algorithme.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les algorithmes génétiques démystifiés 34]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/10/18/les-algorithmes-genetiques-demystifies-34/"/>
    <updated>2013-10-18T20:44:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/10/18/les-algorithmes-genetiques-demystifies-34</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Après avoir vu comment créer un individu qui représente une image,
on regarde aujourd'hui comment évaluer une image.</p>

<!-- more -->


<p>N'étant pas familier du traitement d'image et de tout ce qui s'y rapporte,
j'avoue avoir eu un petit instant de panique quand je me suis demandé:
«Comment savoir, entre deux images, laquelle est <em>la plus proche</em> d'une image
de référence ?».</p>

<p>Et puis j'ai respiré un bon coup: après tout une image n'est rien d'autre
qu'une liste de données, on a qu'à faire au plus simple, c'est à dire
comparer chaque pixel. Y'avait vraiment pas de quoi paniquer ! Voilà donc
la fonction <code>quality</code> qui mesure la similitude entre une image d'origine
et une image candidate:</p>

<p>``` javascript
function quality(individual) {
  var imgOrigin = ctxOrigin.getImageData(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);
  var pixelArrayOrigin = imgOrigin.data;
  var score = 0;
  renderIndividual(individual, ctxBuffer);
  var imgBuffer = ctxBuffer.getImageData(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);
  var pixelArrayCandidate = imgBuffer.data;
  for (var i = 0, n = pixelArrayOrigin.length; i &lt; n; i += 4) {</p>

<pre><code>score += Math.abs(pixelArrayOrigin[i] - pixelArrayCandidate[i]);
score += Math.abs(pixelArrayOrigin[i+1] - pixelArrayCandidate[i+1]);
score += Math.abs(pixelArrayOrigin[i+2] - pixelArrayCandidate[i+2]);
</code></pre>

<p>  }
  return 1 / score;
}
```</p>

<p>C'est parti pour quelques explications. On récupère les pixels de
l'image d'origine (qui se trouve dans un canvas) dans la variable
<code>pixelArrayOrigin</code>:</p>

<pre><code>var imgOrigin = ctxOrigin.getImageData(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);
var pixelArrayOrigin = imgOrigin.data;
</code></pre>

<p>Ensuite, on construit l'image candidate dans un canvas non-affiché. La
fonction <code>renderIndividual</code> sera détaillée plus tard:</p>

<pre><code>renderIndividual(individual, ctxBuffer);
</code></pre>

<p>On récupère les pixels de cette image candidate dans <code>pixelArrayCandidate</code>:</p>

<pre><code>var imgBuffer = ctxBuffer.getImageData(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);
var pixelArrayCandidate = imgBuffer.data;
</code></pre>

<p>Maintenant on vérifie les pixels un à un. Un pixel est représenté par quatre
nombres, respectivement rouge, vert, bleu et alpha. Le score augmente de la
différence entre les composantes rouges, vertes et bleues:</p>

<pre><code>for (var i = 0, n = pixelArrayOrigin.length; i &lt; n; i += 4) {
  score += Math.abs(pixelArrayOrigin[i] - pixelArrayCandidate[i]);
  score += Math.abs(pixelArrayOrigin[i+1] - pixelArrayCandidate[i+1]);
  score += Math.abs(pixelArrayOrigin[i+2] - pixelArrayCandidate[i+2]);
}
</code></pre>

<p>Finalement on retourne l'inverse pour avoir un score compris entre
0 et 1:</p>

<pre><code>return 1 / score;
</code></pre>

<p>La prochaine fois, on met l'algorithme de <em>Hill-Climbing</em> en place.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
