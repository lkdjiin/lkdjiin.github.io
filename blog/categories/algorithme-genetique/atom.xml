<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : algorithme génétique | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/algorithme-genetique/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2014-05-30T21:21:32+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Un algorithme génétique en Julia - partie 12]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/05/30/un-algorithme-genetique-en-julia-partie-12/"/>
    <updated>2014-05-30T21:11:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/05/30/un-algorithme-genetique-en-julia-partie-12</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Avec ce que j'ai compris au <a href="blog/2014/05/29/un-algorithme-genetique-en-julia-partie-11/">dernier épisode</a>
à propos des types, je peux améliorer la fonction <code>mutate</code>:</p>

<p>``` julia
function mutate(ch)
  mutator(g) = if rand(1:10) == 1</p>

<pre><code>g == 1 ? 0 : 1
</code></pre>

<p>  else</p>

<pre><code>g
</code></pre>

<p>  end
  Chromosome([ mutator(x)::Int for x in ch.genes ])
end
```</p>

<!-- more -->


<p>Maintenant les gènes des chromosomes restent toujours des tableaux de
<em>Int</em>:</p>

<pre><code>julia&gt; include("main.jl")
mutate (generic function with 1 method)

julia&gt; pop = create_population(8, 20)
8-element Array{Chromosome,1}:
 Chromosome([0,0,0,0,1,0,0,0,1,0,0,1,1,1,0,1,0,1,1,1])
 Chromosome([1,1,1,1,1,0,0,0,0,1,0,0,0,0,0,0,1,1,0,1])
 Chromosome([1,1,1,0,1,1,0,0,0,1,1,0,1,0,0,0,0,1,1,0])
 Chromosome([0,0,1,0,0,1,1,0,1,0,1,0,1,0,0,0,0,0,1,1])
 Chromosome([0,1,0,1,0,1,1,0,1,0,1,0,1,1,0,0,0,0,1,1])
 Chromosome([0,0,0,1,0,1,1,1,0,0,1,0,1,0,0,0,0,1,0,0])
 Chromosome([0,1,1,0,0,0,1,0,0,0,0,1,0,0,1,0,0,1,1,1])
 Chromosome([0,0,1,1,0,0,0,0,0,0,0,0,0,1,0,1,0,1,0,1])

julia&gt; scores = score(pop)
8-element Array{Int32,1}:
  9
  9
 10
  8
 10
  7
  8
  6

julia&gt; selection = tournament(scores)
16-element Array{Int32,1}:
 7
 2
 7
 5
 2
 7
 3
 7
 2
 2
 1
 3
 6
 5
 2
 3

julia&gt; gen2 = reproduction([], pop, selection)
8-element Array{Chromosome,1}:
 Chromosome([1,1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,1])
 Chromosome([0,1,1,0,0,0,1,1,0,0,0,1,0,0,1,0,0,1,1,1])
 Chromosome([1,1,1,1,1,0,0,0,0,1,0,1,0,0,1,0,0,1,1,1])
 Chromosome([0,0,1,0,1,1,0,0,0,0,1,0,1,0,0,0,0,1,0,1])
 Chromosome([1,1,1,0,1,0,1,0,0,1,0,0,0,1,0,0,1,0,0,0])
 Chromosome([0,0,1,0,1,1,0,0,1,1,1,0,1,0,0,0,0,1,0,0])
 Chromosome([0,0,0,1,0,0,1,1,0,0,1,0,1,1,0,0,1,0,1,1])
 Chromosome([1,0,1,0,1,1,0,0,0,1,1,0,1,0,1,0,1,1,1,0])
</code></pre>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Un algorithme génétique en Julia - partie 11]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/05/29/un-algorithme-genetique-en-julia-partie-11/"/>
    <updated>2014-05-29T21:13:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/05/29/un-algorithme-genetique-en-julia-partie-11</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Hier on a vu qu'il y avait une légère différence de <em>type</em> entre les gènes
d'un chromosome avant et après la mutation:</p>

<pre><code>julia&gt; c = Chromosome(create_genes(10))
Chromosome([0,0,0,1,1,1,1,1,0,1])

julia&gt; d = mutate(c)
Chromosome({0,0,0,1,1,1,1,1,0,1})

julia&gt; c.genes
10-element Array{Int32,1}:

julia&gt; d.genes
10-element Array{Any,1}:
</code></pre>

<p>C'est l'occasion de regarder un peu les types en Julia.</p>

<!-- more -->


<p>Voici une fonction <code>foo</code> qui additionne deux nombres:</p>

<pre><code>julia&gt; foo(a, b) = a + b
foo (generic function with 1 method)

julia&gt; foo(1, 2)
3
</code></pre>

<p>Que se passe-t-il si je lui passe deux chaînes de caractères ?</p>

<pre><code>julia&gt; foo("he", "llo")
ERROR: no method +(ASCIIString, ASCIIString)
</code></pre>

<p>C'est une erreur, puisque la fonction <code>+</code> ne sait pas additionner des
chaînes.</p>

<p>Très bien, apprenons à <code>foo</code> l'addition de chaînes. Pour cela, on indique
à Julia ce qu'il faut faire lorsque les arguments reçus par <code>foo</code> sont de
type <code>String</code>:</p>

<pre><code>julia&gt; foo(a::String, b::String) = "$a$b"
foo (generic function with 2 methods)

julia&gt; foo("he", "llo")
"hello"
</code></pre>

<p>Et <code>foo</code> fonctionne toujours avec des nombres:</p>

<pre><code>julia&gt; foo(1, 2)
3
</code></pre>

<p>La fonction <code>foo</code> possède 2 <em>méthodes</em>, une à utiliser quand elle reçoit des
arguments <em>String</em>, et une autre, à utiliser dans tous les autres cas:</p>

<pre><code>julia&gt; methods(foo)
# 2 methods for generic function "foo":
foo(a::String,b::String) at none:1
foo(a,b) at none:1
</code></pre>

<p>La prochaine fois on arrangera notre fonction <code>mutate</code> pour que les gènes
conservent le même type.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Un algorithme génétique en Julia - partie 10]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/05/28/un-algorithme-genetique-en-julia-partie-10/"/>
    <updated>2014-05-28T21:19:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/05/28/un-algorithme-genetique-en-julia-partie-10</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Voici le nouveau code de l'algorithme:</p>

<p>``` julia main.jl
type Chromosome
  genes
end</p>

<p>create_genes(size) = rand(0:1, size)</p>

<p>function create_population(size, chromosome_size)
  [ Chromosome(create_genes(chromosome_size)) for _ in 1:size ]
end</p>

<p>score(population) = map(x &ndash;> sum(x.genes), population)</p>

<p>function fight(scores, index1, index2)
  scores[index1] > scores[index2] ? index1 : index2
end</p>

<p>function tournament(scores)
  population_size = length(scores)
  selection_size = population_size * 2
  [ fight(scores, rand(1:population_size), rand(1:population_size))</p>

<pre><code>for _ in 1:selection_size ]
</code></pre>

<p>end</p>

<p>function crossover(chromosome1, chromosome2)
  cut_point = rand(1:length(chromosome1.genes))
  first_part = chromosome1.genes[1:cut_point]
  second_part = chromosome2.genes[cut_point + 1:end]
  mutate(Chromosome([ first_part, second_part]))
end</p>

<p>function reproduction(new_population, current_population, selection)
  if selection == []</p>

<pre><code>return new_population
</code></pre>

<p>  else</p>

<pre><code>father = current_population[selection[1]]
mother = current_population[selection[2]]
child = crossover(father, mother)
reproduction([new_population, child], current_population, selection[3:end])
</code></pre>

<p>  end
end</p>

<p>function mutate(ch)
  mutator(g) = if rand(1:10) == 1</p>

<pre><code>g == 1 ? 0 : 1
</code></pre>

<p>  else</p>

<pre><code>g
</code></pre>

<p>  end
  Chromosome([ mutator(x) for x in ch.genes ])
end
```</p>

<!-- more -->


<p>J'ai simplement ajouter la fonction <code>mutate</code> dans <code>crossover</code>:</p>

<p><code>julia
function crossover(chromosome1, chromosome2)
  cut_point = rand(1:length(chromosome1.genes))
  first_part = chromosome1.genes[1:cut_point]
  second_part = chromosome2.genes[cut_point + 1:end]
  mutate(Chromosome([ first_part, second_part]))
end
</code></p>

<p>Et ça fonctionne:</p>

<pre><code>julia&gt; include("main.jl")

julia&gt; pop = create_population(8, 20)
8-element Array{Chromosome,1}:
 Chromosome([0,0,0,1,1,1,0,0,0,0,0,1,1,0,1,1,0,1,0,1])
 Chromosome([1,0,1,1,0,0,0,0,1,1,0,1,1,0,1,0,1,0,1,1])
 Chromosome([1,0,1,1,1,0,1,0,0,0,1,0,0,1,0,1,0,0,0,1])
 Chromosome([1,1,1,1,1,0,0,0,0,0,1,1,0,1,1,0,1,0,0,1])
 Chromosome([0,1,1,0,0,0,0,0,0,1,1,1,0,1,0,0,1,0,1,0])
 Chromosome([0,1,0,1,1,0,0,1,0,0,1,1,1,1,0,0,0,0,0,1])
 Chromosome([1,1,1,0,0,0,1,1,0,1,1,0,0,0,1,1,1,0,0,0])
 Chromosome([1,0,0,0,1,0,0,1,0,1,0,1,0,0,0,0,1,0,0,0])

julia&gt; scores = score(pop)
8-element Array{Int32,1}:
  9
 11
  9
 11
  8
  9
 10
  6

julia&gt; selection = tournament(scores)
16-element Array{Int32,1}:
 7
 7
 7
 7
 ...
 4
 1
 1

julia&gt; gen2 = reproduction([], pop, selection)
8-element Array{Chromosome,1}:
 Chromosome({1,1,1,0,0,0,1,1,0,1,1,0,1,0,1,1,1,0,0,0})
 Chromosome({1,1,1,0,0,0,1,0,0,1,1,0,0,0,1,1,0,0,0,0})
 Chromosome({0,1,0,0,1,0,0,1,0,1,1,1,1,0,1,0,1,0,1,1})
 Chromosome({1,0,1,0,0,1,0,0,1,1,1,1,0,1,0,0,1,0,1,1})
 Chromosome({1,0,1,1,0,0,0,0,1,0,0,1,1,0,1,1,0,0,0,1})
 Chromosome({1,1,1,1,1,1,0,0,0,0,1,1,0,1,1,1,1,0,0,0})
 Chromosome({0,1,1,0,0,0,1,0,0,0,1,1,0,1,1,0,1,0,0,1})
 Chromosome({0,0,0,1,1,1,0,0,0,1,0,1,1,0,1,1,0,1,0,1})
</code></pre>

<p>Mais un truc me dérange toujours, le tableau est <em>modifié</em> après passage
dans <code>mutate</code>:</p>

<pre><code>julia&gt; c = chromosome(create_genes(10))
chromosome([0,0,0,1,1,1,1,1,0,1])

julia&gt; d = mutate(c)
Chromosome({0,0,0,1,1,1,1,1,0,1})

julia&gt; c.genes
10-element Array{Int32,1}:
...

julia&gt; d.genes
10-element Array{Any,1}:
...
</code></pre>

<p>C'est bien ça, le tableau n'est pas du même type. Bon, ça ne dérange pas
l'algorithme et c'est l'occasion d'un prochain article sur Julia ;)</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Un algorithme génétique en Julia - partie 9]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/05/27/un-algorithme-genetique-en-julia-partie-9/"/>
    <updated>2014-05-27T21:16:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/05/27/un-algorithme-genetique-en-julia-partie-9</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Voici une fonction de mutation pour nos chromosomes.</p>

<p>``` julia
function mutate(ch)
  mutator(gene) = if rand(1:10) == 1</p>

<pre><code>gene == 1 ? 0 : 1
</code></pre>

<p>  else</p>

<pre><code>gene
</code></pre>

<p>  end
  Chromosome([ mutator(x) for x in ch.genes ])
end
```</p>

<!-- more -->


<p>Le code me semble un peu <em>maladroit</em>, mais a l'air de fonctionner pas trop
mal ;) La fonction <code>mutate</code> prend en entrée un chromosome et produit un autre
chromosome en sortie. On peut voir qu'une seconde fonction, <code>mutator</code>, est
définie à l'intérieur.</p>

<p>Ça marche pas mal, même si il faudra faire quelque chose pour l'<em>intervalle magique</em> <code>rand(1:10)</code>:</p>

<pre><code>julia&gt; include("main.jl")
mutate (generic function with 1 method)

julia&gt; c = Chromosome(create_genes(20))
Chromosome([0,1,1,0,1,0,1,0,0,0,1,1,0,1,1,0,0,0,1,1])

julia&gt; mutate(c)
Chromosome({0,1,1,0,1,0,1,0,0,0,1,1,0,1,0,0,0,0,0,1})
</code></pre>

<p>Le seul petit truc qui me dérange, c'est qu'on a <code>[...]</code> en entrée et
<code>{...}</code> en sortie. Je ne sais ni pourquoi, ni ce que c'est… On verra bien
au prochain épisode si c'est grave ;)</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Un algorithme génétique en Julia - partie 8]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/05/25/un-algorithme-genetique-en-julia-partie-8/"/>
    <updated>2014-05-25T19:03:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/05/25/un-algorithme-genetique-en-julia-partie-8</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Voici le programme actuel, qui tient compte de l'utilisation du type
<code>Chromosome</code>, ajouté dans la partie 7.</p>

<!-- more -->


<p>``` julia main.jl
type Chromosome
  genes
end</p>

<p>create_genes(size) = rand(0:1, size)</p>

<p>function create_population(size, chromosome_size)
  [ Chromosome(create_genes(chromosome_size)) for _ in 1:size ]
end</p>

<p>score(population) = map(x &ndash;> sum(x.genes), population)</p>

<p>function fight(scores, index1, index2)
  scores[index1] > scores[index2] ? index1 : index2
end</p>

<p>function tournament(scores)
  population_size = length(scores)
  selection_size = population_size * 2
  [ fight(scores, rand(1:population_size), rand(1:population_size))</p>

<pre><code>for _ in 1:selection_size ]
</code></pre>

<p>end</p>

<p>function crossover(chromosome1, chromosome2)
  cut_point = rand(1:length(chromosome1.genes))
  first_part = chromosome1.genes[1:cut_point]
  second_part = chromosome2.genes[cut_point + 1:end]
  Chromosome([ first_part, second_part])
end</p>

<p>function reproduction(new_population, current_population, selection)
  if selection == []</p>

<pre><code>return new_population
</code></pre>

<p>  else</p>

<pre><code>father = current_population[selection[1]]
mother = current_population[selection[2]]
child = crossover(father, mother)
reproduction([new_population, child], current_population, selection[3:end])
</code></pre>

<p>  end
end
```</p>

<p>Le changement le plus important est l'utilisation d'une fonction anonyme:</p>

<p><code>julia
score(population) = map(x -&gt; sum(x.genes), population)
</code></p>

<p>On arrive bien à calculer la génération suivante:</p>

<pre><code>julia&gt; include("main.jl")
reproduction (generic function with 1 method)

julia&gt; pop = create_population(8, 20)
8-element Array{Chromosome,1}:
 Chromosome([1,0,1,1,1,0,0,1,0,0,0,1,0,0,0,0,0,0,0,1])
 Chromosome([0,1,0,0,1,1,1,0,1,0,0,1,0,1,1,0,1,0,0,0])
 Chromosome([0,0,1,0,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,0])
 Chromosome([0,0,0,1,1,0,0,0,1,1,0,0,0,1,1,0,0,1,0,0])
 Chromosome([1,1,0,1,1,0,0,0,1,1,0,0,0,1,0,1,0,1,0,0])
 Chromosome([1,0,1,1,1,1,0,0,1,0,0,0,1,0,0,0,0,1,1,1])
 Chromosome([1,1,0,0,1,0,1,0,0,1,0,1,0,1,0,0,1,1,1,1])
 Chromosome([0,1,1,0,0,1,0,1,0,1,1,0,0,0,1,0,1,1,1,0])

julia&gt; scores = score(pop)
8-element Array{Int32,1}:
  7
  9
  5
  7
  9
 10
 11
 10

julia&gt; selection = tournament(scores)
16-element Array{Int32,1}:
 2
 4
 6
 1
 6
 5
 8
 7
 5
 7
 5
 6
 8
 4
 6
 6

julia&gt; generation2 = reproduction([], pop, selection)
8-element Array{Chromosome,1}:
 Chromosome([0,1,0,0,1,1,1,0,1,1,0,0,0,1,1,0,0,1,0,0])
 Chromosome([1,0,1,1,1,0,0,1,0,0,0,1,0,0,0,0,0,0,0,1])
 Chromosome([1,0,1,1,1,1,0,0,1,0,0,0,1,0,0,0,0,1,0,0])
 Chromosome([0,1,1,0,0,1,1,0,0,1,0,1,0,1,0,0,1,1,1,1])
 Chromosome([1,1,0,1,1,0,0,0,1,1,0,0,0,1,0,0,1,1,1,1])
 Chromosome([1,1,0,1,1,1,0,0,1,0,0,0,1,0,0,0,0,1,1,1])
 Chromosome([0,1,1,0,0,1,0,1,0,1,1,0,0,0,1,0,1,1,0,0])
 Chromosome([1,0,1,1,1,1,0,0,1,0,0,0,1,0,0,0,0,1,1,1])
</code></pre>

<p>La première version de l'algorithme est bientôt finie…</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
