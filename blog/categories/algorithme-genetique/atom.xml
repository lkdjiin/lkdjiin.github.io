<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : algorithme génétique | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/algorithme-genetique/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2013-10-21T21:15:51+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Les algorithmes génétiques démystifiés 35]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/10/20/les-algorithmes-genetiques-demystifies-35/"/>
    <updated>2013-10-20T21:21:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/10/20/les-algorithmes-genetiques-demystifies-35</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>On continue aujourd'hui avec la mise en place de l'algorithme de <em>Hill-climbing</em>
pour s'assurer que la fonction d'évaluation de nos images est pertinente.</p>

<!-- more -->


<p>J'ai déjà parlé du <em>Hill-climbing</em> dans
<a href="http://lkdjiin.github.io/blog/2013/09/17/les-algorithmes-genetiques-demystifies-16-le-hill-climbing/">cet article</a>.
On peut le considérer comme une version très basique d'un algorithme
génétique, sans population et sans reproduction. Utile donc, pour
tester rapidement et facilement l'évaluation:</p>

<p>``` javascript
var solution = makeIndividual();
var generation = 0;
var htmlGeneration = document.getElementById(&ldquo;generation&rdquo;);
var htmlQuality = document.getElementById(&ldquo;quality&rdquo;);
var interval = setInterval(hillClimb, 150);</p>

<p>function hillClimb() {
  var opponent = mutate(copy(solution));
  var score_opponent = quality(opponent);
  var score_solution = quality(solution);
  if (score_opponent > score_solution) {</p>

<pre><code>solution = opponent;
</code></pre>

<p>  }
  generation++;
  if (generation % 100 == 0) renderIndividual(solution, ctx);
  htmlGeneration.innerHTML = generation;
  htmlQuality.innerHTML = score_solution;
  if (generation >= 100000) {</p>

<pre><code>clearInterval(interval);
</code></pre>

<p>  }
}
```</p>

<p>Les explications maintenant. À chaque tour on compare les scores obtenus
par la solution courante (la meilleure jusqu'ici) avec une version mutée
de lui-même (<code>opponent</code>). Si l'opposant est meilleur, il prend la place
de la solution:</p>

<pre><code>var opponent = mutate(copy(solution));
var score_opponent = quality(opponent);
var score_solution = quality(solution);
if (score_opponent &gt; score_solution) {
  solution = opponent;
}
</code></pre>

<p>J'affiche ensuite la solution courante, toutes les 100 générations:</p>

<pre><code>generation++;
if (generation % 100 == 0) renderIndividual(solution, ctx);
</code></pre>

<p>À chaque tour, j'affiche la génération courante et son score:</p>

<pre><code>htmlGeneration.innerHTML = generation;
htmlQuality.innerHTML = score_solution;
</code></pre>

<p>Enfin, on stoppe tout au bout de 100.000 essais:</p>

<pre><code>if (generation &gt;= 100000) {
  clearInterval(interval);
}
</code></pre>

<p>La fonction de mutation est longue, mais simple. On sélectionne au hasard
un carré et une de ses propriétés puis on la modifie:</p>

<p>``` javascript
function mutate(individual) {
  var gene = Math.floor(Math.random() * TOTAL_SQUARES),</p>

<pre><code>  squareProperty = Math.floor(Math.random() * 7);
</code></pre>

<p>  switch (squareProperty) {</p>

<pre><code>case 0:
  individual[gene].x = Math.floor(Math.random() * IMAGE_WIDTH);
  break;
case 1:
  individual[gene].y = Math.floor(Math.random() * IMAGE_HEIGHT);
  break;
case 2:
  individual[gene].size = Math.floor(Math.random() * SQUARE_MAX_SIZE);
  break;
case 3:
  individual[gene].red = Math.floor(Math.random() * 256);
  break;
case 4:
  individual[gene].green = Math.floor(Math.random() * 256);
  break;
case 5:
  individual[gene].blue = Math.floor(Math.random() * 256);
  break;
case 6:
  individual[gene].alpha = Math.random();
  break;
</code></pre>

<p>  }
  return individual;
}
```</p>

<p>La prochaine fois on verra deux dernières fonctions <em>techniques</em>:
<code>copy</code> et <code>renderIndividual</code> et on sera près à faire tourner
notre algorithme.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les algorithmes génétiques démystifiés 34]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/10/18/les-algorithmes-genetiques-demystifies-34/"/>
    <updated>2013-10-18T20:44:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/10/18/les-algorithmes-genetiques-demystifies-34</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Après avoir vu comment créer un individu qui représente une image,
on regarde aujourd'hui comment évaluer une image.</p>

<!-- more -->


<p>N'étant pas familier du traitement d'image et de tout ce qui s'y rapporte,
j'avoue avoir eu un petit instant de panique quand je me suis demandé:
«Comment savoir, entre deux images, laquelle est <em>la plus proche</em> d'une image
de référence ?».</p>

<p>Et puis j'ai respiré un bon coup: après tout une image n'est rien d'autre
qu'une liste de données, on a qu'à faire au plus simple, c'est à dire
comparer chaque pixel. Y'avait vraiment pas de quoi paniquer ! Voilà donc
la fonction <code>quality</code> qui mesure la similitude entre une image d'origine
et une image candidate:</p>

<p>``` javascript
function quality(individual) {
  var imgOrigin = ctxOrigin.getImageData(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);
  var pixelArrayOrigin = imgOrigin.data;
  var score = 0;
  renderIndividual(individual, ctxBuffer);
  var imgBuffer = ctxBuffer.getImageData(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);
  var pixelArrayCandidate = imgBuffer.data;
  for (var i = 0, n = pixelArrayOrigin.length; i &lt; n; i += 4) {</p>

<pre><code>score += Math.abs(pixelArrayOrigin[i] - pixelArrayCandidate[i]);
score += Math.abs(pixelArrayOrigin[i+1] - pixelArrayCandidate[i+1]);
score += Math.abs(pixelArrayOrigin[i+2] - pixelArrayCandidate[i+2]);
</code></pre>

<p>  }
  return 1 / score;
}
```</p>

<p>C'est parti pour quelques explications. On récupère les pixels de
l'image d'origine (qui se trouve dans un canvas) dans la variable
<code>pixelArrayOrigin</code>:</p>

<pre><code>var imgOrigin = ctxOrigin.getImageData(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);
var pixelArrayOrigin = imgOrigin.data;
</code></pre>

<p>Ensuite, on construit l'image candidate dans un canvas non-affiché. La
fonction <code>renderIndividual</code> sera détaillée plus tard:</p>

<pre><code>renderIndividual(individual, ctxBuffer);
</code></pre>

<p>On récupère les pixels de cette image candidate dans <code>pixelArrayCandidate</code>:</p>

<pre><code>var imgBuffer = ctxBuffer.getImageData(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT);
var pixelArrayCandidate = imgBuffer.data;
</code></pre>

<p>Maintenant on vérifie les pixels un à un. Un pixel est représenté par quatre
nombres, respectivement rouge, vert, bleu et alpha. Le score augmente de la
différence entre les composantes rouges, vertes et bleues:</p>

<pre><code>for (var i = 0, n = pixelArrayOrigin.length; i &lt; n; i += 4) {
  score += Math.abs(pixelArrayOrigin[i] - pixelArrayCandidate[i]);
  score += Math.abs(pixelArrayOrigin[i+1] - pixelArrayCandidate[i+1]);
  score += Math.abs(pixelArrayOrigin[i+2] - pixelArrayCandidate[i+2]);
}
</code></pre>

<p>Finalement on retourne l'inverse pour avoir un score compris entre
0 et 1:</p>

<pre><code>return 1 / score;
</code></pre>

<p>La prochaine fois, on met l'algorithme de <em>Hill-Climbing</em> en place.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les algorithmes génétiques démystifiés: Imagerie]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/10/16/les-algorithmes-genetiques-demystifies-imagerie/"/>
    <updated>2013-10-16T16:31:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/10/16/les-algorithmes-genetiques-demystifies-imagerie</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Bonjour, aujourd'hui on commence une nouvelle étude sur les algorithmes
génétiques avec un problème sympa : recréer une photo à partir de plusieurs
carrés de tailles et de couleurs différentes. Au début, l'image est
générée au hasard:</p>

<p><img src="/images/Capture-13.jpg"></p>

<p>Puis, petit à petit, elle converge vers la photo d'origine:</p>

<p><img src="/images/Capture-11.jpg"></p>

<!-- more -->


<p>Avant tout, il faut réfléchir à deux choses: la représentation des individus
et l'évaluation. De plus, comme je l'ai déjà mentionné, Javascript n'est pas
mon fort. Alors plutôt que d'écrire tout de suite un algorithme génétique, je
vais d'abord essayer de mettre en place un algorithme de <em>Hill Climbing</em>.</p>

<h2>Les individus</h2>

<p>Chaque <em>solution/individu</em> sera composé de quelques centaines de petits carrés.
Chaque carré pourra être personnalisé grâce à:</p>

<ul>
<li>sa position x</li>
<li>sa position y</li>
<li>sa taille</li>
<li>sa couleur (rouge, vert et bleu)</li>
<li>sa transparence</li>
</ul>


<p>Voici comment je traduis ça en Javascript:</p>

<p>``` javascript
function makeIndividual() {
  var individual = [];
  for (var i = 0; i &lt; TOTAL_SQUARES; i++) {</p>

<pre><code>individual.push({
  x: Math.floor(Math.random() * IMAGE_WIDTH),
  y: Math.floor(Math.random() * IMAGE_HEIGHT),
  size: Math.floor(Math.random() * IMAGE_WIDTH),
  red: Math.floor(Math.random() * 256),
  green: Math.floor(Math.random() * 256),
  blue: Math.floor(Math.random() * 256),
  alpha: Math.random()
});
</code></pre>

<p>  }
  return individual;
}
```</p>

<p>Techniquement, un individu est donc une liste de gènes, et un gène est un
objet avec les propriétés x, y, size, red, green, blue et alpha.</p>

<p>La prochaine fois on verra comment on peut évaluer nos images.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les algorithmes génétiques démystifiés 32]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/10/11/les-algorithmes-genetiques-demystifies-32/"/>
    <updated>2013-10-11T20:48:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/10/11/les-algorithmes-genetiques-demystifies-32</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Je vais arrêter d'écrire sur le problème des 8 dames, temporairement. On a
réussi à développer un programme qui permet de trouver des solutions pour
un échiquier de 50 x 50 cases en un temps acceptable. Voici un joli
graphique avec en x, la taille d'un coté de l'échiquier et en y, le nombre
de secondes requis pour obtenir une solution:</p>

<p><img src="/images/secondes-pour-tailles.png"></p>

<!-- more -->


<p>26 minutes pour un échiquier de 50 x 50 cases, je trouve que ça n'est pas
si mal. Par contre on voit bien comme le temps augmente de manière
exponentielle ! J'aimerais parvenir à trouver des solutions pour un
échiquier de 100 x 100 cases (voir même 1000 x 1000) en un temps raisonable,
disons quelques heures. Pour ça, il faudra améliorer le programme. Peut-être
explorer d'autres méthodes de sélection et/ou croisement ; utiliser les
multiples coeurs de nos machines ; peut-être changer de langage (je pense
en ce moment à Elixir ou Scala, mais je suis ouvert aux suggestions).
Enfin, tout ça sera pour plus tard.</p>

<p>En attendant, je voudrais aborder un problème d'imagerie: un algorithme
génétique qui copierait au mieux une photo à partir de petits carrés de
couleurs et de tailles quelconques. Je compte le faire en Javascript
mais je dois vous prévenir que Javascript et moi, ça fait deux.
Je vais commencer à regarder ça ce week-end, et je compte sur vous pour
pointer les erreurs et les maladresses de mon futur code…</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les algorithmes génétiques démystifiés: un point sur les performances]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/10/09/les-algorithmes-genetiques-demystifies-un-point-sur-les-performances/"/>
    <updated>2013-10-09T11:57:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/10/09/les-algorithmes-genetiques-demystifies-un-point-sur-les-performances</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Aujourd'hui j'ai peu de temps à consacrer à ce blog. Je voudrais faire
un petit point sur les performances de différentes versions de
l'interpréteur Ruby.</p>

<!-- more -->


<p>Utiliser un interpréteur plus rapide est le moyen le plus simple de
booster les performances. J'ai calculé le temps que prends une génération
avec diverses tailles d'échiquier (16, 30 et 40) et trois interpréteurs
différents: MRI 1.9.3, MRI 2.0.0 et Rubinius 2.0.0.
Voici les résultats:</p>

<pre><code>Temps en seconde pour une génération
====================================

                 16x16  30x30  40x40

MRI 1.9.3        0.092  0.24   0.40
MRI 2.0.0        0.081  0.20   0.34
Rubinius 2.0.0   0.075  0.15   0.24
</code></pre>

<p>C'est sans appel et sans surprise. On peut quand même noter que plus
la taille de l'échiquier augmente, plus Rubinius est proportionnelement rapide.
En gros 22% plus rapide sur un échiquier de 16x16 cases et 66% plus rapide sur
un échiquier de 40x40 cases.</p>

<p>Conclusion évidente: choisissez bien vos outils ;&ndash;)</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
