<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : javascript | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/javascript/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2014-06-15T21:16:50+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Un space invaders avec Opal.rb - partie 6]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/06/15/un-space-invaders-avec-opal-dot-rb-partie-6/"/>
    <updated>2014-06-15T19:53:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/06/15/un-space-invaders-avec-opal-dot-rb-partie-6</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Et si on controlait notre joueur au clavier ? On commence par ajouter deux
méthodes à la classe <code>Player</code>, une pour changer sa position vers la
gauche (<code>move_left</code>), et une autre pour aller à droite (<code>move_right</code>):</p>

<p>``` ruby app/player.rb
class Player
  DELTA = 10</p>

<p>  attr_accessor :x, :y, :w, :h, :color</p>

<p>  def initialize</p>

<pre><code>@x = 325
@y = 560
@w = 50
@h = 30
@color = 'green'
</code></pre>

<p>  end</p>

<p>  def move_left</p>

<pre><code>@x -= DELTA
</code></pre>

<p>  end</p>

<p>  def move_right</p>

<pre><code>@x += DELTA
</code></pre>

<p>  end</p>

<p>end
```</p>

<!-- more -->


<p>Maintenant, il faut faire en sorte qu'un appui sur la touche <em>flêche gauche</em>
appelle la méthode <code>move_left</code> (et qu'un appui sur <em>flêche droite</em> appelle
<code>move_right</code>). Pour ça, je vais encore écrire un mélange de ruby/javascript:</p>

<p>``` ruby
def init_keyboard
  %x(</p>

<pre><code>window.addEventListener("keydown",
  function(e) {
    if(e.keyCode == 37) { #{@player.move_left} }
    if(e.keyCode == 39) { #{@player.move_right} }
  },
  false);
</code></pre>

<p>  )
end
```</p>

<p>Le <code>%x()</code> joue le même rôle que les backticks, mais sur plusieurs lignes.
Ce qui est entre <code>%x(</code> et <code>)</code> est donc du code javascript (mais qui peut
utiliser l'interpolation de chaînes de caractères ruby…).</p>

<p>Le code javascript est simple, on enregistre un <em>listener</em> sur l'évenement
<code>"keydown"</code>. Le code <code>37</code> correspond à la touche <em>flêche gauche</em>, le code
<code>39</code>, bin, vous avez deviné ;)</p>

<p>Il reste a insérer la méthode <code>init_keyboard</code> dans la méthode <code>start</code>:</p>

<p>``` ruby
def start
  init_keyboard
  main_loop(50) do</p>

<pre><code>@canvas.clear_background
@canvas.draw_player(@player)
</code></pre>

<p>  end
end
```</p>

<p>Après un <code>rake build</code>, vous pouvez déplacer le joueur au clavier.</p>

<p>Pour info, voici le code complet de <code>application.rb</code>:</p>

<p>``` ruby app/application.rb
require &lsquo;opal&rsquo;
require &lsquo;opal-jquery&rsquo;</p>

<p>require &lsquo;space_canvas&rsquo;
require &lsquo;player&rsquo;</p>

<p>@canvas = SpaceCanvas.new
@player = Player.new</p>

<p>def main_loop(interval, &amp;block)
  <code>setInterval(#{block.to_n}, #{interval})</code>
end</p>

<p>def init_keyboard
  %x(</p>

<pre><code>window.addEventListener("keydown",
  function(e) {
    if(e.keyCode == 37) { #{@player.move_left} }
    if(e.keyCode == 39) { #{@player.move_right} }
  },
  false);
</code></pre>

<p>  )
end</p>

<p>def start
  init_keyboard
  main_loop(50) do</p>

<pre><code>@canvas.clear_background
@canvas.draw_player(@player)
</code></pre>

<p>  end
end</p>

<p>start
```</p>

<p>Je pense que demain, on commencera à s'occuper des envahisseurs…</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Un space invaders avec Opal.rb - partie 5]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/06/14/un-space-invaders-avec-opal-dot-rb-partie-5/"/>
    <updated>2014-06-14T21:15:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/06/14/un-space-invaders-avec-opal-dot-rb-partie-5</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>On faire faire un peu d'animation. Ça va être très simple, on va juste
faire bouger le joueur automatiquement d'un coté. Malgré la simplicité,
on aura après ça tout ce qu'il nous faut pour animer notre futur jeu.</p>

<!-- more -->


<p>Je vais ajouter une méthode <code>update</code> à la classe <code>Player</code>:</p>

<p>``` ruby app/player.rb
class Player
  attr_accessor :x, :y, :w, :h, :color</p>

<p>  def initialize</p>

<pre><code>@x = 325
@y = 560
@w = 50
@h = 30
@color = 'green'
</code></pre>

<p>  end</p>

<p>  def update</p>

<pre><code>@x += 1
</code></pre>

<p>  end
end
```</p>

<p>À chaque appel de cette méthode, la position du joueur sera décalée de 1
pixel vers la droite. Peux pas faire plus simple ;)</p>

<p>Maintenant, voici le nouveau fichier <code>application.rb</code>, où se trouve
l'animation proprement dite:</p>

<p>``` ruby app/application.rb
require &lsquo;opal&rsquo;
require &lsquo;opal-jquery&rsquo;</p>

<p>require &lsquo;space_canvas&rsquo;
require &lsquo;player&rsquo;</p>

<p>@canvas = SpaceCanvas.new
@player = Player.new</p>

<p>def main_loop(interval, &amp;block)
  <code>setInterval(#{block.to_n}, #{interval})</code>
end</p>

<p>def start
  main_loop(50) do</p>

<pre><code>@canvas.clear_background
@canvas.draw_player(@player)
@player.update
</code></pre>

<p>  end
end</p>

<p>start
```</p>

<p>Tout d'abord, la méthode <code>main_loop</code>:</p>

<p><code>ruby
def main_loop(interval, &amp;block)
  `setInterval(#{block.to_n}, #{interval})`
end
</code></p>

<p>Elle prend comme arguments un intervalle en millisecondes et un bloc
d'instructions ruby à exécuter toutes les <code>interval</code> millisecondes.
Elle appelle la méthode javascript <code>setInterval</code> avec ses arguments.
La méthode <code>to_n</code>, sur <code>#{block.to_n}</code>, convertie le bloc d'instructions
ruby en instructions javascript. Il me semble que <code>to_n</code> est là pour
<em>to native</em>.</p>

<p>Je ne suis pas content de cette méthode. En effet, mélanger deux
langages différents n'est pas très heureux. Je ne sais pas si il existe
une façon de faire cela en ruby pur, mais j'espère. Je chercherais plus
tard, pour l'instant ça fonctionnera comme ça.</p>

<p>Et maintenant la méthode <code>start</code> s'explique simplement:</p>

<p>``` ruby
def start
  main_loop(50) do</p>

<pre><code>@canvas.clear_background
@canvas.draw_player(@player)
@player.update
</code></pre>

<p>  end
end
```</p>

<p>Toutes les 50 millisecondes (<code>main_loop(50)</code>) on exécute le bloc
d'instructions suivantes:</p>

<pre><code>@canvas.clear_background
@canvas.draw_player(@player)
@player.update
</code></pre>

<p>C'est à dire qu'on efface l'écran (le canvas), puis on affiche le joueur,
et enfin on déplace le joueur.</p>

<p>Après un <code>rake build</code> et un rafraichissement du navigateur, vous devriez
voir le joueur se déplacer lentement vers la droite. Mission accomplie !</p>

<p>Demain on déplace le joueur avec le clavier ?</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Un space invaders avec Opal.rb - partie 4]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/06/13/un-space-invaders-avec-opal-dot-rb-partie-4/"/>
    <updated>2014-06-13T19:01:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/06/13/un-space-invaders-avec-opal-dot-rb-partie-4</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Petite séance de refactoring aujourd'hui. Tout d'abord, comme nous avons
maintenant deux classes dans le fichier <code>app/application.rb</code>, on va les mettre
dans des fichiers séparés, pour obtenir ça:</p>

<pre><code>● tree
.
├── app
│   ├── application.rb
│   ├── player.rb
│   └── space_canvas.rb
├── build.js
├── Gemfile
├── Gemfile.lock
├── index.html
└── Rakefile
</code></pre>

<!-- more -->


<p>Le fichier <code>application.rb</code> est maintenant réduit à ceci:</p>

<p>``` ruby app/application.rb
require &lsquo;opal&rsquo;
require &lsquo;opal-jquery&rsquo;</p>

<p>require &lsquo;space_canvas&rsquo;
require &lsquo;player&rsquo;</p>

<p>canvas = SpaceCanvas.new
player = Player.new
canvas.clear_background
canvas.draw_player(player)
```</p>

<p>Le fichier <code>player.rb</code> contient la classe <code>Player</code>:</p>

<p>``` ruby app/player.rb
class Player
  attr_accessor :x, :y, :w, :h, :color</p>

<p>  def initialize</p>

<pre><code>@x = 325
@y = 560
@w = 50
@h = 30
@color = 'green'
</code></pre>

<p>  end
end
```</p>

<p>Quant au fichier <code>space_canvas.rb</code>, le voici:</p>

<p>``` ruby app/space_canvas.rb
class SpaceCanvas</p>

<p>  def initialize</p>

<pre><code>@canvas  = `document.getElementById('canvas')`
@context = `#@canvas.getContext('2d')`
@height  = `#@canvas.height`
@width   = `#@canvas.width`
</code></pre>

<p>  end</p>

<p>  def clear_background</p>

<pre><code>`#@context.fillStyle = 'black'`
`#@context.fillRect(0, 0, #@width, #@height)`
</code></pre>

<p>  end</p>

<p>  def draw_player(player)</p>

<pre><code>`#@context.fillStyle = #{player.color}`
`#@context.fillRect(#{player.x}, #{player.y}, #{player.w}, #{player.h})`
</code></pre>

<p>  end
end
```</p>

<p>Les méthodes <code>clear_background</code> et <code>draw_player</code> sont trop similaires pour
être laissées en l'état ! En voici un petit refactoring:</p>

<p>``` ruby app/space_canvas.rb
class SpaceCanvas</p>

<p>  def initialize</p>

<pre><code>@canvas  = `document.getElementById('canvas')`
@context = `#@canvas.getContext('2d')`
@height  = `#@canvas.height`
@width   = `#@canvas.width`
</code></pre>

<p>  end</p>

<p>  def clear_background</p>

<pre><code>draw_rect(0, 0, @width, @height, 'black')
</code></pre>

<p>  end</p>

<p>  def draw_player(player)</p>

<pre><code>draw_rect(player.x, player.y, player.w, player.h, player.color)
</code></pre>

<p>  end</p>

<p>  private</p>

<p>  def draw_rect(x, y, w, h, color)</p>

<pre><code>`#@context.fillStyle = #{color}`
`#@context.fillRect(#{x}, #{y}, #{w}, #{h})`
</code></pre>

<p>  end</p>

<p>end
```</p>

<p>Comme toujours, <code>rake build</code> pour s'assurer que ça fonctionne bien !</p>

<p>Demain, on verra comment faire bouger notre joueur…</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Un space invaders avec Opal.rb - partie 3]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/06/12/un-space-invaders-avec-opal-dot-rb-partie-3/"/>
    <updated>2014-06-12T20:54:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/06/12/un-space-invaders-avec-opal-dot-rb-partie-3</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>C'est le moment d'afficher un joli vaisseau pour le joueur. Bon, en fait,
ça va être un gros rectangle vert, mais c'est pareil ;)</p>

<!-- more -->


<p>On commence par ajouter une classe <code>Player</code>:</p>

<p>``` ruby
class Player
  attr_accessor :x, :y, :w, :h, :color</p>

<p>  def initialize</p>

<pre><code>@x = 325
@y = 560
@w = 50
@h = 30
@color = 'green'
</code></pre>

<p>  end
end
```</p>

<p>Y a pas grand chose à dire, hein ? X et y sont la position du coin supérieur
gauche sur le canvas, w est la largeur et h est la hauteur. C'est tout.</p>

<p>Pour afficher notre joueur, on ajoute une méthode <code>draw_player</code> à la classe
<code>SpaceCanvas</code>:</p>

<p>``` ruby
  def draw_player(player)</p>

<pre><code>`#@context.fillStyle = #{player.color}`
`#@context.fillRect(#{player.x}, #{player.y}, #{player.w}, #{player.h})`
</code></pre>

<p>  end
```</p>

<p>Cette méthode est similaire à la méthode <code>clear_background</code>, vue la dernière
fois, ce qui va nous donner une séance de refactoring demain…</p>

<p>Finalement, voici le code complet du fichier <code>app/application.rb</code>:</p>

<p>``` ruby app/application.rb
require &lsquo;opal&rsquo;
require &lsquo;opal-jquery&rsquo;</p>

<p>class SpaceCanvas</p>

<p>  def initialize</p>

<pre><code>@canvas  = `document.getElementById('canvas')`
@context = `#@canvas.getContext('2d')`
@height  = `#@canvas.height`
@width   = `#@canvas.width`
</code></pre>

<p>  end</p>

<p>  def clear_background</p>

<pre><code>`#@context.fillStyle = 'black'`
`#@context.fillRect(0, 0, #@width, #@height)`
</code></pre>

<p>  end</p>

<p>  def draw_player(player)</p>

<pre><code>`#@context.fillStyle = #{player.color}`
`#@context.fillRect(#{player.x}, #{player.y}, #{player.w}, #{player.h})`
</code></pre>

<p>  end
end</p>

<p>class Player
  attr_accessor :x, :y, :w, :h, :color</p>

<p>  def initialize</p>

<pre><code>@x = 325
@y = 560
@w = 50
@h = 30
@color = 'green'
</code></pre>

<p>  end
end</p>

<p>canvas = SpaceCanvas.new
player = Player.new
canvas.clear_background
canvas.draw_player(player)
```</p>

<p>N'oubliez pas de faire un <code>rake build</code> avant d'ouvrir le fichier HTML.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Un space invaders avec Opal.rb - partie 2]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/06/11/un-space-invaders-avec-opal-dot-rb-partie-2/"/>
    <updated>2014-06-11T12:19:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/06/11/un-space-invaders-avec-opal-dot-rb-partie-2</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Hier j'ai commencé l'écriture d'un Space Invaders avec Opal.rb, et on a pu
afficher un beau canvas tout noir ;) Il manquait l'explication de la classe
<code>SpaceCanvas</code>, la voici.</p>

<!-- more -->


<p>``` ruby
class SpaceCanvas</p>

<p>  def initialize</p>

<pre><code>@canvas  = `document.getElementById('canvas')`
@context = `#@canvas.getContext('2d')`
@height  = `#@canvas.height`
@width   = `#@canvas.width`
</code></pre>

<p>  end</p>

<p>  def clear_background</p>

<pre><code>`#@context.fillStyle = 'black'`
`#@context.fillRect(0, 0, #{@width}, #{@height})`
</code></pre>

<p>  end
end
```</p>

<p>Toute cette classe utilise un <em>truc</em> de Opal : ce qui se trouve entre
<em>backticks</em> est du javascript et on a accès à l'interpolation Ruby des
chaînes de caractères. En Ruby, les backticks permettent d'appeller une
commande externe, avec Opal c'est pareil, sauf que l'extérieur c'est
javascript.</p>

<p>Tout d'abord dans la méthode <code>initialize</code>, la première ligne:</p>

<p>``` ruby</p>

<pre><code>@canvas  = `document.getElementById('canvas')`
</code></pre>

<p>```</p>

<p>C'est du javascript pur et dur ;) On récupère un référence au canvas par
son ID et on stocke cette référence dans <code>@canvas</code>.</p>

<p>Les trois lignes suivantes utilisent le même truc avec en plus de l'interpolation:</p>

<p>``` ruby</p>

<pre><code>@context = `#@canvas.getContext('2d')`
@height  = `#@canvas.height`
@width   = `#@canvas.width`
</code></pre>

<p>```</p>

<p>On obtient une référence au <em>contexte</em> du canvas, ce qui sera utile pour
dessiner dedans et on récupère sa hauteur et sa largeur.</p>

<p>La méthode <code>clear_background</code> maintenant:</p>

<p>``` ruby
  def clear_background</p>

<pre><code>`#@context.fillStyle = 'black'`
`#@context.fillRect(0, 0, #{@width}, #{@height})`
</code></pre>

<p>  end
```</p>

<p>On selectionne d'abord une couleur de remplissage avec:</p>

<pre><code>`#@context.fillStyle = 'black'`
</code></pre>

<p>Puis on remplit le canvas avec cette couleur:</p>

<pre><code>`#@context.fillRect(0, 0, #{@width}, #{@height})`
</code></pre>

<p>Notez que j'ai utilisé ici une autre écriture pour l'interpolation. La ligne
précédente est equivalente à:</p>

<pre><code>`#@context.fillRect(0, 0, #@width, #@height)`
</code></pre>

<p>J'aurais d'ailleurs du écrire comme ça pour être homogène ;)</p>

<p>La prochaine on affiche un joueur ?</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
