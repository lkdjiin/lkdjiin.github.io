<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : framework | Xavier Nayrac]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/framework/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2018-07-21T09:40:22+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Comment écrire un framework de test pour Ruby]]></title>
    <link href="http://lkdjiin.github.io/blog/2016/11/02/comment-ecrire-un-framework-de-test-pour-ruby/"/>
    <updated>2016-11-02T09:06:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2016/11/02/comment-ecrire-un-framework-de-test-pour-ruby</id>
    <content type="html"><![CDATA[<p>Si vous souhaitez comprendre le fonctionnement d’un framework de test, si vous
voulez écrire votre propre framework et que vous ressentiez le besoin d’un coup
de pouce, cet article est fait pour vous. Nous verrons étape par étape comment écrire
une telle chose. Le framework que nous réaliserons tiendra en quelques dizaines de
lignes de Ruby et pourra être utilisé comme une base pour vos futures
réalisations.</p>

<p><img class="center" src="/images/colorful-test-tubes.jpg"></p>

<!-- more -->

<h2 id="par-o-commencer-">Par où commencer ?</h2>

<p>Pour ce genre de problématique, je trouve qu’il est plus simple de partir d’un
exemple concret du <strong>langage</strong>, de l’<strong>API</strong>, que l’on souhaite obtenir. Dans notre
cas, nous pouvons déjà écrire quelques tests même si nous ne pouvons pas encore
les faire tourner.</p>

<p>Voici 3 tests pour une classe Rover. Classe qui aura une position x,y et une
direction :</p>

<p>```ruby
# fichier test_rover.rb final.</p>

<p>require ‘rover’</p>

<p>class TestRover &lt; Tasty::Unit</p>

<p>def test_it_has_a_position
    rover = Rover.new(3, 2)
    assert(rover.position == [3, 2])
  end</p>

<p>def test_it_has_a_direction_by_default
    rover = Rover.new(3, 2)
    assert(rover.direction == ‘north’)
  end</p>

<p>def test_it_has_a_given_direction
    rover = Rover.new(3, 2, ‘west’)
    assert(rover.direction == ‘west’)
  end</p>

<p>end
```</p>

<p>J’ai cherché à faire au plus simple. Tout se passe à l’intérieur d’une classe.
Ça nous permettra d’hériter facilement de certains comportements, comme la
méthode <code>assert</code> qui sera définit dans la classe <code>Tasty::Unit</code>.</p>

<p>Chaque méthode qui commence par <code>test_</code> représente un test, et <code>assert</code> se
contente de vérifier si son argument est vrai ou faux.</p>

<p>On lancera le programme avec le nom d’un fichier de test, par exemple
<code>tasty test_rover.rb</code>. Mais par souci de simplicité, nous nous contenterons
d’utiliser directement l’interpréteur Ruby de cette manière :
<code>ruby tasty.rb test_rover.rb</code>.</p>

<p>Voici ce que j’imagine en terme d’affichage :</p>

<pre><code>$ ruby tasty.rb test_rover.rb
ok - test_it_has_a_position
not ok - test_it_has_a_given_direction
&lt;&lt; ERROR REPORT GOES HERE &gt;&gt;
ok - test_it_has_a_direction_by_default
</code></pre>

<p>Le nom d’un test est précédé de “ok” si il a réussi, ou de “not ok” si il a
échoué. Le rapport d’erreur est affiché aussitôt après une ligne “not ok”.</p>

<h2 id="retrouver-la-classe-de-test">Retrouver la classe de test</h2>

<p>Commençons par le plus simple, définissons une classe Rover dans un fichier
<code>rover.rb</code> :</p>

<p>```ruby
# fichier rover.rb</p>

<p>class Rover
end
```</p>

<p>Puis définissons notre premier test, dans un fichier <code>test_rover.rb</code>. Ce
premier test va nous guider pendant un bout de temps :</p>

<p>```ruby
# fichier test_rover.rb</p>

<p>require_relative ‘rover’</p>

<p>class TestRover &lt; Tasty::Unit</p>

<p>def test_it_has_a_position
    rover = Rover.new(3, 2)
    assert(rover.position == [3, 2])
  end</p>

<p>end
```</p>

<p>Maintenant, dans un fichier <code>tasty.rb</code>, définissons le namespace Tasty et une
classe principale. Nous initialiserons cette classe avec le nom de fichier
passé en argument sur la ligne de commande. Nous afficherons un message
temporaire pour nous assurer que nous sommes sur la bonne voie :</p>

<p>```ruby
# fichier tasty.rb</p>

<p>module Tasty</p>

<p>class Main
    def initialize(filename)
      puts “Testing #{filename}”
    end
  end</p>

<p>end</p>

<p>main = Tasty::Main.new(ARGV[0])
```</p>

<p>L’essai est concluant :</p>

<pre><code>$ ruby tasty.rb test_rover.rb
Testing test_rover.rb
</code></pre>

<p>Tant qu’on y est, mieux vaut définir tout de suite la classe <code>Tasty::Unit</code>,
voici à quoi devrait ressembler votre fichier <code>tasty.rb</code> :</p>

<p>```ruby
# fichier tasty.rb</p>

<p>module Tasty</p>

<p>class Unit
  end</p>

<p>class Main
    def initialize(filename)
      puts “Testing #{filename}”
    end
  end</p>

<p>end</p>

<p>main = Tasty::Main.new(ARGV[0])
```</p>

<p>Passons maintenant au sujet principal de cette section : nous devons retrouver
le nom de la classe de test, à savoir <code>TestRover</code>, depuis la classe
<code>Tasty::Main</code>. Pour ce faire nous pourrions écrire un parser qui
analyserait le contenu du fichier passé en argument. Ou bien nous pouvons
compter sur les facilités d’introspection du langage Ruby. Je parie volontiers
sur cette seconde solution. Nous laisserons Ruby charger et parser le fichier de
test pour nous. Nous chargerons le fichier de la même manière qu’un autre, avec
un <code>require</code>. Puis nous utilerons <code>Object.constants</code> pour accéder à toutes les
constantes définies jusqu’ici (une classe est représentée par une constante) :</p>

<p>```ruby
module Tasty</p>

<p>class Main
    def initialize(filename)
      require File.join(Dir.pwd, filename)
      puts Object.constants
    end
  end</p>

<p>end
```</p>

<p>Si vous lancez ce programme, vous verrez une liste de toutes les constantes
définies, dont celle que nous cherchons, <code>TestRover</code> :</p>

<pre><code>$ ruby tasty.rb test_rover.rb 
Object
Module
Class
BasicObject
...
SimpleDelegator
Tasty
Rover
TestRover # &lt;============================
RUBYGEMS_ACTIVATION_MONITOR
</code></pre>

<p>Attention, il s’agit d’un tableau de symboles. Vous pouvez vous en convaincre
en changeant de méthode d’affichage. Remplacez <code>puts</code> par <code>p</code> :</p>

<p><code>ruby
def initialize(filename)
  require File.join(Dir.pwd, filename)
  p Object.constants
end
</code></p>

<p>Vous pouvez voir qu’il s’agit de symboles :</p>

<pre><code>$ ruby tasty.rb test_rover.rb 
[:Object, :Module, :Class, :BasicObject, :Kernel, :NilClass, :NIL, :Data,
...
:SimpleDelegator, :Tasty, :Rover, :TestRover, :RUBYGEMS_ACTIVATION_MONITOR]
</code></pre>

<p>Nous pouvons sélectionner uniquement les classes commençant par <code>Test</code> :</p>

<p>```ruby
# fichier tasty.rb</p>

<p>module Tasty</p>

<p>class Unit
  end</p>

<p>class Main
    def initialize(filename)
      require File.join(Dir.pwd, filename)
      p Object.constants.select { |name| name.to_s.start_with?(‘Test’) }
    end
  end</p>

<p>end</p>

<p>main = Tasty::Main.new(ARGV[0])
```</p>

<p>Nous avons réduit le tableau aux seules classes de test. Nous en avons une
seule ici, mais nous pourrions très bien en avoir plusieurs :</p>

<pre><code>$ ruby tasty.rb test_rover.rb 
[:TestRover]
</code></pre>

<p>Il y a une convention qui est à l’oeuvre : seule une classe de test peut
commencer par <code>Test</code>. Ça n’est pas un bien grand sacrifice, et nous pourrions
y remédier si besoin.</p>

<h2 id="les-mthodes-de-test">Les méthodes de test</h2>

<p>La prochaine étape consistera à récupérer les méthodes qui sont dans la classe
de test, et à les lancer.</p>

<p>Un peu de recherche, dans une session irb et avec la <a href="http://ruby-doc.org/">documentation Ruby</a>,
nous montrera que nous pouvons transformer un symbole en une classe, et aussi
instancier cette classe, à l’aide de <code>Object.const_get</code> :</p>

<p><code>irb
$ irb
&gt;&gt; :Module
:Module
&gt;&gt; Object.const_get(:Module)
Module &lt; Object
&gt;&gt; Object.const_get(:Module).new
#&lt;Module:0x0055e0036e5580&gt;
</code>
On peut donc transformer notre tableau de symboles selon cette méthode :</p>

<p><code>ruby
class Main
  def initialize(filename)
    require File.join(Dir.pwd, filename)
    classes = Object.constants.select { |name| name.to_s.start_with?('Test') }
    classes.map! { |name| Object.const_get(name) }
  end
end
</code></p>

<p>Retournons dans une session irb pour voir comment obtenir les méthodes d’une
classe quelconque.  Définissons une classe <code>C</code> avec une méthode
<code>method_in_class_c</code> pour les besoins de la cause :</p>

<p><code>irb
$ irb
&gt;&gt; class C
&gt;&gt;   def method_in_class_c; end
&gt;&gt; end
</code></p>

<p>La méthode <code>instance_methods</code> appliquée sur une classe liste les méthodes de
cette classe. Nous retrouvons notre méthode <code>method_in_class_c</code>, parmi plein
d’autres :</p>

<p><code>irb
&gt;&gt; puts C.instance_methods
method_in_class_c # &lt;--------------------
methods
singleton_methods
protected_methods
private_methods
public_methods
instance_of?
...
</code></p>

<p>D’où viennent ces autres méthodes ? Ce sont les méthodes héritées ou incluses.
Pour restreindre les méthodes à celles définies dans la classe C, nous devons
utiliser un artifice :</p>

<p><code>irb
&gt;&gt; puts C.instance_methods(false)
method_in_class_c
</code></p>

<p>Nous pouvons nous servir de ce nouveau savoir pour lister les méthodes de test :</p>

<p>```ruby
# fichier tasty.rb</p>

<p>module Tasty</p>

<p>class Unit
  end</p>

<p>class Main
    def initialize(filename)
      require File.join(Dir.pwd, filename)
      classes = Object.constants.select { |name| name.to_s.start_with?(‘Test’) }
      classes.map! { |name| Object.const_get(name) }</p>

<pre><code>  classes.each do |c|
    c.instance_methods(false).each do |m|
      puts m
    end
  end
end   end
</code></pre>

<p>end</p>

<p>main = Tasty::Main.new(ARGV[0])
```</p>

<p>Nous l’avons trouvé :</p>

<pre><code>$ ruby tasty.rb test_rover.rb 
test_it_has_a_position
</code></pre>

<p>Il reste à lancer chaque test en se servant de la méthode <a href="http://ruby-doc.org/core-2.3.1/Object.html#method-i-send">send</a> sur une
instance de la classe de test. Nous ferons cela ailleurs que dans le
constructeur de la classe Tasty::Main. Dans une méthode <code>run</code> par exemple, ça
sera plus propre :</p>

<p>```ruby
# fichier tasty.rb</p>

<p>module Tasty</p>

<p>class Unit
  end</p>

<p>class Main
    def initialize(filename)
      require File.join(Dir.pwd, filename)
      @classes = Object.constants.select { |name| name.to_s.start_with?(‘Test’) }
      @classes.map! { |name| Object.const_get(name) }
    end</p>

<pre><code>def run
  @classes.each do |class_under_test|
    instance = class_under_test.new
    class_under_test.instance_methods(false).each do |m|
      instance.send(m)
    end
  end
end   end
</code></pre>

<p>end</p>

<p>main = Tasty::Main.new(ARGV[0])
main.run
```</p>

<p>Alors, et si on lançait les tests :</p>

<pre><code>$ ruby tasty.rb test_rover.rb 
test_rover.rb:6:in `initialize':
  wrong number of arguments (given 2, expected 0) (ArgumentError)
  from test_rover.rb:6:in `new'
  from test_rover.rb:6:in `test_it_has_a_position'
</code></pre>

<p>Déçu ? Vous ne devriez pas, ça a parfaitement fonctionné. Le programme nous dit
qu’en ligne 6 du fichier <code>test_rover.rb</code> nous tentons d’initialiser un rover
avec 2 arguments alors que la méthode <code>initialize</code> de rover attends 0
arguments. Voyons cette fameuse ligne 6, dans le test nous cherchons à
initialiser un rover avec des coordonnées x et y :</p>

<p><code>ruby
rover = Rover.new(3, 2)
</code></p>

<p>Et comme notre classe <code>Rover</code> est déséspérement vide, il est normal que Ruby
crashe.</p>

<h2 id="passons-le-premier-test">Passons le premier test</h2>

<p>Dotons la méthode <code>Rover#initialize</code> de deux arguments, comme attendu :</p>

<p><code>
# fichier rover.rb
class Rover
  def initialize(x, y)
  end
end
</code></p>

<p>Et le programme nous emmène au prochain problème :</p>

<pre><code>$ ruby tasty.rb test_rover.rb 
test_rover.rb:7:in `test_it_has_a_position': undefined method `position'
for #&lt;Rover:0x0055778cf43a90&gt; (NoMethodError)
</code></pre>

<p>On en vient facilement à bout en ajoutant la méthode <code>Rover#position</code> :</p>

<p>```
# fichier rover.rb
class Rover
  def initialize(x, y)
  end</p>

<p>def position
  end
end
```</p>

<p>L’erreur suivante est beaucoup plus intéressante :</p>

<pre><code>$ ruby tasty.rb test_rover.rb 
test_rover.rb:7:in `test_it_has_a_position': undefined method `assert'
for #&lt;TestRover:0x00558edbe7a828&gt; (NoMethodError)
</code></pre>

<p>Nous devons coder <code>assert</code> de telle manière qu’elle produise une erreur si son
argument est différent de <code>true</code>.  Et pour que les classes de test puissent y
accéder, nous la placerons dans <code>Tasty::Unit</code>. Nous utiliserons aussi une erreur
custom, <code>AssertionError</code> :</p>

<p>```ruby
module Tasty</p>

<p>class AssertionError &lt; StandardError
  end</p>

<p>class Unit
    def assert(boolean)
      raise AssertionError unless boolean
    end
  end</p>

<p>end
```</p>

<p>Nous y sommes presque. La méthode <code>assert</code> est codée et produit l’erreur attendue :</p>

<pre><code>$ ruby tasty.rb test_rover.rb 
tasty.rb:8:in `assert': Tasty::AssertionError (Tasty::AssertionError)
  from test_rover.rb:7:in `test_it_has_a_position'
</code></pre>

<p>Que se passerait-il si nous implémentions <code>Rover</code> de telle manière qu’elle
passe le test ?</p>

<p>```ruby
# fichier rover.rb
class Rover
  def initialize(x, y)
    @x = x
    @y = y
  end</p>

<p>def position
    [@x, @y]
  end
end
```</p>

<p>Et bien rien. Il ne se passe rien.</p>

<pre><code>$ ruby tasty.rb test_rover.rb 
$ # &lt;---- Cruelle absence d'affichage
</code></pre>

<p>En l’occurence, ce rien signifie quand même que nous avons réussi cette
partie !  Le test est passé ! Ajoutons un petit quelque chose pour être tenu au
courant :</p>

<p><code>ruby
module Tasty
  class Main
    def run
      @classes.each do |class_under_test|
        instance = class_under_test.new
        class_under_test.instance_methods(false).each do |m|
          instance.send(m)
          puts "ok - #{m}" # &lt;---------------
        end
      end
    end
  end
end
</code></p>

<p>Et c’est la victoire :</p>

<p><code>
$ ruby tasty.rb test_rover.rb 
ok - test_it_has_a_position
</code></p>

<h2 id="les-autres-tests">Les autres tests</h2>

<p>Ajoutons le second test, mais plaçons le avant le premier (!) pour observer un
phénomène curieux :</p>

<p>```ruby
# fichier test_rover.rb
require_relative ‘rover’</p>

<p>class TestRover &lt; Tasty::Unit</p>

<p>def test_it_has_a_direction_by_default
    rover = Rover.new(3, 2)
    assert(rover.direction == ‘north’)
  end</p>

<p>def test_it_has_a_position
    rover = Rover.new(3, 2)
    assert(rover.position == [3, 2])
  end</p>

<p>end
```</p>

<p>Le programme reporte bien le nouveau problème qui se trouve dans la méthode
<code>test_it_has_a_direction_by_default</code> mais il n’y a aucune mention de
<code>test_it_has_a_position</code> qui fonctionnait pourtant bien.</p>

<pre><code>$ ruby tasty.rb test_rover.rb 
test_rover.rb:7:in `test_it_has_a_direction_by_default': undefined method
`direction' for #&lt;Rover:0x0055a03b444db0 @x=3, @y=2&gt; (NoMethodError)
</code></pre>

<p>Lorsqu’une erreur se produit dans <code>Tasty::Main#run</code>, le programme s’arrête
purement et simplement. Ce n’est pas du tout ce que nous voulons. Nous voulons
qu’une erreur soit rapportée, et que le programme continue en traitant le test
suivant. Commençons par remanier un peu la méthode <code>run</code> en la splittant en
deux parties :</p>

<p>```ruby
class Main
  def run
    @classes.each do |under_test|
      instance = under_test.new
      under_test.instance_methods(false).each { |m| run_test(instance, m) }
    end
  end</p>

<p>def run_test(instance, method)
    instance.send(method)
    puts “ok - #{m}”
  end
end
```</p>

<p>Nous pouvons alors <em>attraper</em> les erreurs facilement dans la méthode <code>run_test</code> :</p>

<p><code>ruby
  def run_test(instance, method)
    instance.send(method)
    puts "ok - #{method}"
  rescue =&gt; ex
    puts "not ok - #{method}"
    puts ex.inspect
    puts ex.backtrace
  end
</code></p>

<p>Et voilà le résultat, nous affichons à la fois les tests qui passent et ceux
qui échouent :</p>

<pre><code>$ ruby tasty.rb test_rover.rb 
not ok - test_it_has_a_direction_by_default
#&lt;NoMethodError: undefined method `direction' for #&lt;Rover:0x0055a7709c03c0 @x=3, @y=2&gt;&gt;
test_rover.rb:7:in `test_it_has_a_direction_by_default'
...
ok - test_it_has_a_position
</code></pre>

<p>En dotant <code>Rover</code> de la méthode <code>position</code> qui suit, les tests passent :</p>

<p><code>ruby
def position
  'north'
end
</code></p>

<pre><code>$ ruby tasty.rb test_rover.rb 
ok - test_it_has_a_direction_by_default
ok - test_it_has_a_position
</code></pre>

<p>Faire passer le 3ème test implique seulement d’implémenter la classe <code>Rover</code> de
façon correcte. Il n’y a rien à ajouter ou à modifier dans notre framework
<code>Tasty</code>.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Nous venons d’écrire un framework de test en quelques dizaines de lignes de
code grâce aux facultés d’introspection de Ruby. C’est maintenant à votre tour
de jouer en l’améliorant.  Voici quelques idées :</p>

<ul>
  <li>Faire jouer les tests dans un ordre aléatoire</li>
  <li>Afficher une ligne de résultat final : <code>X tests, Y errors</code></li>
  <li>La sortie console devrait se faire en couleur, les lignes “ok” en vert, les
lignes “not ok” en rouges, et le reste en normal</li>
  <li>Écrire <code>ok - it has a position</code> plutôt que <code>ok - test_it_has_a_position</code></li>
  <li>Faire en sorte que des classes autres que celles de test puissent commencer par <code>Test</code>.</li>
  <li>Le must pour un compilateur, c’est d’être écrit dans son langage. Faire
pareil ici : tester Tasty avec Tasty</li>
</ul>

<p>Pour finir, voici le code complet :</p>

<p>```ruby
# fichier rover.rb
class Rover
  def initialize(x, y, direction=’north’)
    @x = x
    @y = y
    @direction = direction
  end</p>

<p>def position
    [@x, @y]
  end</p>

<p>attr_reader :direction
end
```</p>

<p>```ruby
# fichier test_rover.rb
require_relative ‘rover’</p>

<p>class TestRover &lt; Tasty::Unit</p>

<p>def test_it_has_a_direction_by_default
    rover = Rover.new(3, 2)
    assert(rover.direction == ‘north’)
  end</p>

<p>def test_it_has_a_position
    rover = Rover.new(3, 2)
    assert(rover.position == [3, 2])
  end</p>

<p>def test_it_has_a_given_direction
    rover = Rover.new(3, 2, ‘west’)
    assert(rover.direction == ‘west’)
  end</p>

<p>end
```</p>

<p>```ruby
# fichier tasty.rb
module Tasty</p>

<p>class AssertionError &lt; StandardError
  end</p>

<p>class Unit
    def assert(boolean)
      raise AssertionError unless boolean
    end
  end</p>

<p>class Main
    def initialize(filename)
      require File.join(Dir.pwd, filename)
      @classes = Object.constants.select { |name| name.to_s.start_with?(‘Test’) }
      @classes.map! { |name| Object.const_get(name) }
    end</p>

<pre><code>def run
  @classes.each do |under_test|
    instance = under_test.new
    under_test.instance_methods(false).each { |m| run_test(instance, m) }
  end
end

def run_test(instance, method)
  instance.send(method)
  puts "ok - #{method}"
rescue =&gt; ex
  puts "not ok - #{method}"
  puts ex.message
  puts ex.backtrace
end   end
</code></pre>

<p>end</p>

<p>main = Tasty::Main.new(ARGV[0])
main.run
```</p>

<p>Bons tests ! À plus tard.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Commencer le développement web en Ruby]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/09/16/commencer-le-developpement-web-en-ruby/"/>
    <updated>2015-09-16T15:10:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/09/16/commencer-le-developpement-web-en-ruby</id>
    <content type="html"><![CDATA[<h2 id="guest-post-"><code>{ Guest Post }</code></h2>

<p>Grâce au framework <a href="http://rubyonrails.org/">Ruby on Rails</a>, Ruby est maintenant très populaire pour le développement d’application web.
Ce domaine est un pleine croissance et Ruby on Rails attire beaucoup de débutants de tout horizons.</p>

<p>Je pense que commencer l’apprentissage d’un framework web nécessite de bien comprendre le rôle de chacun de ses composants.
Des composants, Ruby on Rails en comporte beaucoup et chacun d’entre eux répond à une problématique bien précise.
ORM, routeur, templates, controlleurs, tâches de fond et bien d’autres ; il y a de quoi se perdre.</p>

<p>Mon conseil à ceux qui débutent dans le domaine est de bien comprendre la raison d’être de chaque chose.
Une manière amusante de cerner les problématiques qui ont donnés naissance aux frameworks tel que Rails,
c’est de se passer complètement de ces briques. C’est à dire partir du strict minimum et ajouter, petit à petit,
les composants dont on ressent le besoin.</p>

<!-- more -->

<h2 id="rack">Rack</h2>

<p><a href="https://rack.github.io/">Rack</a> est la brique de base de la plupart des frameworks web Ruby actuels. Rack est avant tout une API définissant
la manière pour un programme Ruby de prendre en charge et de répondre à une requête HTTP. Voici un exemple simple :</p>

<p>``` ruby
# ./config.ru</p>

<p>app = Proc.new do |env|
  [
    200,
    { “Content-Type” =&gt; “text/html” },
    [ “&lt;h1&gt;Hello world&lt;/h1&gt;” ]
  ]
end</p>

<p>run app
```</p>

<p>Dans cet exemple, on voit que l’on declare une variable <code>app</code> à laquelle on assigne un object <code>Proc</code>.
Cet objet <code>app</code> est ensuite passé à la méthode <code>Rack::Builder#run</code> indiquant ainsi au serveur compatible
ce qu’il faut exectuter lorsqu’une requête arrivera.</p>

<p>Regardons de plus près comment se comporte le <code>Proc</code> ci-dessus. On voit qu’il prend un argument que l’on
appelle <em>l’environement Rack</em>. Le <code>Proc</code> retourne une <em>réponse Rack</em> qui est un tableau contenant les
informations nécessaire à la construction de la réponse HTTP : le code de retour, les entêtes et le corps
de la reponse.</p>

<p>Rack ne nécessite pas d’utiliser un <code>Proc</code>. La seule contrainte est d’être un objet répondant à la méthode
<code>#call</code> prenant en argument un environement Rack et retournant une réponse Rack telle que nous venons de le voir.</p>

<h3 id="excuter-lapplication">Exécuter l’application</h3>

<p>Pour executer ce <code>config.ru</code> on peut utiliser l’outil <code>rackup</code> fourni avec la gem <code>rack</code>:</p>

<p><code>
$ gem install rack
$ rackup config.ru
[2015-07-21 10:54:21] INFO  WEBrick 1.3.1
[2015-07-21 10:54:21] INFO  ruby 2.2.2 (2015-04-13) [x86_64-linux]
[2015-07-21 10:54:21] INFO  WEBrick::HTTPServer#start: pid=24457 port=9292
</code></p>

<p>Cette commande va écouter sur le port 9292 et pour chaque requête appeller la méthode <code>#call</code> de l’objet <code>app</code>.</p>

<p>Lorsque l’on apportera es modification à notre code, il faudra bien penser à redémarrer le serveur : <code>CTRL-C</code> pour l’arrêter et le relancer avec la commande que l’on vient de voir.</p>

<h3 id="quy-a-t-il-dans-lenv">Qu’y a-t-il dans l’env</h3>

<p>Pour voir ce qui se trouve dans l’environement je vais utiliser <code>JSON.pretty_generate</code> qui va m’afficher la variable
<code>env</code> au format JSON.</p>

<p>``` ruby
# ./config.ru</p>

<p>require “json”</p>

<p>app = Proc.new do |env|
  puts JSON.pretty_generate(env)
  [
    200,
    { “Content-Type” =&gt; “text/html” },
    [ “&lt;h1&gt;Hello world&lt;/h1&gt;” ]
  ]
end</p>

<p>run app
```</p>

<p>Après avoir modifié le <code>config.ru</code>, il faut redémarrer le serveur.</p>

<p>Pour faire une requête, j’utilise <a href="https://github.com/jkbrzt/httpie">httpie</a> qui permet simplement d’envoyer des requêtes HTTP depuis le terminal et qui est équivalent à <code>curl</code> avec de jolies couleurs en plus. Vous pouvez utiliser le client de votre choix bien entendu. Chez moi cela donne :</p>

<p>```
$ http -v localhost:9292
GET / HTTP/1.1
Accept: <em>/</em>
Accept-Encoding: gzip, deflate
Connection: keep-alive
Host: localhost:9292
User-Agent: HTTPie/0.9.2</p>

<p>HTTP/1.1 200 OK
Connection: Keep-Alive
Content-Type: text/html
Date: Tue, 21 Jul 2015 11:21:16 GMT
Server: WEBrick/1.3.1 (Ruby/2.2.2/2015-04-13)
Transfer-Encoding: chunked</p>

<h1>Hello world</h1>
<p>```</p>

<p>À l’issue de cette requête, on a bien le body <code>&lt;h1&gt;Hello world&lt;/h1&gt;</code> qui s’affiche.
On remarque également que dans le terminal où notre serveur est lancé, on voit s’afficher
sur la sortie standard :</p>

<p>``` javascript
{
  “GATEWAY_INTERFACE”: “CGI/1.1”,
  “PATH_INFO”: “/”,
  “QUERY_STRING”: “”,
  “REMOTE_ADDR”: “127.0.0.1”,
  “REMOTE_HOST”: “localhost”,
  “REQUEST_METHOD”: “GET”,
  “REQUEST_URI”: “http://localhost:9292/”,
  “SCRIPT_NAME”: “”,
  “SERVER_NAME”: “localhost”,
  “SERVER_PORT”: “9292”,
  “SERVER_PROTOCOL”: “HTTP/1.1”,
  “SERVER_SOFTWARE”: “WEBrick/1.3.1 (Ruby/2.2.2/2015-04-13)”,
  “HTTP_HOST”: “localhost:9292”,
  “HTTP_CONNECTION”: “keep-alive”,
  “HTTP_ACCEPT_ENCODING”: “gzip, deflate”,
  “HTTP_ACCEPT”: “<em>/</em>”,
  “HTTP_USER_AGENT”: “HTTPie/0.9.2”,
  “rack.version”: [
    1,
    3
  ],
  “rack.input”: “#<rack::lint::inputwrapper:0x007fcac62086c0>",
  "rack.errors": "#<rack::lint::errorwrapper:0x007fcac6208698>",
  "rack.multithread": true,
  "rack.multiprocess": false,
  "rack.run_once": false,
  "rack.url_scheme": "http",
  "rack.hijack?": true,
  "rack.hijack": "#&lt;Proc:0x007fcac6208b70@/home/n25/.gem/ruby/2.2.2/gems/rack-1.6.4/lib/rack/lint.rb:525&gt;",
  "rack.hijack_io": null,
  "HTTP_VERSION": "HTTP/1.1",
  "REQUEST_PATH": "/",
  "rack.tempfiles": [</rack::lint::errorwrapper:0x007fcac6208698></rack::lint::inputwrapper:0x007fcac62086c0></p>

<p>]
}
```</p>

<p>C’est uniquement à partir de cette variable <code>env</code> que notre application devra formuler une réponse Rack !</p>

<h2 id="de-rack-au-frameworks-web">De Rack au frameworks Web</h2>

<p>Dans cette partie, essayons de trouver des solutions a de petits problèmes.
Bien sûr on n’utilisera que Rack.</p>

<p>Comme support nous nous mettrons dans le cas d’un réseau social très simplifié.</p>

<h3 id="le-routage">Le routage</h3>

<p>Chaque membre de notre réseau social va avoir une page qui lui est propre.
Pour y accéder nous utilisons le chemin suivant : <code>/members/&lt;id&gt;</code> où <code>&lt;id&gt;</code> sera <em>l’identifiant du membre</em>.</p>

<p>Avec Rack nous pouvons écrire le code suivant pour parvenir à isoler l’identifiant du membre :</p>

<p><code>ruby
def member(env)
  env["PATH_INFO"] =~ %r{\A/members/([A-Za-z0-9]+)\z} &amp;&amp; $1
end
</code></p>

<p>Cette méthode va nous permettre d’obtenir l’identifiant du membre en fonction de l’environement Rack.
On peut introduire ce code dans notre application :</p>

<p><code>ruby
app = Proc.new do |env|
  member_id = member(env)
  [
    200,
    { "Content-Type" =&gt; "text/html" },
    [ "&lt;h1&gt;Hello #{member_id}&lt;/h1&gt;" ]
  ]
end
</code></p>

<p>Ici on a extrait un paramètre de l’URL. Si on visite <code>/members/Nicolas</code> on verra le texte <em>Hello Nicolas</em> s’afficher.
Par contre, si on visite <code>/signup</code>, on verra <em>Hello</em> s’afficher seul puisque <code>member_id</code> sera égal à <code>nil</code>.</p>

<p>En pratique, notre réseau social va avoir besoin d’identifier des dixaines voir des centaines d’URLs différentes.
Avec ce volume, il est nécessaire de s’organiser autrement et d’associer les URLs gérée par notre application avec
le code responsable de répondre à la requête. Dans le cas ou une URL n’est pas gérée, on souhaite répondre par un code
d’erreur.</p>

<p>Voici un extrait de code permettant de répondre à cette problématique :</p>

<p>``` ruby
class ShowMember
  def self.match?(env)
    env[“PATH_INFO”] =~ %r{\A/members/[A-Za-z0-9]+\z}
  end</p>

<p>def self.call(env)
    member_id = env[“PATH_INFO”].sub(“/members/”, “”)
    headers = { “Content-Type” =&gt; “text/html” }
    body = “&lt;h1&gt;Hello #{member_id}&lt;/h1&gt;”
    [ 200, headers, [ body ] ]
  end
end</p>

<p>actions = [ ShowMember ]</p>

<p>app = Proc.new do |env|
  action = actions.find { |action| action.match?(env) }
  action ? action.call(env) : [ 404, {}, [ “Not Found” ] ]
end
```</p>

<p>On voit que j’ai implicitement définit une interface : <code>#match?(env)</code> et <code>call(env)</code> pour les actions que
l’application peut réaliser. Chaque action est responsable de formuler une réponse Rack lors d’un appel à la
méthode <code>call</code> et de savoir, via <code>match?</code>, si oui ou non elle doit s’executer.</p>

<p>L’ensemble des frameworks web font un traitement semblable en utilisant une solution que l’on appelle le routage.
Différentes approches concernant le routage existent, voir <a href="http://roda.jeremyevans.net/">Roda</a>, <a href="http://www.sinatrarb.com/">Sinatra</a> et <a href="http://guides.rubyonrails.org/routing.html">Rails</a>.</p>

<p>Voici par exemple un extrait de code qui utilise Sinatra pour faire exactement ce que nous avons fait :</p>

<p>``` ruby
require “sinatra”</p>

<p>get “/members/:member_id” do
  member_id = params[“member_id”]
  “&lt;h1&gt;Hello #{member_id}&lt;/h1&gt;”
end
```</p>

<p><em>Remarque</em> :On voit dans cet exemple que Sinatra permet d’extraire les paramètres de l’URL automatiquement.</p>

<h3 id="les-templates">Les templates</h3>

<p>Lorsque l’on développe une fonctionnalité d’un site web, il est fréquent de le faire en deux phases.
Une phase de design où l’on va écrire HTML et CSS afin de visualiser le résultat voulu. Une autre phase
où l’on écrira le code métier qui va injecter les bonnes valeurs dans le HTML en fonction de l’action
effectuée.</p>

<p>Par exemple dans notre code : <code>"&lt;h1&gt;Hello #{member_id}&lt;/h1&gt;"</code> on injecte la variable <code>member_id</code> dans
du HTML. De manière générale, le HTML est beaucoup plus volumineux que dans notre exemple.</p>

<p>Dans la vie de tout les jours, il est fréquent qu’une équipe soit en charge de la phase plus visuelle
(HTML / CSS) et une autre en charge du code métier. Il est donc fréquent de séparer ces deux composantes
de notre code.</p>

<p>Pour effectuer cette séparation, on a recours à des <em>moteurs de templates</em>. Ces briques logicielles vont
nous permettre de séparer notre présentation du code métier. Voici un exemple, toujours en utilisant
Rack :</p>

<p>``` ruby
require “erb”
require “ostruct”</p>

<p>module Template
  def erb(template_path, locals={})
    file_content = File.read(template_path)
    context = OpenStruct.new(locals).instance_eval { binding }
    ERB.new(file_content).result(context)
  end
end</p>

<p>class ShowMember
  extend Templating</p>

<p>def self.call(env)
    member_id = env[“PATH_INFO”].sub(“/members/”, “”)
    headers = { “Content-Type” =&gt; “text/html” }
    body = Template.erb(“template.html.erb”, member_id: member_id)
    [ 200, headers, [ body ] ]
  end
end
```</p>

<p>``` erb</p>
<h1>Hello &lt;%= member_id %&gt;</h1>
<p>```</p>

<p>Ici, on va utiliser <code>ERB</code> pour charger le fichier <code>template.html.erb</code>. Au sein de ce fichier,
la variable <code>member_id</code> sera injectée dans le HTML grâce à la notation <code>&lt;%= ... %&gt;</code>.</p>

<p>Les moteurs de templates sont nombreux : <a href="http://ruby-doc.org/stdlib-2.2.2/libdoc/erb/rdoc/ERB.html">erb</a>, <a href="http://haml.info/">haml</a>, <a href="http://slim-lang.com/">slim</a>, <a href="https://github.com/jimweirich/builder">builder</a>,
<a href="http://www.liquidmarkup.org/">liquid</a> etc. Leur usage va plus loin que la simple séparation du code de présentation et
du code métier (voir les <a href="http://guides.rubyonrails.org/layouts_and_rendering.html#using-partials">partials</a>, <a href="http://www.rubydoc.info/gems/slim/frames#Control_code_-">stuctures de controle</a>…).</p>

<h3 id="tester-son-application">Tester son application</h3>

<p>Avant de continuer je vais déplacer le code de l’application du fichier <code>config.ru</code> vers <code>app.rb</code>.
Au passage, j’en profite pour extraire une classe <code>Router</code> ainsi qu’une constante <code>App</code> qui contiendra
notre application.</p>

<p>Les tests sont indispensables lors du développement d’une application. Tester une application Rack est
assez aisé grâce aux outils inclus dans la gem <code>rack-test</code>. Voici un exemple d’un fichier de test écrit
avec minitest :</p>

<p>``` ruby
# ./app_test.rb</p>

<p>require “minitest/autorun”
require “rack/test”</p>

<p>require_relative “app”</p>

<p>describe App do
  include Rack::Test::Methods</p>

<p>describe “when the URL match no known action” do
    it “returns a 404 status code” do
      get “/unknown/path”
      last_response.status.must_equal 404
    end
  end</p>

<p>describe “when the URL match the members’s path” do
    it “displays the member’s id” do
      get “/members/Nicolas”
      last_response.body.must_include “Nicolas”
    end
  end</p>

<p>def app
    App
  end
end
```</p>

<p>Pour lancer les tests, la commande : <code>bundle exec ruby -Ilib:test *_test.rb --pride</code> suffit.</p>

<p>Le frameworks web tels que Rails instaurent des conventions et des outils par défaut pour le test
de ses applications. Les outils de tests fonctionnent également hors des frameworks comme le montre
notre exemple.</p>

<h2 id="pour-finir">Pour finir</h2>

<p>En continuant sur cette lancée, on peut rencontrer d’autres problématiques comme les sessions, la persistance,
l’organisation du coe métier, le caching et bien d’autres. Il est très facile, avec un peu de recul, de créer
son propre framework ou d’utiliser un micro-framework puis d’y ajouter ses propres conventions ainsi que les
outils de son choix.</p>

<p>Même si ce billet s’adresse principalement aux débutants, j’espère qu’il touchera également quelques
enseignants ou mentors. Peu importe votre profil, n’hésitez pas à partager vos premiers pas avec le
développement web en Ruby ainsi que la manière dont vous l’aborderiez aujourd’hui.</p>

<h1 id="qui-a-crit-cet-article-">Qui a écrit cet article ?</h1>

<p><img src="https://secure.gravatar.com/avatar/510312aa405bc675fc275fad7648eb1c?s=200"></p>

<p><strong>Nicolas Zermati</strong><br />
Software writer, building the backend of Sleekapp.io at Tigerlily</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Exemple de test pour Vim avec le framework Vader]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/03/29/exemple-de-test-pour-vim-avec-le-framework-vader/"/>
    <updated>2014-03-29T21:10:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/03/29/exemple-de-test-pour-vim-avec-le-framework-vader</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Pour mon plugin <a href="https://github.com/lkdjiin/quickmarkdown">QuickMarkdown</a>, je vais ajouter une petite fonction
qui insère la ligne <code>&lt;!-- more --&gt;</code> quand je tape la combinaison de
touche <code>&lt;Leader&gt;qm</code>. Ça devrait m’être utile vu que j’écris du markdown
pour Octopress tous les jours ;) Si on est pas obligé de passer par un
plugin pour ce genre de chose, ça va aussi me permettre de parler un peu
de Vader. Voici donc un exemple simple de TDD pour
Vim, avec le framework de test Vader.</p>

<!-- more -->

<p>Tout d’abord, j’écris le test:</p>

<p>``` raw test/more.vader
Given (some text):
  First line
  Last line</p>

<p>Do (insert more marker in normal mode):
  gg
  :QuickMarkdownMore&lt;Enter&gt;</p>

<p>Expect (marker inserted):
  First line
  <!-- more -->
  Last line
```</p>

<p>Voici comment il fonctionne. La directive <code>Given</code> produit un buffer (=~ fichier)
utilisé dans les directives suivante, qui contient 2 lignes, respectivement
<code>First line</code> et <code>Last line</code>:</p>

<p><code>raw
Given (some text):
  First line
  Last line
</code></p>

<p>Ensuite, la directive <code>Do</code> joue des commandes en mode normal. Tout d’abord
<code>gg</code>, pour s’assurer qu’on est sur la première ligne, puis la commande
<code>QuickMarkdownMore</code>, qui est celle qui est censée faire le travail:</p>

<p><code>raw
Do (insert more marker in normal mode):
  gg
  :QuickMarkdownMore\&lt;Enter&gt;
</code></p>

<p>Finalement, la directive <code>Expect</code> s’assure que le buffer de test a été
transformé comme je le voulais:</p>

<p><code>raw
Expect (marker inserted):
  First line
  &lt;!-- more --&gt;
  Last line
</code></p>

<p>Il reste à lancer le test (avec <code>:Vader</code>) pour s’assurer qu’il ne passe
pas, puis à écrire la fonction, et relancer le test en s’assurant qu’il
passe bien cette fois-ci.</p>

<p>Et voici pour finir le code d’implémentation:</p>

<p><code>vim plugin/markdown.vim
command! QuickMarkdownMore call quickmarkdown#more()
</code></p>

<p><code>vim autoload/markdown.vim
function! quickmarkdown#more()
  call append('.', "&lt;!-- more --&gt;")
endfunction
</code></p>

<script id="fb33k8u">(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>

<p>À demain.</p>

<p></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vader, un framework de test pour Vim]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/03/16/vader-un-framework-de-test-pour-vim/"/>
    <updated>2014-03-16T20:52:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/03/16/vader-un-framework-de-test-pour-vim</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/junegunn/vader.vim">Vader</a> est un framework de test pour Vim, écrit en VimScript. Sa syntaxe très simple
fait penser un peu à un mélange de Cucumber et de Python. Il est vraiment sympa
à utiliser.</p>

<!-- more -->

<p>Voici à quoi ressemble un test simple avec Vader:</p>

<pre><code>Given (A line of text):
  Make a title of this

Execute (To level 1 title):
  QuickMarkdownTitle1

Expect (to be a level 1 title):
  Make a title of this
  ====================
</code></pre>

<p>Le bloc <code>Given</code> permet de remplir un buffer de test avec des données.</p>

<p>Le bloc <code>Execute</code> lance des fonctions Vim.</p>

<p>Le bloc <code>Expect</code> vérifie que le buffer de test est bien celui attendu
après le passage du bloc <code>Execute</code>.</p>

<p>Il existe aussi un bloc <code>Do</code>, qui simule le mode normal:</p>

<pre><code>Given (Some text):
  Make a title of this
  and not of this one

Do (To title 1):
  gg
  :QuickMarkdownTitle1\&lt;Enter&gt;

Expect (to be a level 1 title):
  Make a title of this
  ====================
  and not of this one
</code></pre>

<p>On lance Vader simplement avec:</p>

<p><code>vim
:Vader
</code></p>

<p>et le framework ouvre un nouveau buffer avec toutes les informations
nécessaires:</p>

<pre><code>Starting Vader: 1 suite(s), 6 case(s)
  Starting Vader: /home/xavier/devel/vim/quickmarkdown/test/titles.vader
    (1/6) [  GIVEN] A line of text
    (1/6) [EXECUTE] To level 1 title
    (1/6) [ EXPECT] to be a level 1 title
    (2/6) [  GIVEN] A line of text
    (2/6) [EXECUTE] To level 2 title
    (2/6) [ EXPECT] to be a level 2 title
    (3/6) [  GIVEN] A line of text
    (3/6) [EXECUTE] To level 3 title
    (3/6) [ EXPECT] to be a level 3 title
    (4/6) [  GIVEN] Some text
    (4/6) [     DO] To title 1
    (4/6) [ EXPECT] to be a level 1 title
    (5/6) [  GIVEN] Some text
    (5/6) [     DO] To title 2
    (5/6) [ EXPECT] to be a level 2 title
    (6/6) [  GIVEN] Some text
    (6/6) [     DO] To title 3
    (6/6) [ EXPECT] to be a level 3 title
  Success/Total: 6/6
Success/Total: 6/6 (assertions: 0/0)
Elapsed time: 0.419884 sec.
</code></pre>

<p>Vader est «livré» avec coloration syntaxique, ftplugin, plusieurs exemples
d’utilisations. Il peut aussi faire des hooks <code>before</code> et <code>after</code>, inclure des
fichiers et d’autres choses encore…</p>

<p>Une très bonne découverte, très agréable à utiliser.</p>

<script id="fb33k8u">(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>

<p>À demain.</p>

<p></p>

]]></content>
  </entry>
  
</feed>
