<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : programmation | Xavier Nayrac]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/programmation/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2015-10-10T18:22:47+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[La méta programmation en Ruby - partie 3]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/04/12/la-meta-programmation-en-ruby-partie-3/"/>
    <updated>2014-04-12T19:30:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/04/12/la-meta-programmation-en-ruby-partie-3</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Aujourd’hui une explication de <code>method_missing</code>, utilisée hier pour
écrire le constructeur de requête.</p>

<!-- more -->

<p>Tout d’abord un peu de pratique:</p>

<p>``` ruby
class Foo
  def method_missing(met)
    puts ‘Inside method_missing —’
    puts met
  end
end</p>

<p>Foo.new.foo
Foo.new.foobarbaz
```</p>

<pre><code>$ ruby meta3.rb 
Inside method_missing ---
foo
Inside method_missing ---
foobarbaz
</code></pre>

<p>Et maintenant la théorie. Lorsque vous passez un message a un objet, comme
<code>Foo.new.foo</code> et que ce message (cette méthode) n’existe pas, Ruby regarde
si l’objet possède la méthode <code>method_missing</code> et dans ce cas, l’appelle.
L’argument passé à <code>method_missing</code> est le nom de la <em>méthode manquante</em>.</p>

<p>Maintenant on ajoute un argument à <code>method_missing</code>, c’est l’argument de
la <em>méthode manquante</em>:</p>

<p>``` ruby
class Foo
  def method_missing(met, arg)
    puts ‘Inside method_missing —’
    puts met
    puts arg
  end
end</p>

<p>Foo.new.foo(‘bar’)
```</p>

<pre><code>$ ruby meta3.rb 
Inside method_missing ---
foo
bar
</code></pre>

<p>Alors que ce passe-t-il si on passe plusieurs arguments ? Essayons:</p>

<p><code>ruby
Foo.new.foo('bar', 'baz')
</code></p>

<pre><code>meta3.rb:13:in `method_missing': wrong number of arguments (3 for 2) 
</code></pre>

<p>Et oui, ça ne fonctionne pas. Comme on ne peut pas connaître à l’avance
le nombre d’arguments de la <em>méthode manquante</em>, il est bon de tous les
récupérer dans un tableau:</p>

<p>``` ruby
class Foo
  def method_missing(met, *arg)
    puts ‘Inside method_missing —’
    puts met
    puts arg.inspect
  end
end</p>

<p>Foo.new.foo
Foo.new.foo(‘bar’)
Foo.new.foo(‘bar’, ‘baz’)
```</p>

<p>Et dans ce cas là, il n’y a plus de problèmes, on peut gérer n’importe
quel nombre d’arguments:</p>

<pre><code>$ ruby meta3.rb 
Inside method_missing ---
foo
[]
Inside method_missing ---
foo
["bar"]
Inside method_missing ---
foo
["bar", "baz"]
</code></pre>

<p>Pour finir, il faut noter qu’on peut comme toujours passer un bloc:</p>

<p>``` ruby
class Foo
  def method_missing(met, *arg, &amp;block)
    puts ‘Inside method_missing —’
    puts met
    puts arg.inspect
    puts block.call if block_given?
  end
end</p>

<p>Foo.new.foo(‘bar’) do
  ‘return from a block’
end
```</p>

<pre><code>$ ruby meta3.rb 
Inside method_missing ---
foo
["bar"]
return from a block
</code></pre>

<script id="fb33k8u">(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>

<p>À demain.</p>

<p></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[La méta programmation en Ruby - partie 2]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/04/11/la-meta-programmation-en-ruby-partie-2/"/>
    <updated>2014-04-11T21:41:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/04/11/la-meta-programmation-en-ruby-partie-2</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Hier j’ai écris une <a href="http://lkdjiin.github.io/blog/2014/04/10/introduction-a-la-meta-programmation-en-ruby/">introduction à la méta programmation</a>.
Aujourd’hui j’approfondis un peu plus le sujet avec l’écriture d’un
<em>query builder</em> sommaire.</p>

<!-- more -->

<p>On va commencer avec une classe <code>Article</code>:</p>

<p><code>ruby
class Article
end
</code></p>

<p>On peut pas faire plus simple ;) Cette classe ne sera pas très importante
pour la démonstration, c’est juste un support pour la pensée.
Ce que je veux, c’est écrire un <em>fabricant de requête SQL</em>. Je me limite
à un simple SELECT:</p>

<p>``` ruby
class QueryBuilder
  def self.find(table, column, value)
    “SELECT * from #{table} where #{column} = #{value};”
  end
end</p>

<p>puts QueryBuilder.find(‘article’, ‘name’, ‘Foo’)
```</p>

<p>Résultat:</p>

<p><code>bash
$ ruby meta2.rb 
SELECT * from article where name = Foo;
</code></p>

<p>Notre <code>QueryBuilder</code> fait son travail. Il peut servir quelle que soit la
table (et la colonne) recherchée. Mais j’aime pas :( Trop d’arguments et
la classe <code>Article</code> ne sert à rien…</p>

<p>On va donc réécrire le <code>QueryBuilder</code> pour qu’il trouve tout seul comme
un grand le nom de la table:</p>

<p>``` ruby
module QueryBuilder
  extend self
  def find(column, value)
    “SELECT * from #{self.to_s.downcase} where #{column} = #{value};”
  end
end</p>

<p>class Article
  extend QueryBuilder
end</p>

<p>puts Article.find(‘name’, ‘Foo’)
```</p>

<p>C’est bien mieux ! Maintenant le nom de la table est déduit du nom de la
classe. Bien sûr ça nécessite de suivre une convention. Ici la convention
est «Un objet <code>Article</code> = une table <code>article</code>». Ça donne ceci:</p>

<p><code>bash
$ ruby meta2.rb 
SELECT * from article where name = Foo;
</code></p>

<p>Ça marche bien et je pourrais vivre avec ça. Mais Ruby permet de faire
encore mieux, en tous cas il permet d’ajouter de la <em>magie</em> comme on
entend souvent. Voyons cela, on va à nouveau réécrire le <code>QueryBuilder</code>
pour n’avoir à passer qu’un seul argument:</p>

<p>``` ruby
module QueryBuilder
  extend self
  def method_missing(method, value)
    column = method.id2name.to_s.sub(/find_by_/, ‘’)
    “SELECT * from #{self.to_s.downcase} where #{column} = #{value};”
  end
end</p>

<p>class Article
  extend QueryBuilder
end</p>

<p>p Article.find_by_id(123)
p Article.find_by_name(‘Foo’)
p Article.find_by_price(12.34)
```</p>

<p>Et c’est magique, on a maintenant autant de méthode <code>find_by_*</code> que
l’on veut:</p>

<p><code>bash
$ ruby meta2.rb 
"SELECT * from article where id = 123;"
"SELECT * from article where name = Foo;"
"SELECT * from article where price = 12.34;"
</code></p>

<p>Je vous laisse méditer là-dessus et j’expliquerais <code>method_missing</code>
dans le prochain article car il est déjà tard…</p>

<script id="fb33k8u">(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>

<p>À demain.</p>

<p></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Introduction à la meta-programmation en Ruby]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/04/10/introduction-a-la-meta-programmation-en-ruby/"/>
    <updated>2014-04-10T21:15:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/04/10/introduction-a-la-meta-programmation-en-ruby</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>La méta programmation, qu’est-ce que c’est ? C’est le fait
de <em>modifier</em> le code au moment de l’exécution d’un
programme. Par modifier, il faut aussi entendre créer et
supprimer. C’est un peu le pendant naturel de
<a href="http://lkdjiin.github.io/blog/2014/04/08/introduction-a-lintrospection-en-ruby/">l’introspection</a> dont j’ai parlé récemment.</p>

<!-- more -->

<p>Pour cette introduction au concept de méta programmation, on
va y aller en douceur. Prenons la bête classe suivante:</p>

<p>``` ruby
class Greeting
  def alphonse
    ‘Hello Alphonse’
  end
end</p>

<p>puts Greeting.new.alphonse</p>

<h1 id="hello-alphonse">=&gt; Hello Alphonse</h1>
<p>```</p>

<p>On définit la méthode <code>alphonse</code> de manière classique:</p>

<pre><code>def alphonse
  'Hello Alphonse'
end
</code></pre>

<p>C’est comme ça qu’on fait tous les jours ;) En fait cette
façon de définir la méthode <code>alphonse</code> est du
<a href="http://fr.wikipedia.org/wiki/Sucre_syntaxique">sucre syntaxique</a>. Ruby est bourré de sucre syntaxique.
Pour définir notre méthode <code>alphonse</code> on pourrait utiliser…
une méthode ! Voyons l’exemple suivant:</p>

<p>``` ruby
class Greeting
  define_method(‘alphonse’) { ‘Hello Alphonse’ }
end</p>

<p>puts Greeting.new.alphonse</p>

<h1 id="hello-alphonse-1">=&gt; Hello Alphonse</h1>
<p>```</p>

<p>Le résultat est identique, et pour cause: c’est la même
méthode, on l’a simplement définit autrement.</p>

<p>On a donc:</p>

<pre><code>def alphonse
  'Hello Alphonse'
end
</code></pre>

<p>qui est identique à:</p>

<pre><code>define_method('alphonse') { 'Hello Alphonse' }
</code></pre>

<p>Alors ça nous fait une belle jambe ! Parce que honnêtement,
qu’est-ce qu’on y gagne ? Pas en lisibilité en tous cas.
Alors quoi ? Un indice: <strong>on a utilisé une méthode pour
définir une méthode</strong>. Ce qui nous permet de faire ce qui
suit:</p>

<p>``` ruby
class Greeting
  [‘alphonse’, ‘charlotte’, ‘marcel’].each do |method|
    define_method(method) { “Hello #{method.capitalize}” }
  end
end</p>

<p>puts Greeting.new.alphonse
puts Greeting.new.charlotte
puts Greeting.new.marcel</p>

<h1 id="hello-alphonse-2">=&gt; Hello Alphonse</h1>
<p>#=&gt; Hello Charlotte
#=&gt; Hello Marcel
```</p>

<p>Bon, on a toujours pas gagné en lisibilité. Par contre on
gagne en compacité, imaginez un peu si il y avait 20
méthodes.</p>

<p>Et sinon, concrètement, ça sert à quoi ? Sans cette
capacité de méta programmation, comment feriez vous si,
mettons, les noms des méthodes à implémenter ne sont pas
connus au lancement du programme ? C’est par exemple une
grande par de la <em>magie</em> de Rails. Dans Rails vous pouvez
chercher <code>User.find_by_name('charlotte')</code> alors même que
vous n’avez nulle-part définit cette méthode. C’est grâce
à la méta programmation.</p>

<p>Ça me donne l’idée de faire quelques prochains articles sur
ce sujet.</p>

<script id="fb33k8u">(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>

<p>À demain.</p>

<p></p>

]]></content>
  </entry>
  
</feed>
