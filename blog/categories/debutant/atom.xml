<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : débutant | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/debutant/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2013-11-05T16:22:49+01:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Racket pour les Rubyists: Définir une fonction]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/11/03/racket-pour-les-rubyists-definir-une-fonction/"/>
    <updated>2013-11-03T15:06:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/11/03/racket-pour-les-rubyists-definir-une-fonction</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Racket est un langage dérivé de Scheme que je suis en train d'apprendre.
Je vais m'inspirer de ma série d'articles
<a href="http://lkdjiin.github.io/blog/2013/10/21/apprendre-ruby-en-faisant-des-maths/">Apprendre Ruby en faisant des maths</a>
pour expliquer les bases de Racket en le comparant à Ruby. Si vous
connaissez un peu Ruby, j'espère que vous n'aurez aucun mal à suivre
ces articles. On commence aujourd'hui avec la définition d'une fonction.</p>

<!-- more -->


<p>J'utiliserais la version 5.3.6 de Racket et la version 2.0 de Ruby.
Au début, on va utiliser le REPL, pour Ruby on a <code>irb</code>, pour Racket on
a <code>racket</code>.</p>

<h2>Définir une fonction</h2>

<p>Racket a des fonctions et Ruby a des méthodes, mais ça ne fait aucune
différence pour l'instant. Voyons comment définir une fonction <code>addition</code>,
qui va calculer et renvoyer la somme de deux arguments, <code>a</code> et <code>b</code>:</p>

<pre><code>[~]⇒ racket
-&gt; (define (addition a b)
     (+ a b))
-&gt; (addition 12 34)
46
</code></pre>

<p>Comparons immédiatement avec la version Ruby:</p>

<pre><code>[~]⇒ irb
&gt;&gt; def addition(a, b)
&gt;&gt;   a + b
&gt;&gt; end
nil
&gt;&gt; addition 12, 34
46
</code></pre>

<p>Première remarque: avec Racket les parenthèses sont <strong>très importantes</strong>.
On est obligé de les utilisées, et de les utilisées correctement.</p>

<p>Deuxième remarque: Ruby utilise la notation <em>infix</em> (<code>a + b</code>) alors que
Racket utilise la notation <em>prefix</em> (<code>+ a b</code>). Étrange au début si vous
n'avez jamais utilisé ce genre de truc, on s'y fait très vite.</p>

<p>Troisième remarque: avec Racket les arguments ne sont pas séparés par des
virgules.</p>

<p>Enfin, Ruby utilise des mots clés (<code>def</code> et <code>end</code>) pour délimiter un
bloc/ensemble d'instructions alors que Racket utilise simplement les
parenthèses.</p>

<p><strong>Exercice</strong>: Sur le même modèle que la fonction <code>addition</code>, définissez et
utilsez les fonctions <code>soustraction</code> et <code>multiplication</code>. Voici les solutions:</p>

<p>``` racket
(define (soustraction a b)
  (&ndash; a b))</p>

<p>(soustraction 17 7)</p>

<p>(define (multiplication a b)
  (* a b))</p>

<p>(multiplication 2 3)
```</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vim: Coloration syntaxique des parenthèses]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/11/02/vim-coloration-syntaxique-des-parentheses/"/>
    <updated>2013-11-02T12:04:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/11/02/vim-coloration-syntaxique-des-parentheses</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Je l'ai annoncé sur ce blog, je suis en train d'apprendre Racket (dérivé de
Scheme, de Lisp). Donc un langage qui fait un très large usage des
parenthèses.</p>

<p><img src="/images/rainbow-parentheses.png"></p>

<!-- more -->


<p>C'est là que le plugin <a href="http://www.vim.org/scripts/script.php?script_id=3772">Rainbow Parentheses</a> peut aider.
Il colore les parenthèses différement suivant le niveau d'imbrication.
Il n'est pas activé par défaut, et c'est tant mieux: ce type de coloration
syntaxique n'est pas utile tout le temps, mais seulement à certains moments,
quand on se sent un peu perdu
(<em>sinon, bonjour l'effet sapin de Noël</em>). Pour l'activer/le désactiver, il suffit de
taper:</p>

<p><code>vim
:RainbowParenthesesToggle
</code></p>

<p>Si vous l'utilsez régulièrement, il sera sûrement utile de mapper la fonction
précédente. Par exemple pour l'avoir en tapant la touche <code>leader</code> puis <code>p</code>,
vous ajouterez ceci dans votre .vimrc:</p>

<p><code>vim
map &lt;Leader&gt;p :RainbowParenthesesToggle&lt;Enter&gt;
</code></p>

<p>Le plugin Rainbow Parentheses peut aussi colorer d'autres paires de caractères,
comme <code>[]</code>, <code>{}</code> et <code>&lt;&gt;</code>. Consultez le readme pour en savoir plus.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Apprendre Ruby en faisant des maths 6: méthodes utilitaires et module]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/11/01/apprendre-ruby-en-faisant-des-maths-6-methodes-utilitaires-et-module/"/>
    <updated>2013-11-01T21:54:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/11/01/apprendre-ruby-en-faisant-des-maths-6-methodes-utilitaires-et-module</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Dans les articles précédents, nous avons définis trois méthodes:
<code>divisors</code>, <code>proper_divisors</code> et <code>sum_of_proper_divisors</code>.
Ces trois méthodes commencent à former ce qu'on appelle une
collection, ou un ensemble, de méthodes utilitaires. Nous allons
aujourd'hui les regrouper dans un module.</p>

<!-- more -->


<p>Pour l'instant nous n'avons que trois méthodes, et elles portent toutes
sur les nombres. Mais nous allons bientôt en ajouter d'autres, peut-être
beaucoup d'autres. Certaines porteront peut-être sur la géométrie ou les
probabilités ? Il est plus propre de regrouper entre elles les méthodes
qui traitent du même sujet, alors pourquoi attendre ?</p>

<p>Voici comment on peut regrouper nos méthodes au sein du module <code>Number</code>:</p>

<p>``` ruby number.rb
module Number
  def self.divisors(n)</p>

<pre><code>(1..n).select {|i| n % i == 0 }
</code></pre>

<p>  end</p>

<p>  def self.proper_divisors(n)</p>

<pre><code>divisors(n)[0..-2]
</code></pre>

<p>  end</p>

<p>  def self.sum_of_proper_divisors(n)</p>

<pre><code>proper_divisors(n).reduce(:+)
</code></pre>

<p>  end
end
```</p>

<p>Vous voyez que les méthodes sont insérées à l'intérieur de:</p>

<p><code>ruby
module Number
end
</code></p>

<p>Vous voyez aussi qu'on a ajouté <code>self.</code> devant le nom de chaque méthode.
Cela indique à Ruby qu'on veut utiliser ces méthodes sans pour autant
avoir à créer un objet (<em>si vous ne savez pas encore ce qu'est un objet,
ne vous inquiétez pas, nous n'en avons pas besoin pour l'instant</em>).</p>

<p>Voici une seconde manière de regrouper nos méthodes au sein du module <code>Number</code>:</p>

<p>``` ruby number.rb
module Number
  class &lt;&lt; self</p>

<pre><code>def divisors(n)
  (1..n).select {|i| n % i == 0 }
end

def proper_divisors(n)
  divisors(n)[0..-2]
end

def sum_of_proper_divisors(n)
  proper_divisors(n).reduce(:+)
end
</code></pre>

<p>  end
end
```</p>

<p>Cette deuxième syntaxe, qui peut sembler un peu bizarre si vous la
rencontrez pour la première fois, fait exactement la même chose que
la première syntaxe. Avec Ruby, il y a souvent plusieurs façons de dire
une même chose.
Je ne vais pas expliquer cette syntaxe aujourd'hui, mais sachez qu'elle
est très prisée dans la communauté Ruby et que vous la rencontrerez
souvent. Vous pouvez choisir celle que vous voulez.</p>

<p>Notez que, <strong>par convention</strong>, le module Number doit être enregistré
dans le fichier <code>number.rb</code>. Il n'y a pas d'obligation, mais avouez
que ça facilite grandement les choses.</p>

<h2>Comment utiliser un module ?</h2>

<p><strong>Première solution</strong>, vous pouvez écrire votre code à la suite du module:</p>

<p>``` ruby number.rb
module Number
  class &lt;&lt; self</p>

<pre><code>def divisors(n)
  (1..n).select {|i| n % i == 0 }
end

def proper_divisors(n)
  divisors(n)[0..-2]
end

def sum_of_proper_divisors(n)
  proper_divisors(n).reduce(:+)
end
</code></pre>

<p>  end
end</p>

<p>puts Number.sum_of_proper_divisors 8
```</p>

<p>Puis vous lancez le programme:</p>

<pre><code>[~/]⇒ ruby number.rb 
7
</code></pre>

<p><strong>Deuxième solution</strong>, vous lancez irb, <em>dans le même dossier</em> que le fichier
<code>number.rb</code> et vous chargez le module:</p>

<pre><code>[~/]⇒ irb
&gt;&gt; require "./number"
true
&gt;&gt; Number.sum_of_proper_divisors 8
7
</code></pre>

<p><strong>Troisième solution</strong>, vous écrivez un programme dans un fichier séparé, par
exemple <code>test.rb</code>, <em>dans le même dossier</em> que le fichier
<code>number.rb</code>:</p>

<p>``` ruby test.rb
require &ldquo;./number&rdquo;</p>

<p>puts Number.sum_of_proper_divisors 8
```</p>

<p>Puis vous le lancez:</p>

<pre><code>[~/]⇒ ruby test.rb
7
</code></pre>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Installer Scheme]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/10/31/installer-scheme/"/>
    <updated>2013-10-31T18:50:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/10/31/installer-scheme</id>
    <content type="html"><![CDATA[<p>Avant d'apprendre Scheme, il faut l'installer. Avant de l'installer, il
faut choisir une implémentation: interpréteur ou compilateur ? Les deux ?
Quel OS ? Quel(s) dialecte(s) ? Le site
<a href="http://community.schemewiki.org/?scheme-faq-standards#implementations">community.schemewiki.org</a>
recense 75 implémentations ! Oui, j'ai compté.</p>

<!-- more -->


<p>Après prises de conseils et réflexion, j'ai décidé d'essayer trois
implémentations:
<a href="http://www.gnu.org/software/guile/">Guile</a>,
<a href="http://www.call-cc.org/">Chicken</a>
et <a href="http://racket-lang.org/">Racket</a>.
<strong>Guile</strong> parce qu'il est déjà installé sur ma machine.
<strong>Chicken</strong> pour son compilateur vers
le langage C. <strong>Racket</strong> pour ses nombreux DSL, parce qu'il a l'air très cool
pour créer de nouveaux DSL et parce qu'il semble être le plus utilisé.</p>

<h2>Guile</h2>

<p>Guile semble être déjà installé sur la plupart des Linux. En tout cas, il
l'était sur ma machine…
Le REPL n'utilise pas readline par défaut, ce qui est d'ailleurs le cas
des 3 implementations que j'ai testé.
Pour activer readline, il faut créer un fichier <code>.guile</code> dans le <code>home</code> et y mettre:</p>

<p><code>scheme .guile
(use-modules (ice-9 readline))
(activate-readline)
</code></p>

<h2>Chicken</h2>

<p>J'ai installé Chicken grâce aux paquets Debian, rien à dire… Pour activer
readline dans le REPL, il faut d'abord installer une bibliothèque (un <em>egg</em>
dans le jargon Chicken):</p>

<pre><code>sudo chicken-install readline
</code></pre>

<p>Ensuite on crée un fichier <code>~/.csirc</code> avec le contenu suivant:</p>

<p><code>scheme .csirc
(use readline)
(current-input-port (make-gnu-readline-port))
(gnu-history-install-file-manager
 (string-append (or (get-environment-variable "HOME") ".") "/.csi.history"))
</code></p>

<p>Enfin on crée le fichier d'historique:</p>

<pre><code>touch ~/.csi.history
</code></pre>

<h2>Racket</h2>

<p>Je voulais la toute dernière version, j'ai donc téléchargé les sources et
lancé une compilation. Tout a très bien fonctionné, le fichier <code>README</code> est
parfaitement clair. Pour activer readline dans le REPL de Racket, il faut
cette fois créé un fichier <code>~/.racketrc</code> avec le texte suivant:</p>

<p><code>scheme .racketrc
(require xrepl)
</code></p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Apprendre Ruby en faisant des maths 5]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/10/30/apprendre-ruby-en-faisant-des-maths-5/"/>
    <updated>2013-10-30T19:15:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/10/30/apprendre-ruby-en-faisant-des-maths-5</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Jusqu'ici on a écrit une méthode qui calcule les diviseurs d'un nombre et
une seconde méthode qui calcule les diviseurs stricts.
Notre objectif étant de lister les nombres amiables jusqu'à 10 000, il nous
faut maintenant obtenir la <em>somme</em> des diviseurs stricts d'un nombre.</p>

<!-- more -->


<p>Il nous faut donc calculer la somme des nombres qui composent une liste.
Allons y, prenons une liste et plaçons la dans une variable nommée <code>x</code>:</p>

<p>``` irb</p>

<blockquote><blockquote><p>x = [1,2,4]
=> [1, 2, 4]
```</p></blockquote></blockquote>

<p>Nous avons déjà vu la méthode <code>select</code>, qui sélectionne certains éléments
d'une liste ; nous allons voir maintenant la méthode <code>reduce</code>, qui va <em>réduire</em>
les éléments d'une liste à <em>un seul</em> élément:</p>

<p>``` irb</p>

<blockquote><blockquote><p>x.reduce {|sum, int| sum + int}
=> 7
```</p></blockquote></blockquote>

<p>Contrairement à la méthode <code>select</code> qui ne prenait qu'une seule variable
dans le bloc d'instruction, la méthode <code>reduce</code> en prends ici deux:
<code>sum</code> et <code>int</code>. <code>sum</code> joue le rôle d'un accumulateur et contient le résultat
qui sera retourné par la méthode. <code>int</code> fait référence à l'élément de la
liste en cours de traitement, exactement comme avec <code>select</code>. Pour chaque
élément de la liste <code>x</code>, l'instruction <code>sum + int</code> est exécutée.</p>

<p>On peut se demander quelle est la valeur initiale de <code>sum</code> ? Tout simplement
le premier élément de la liste. Et nous ne sommes pas limité aux nombres,
<code>reduce</code> fonctionnera avec ce qu'on veut, par exemple des chaînes de
caractères:</p>

<p>``` irb</p>

<blockquote><blockquote><p>[&ldquo;f&rdquo;, &ldquo;o&rdquo;, &ldquo;o&rdquo;].reduce {|string, letter| string + letter}
=> &ldquo;foo&rdquo;
```</p></blockquote></blockquote>

<p>Ruby permet aussi de simplifier l'écriture dans un cas trivial comme le
notre:</p>

<p>``` irb</p>

<blockquote><blockquote><p>x.reduce(:+)
=> 7
```</p></blockquote></blockquote>

<p>En fait, <code>reduce</code> ne prend pas obligatoirement un bloc. Ci-dessus,
<code>reduce</code> prend
en argument un symbole: <code>:+</code>. <code>+</code> est le nom d'une méthode. Oui, <code>+</code> est
bien une méthode:</p>

<p>``` irb</p>

<blockquote><blockquote><p>1.+(2)
=> 3
```</p></blockquote></blockquote>

<p>Je ne vais pas parler plus des symboles aujourd'hui, sachez seulement
que les deux écritures suivantes font la même chose mais que la seconde
est plus dans l'esprit de Ruby:</p>

<p><code>ruby
x.reduce {|sum, int| sum + int}
x.reduce(:+)
</code></p>

<p>Voilà, on est prêt à implémenter la méthode <code>sum_of_proper_divisors</code>, ce
qui signifie en français «somme des diviseurs stricts»:</p>

<p><code>ruby
def sum_of_proper_divisors(n)
  proper_divisors(n).reduce(:+)
end
</code></p>

<p>Comme la dernière fois, on se sert d'une méthode plus générale
(<code>proper_divisors</code>) pour écrire une méthode plus spécifique.</p>

<p>``` irb</p>

<blockquote><blockquote><p>def divisors(n)
  (1..n).select {|i| n % i == 0 }
end</p>

<p>def proper_divisors(n)
  divisors(n)[0..-2]
end</p>

<p>def sum_of_proper_divisors(n)
  proper_divisors(n).reduce(:+)
end</p>

<p>divisors 8
=> [1, 2, 4, 8]
proper_divisors 8
=> [1, 2, 4]
sum_of_proper_divisors 8
=> 7
```</p></blockquote></blockquote>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
