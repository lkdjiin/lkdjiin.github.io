<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : débutant | Xavier Nayrac]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/debutant/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2016-02-02T15:21:18+01:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Différence entre require_relative et require en Ruby]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/06/16/difference-entre-require-relative-et-require-en-ruby/"/>
    <updated>2015-06-16T16:59:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/06/16/difference-entre-require-relative-et-require-en-ruby</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Quelle est la différence entre <code>require</code> et <code>require_relative</code>, les deux
méthodes pour charger du code en Ruby ?</p>

<p>L’une, <code>require</code>, agit par rapport au répertoire de travail (dossier courant),
tandis que
l’autre, <code>require_relative</code>, agit par rapport au fichier qui l’utilise.</p>

<p><img class="center" src="/images/we-want-you-with-us.jpeg"></p>

<!-- more -->

<h2 id="require">require</h2>

<p>Nous avons la structure suivante :</p>

<pre><code>$ tree
.
├── foo.rb
└── lib
    ├── bar.rb
    └── baz.rb
</code></pre>

<p>Le fichier <code>foo.rb</code>, dans le répertoire racine, qui <em>require</em> le fichier <code>bar.rb</code>, qui se trouve dans le répertoire <code>lib</code>:</p>

<p><code>ruby foo.rb
require 'lib/bar'
puts bar
</code></p>

<p>Le fichier <code>bar.rb</code> <em>require</em> le fichier <code>baz.rb</code> qui se trouve dans le même
répertoire que lui:</p>

<p>``` ruby lib/bar.rb
require ‘lib/baz.rb’</p>

<p>def bar
  baz
end
```</p>

<p>Et le fichier <code>baz.rb</code> ne fait rien d’extraordinaire:</p>

<p><code>ruby lib/baz.rb
def baz
  'Hello, world!'
end
</code></p>

<p>Toute cette chaîne fonctionne correctement, si on prend garde à ajouter le
répertoire courant au chemin des bibliothèques (aussi connu comme le LOAD PATH):</p>

<p><code>bash
$ ruby -I. foo.rb 
Hello, world!
</code></p>

<h2 id="requirerelative">require_relative</h2>

<p>La structure reste exactement la même:</p>

<pre><code>$ tree
.
├── foo.rb
└── lib
    ├── bar.rb
    └── baz.rb
</code></pre>

<p>Bien entendu le code change légèrement dans <code>foo.rb</code>, et surtout dans <code>bar.rb</code>:</p>

<p><code>ruby foo.rb
require_relative 'lib/bar'
puts bar
</code></p>

<p>``` ruby lib/bar.rb
require_relative ‘baz.rb’</p>

<p>def bar
  baz
end
```</p>

<p><code>ruby lib/baz.rb
def baz
  'Hello, world!'
end
</code></p>

<p>Cette fois il n’y a pas besoin du switch <code>-I</code> puisque les fichiers sont requis
<em>relativement à eux-mêmes</em>:</p>

<p><code>bash
$ ruby foo.rb 
Hello, world!
</code></p>

<h2 id="pourquoi-utiliser-lun-plutt-que-lautre-">Pourquoi utiliser l’un plutôt que l’autre ?</h2>

<p>Avant, à l’époque de Ruby 1.8.x, il n’existait que <code>require</code> et le dossier
courant était automatiquement ajouté au LOAD PATH (<em>du moins si ma mémoire est
bonne</em>). Avant donc, la question ne se posait pas.</p>

<p>Aujourd’hui par contre la question peut se poser, et je n’ai pas de réponse
définitive. Personnellement j’utilise <code>require_relative</code> régulièrement dans
deux cas: 1) dans un script qui a <em>grossi</em> et que je sépare en plusieurs
fichiers, et 2) dans les tests (RSpec ou autres) pour importer des données.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[R : rep vs replicate]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/06/08/r-rep-vs-replicate/"/>
    <updated>2015-06-08T15:45:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/06/08/r-rep-vs-replicate</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Nouveau venu en R, je découvre régulièrement des nouvelles fonctions qui me
simplifient la vie. Comme par exemple la fonction <code>replicate</code> dont je vais
parler aujourd’hui.</p>

<p>Partons de l’hypothèse que je veuille générer plusieurs nombres aléatoires de
1 à 10. Pour ceci je dispose de la fonction <code>random</code> suivante, qui produit
justement un nombre aléatoire entre 1 et 10 :</p>

<!-- more -->

<p>``` r
random &lt;- function() {
  sample(1:10, size=1)
}</p>

<p>random()
[1] 5</p>

<p>random()
[1] 1
```</p>

<p>Comment faire pour obtenir <em>n</em> nombres aléatoires en utilisant cette fonction ?
Mettons quatre nombres. Si je me sers de <code>rep</code>, je vais avoir quelques
surprises :</p>

<p>``` r
rep(random(), 4)
[1] 8 8 8 8</p>

<p>rep(random(), 4)
[1] 2 2 2 2
```</p>

<p>En effet, l’appel à <code>random()</code> est fait avant la répétition, j’obtiens donc
quatre fois la même valeur.</p>

<p>Pour résoudre ce problème, je peux utiliser la fonction <code>replicate</code> :</p>

<p><code>r
replicate(4, random())
[1]  3  6 10  3
</code></p>

<p>Ça fonctionne car cette fois <code>random()</code> est appelé pour chacune des
répétitions.</p>

<p>Pour la petite histoire, <code>replicate</code> est un cas spécial de la fonction plus
générale <code>sapply</code> :</p>

<p><code>r
sapply(1:4, function(x) random())
[1] 10  4  2  1
</code></p>

<p>Dans ce cas d’utilisation précis <code>replicate</code> est plus confortable à utiliser,
puisque cette méthode évite de générer un vecteur inutile (<code>1:4</code>) et de passer par une fonction anonyme qui n’utilise pas son argument.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Le système binaire]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/06/04/le-systeme-binaire/"/>
    <updated>2015-06-04T13:55:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/06/04/le-systeme-binaire</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>J’ai appris l’algèbre de Boole au lycée, j’ai programmé en assembleur très tôt,
j’ai donc de bonnes raisons de connaître le binaire ; ce truc fait en quelque
sorte partie de moi.  Par expérience, je sais que certains développeurs manque
de connaissances dans le domaine, mais pas pour autant de curiosité.  Alors si
vous n’êtes pas sûr de savoir ce qu’est vraiment le système binaire, continuez
la lecture…</p>

<p><img class="center" src="/images/one-plus-one.png"></p>

<!-- more -->

<p><strong>Le système binaire est une manière de compter</strong>, tout comme le système
décimal que vous connaissez bien. Sauf qu’au lieu de compter en se basant sur
le nombre 10 (on dit aussi «compter en base dix»), on compte avec une base
deux. Le système décimal et le système binaire ne sont pas les seuls systèmes
de «comptage» existants, loin de là. Vous connaissez (et utilisez) d’autres
systèmes, comme le système en base 60 pour compter les secondes et les minutes
et le système en base 24 pour compter les heures.  Tout ça pour dire et redire
qu’<strong>il n’y a absolument rien de bizarre à compter autrement qu’en base 10</strong>.</p>

<p>Pourquoi, alors, le système décimal nous semble être <em>LE</em> système de référence ?
Et pourquoi 10, d’ailleurs ? Certainement parce qu’<strong>on a dix doigts</strong>, il est
donc naturel de prendre 10 comme base. Mais si nous rencontrions des
extra-terrestres à 8 doigts, il y a fort à parier que leur système <em>naturel</em>
serait en base 8.</p>

<p>Le système décimal possède dix symboles, qui représentent chacun une valeur que
j’appellerai <em>unitaire</em> : 0, 1, 2, 3, 4, 5, 6, 7, 8 et 9. Ces symboles peuvent
se combiner à l’infini pour représenter d’autres valeurs. <strong>C’est pareil pour
les autres systèmes</strong>, ils représentent un certain nombre de valeurs en utilisant
des symboles :</p>

<pre><code>Système     | # de symboles | Symboles
-------------------------------------------------------------
hexadécimal | 16            | 0 1 2 3 4 5 6 7 8 9 A B C D E F
décimal     | 10            | 0 1 2 3 4 5 6 7 8 9
octal       |  8            | 0 1 2 3 4 5 6 7
binaire     |  2            | 0 1
</code></pre>

<p>Le système binaire doit représenter seulement deux valeurs.  On utilise
généralement des 1 et des 0, mais on pourrait exprimer/symboliser ces valeurs
par n’importe quoi d’autre : vrai et faux, 5 volts et 0 volts, oui et non,
rouge et vert, allumé et éteint, haut et bas, etc.</p>

<p>Pourquoi a-t-on besoin d’un système avec seulement deux valeurs ?
<strong>i)</strong> parce que ça représente bien <strong>la logique</strong> : ceci <em>OU</em> cela, ceci <em>ET</em> cela.
<strong>ii)</strong> parce que c’est le système de comptage <strong>le plus simple</strong> (du moins pour une machine) et que simplicité est généralement synonyme d’efficacité.</p>

<p>Pour illustrer ce dernier point, et terminer cet article d’introduction au
système binaire — <em>j’espère qu’il y en aura plein d’autres</em> —  voici le
résultat de l’opération logique 1 OU 1, et celui de l’addition de 1 + 1 :</p>

<pre><code>1 OU 1 = 1
1  + 1 = 10
</code></pre>

<p>Pour comprendre comment tout cela fonctionne, rendez-vous dans les prochains
articles.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hacker la classe Fixnum]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/05/23/hacker-la-classe-fixnum/"/>
    <updated>2015-05-23T08:48:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/05/23/hacker-la-classe-fixnum</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<h2 id="ou-les-classes-ouvertes-en-ruby">Ou les classes ouvertes en Ruby</h2>

<p>``` ruby
1.hour_in_minutes #=&gt; 60</p>

<p>37.celsius_in_farenheit #=&gt; 0</p>

<p>2.dozens #=&gt; 24
```</p>

<p>C’est un aspect du langage que tous les rubyistes confirmés connaissent, mais
il est toujours utile d’en reparler pour les plus novices : En Ruby, même les
classes dites <em>système</em> peuvent être redéfinies, modifiées, augmentées, pliées
à vos besoins.</p>

<p>En un mot, on dit que les classes restent <strong>ouvertes</strong>.</p>

<p><img class="center" src="/images/open-640.jpg"></p>

<!-- more -->

<p>Si je veux par exemple pouvoir transformer les nombres entiers en <em>bytes</em> et en
<em>words</em>, je peux écrire les méthodes <code>to_bytes</code> et <code>to_words</code>.</p>

<blockquote>
  <p>Un byte = un octet  <br />
Un word = deux octets</p>
</blockquote>

<p>Voici ces méthodes simples, définies dans une session irb :</p>

<p>``` irb
» def to_bytes(number)
»   number
» end</p>

<blockquote>
  <blockquote>
    <p>def to_words(number)
  number * 2
end</p>
  </blockquote>
</blockquote>

<blockquote>
  <blockquote>
    <p>to_bytes(11)
11
to_words(11)
22
```</p>
  </blockquote>
</blockquote>

<p>Ça fonctionne très bien mais 1) ça n’est pas très <em>orienté objet</em>, et 2) ça
n’est pas très <em>ruby</em>. Plutôt que <code>to_words(11)</code>, on écrirait plus volontiers
<code>11.words</code>, c’est quand même plus classe (oh le jeu de mot à deux balles).</p>

<p>En parlant de classe justement, voyons quelle est la classe d’un nombre entier :</p>

<p><code>irb
&gt;&gt; 123.class
Fixnum &lt; Integer
</code></p>

<p>C’est tout ce qu’il nous faut savoir pour <em>augmenter</em> les nombres entiers avec
nos propres méthodes <code>byte</code>, <code>bytes</code>, <code>word</code> et <code>words</code> :</p>

<p>``` ruby
class Fixnum
  def byte
    self
  end
  alias_method :bytes, :byte</p>

<p>def word
    2 * self
  end
  alias_method :words, :word
end
```</p>

<p>Comme vous pouvez le constater, j’ai <em>ouvert</em> la classe Fixnum pour y ajouter
mes méthodes. Je rappelle que <code>self</code> est l’objet courant.</p>

<p>Si vous ne savez pas ce qu’est ce <code>alias_method</code>, dites vous que ceci :</p>

<p><code>ruby
  def word
    2 * self
  end
  alias_method :words, :word
</code></p>

<p>est équivalent à cela :</p>

<p>``` ruby
  def word
    2 * self
  end</p>

<p>def words
    word
  end
```</p>

<p>Et voilà :</p>

<p><code>ruby
1.byte  #=&gt; 1
2.bytes #=&gt; 2
1.word  #=&gt; 2
3.words #=&gt; 6
</code></p>

<p><strong>Edit du 5 juin 2015</strong> J’ai oublié de mentionner que l’utilisation des classes
ouvertes est sujet à controverse parmi les rubyistes. Trop de <em>monkey
patching</em> (l’autre nom pas très gentil des classes ouvertes) peut
effectivement rendre une gem compliquée ou délicate à utiliser en commun
avec d’autres gems. Comme toujours, je pense que c’est une histoire de
compromis et de «ça dépend». Notez que depuis Ruby 2.0 il existe une
alternative au <em>monkey patching</em> : <a href="http://lkdjiin.github.io/blog/2013/10/10/ruby-2-dot-0-raffinement-de-methode/">le raffinement de méthode</a>.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Créer plusieurs fichiers en Bash]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/05/15/creer-plusieurs-fichiers-en-bash/"/>
    <updated>2015-05-15T13:46:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/05/15/creer-plusieurs-fichiers-en-bash</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p><em>Faire deux fois la même chose, c’est une coincidence ; faire
trois fois la même chose, c’est déjà deux de trop.</em></p>

<p>Mettons que j’ai besoin de créer 20 fichiers quelconques (ici en Ruby) nommés ainsi :</p>

<ul>
  <li><code>asm01.rb</code></li>
  <li><code>asm02.rb</code></li>
  <li><code>asm03.rb</code></li>
  <li>etcétéra jusqu’à <code>asm20.rb</code></li>
</ul>

<!-- more -->

<p>Je peux les créer les uns après les autres de cette manière :</p>

<p><code>bash
$ touch lib/c8dasm/assemblies/asm01.rb
$ touch lib/c8dasm/assemblies/asm02.rb
$ touch lib/c8dasm/assemblies/asm03.rb
$ # même chose jusqu'à :
$ touch lib/c8dasm/assemblies/asm20.rb
</code></p>

<p>Imaginez si vous deviez en faire 200 comme cela ! Et même s’il n’y en avait que
10, c’est juste ennuyeux au possible. En tant que développeurs, <strong>nous devrions
apprendre à automatiser ces tâches pour notre confort</strong>.</p>

<p>On peut utiliser une boucle pour résoudre ce problème :</p>

<p><code>bash
$ for i in {01..20}; do
… &gt; touch lib/c8dasm/assemblies/asm$i.rb
… &gt; done
</code></p>

<p>Ou bien la version sur une seule ligne :</p>

<p><code>bash
$ for i in {01..20}; do touch lib/c8dasm/assemblies/asm$i.rb; done
</code></p>

<p>À bientôt.</p>

<p></p>

]]></content>
  </entry>
  
</feed>
