<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : débutant | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/debutant/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2013-12-09T21:07:53+01:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Remplacer Sed et Awk par Ruby 8: Script sur la ligne de commande]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/12/09/remplacer-sed-et-awk-par-ruby-8-script-sur-la-ligne-de-commande/"/>
    <updated>2013-12-09T20:36:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/12/09/remplacer-sed-et-awk-par-ruby-8-script-sur-la-ligne-de-commande</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Il est temps de se passer d'un fichier pour notre script… Lorsque celui-ci
est suffisament court, on peut l'écrire directement sur la ligne de
commande.</p>

<!-- more -->


<p>Si on reprend l'exemple tout simple du <a href="http://lkdjiin.github.io/blog/2013/12/08/remplacer-sed-et-awk-par-ruby-7-modifier-slash-sauvegarder-les-donnees/">dernier article</a>,
nous avions le fichier de données suivant à transformer <em>en place</em> en
majuscule:</p>

<p><code>raw data.txt
alice
bob
</code></p>

<p>Ce qu'on a fait à l'aide du script suivant:</p>

<p><code>ruby test.rb
$_.upcase!
</code></p>

<p>Autrement une seule ligne ! Est-ce que ça vaut vraiment la peine d'écrire
un fichier pour ça ? Bien sûr que non. On va donc se passer du fichier
script en donnant le code sur la ligne de commande grâce à l'option <code>-e</code>:</p>

<p><code>bash
ruby -p -i.2 -e '$_.upcase!' data.txt
</code></p>

<p>Et voilà, vous êtes maintenant prêts à écrire des <em>one liners</em>. Notez
quand même qu'il vaut mieux utiliser les guillemets simples (<code>'</code>) autour
du code plutôt que les doubles (<code>"</code>), pour empêcher Bash d'interpréter
certains caractères (comme ici le <code>!</code>).</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Remplacer Sed et Awk par Ruby 7: Modifier/sauvegarder les données]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/12/08/remplacer-sed-et-awk-par-ruby-7-modifier-slash-sauvegarder-les-donnees/"/>
    <updated>2013-12-08T19:30:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/12/08/remplacer-sed-et-awk-par-ruby-7-modifier-slash-sauvegarder-les-donnees</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Parfois on veut analyser un fichier, et parfois on veut le modifier.
Si on suit la logique de <a href="http://lkdjiin.github.io/blog/2013/11/29/remplacer-sed-et-awk-par-ruby/">cette série d'articles</a>, Ruby devrait offrir
un switch permettant de modifier un fichier sans avoir à l'enregistrer
explicitement. Et je ne vais pas vous surprendre
en vous apprenant qu'un tel switch existe, il s'agit de l'option
<code>-i</code>, qui permet aussi de sauvegarder l'ancien fichier.</p>

<!-- more -->


<p>L'exemple d'aujourd'hui est encore plus trivial que d'habitude ;) Voici
le fichier de données:</p>

<p><code>raw data.txt
alice
bob
</code></p>

<p>Ce que je voudrais, c'est simplement tout mettre en majuscule. Ce que
permet le script suivant:</p>

<p><code>ruby test.rb
$_.upcase!
</code></p>

<p>Si on lance le script comme on sait le faire maintenant
(voir par exemple <a href="http://lkdjiin.github.io/blog/2013/12/07/remplacer-sed-et-awk-par-ruby-6-separateur-de-champ/">l'article précédant</a>), on obtient un bel
affichage:</p>

<pre><code>[~/test]⇒ ruby -p test.rb data.txt 
ALICE
BOB
</code></pre>

<p>Mais le fichier lui-même n'a pas changé:</p>

<pre><code>[~/test]⇒ cat data.txt
alice
bob
</code></pre>

<p>Si on veut modifier le fichier, on doit se servir de l'option <code>-i</code> en
spécifiant l'extension qui sera ajouter au fichier original sauvegardé,
ici <code>.2</code>:</p>

<pre><code>[~/test]⇒ ruby -p -i.2 test.rb data.txt 
</code></pre>

<p>Et voilà, on a bien les deux fichiers attendus:</p>

<pre><code>[~/test]⇒ ls data*
data.txt  data.txt.2
</code></pre>

<p>Notre fichier est bien modifié:</p>

<pre><code>[~/test]⇒ cat data.txt
ALICE
BOB
</code></pre>

<p>Et il est bien sauvegardé:</p>

<pre><code>[~/test]⇒ cat data.txt.2
alice
bob
</code></pre>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Remplacer Sed et Awk par Ruby 6: Séparateur de champ]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/12/07/remplacer-sed-et-awk-par-ruby-6-separateur-de-champ/"/>
    <updated>2013-12-07T20:54:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/12/07/remplacer-sed-et-awk-par-ruby-6-separateur-de-champ</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Aujourd'hui on voit comment changer le séparateur de champ à l'aide de
l'option <code>-F</code>.</p>

<!-- more -->


<p>Reprenons le fichier de données du <a href="http://lkdjiin.github.io/blog/2013/12/05/remplacer-sed-et-awk-par-ruby-5-acceder-aux-champs-slash-colonnes/">dernier article</a>,
ajoutons un séparateur de champ, par exemple la virgule (<code>,</code>) et
<em>salissons-le</em> quelque peu:</p>

<p><code>raw data.txt
1, a
2, a
3, b
4 , a
5 ,a
6 ,b
7,b
8,b
9,b
</code></p>

<p>Le script du dernier article ne fonctionnera plus, puisque jusqu'ici nous
supposions que les champs étaient séparés par des espaces, ce qui n'est plus
le cas.</p>

<p>En admettant que les champs seront séparés par des virgules, il faut effectuer
un petit changement dans notre script, pour nettoyer le second champ:</p>

<p>``` ruby test.rb
BEGIN { total = 0 }</p>

<p>total += $F[0].to_i if $F[1].strip == &ldquo;a&rdquo;</p>

<p>END { puts &ldquo;Total: #{total}&rdquo; }
```</p>

<p>Et pour que Ruby sépare bien les champs en tenant compte des virgules, il faut
lui passer l'option <code>-F</code>, suivie d'une <em>regex</em> (sans les <code>//</code>) décrivant
le séparateur:</p>

<pre><code>[~]⇒ ruby -an -F, test.rb &lt; data.txt 
Total: 12
</code></pre>

<p>Et voilà.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Aidez-vous : traduisez !]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/12/06/aidez-vous-traduisez/"/>
    <updated>2013-12-06T20:52:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/12/06/aidez-vous-traduisez</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>D'aussi loin que je me souvienne,
j'ai toujours traduit de la documentation technique anglaise en français.
J'ai commencé par traduire des tutoriaux sur l'assembleur, juste pour moi.
Plus tard, j'ai traduis des pages de documentation sur Netbeans.
C'était un autre temps, un temps où je n'utilisais pas encore Vim, où je
programmais en Java… Et j'ai énormement appris en faisant des traductions.</p>

<!-- more -->


<p>Tous les développeurs ne lisent pas l'anglais, même technique. Certains ont
des problèmes avec la langue de Shakespeare et ont besoin de documentation
en français. On peut toujours se dire que, quand même, ils devraient s'y
mettre, mais en attendant, ils font comment ?</p>

<p>Même quand vous maitrisez assez l'anglais pour lire la documentation dans
la langue originale, il est toujours plaisant de pouvoir
lire dans sa langue, surtout pour une première approche du produit.</p>

<p><strong>Aidez-vous, traduisez de la documentation open-source !</strong> J'y vois trois
avantages:</p>

<ol>
<li>Quel que soit votre niveau en anglais, vous allez vous améliorer en
en faisant des traductions. Apprendre du nouveau vocabulaire, des
nouvelles tournures, etc.</li>
<li>En traduisant des documentations, vous allez en apprendre plus sur
le produit, quel qu'il soit, puisque vous serez dans l'obligation
de comprendre chaque détail du produit.</li>
<li>Ça peut être un avantage pour votre CV. S'il est vrai que certains
employeur ne s'intéressent pas à votre anglais, je n'en ai jamais vu
qui considèrent un bon niveau d'anglais comme un point négatif ;)</li>
</ol>


<p>Même si vous pensez ne pas avoir un niveau suffisant, lancez-vous ! Vous
en retirerez toujours un bénéfice.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Remplacer Sed et Awk par Ruby 5: Accéder aux champs/colonnes]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/12/05/remplacer-sed-et-awk-par-ruby-5-acceder-aux-champs-slash-colonnes/"/>
    <updated>2013-12-05T19:12:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/12/05/remplacer-sed-et-awk-par-ruby-5-acceder-aux-champs-slash-colonnes</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Toujours dans l'optique de remplacer Sed et Awk par Ruby,
et après avoir vu <a href="http://lkdjiin.github.io/blog/2013/12/04/remplacer-sed-et-awk-par-ruby-4-les-options-p-et-l/">les options -p et -l</a>, on voit
comment accéder facilement aux différentes colonnes
d'un fichier.</p>

<!-- more -->


<p>Voici le fichier de données tout simple qui va nous servir aujourd'hui:</p>

<p><code>raw data.txt
1 a
2 a
3 b
4 a
5 a
6 b
7 b
8 b
9 b
</code></p>

<p>L'objectif est de calculer la somme des valeurs de la 1ère colonne,
uniquement quand la 2e colonne affiche <code>a</code>. On pourrait bien sûr splitter
la ligne (<code>$_</code>) pour obtenir nos champs, mais il y a plus rapide.
En activant l'option <code>-a</code> de la ligne de commande, Ruby va automatiquement
splitter chaque lignes du fichier de données dans la variable prédéfinie
<code>$F</code> (pour <em>Fields</em>). On n'a donc rien à faire ;) et on peut se concentrer
sur les calculs:</p>

<p>``` ruby test.rb
BEGIN { total = 0 }</p>

<p>total += $F[0].to_i if $F[1] == &ldquo;a&rdquo;</p>

<p>END { puts &ldquo;Total: #{total}&rdquo; }
```</p>

<pre><code>[~]⇒ ruby -an test.rb &lt; data.txt 
Total: 12
</code></pre>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
