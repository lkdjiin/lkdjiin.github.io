<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : débutant | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/debutant/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2014-01-15T20:51:30+01:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Vim et les digraphes]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/01/12/vim-et-les-digraphes/"/>
    <updated>2014-01-12T11:27:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/01/12/vim-et-les-digraphes</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Comment saisir facilement et rapidement des caractères tels que ¡, ¿ ou encore
ß dans Vim ?</p>

<!-- more -->


<p>Pour voir à quoi ressemble ces fameux digraphes dans Vim, tapez la commande
<code>:digraphs</code>. Vous allez obtenir la liste des digraphes qui sont définis.
La définition d'un digraphe ressemble à ceci:</p>

<pre><code>?I ¿  191
</code></pre>

<p>Ici, seules les deux premières colonnes nous intéressent. La première colonne
est le code de deux caractères qu'il faut saisir pour obtenir le caractère
de la seconde colonne.</p>

<p>Pour saisir un digraphe, il faut être en mode insertion et entrer
Control + k, puis les deux caractères du code. Donc <code>Control</code>, puis <code>k</code>,
puis <code>?</code>, puis <code>I</code> donnera le caractère <code>¿</code>.</p>

<p>Voici quelques exemples:</p>

<pre><code>!I ¡
?I ¿
ss ß
%0 ‰
13 ⅓
78 ⅞
l* λ
p* π
-&gt; →
=&gt; ⇒
</code></pre>

<p>Si vous utilisez régulièrement certains digraphes, il existe une manière
plus rapide de les saisir. Activez tout d'abord l'option <code>digraph</code> dans
votre <code>.vimrc</code>:</p>

<p><code>vim
set digraph
</code></p>

<p>Maintenant vous pouvez saisir un digraphe en entrant le premier caractère
du code, puis la touche Backspace, puis le second caractère du code.
Donc <code>p</code>, puis <code>Backspace</code>, puis <code>*</code> vous donneront le caractère Pi (<code>π</code>).
Attention quand même avec cette option, si vous faites régulièrement des
fautes de frappes, vous risquez de voir apparaître assez souvent des caractères
étranges et inattendus ;)</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Trouves mon nombre - partie 3]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/01/09/trouves-mon-nombre-partie-3/"/>
    <updated>2014-01-09T21:00:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/01/09/trouves-mon-nombre-partie-3</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Aujourd'hui on regarde la fonction <code>bigger</code>, qui est l'inverse de la
fonction <code>smaller</code> <a href="http://lkdjiin.github.io/blog/2014/01/05/racket-trouves-mon-nombre-partie-2/">vue la dernière fois</a>.</p>

<!-- more -->


<p>Voici donc notre nouveau fichier <code>guess.rkt</code> avec sa nouvelle fonction:</p>

<p>``` racket guess.rkt</p>

<h1>lang racket</h1>

<p>(define lower 1)
(define upper 100)</p>

<p>(define (guess)
  (quotient (+ lower upper) 2))</p>

<p>(define (smaller)
  (set! upper (max lower (sub1 (guess))))
  (guess))</p>

<p>(define (bigger)
  (set! lower (min upper (add1 (guess))))
  (guess))
```</p>

<p>La fonction <code>bigger</code> fait exactement l'inverse de <code>smaller</code>:</p>

<pre><code>[~]⇒ racket
Welcome to Racket v5.3.6.
-&gt; (enter! "guess.rkt")
-&gt; (guess)
50
-&gt; (bigger)
75
</code></pre>

<p>Et c'est tout ce qu'il nous faut pour que la machine trouve le
nombre que j'ai choisi. Si par exemple je pensais au nombre
77, on continuerait ainsi:</p>

<pre><code>-&gt; (bigger)
88
-&gt; (smaller)
81
-&gt; (smaller)
78
-&gt; (smaller)
76
-&gt; (bigger)
77
</code></pre>

<p>La prochaine fois, on verra comment démarrer le jeu avec n'importe
quelle étendue de nombres.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Deuxième jour sur OS X]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/01/07/deuxieme-jour-sur-os-x/"/>
    <updated>2014-01-07T20:52:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/01/07/deuxieme-jour-sur-os-x</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>C'est mon second jour sur OS X. Pendant la nuit, des petits lutins
on fait une mise à jour de mon poste. Je suis passé de la version 10.6
(dont j'ai oublié le nom), à Mavericks (si j'ai bien tout bon).</p>

<!-- more -->


<p>Et donc, en arrivant ce matin, pratiquement tout fonctionnait normalement.
Merci les lutins ! J'avais emmené avec moi mon TypeMatrix 2030, et ça aide.
Par contre la deception: le mode «102 key layout» ne fonctionne tout
simplement pas. Ce qui fait que je n'ai pas un accès direct à la touche
<code>ê</code>. Ce qui pourrait sembler insignifiant, sauf que c'est ma touche
<code>&lt;Leader&gt;</code> sous Vim. Du coup, obligé de changer de touche Leader…
Autre déception, qui cette fois fois concerne OS X: impossible de
remapper facilement la touche «verrou majuscule» au niveau de l'OS.
Agaçant, puisque j'ai l'habitude de m'en servir comme d'une touche Escape.
Bon, c'est pas la mort, je suis revenu au bon vieux Ctrl-C, mais quand
même, j'attendais mieux de OS X.</p>

<p>Mais je ne voudrais quand même pas donné l'impression de n'avoir rencontré
que des problèmes.
Par exemple, j'ai découvert <em>rbenv</em> et <em>homebrew</em>, les deux très bonnes
surprises du jour. Avec homebrew, on se croirait presque sous Linux, et
la gestion des listes (les Formulas) avec git me semble assez ingénieuse. J'en parlerais
sûrement en détail quand j'aurais bien compris le truc.
Quand à rbenv, que je ne connaissais pas, il m'a paru beaucoup plus simple
que rvm, que j'utilise depuis … depuis le début quoi. Il y a de
grandes chances que je me mette à écrire aussi à propos de rbenv, donc.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Premier jour de mon nouveau boulot]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/01/06/premier-jour-de-mon-nouveau-boulot/"/>
    <updated>2014-01-06T21:11:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/01/06/premier-jour-de-mon-nouveau-boulot</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Aujourd'hui fût le premier jour de mon nouveau boulot. Cet article sera court,
je suis fatigué, il est tard, et je n'ai pas d'idée. Ou alors je pourrais
parler un peu d'OS X…</p>

<!-- more -->


<p>Mais un peu seulement, alors. Parce que c'est la toute première fois que
je touche à ce système d'exploitation. Je ne vais donc pas pouvoir vous
apprendre grand chose…</p>

<p>OS X c'est beau. Je ne peut pas dire le contraire. Habitué à
mon spartiate Debian, j'en ai pris plein les mirettes…</p>

<p>Je me suis battu avec le clavier, demain j'apporte mon TypeMatrix, histoire
de pouvoir me concentrer sur autre chose…</p>

<p>Je dois encore comprendre pourquoi MacVim n'accepte pas de faire
fonctionner pathogen…</p>

<p>En parlant de MacVim, j'ai noté un comportement très cool, il suffit d'un
seul appui sur <code>^</code> pour aller en début de ligne, alors que sur mon gVim,
il en faut deux. Ça j'aime bien, je ne sais pas pourquoi je n'ai jamais
pensé à adapter ce comportement sur gVim…</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Racket: Trouves mon nombre - partie 2]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/01/05/racket-trouves-mon-nombre-partie-2/"/>
    <updated>2014-01-05T20:32:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/01/05/racket-trouves-mon-nombre-partie-2</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Suite de l'article d'hier, aujourd'hui on ajoute la fonction
<code>smaller</code> à notre petit jeu textuel.</p>

<!-- more -->


<p>Voici le fichier <code>guess.rkt</code> avec la nouvelle fonction:</p>

<p>``` racket guess.rkt</p>

<h1>lang racket</h1>

<p>(define lower 1)
(define upper 100)</p>

<p>(define (guess)
  (quotient (+ lower upper) 2))</p>

<p>(define (smaller)
  (set! upper (max lower (sub1 (guess))))
  (guess))
```</p>

<p>Cette fonction change l'étendue du nombre à trouver, puis fait une nouvelle
proposition:</p>

<pre><code>[~]⇒ racket
Welcome to Racket v5.3.6.
-&gt; (enter! "guess.rkt")
-&gt; (guess)
50
-&gt; (smaller)
25
</code></pre>

<p>Voyons notre nouvelle fonction en détail:</p>

<p><code>racket
(define (smaller)
  (set! upper (max lower (sub1 (guess))))
  (guess))
</code></p>

<p>Si le nombre à trouver est plus petit que 50, il est donc compris entre
1 et 49. Il faut donc changer la limite haute (<code>upper</code>) pour refléter
cette nouvelle donne.</p>

<p>Le rôle de <code>set!</code> est de redéfinir une variable. Ici, on va changer le
contenu de la variable <code>upper</code>.</p>

<p>La fonction <code>sub1</code> décremente le nombre passé en argument, donc
<code>(sub1 (guess))</code> renvoie 49. Et nous prenons, grâce à <code>max</code>, le nombre maximum entre
celui-ci (49) et la valeur de la limite basse, ce qui permet de
s'assurer que la valeur de <code>upper</code> ne sera jamais inférieure à
la valeur de <code>lower</code>. Ce qu'on peut vérifier en continuant à évaluer
<code>smaller</code>:</p>

<pre><code>-&gt; (smaller)
25
-&gt; (smaller)
12
-&gt; (smaller)
6
-&gt; (smaller)
3
-&gt; (smaller)
1
-&gt; (smaller)
1
-&gt; (smaller)
1
...
</code></pre>

<p>La prochaine fois on verra la fonction inverse: <code>bigger</code> que vous
pouvez essayer de coder par vous-même en attendant.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
