<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : débutant | Xavier Nayrac]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/debutant/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2015-02-04T10:34:03+01:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Une machine de Turing en Ruby - Le parser]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/02/02/une-machine-de-turing-en-ruby-le-parser/"/>
    <updated>2015-02-02T18:04:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/02/02/une-machine-de-turing-en-ruby-le-parser</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>La machine de Turing réalisée dans le <a href="/blog/2015/02/01/une-machine-de-turing-en-ruby/">dernier article</a>
était seulement un brouillon, et elle souffre de plusieurs limitations.
J'aimerais maintenant faire évoluer le programme en permettant à l'utilisateur
de charger un jeu d'instructions quelconque. Pour cela j'aurai besoin
d'un <em>parser</em>, qui sera vite écrit grâce à Ruby.</p>

<p><img class="center" src="/images/gears4.jpg"></p>

<!-- more -->


<p>Un jeu d'instruction pour la machine de Turing ressemblera à ceci (si vous avez
besoin du code, <a href="https://github.com/lkdjiin/turing_machine">il est ici</a>):</p>

<p><code>raw instruction_sets/busy_beaver_3
0 A =&gt; 1 R B
1 A =&gt; 1 L C
0 B =&gt; 1 L A
1 B =&gt; 1 R B
0 C =&gt; 1 L B
1 C =&gt; 1 R HALT
</code></p>

<p>C'est l'algorithme <em>busy beaver à 3 états</em> que j'ai utilisé pour coder la
première version de la machine. Il faut écrire un <em>parser</em> qui va transformer
ce <em>code source</em> en ce hash Ruby, utilisé en interne par la machine:</p>

<p><code>
{
  ['0', 'A'] =&gt; {write: '1', move: 'R', next_state: 'B'},
  ['1', 'A'] =&gt; {write: '1', move: 'L', next_state: 'C'},
  ['0', 'B'] =&gt; {write: '1', move: 'L', next_state: 'A'},
  ['1', 'B'] =&gt; {write: '1', move: 'R', next_state: 'B'},
  ['0', 'C'] =&gt; {write: '1', move: 'L', next_state: 'B'},
  ['1', 'C'] =&gt; {write: '1', move: 'R', next_state: 'HALT'},
}
</code></p>

<p>Voici le parser, qui est construit autour de la méthode <code>String#split</code>.</p>

<p>``` ruby lib/turing_machine/instructions_parser.rb
module TuringMachine</p>

<p>  class InstructionsParser</p>

<pre><code>def initialize(raw_instructions)
  @lines = raw_instructions.split("\n")
  @instructions = {}
end

def parse
  build_instructions
  @instructions
end

private

def build_instructions
  @lines.each do |instruction|
    keys, value = instruction.split('=&gt;')
    key_symbol, key_state = keys.split
    write, move, next_state = value.split
    @instructions[[key_symbol, key_state]] = {
      write: write, move: move, next_state: next_state
    }
  end
end
</code></pre>

<p>  end</p>

<p>end
```</p>

<p>On va l'utiliser comme ça:</p>

<p><code>ruby
raw_instructions = IO.read(ARGV[0])
parser = InstructionsParser.new(raw_instructions)
instructions = parser.parse
</code></p>

<p>Je vais expliquer plus en détail. Tout d'abord dans le constructeur, on divise
la grande chaîne de caractères en entrée en autant de lignes indépendantes:</p>

<pre><code>@lines = raw_instructions.split("\n")
</code></pre>

<p>Puis dans la méthode privée <code>build_instructions</code>, on itère sur chacune des
lignes pour construire le hash:</p>

<pre><code>@lines.each do |instruction|
</code></pre>

<p>Chaque ligne est d'abord divisé en deux parties, de chaque coté de <code>=&gt;</code>:</p>

<pre><code>keys, value = instruction.split('=&gt;')
</code></pre>

<p>La partie des clés (celle de gauche) est à son tour divisé en deux, le symbole
sous la tête de lecture et l'état de la machine:</p>

<pre><code>key_symbol, key_state = keys.split
</code></pre>

<p>Ensuite c'est au tour de la partie de droite, celle qui représente la prochaine
instruction:</p>

<pre><code>write, move, next_state = value.split
</code></pre>

<p>Enfin, on ajoute clé et valeur dans le hash:</p>

<pre><code>@instructions[[key_symbol, key_state]] = {
  write: write, move: move, next_state: next_state
}
</code></pre>

<p>Pour finir, voici mon premier jeu d'instructions pour une machine de Turing:</p>

<p><code>raw instruction_sets/write101
0 A =&gt; 1 R B
0 B =&gt; 0 R C
0 C =&gt; 1 R HALT
</code></p>

<p>Ça fait quoi ? Ça écrit 101, tout simplement :</p>

<pre><code> turing_machine instruction_sets/write101 
  1 0000000000000000000000000000000000000000 A -&gt; 1RB
                       ^
  2 0000000000000000000100000000000000000000 B -&gt; 0RC
                        ^
  3 0000000000000000000100000000000000000000 C -&gt; 1RHALT
                         ^
  4 0000000000000000000101000000000000000000 HALT
</code></pre>

<p>Je vous rappelle que vous pouvez consulter le code de la
<a href="https://github.com/lkdjiin/turing_machine">machine de Turing</a>.</p>

<p>Voilà, avec l'aide de <code>String#split</code> il est facile d'écrire un parser simple.
Alors bien sûr, ce parser n'est pas vraiment complet, il manque par exemple la
gestion des erreurs. Mais il y a des choses plus urgentes à implémenter, comme
le mouvement nul, le ruban infini, ou la possibilité de commencer le programme
avec un ruban qui contient des données…</p>

<p>À plus tard.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mieux utiliser le programme gem]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/01/23/mieux-utiliser-le-programme-gem/"/>
    <updated>2015-01-23T11:49:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/01/23/mieux-utiliser-le-programme-gem</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Le programme <code>gem</code> est bien connu des rubyistes, et ce pour une bonne raison:
il est au coeur de l'utilisation de Ruby. Si je veux par exemple profiter
de <a href="https://github.com/michaeldv/awesome_print">awesome_print</a>
dans ma console irb, je vais l'installer grâce à <code>gem</code>:</p>

<pre><code>$ gem install awesome_print
</code></pre>

<p>De même, avez-vous déjà vu une appli Rails se passer d'un Gemfile ?</p>

<p>``` ruby Gemfile
source &lsquo;<a href="https://rubygems.org">https://rubygems.org</a>&rsquo;
ruby &lsquo;2.0.0&rsquo;</p>

<p>gem &lsquo;rails&rsquo;, &lsquo;4.0.0&rsquo;
gem &lsquo;pg&rsquo;
&hellip;
```</p>

<p>En fait, si vous avez fait seulement 3 jours de Ruby dans votre vie, vous savez
utiliser <code>gem</code>. Mais l'utilisez-vous à fond ? Moi, non. Enfin pas encore.</p>

<p><img class="center" src="/images/diamond-1_512.png"></p>

<!-- more -->


<p>Depuis 5 ou 6 ans que j'utilise quotidiennement Ruby, je n'avais jamais
écrit <code>gem --help</code>. Jamais. Pas une seule fois.</p>

<pre><code>$ gem --help
RubyGems is a sophisticated package manager for Ruby.  This is a
...
  Further help:
    gem help commands            list all 'gem' commands
    gem help examples            show some examples of usage
    gem help gem_dependencies    gem dependencies file guide
    gem help platforms           gem platforms guide
    gem help &lt;COMMAND&gt;           show help on COMMAND
    gem server                   present a web page at
...
</code></pre>

<p>J'ai l'impression qu'il y a de quoi lire et de quoi faire. Voici donc un rapide
tour d'horizon des possibilités offertes par <code>gem</code>.</p>

<h2>gem help commands</h2>

<p>Commençons par regarder les différentes commandes:</p>

<pre><code>$ gem help commands
GEM commands are:

    build                  Build a gem from a gemspec
    cert                   Manage RubyGems certificates and signing settings
...
    wrappers               Re run generation of environment wrappers for gems.
    yank                   Remove a pushed gem from the index
...
Commands may be abbreviated, so long as they are unambiguous.
</code></pre>

<p>J'ai abrégé la sortie ci-dessus car il y a <strong>33 commandes</strong>, je n'avais vraiment
pas la moindre idée d'un nombre si important de commande. En voici la liste:</p>

<ul>
<li>build</li>
<li>cert</li>
<li>check</li>
<li>cleanup</li>
<li>contents</li>
<li>dependency</li>
<li>environment</li>
<li>fetch</li>
<li>generate_index</li>
<li>help</li>
<li>install</li>
<li>list</li>
<li>lock</li>
<li>mirror</li>
<li>open</li>
<li>outdated</li>
<li>owner</li>
<li>pristine</li>
<li>push</li>
<li>query</li>
<li>rdoc</li>
<li>regenerate_binstubs</li>
<li>search</li>
<li>server</li>
<li>sources</li>
<li>specification</li>
<li>stale</li>
<li>uninstall</li>
<li>unpack</li>
<li>update</li>
<li>which</li>
<li>wrappers</li>
<li>yank</li>
</ul>


<p>Personnellement j'ai déjà utilisé <code>build</code>, <code>cleanup</code>, <code>install</code>, <code>list</code>,
<code>push</code>, <code>uninstall</code>, <code>update</code> et c'est tout. 7 commandes sur 33, je suis loin du compte.</p>

<p>En regardant d'un peu plus près la sortie de <code>gem help commands</code>,
je m'aperçois qu'on peut abréger chaque commande:</p>

<pre><code>$ gem install my_gem
</code></pre>

<p>seras donc identique à:</p>

<pre><code>$ gem i my_gem
</code></pre>

<p>J'aime beaucoup cette idée.</p>

<h2>gem help a_command</h2>

<p>On peut obtenir de l'aide sur une commande spécifique.
Par exemple, avec <code>gem help install</code>, j'apprend que les options permettant de
ne pas générer la documentation:</p>

<pre><code>--no-rdoc
--no-ri
</code></pre>

<p>sont des options dépréciées. On peut maintenant utiliser:</p>

<pre><code>-N, --no-document
</code></pre>

<h2>gem help examples</h2>

<p>Évidemment cette commande affiche plusieurs exemples ;) Comme la manière
d'installer une version spécifique d'une gem:</p>

<pre><code>$ gem install rake --version 0.3.1
</code></pre>

<p>Je ne sais pas pourquoi je ne me souviens jamais de cette manière de faire,
pourtant évidente. Maintenant je n'aurais plus besoin de poser la question à
un moteur de recherche, je me contenterais de <code>gem help examples</code>.</p>

<h2>gem server</h2>

<p>Une petite curiosité : <code>gem server</code> fournit une page html, à consulter à
l'adresse <code>localhost:8808</code> avec la liste des gems installées. Ça semble un peu
gadget, d'autant plus qu'on peut avoir ces informations rapidement dans la
console avec la commande <code>list</code>:</p>

<pre><code>$ gem list

*** LOCAL GEMS ***

awesome_print (1.6.1)
bigdecimal (1.2.6)
bundler (1.7.9)
...
</code></pre>

<p>Et puis avec <code>gem help list</code>, j'ai trouvé comment obtenir des détails sur les
gems:</p>

<pre><code>$ gem list -d

*** LOCAL GEMS ***

awesome_print (1.6.1)
    Author: Michael Dvorkin
    Homepage: http://github.com/michaeldv/awesome_print
    License: MIT
    Installed at: /home/xavier/.rvm/gems/ruby-2.2.0

    Pretty print Ruby objects with proper indentation and colors

bigdecimal (1.2.6)
    Authors: Kenta Murata, Zachary Scott, Shigeo Kobayashi
    Homepage: http://www.ruby-lang.org
    Installed at (default): /home/xavier/.rvm/rubies/ruby-2.2.0/lib/ruby/gems/2.2.0

Arbitrary-precision decimal floating-point number library.

...
</code></pre>

<h2>Encore du boulot…</h2>

<p>Je n'ai pas fini de la lire, cette documentation. Elle semble prometteuse, et
je sens que je vais apprendre encore pas mal de choses.</p>

<p>J'espère vous avoir donné envie de regarder certaines commandes plus en détails.
Dans un monde idéal, il faudrait que je regarde les 33…</p>

<p>À bientôt.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby 2.2 - Une sélection des nouvelles méthodes]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/12/27/ruby-2-dot-2-une-selection-des-nouvelles-methodes/"/>
    <updated>2014-12-27T15:40:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/12/27/ruby-2-dot-2-une-selection-des-nouvelles-methodes</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Ça y est, noël est passé et Ruby 2.2.0 est arrivé.
Je vous ai préparé une sélection (personnelle) des nouveautés de cette dernière
version de Ruby.</p>

<p>Vous pouvez voir la liste exhaustive des changements ici:
<a href="https://github.com/ruby/ruby/blob/v2_2_0/NEWS">ruby v2.2.0 NEWS</a></p>

<!-- more -->


<h2>Les symboles pour les clés d'un Hash peuvent être entre guillemets</h2>

<p>Ce qui autorise l'utilisation des espaces.</p>

<p>``` irb</p>

<blockquote><blockquote><p>hash = { &ldquo;foo bar&rdquo;: &ldquo;baz&rdquo; }
=> {:&ldquo;foo bar&rdquo;=>&ldquo;baz&rdquo;}</p>

<p>hash[:&ldquo;foo bar&rdquo;]
=> &ldquo;baz&rdquo;
```</p></blockquote></blockquote>

<h2>Enumerable#slice_when</h2>

<p>J'ai le tableau suivant:</p>

<p>``` irb</p>

<blockquote><blockquote><p>a = [1, 2, 4, 9, 10, 11, 12, 15, 16, 19, 20, 21]
```</p></blockquote></blockquote>

<p>Je veux rassembler ensemble les séries de nombre qui se suivent. Autrement dit,
je veux obtenir ceci:</p>

<pre><code>[ [1, 2], [4], [9, 10, 11, 12], [15, 16], [19, 20, 21] ]
</code></pre>

<p><code>slice_when</code> me fait ça facilement:</p>

<p>``` irb</p>

<blockquote><blockquote><p>a.slice_when {|i, j| i+1 != j }.to_a
=> [[1, 2], [4], [9, 10, 11, 12], [15, 16], [19, 20, 21]]
```</p></blockquote></blockquote>

<h2>max et min peuvent retourner plusieurs valeurs</h2>

<p>Plutôt que d'obtenir la seule et unique valeur limite, on peut maintenant
obtenir une liste.</p>

<p>``` irb</p>

<blockquote><blockquote><p>[1, 2, 3].max
=> 3</p>

<p>[1, 2, 3].max(2)
=> [3, 2]</p>

<p>[1, 2, 3, 3].max(2)
=> [3, 3]
```</p></blockquote></blockquote>

<h2>Method#curry</h2>

<p>Tout d'abord, voici une méthode <code>add</code>, qui prend 3 arguments:</p>

<p><code>ruby
def add(a, b, c)
  a + b + c
end
</code></p>

<p>On <em>currifie</em> cette méthode:</p>

<p>``` irb</p>

<blockquote><blockquote><p>proc = self.method(:add).curry
=> #&lt;Proc:0x8f945a4 (lambda)>
```</p></blockquote></blockquote>

<p>Je peux maintenant l'appliquer partiellement:</p>

<p>``` irb</p>

<blockquote><blockquote><p>proc = proc.call(1, 2)
=> #&lt;Proc:0x9407dfc (lambda)></p>

<p>proc.call(3)
=> 6</p>

<p>proc.call(10)
=> 13
```</p></blockquote></blockquote>

<h2>La lib Etc</h2>

<p>Pour finir, voici deux nouvelles méthodes de la bibliothèque standard <code>Etc</code>.</p>

<p>``` irb</p>

<blockquote><blockquote><p>require &lsquo;etc&rsquo;</p>

<p>Etc.uname
=> {:sysname=>&ldquo;Linux&rdquo;, &hellip; }</p>

<p>Etc.nprocessors
=> 2
```</p></blockquote></blockquote>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Affichage de toutes les tâches rake]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/06/25/affichage-de-toutes-les-taches-rake/"/>
    <updated>2014-06-25T20:54:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/06/25/affichage-de-toutes-les-taches-rake</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Hier je parlais des switchs <code>-T</code> et <code>-D</code> de l'executable <code>rake</code> pour
obtenir la liste des tâches, respectivement tronquées ou détaillées.</p>

<p>Aujourd'hui, pour ceux qui aurait la flemme de lire la sortie de
<code>rake --help</code>, c'est comment les obtenir <strong>toutes</strong>, car il y en a souvent
plus que l'on croit ;)</p>

<!-- more -->


<p>En effet, les switchs <code>-T</code> et <code>-D</code> n'affichent que les tâches possédant
une description. Et quand on débarque sur un projet Rails, ou Ruby, il
n'est pas rare qu'une petite armée de développeurs soient passés avant
vous en ajoutant plusieurs tâches bien utiles, mais sans description.</p>

<p>Pour en avoir la liste sans avoir à lire les nombreux fichiers <code>*.rake</code>,
il vous suffit d'utiliser le switch <code>--all</code>:</p>

<pre><code>$ rake --all -T
</code></pre>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Description détaillée des tâches rake]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/06/24/description-detaillee-des-taches-rake/"/>
    <updated>2014-06-24T21:15:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/06/24/description-detaillee-des-taches-rake</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Vous savez certainement comment obtenir la liste des tâches <code>rake</code> disponibles
dans votre projet Rails ou dans votre gem Ruby. Il faut utiliser le switch
<code>-T</code>. Par exemple, à partir d'un projet Rails bidon:</p>

<pre><code>$ rake -T
rake about                              # List versions of all Rails framew...
rake assets:clean[keep]                 # Remove old compiled assets
rake assets:clobber                     # Remove compiled assets
rake assets:environment                 # Load asset compile environment
rake assets:precompile                  # Compile all the assets named in c...
rake cache_digests:dependencies         # Lookup first-level dependencies f...
rake cache_digests:nested_dependencies  # Lookup nested dependencies for TE...
rake db:create                          # Creates the database from DATABAS...
rake db:drop                            # Drops the database from DATABASE_...
</code></pre>

<!-- more -->


<p>Et il y en a quelques dizaines d'autres. Vous remarquez que certaines descriptions sont
tronquées, comme <code># Compile all the assets named in c...</code>. Lorsqu'il s'agit d'une
tâche qu'on ne connait pas très bien, on aimerait pouvoir lire la description
complête. Pour cela, il faut utiliser le switch <code>-D</code>:</p>

<pre><code>$ rake -D
rake about
    List versions of all Rails frameworks and the environment

rake assets:clean[keep]
    Remove old compiled assets

rake assets:clobber
    Remove compiled assets

rake assets:environment
    Load asset compile environment

rake assets:precompile
    Compile all the assets named in config.assets.precompile

rake cache_digests:dependencies
    Lookup first-level dependencies for TEMPLATE (like messages/show or comments/_comment.html)
</code></pre>

<p>Pour en savoir plus sur les switchs de rake, tapez <code>rake --help</code>.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
