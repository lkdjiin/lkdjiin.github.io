<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : débutant | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/debutant/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2014-04-05T21:25:20+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Vim - Un plugin pour markdown - partie 9]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/04/04/vim-un-plugin-pour-markdown-partie-9/"/>
    <updated>2014-04-04T21:26:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/04/04/vim-un-plugin-pour-markdown-partie-9</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Je voudrais maintenant tester que ma fonction pour passer un mot en
italique fonctionne sur le dernier mot de la phrase, lorsque celui-ci
n'a qu'un seul caractère…</p>

<!-- more -->


<p>Voilà le test Vader:</p>

<p>``` raw
Given (a line whose the last word is of length 1):
  abc def ghi j</p>

<p>Execute (starting at the end of the last word who is of length 1):
  execute &ldquo;normal! fj&rdquo;
  QuickMarkdownItalic</p>

<p>Expect (last word in italic):
  abc def ghi <em>j</em>
```</p>

<p>Et malheureusement, il échoue:</p>

<p>``` raw</p>

<pre><code>(4/4) [  GIVEN] a line whose the last word is of length 1
(4/4) [EXECUTE] starting at the end of the last word who is of length 1
(4/4) [ EXPECT] (X) last word in italic
  - Expected:
      abc def ghi *j*
  - Got:
      abc def ghi j
</code></pre>

<p>```</p>

<p>Je m'attendais à un échec, mais pas à celui-ci ! Je pensais obtenir ceci:</p>

<pre><code>abc def *ghi* j
</code></pre>

<p>Donc je trouve ça assez bizarre et j'écris deux autres tests sur le dernier
mot d'une phrase, quand ce mot est d'une longueur correcte:</p>

<p>```
Given (some text):
  abc def ghi jkl mno</p>

<p>Execute (from the beginning of the last word):
  execute &ldquo;normal! fm&rdquo;
  QuickMarkdownItalic</p>

<p>Expect (last word in italic):
  abc def ghi jkl <em>mno</em></p>

<p>Execute (from the end of the last word):
  execute &ldquo;normal! fo&rdquo;
  QuickMarkdownItalic</p>

<p>Expect (last word in italic):
  abc def ghi jkl <em>mno</em>
```</p>

<p>Là encore le test qui débute sur le dernier caractère échoue de la même
manière, c'est à dire sans avoir ajouter aucun <code>*</code>.</p>

<p>J'ai déjà entendu dire que Vim pouvait faire des choses bizarres quand
on se trouve à la fin d'une phrase. Je ne sais pas si c'est cela ou la
logique de ma fonction qui est en cause, c'est toujours un mystère et
j'espère avoir le temps ce week-end pour investiguer.</p>

<p>En attendant que je m'y mette, si vous avez des pistes, je suis preneur ;)</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ActiveRecord - Voir la requête SQL pendant l'écriture des tests]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/04/03/activerecord-voir-la-requete-sql-pendant-lecriture-des-tests/"/>
    <updated>2014-04-03T20:58:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/04/03/activerecord-voir-la-requete-sql-pendant-lecriture-des-tests</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Cet après-midi, avec un collègue, on écrivait des tests pour une requête
en base de données avec ActiveRecord. Et on a eu besoin d'étudier le
code SQL qui était généré.</p>

<!-- more -->


<p>On aurait pu lancer une console et jouer avec ActiveRecord dedans, mais
le setup nécessaire pour accéder à l'objet sur lequel on travaillait est
assez long à mettre en place. On voulait plutôt faire rapidement:</p>

<ol>
<li>On bidouille la requête ActiveRecord.</li>
<li>On lance le test.</li>
<li>On examine le code SQL.</li>
<li>On recommence tant que ça ne nous convient pas.</li>
</ol>


<p>Pour ça, placez la ligne suivante dans votre fichier de test et le tour
est joué.</p>

<p><code>ruby
ActiveRecord::Base.logger = Logger.new(STDOUT)
</code></p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tester facilement vos dates avec Timecop]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/04/01/tester-facilement-vos-dates-avec-timecop/"/>
    <updated>2014-04-01T21:06:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/04/01/tester-facilement-vos-dates-avec-timecop</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p><a href="https://github.com/travisjeffery/timecop">Timecop</a>
n'est pas une nouvelle gem. Mais je ne la découvre qu'aujourd'hui.
Ça fait pourtant 4 ans que je travaille quotidiennement avec Ruby
et/ou Rails… Et je ne me suis jamais sentis très à l'aise pour tester
les dates. Avec Timecop, ça devient un jeu d'enfant.</p>

<!-- more -->


<p>Pour voir un souci possible, prenons la classe suivante qui représente
un article:</p>

<p>``` ruby article.rb
class Article
  def initialize(name)</p>

<pre><code>@name = name
@created_at = Time.now
</code></pre>

<p>  end</p>

<p>  attr_reader :name, :created_at
end
```</p>

<p>Dans le monde réel, ce serait surement un ActiveRecord, mais pour
l'exemple on se contentera bien de cette classe ;)</p>

<p>Maintenant testons la création d'un article:</p>

<p>``` ruby tc_article.rb
require_relative &ldquo;article&rdquo;
require &ldquo;test/unit&rdquo;</p>

<p>class TestArticle &lt; Test::Unit::TestCase
  def test_creation</p>

<pre><code>article = Article.new('Foo')
assert_equal 'Foo', article.name
assert_equal Time.now, article.created_at
</code></pre>

<p>  end
end
```</p>

<p>Et voilà le souci, à quelques nano-secondes près ça pète:</p>

<p>``` bash
$ ruby tc_article.rb
Run options:</p>

<h1>Running tests:</h1>

<p>[1/1] TestArticle#test_creation = 0.00 s
  1) Failure:
TestArticle#test_creation [tc_article.rb:8]:
&lt;2014-04-01 21:05:10 +0200> (204201[ns]) expected but was
&lt;2014-04-01 21:05:10 +0200> (176685[ns]).</p>

<p>Finished tests in 0.009979s, 100.2062 tests/s, 200.4125 assertions/s.
1 tests, 2 assertions, 1 failures, 0 errors, 0 skips
```</p>

<p>Timecop est la meilleure solution que j'ai vu jusqu'ici pour régler
ce type de problème. La gem propose tout simplement (entre autres)
<em>de geler le temps</em>:</p>

<p>``` ruby tc_article.rb
require_relative &ldquo;article&rdquo;
require &ldquo;test/unit&rdquo;
require &ldquo;timecop&rdquo;</p>

<p>class TestArticle &lt; Test::Unit::TestCase
  def test_creation</p>

<pre><code>Timecop.freeze do
  article = Article.new('Foo')
  assert_equal 'Foo', article.name
  assert_equal Time.now, article.created_at
end
</code></pre>

<p>  end
end
```</p>

<p>Et voilà le résultat:</p>

<p>``` bash
ruby tc_article.rb
Run options:</p>

<h1>Running tests:</h1>

<p>Finished tests in 0.010756s, 92.9747 tests/s, 185.9494 assertions/s.
1 tests, 2 assertions, 0 failures, 0 errors, 0 skips
```</p>

<p>J'aimerais bien savoir quelles solutions vous avez adoptés pour
régler ce genre de soucis…</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vim - Un plugin pour markdown - partie 8]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/03/31/vim-un-plugin-pour-markdown-partie-8/"/>
    <updated>2014-03-31T20:58:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/03/31/vim-un-plugin-pour-markdown-partie-8</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>On continue d'implémenter <a href="/blog/2014/03/30/vim-un-plugin-pour-markdown-partie-7/">la fonctionnalité commencée hier</a>
en testant deux cas exceptionnels, toujours à l'aide de Vader.</p>

<!-- more -->


<p>Revoici le fichier de test d'hier:</p>

<p>``` raw
Given (some text):
  abc def ghi jkl mno</p>

<p>Execute (starting in middle of a word):
  execute &ldquo;normal! fe&rdquo;
  QuickMarkdownItalic</p>

<p>Expect (2nd word in italic):
  abc <em>def</em> ghi jkl mno
```</p>

<p>Je vais ajouter deux tests. L'un pour voir ce qu'il se passe quand le
curseur se trouve au début d'un mot, et idem pour la fin d'un mot:</p>

<p>``` raw
Given (some text):
  abc def ghi jkl mno</p>

<p>Execute (starting in middle of a word):
  execute &ldquo;normal! fe&rdquo;
  QuickMarkdownItalic</p>

<p>Expect (2nd word in italic):
  abc <em>def</em> ghi jkl mno</p>

<p>Execute (starting at beginning of a word):
  execute &ldquo;normal! fd&rdquo;
  QuickMarkdownItalic</p>

<p>Expect (2nd word in italic):
  abc <em>def</em> ghi jkl mno</p>

<p>Execute (starting at the end of a word):
  execute &ldquo;normal! ff&rdquo;
  QuickMarkdownItalic</p>

<p>Expect (2nd word in italic):
  abc <em>def</em> ghi jkl mno
```</p>

<p>Et avec l'implémentation de la dernière fois:</p>

<p><code>vim autoload/quickmarkdown.vim
function! quickmarkdown#italic()
  execute "normal! bi*\&lt;Esc&gt;ea*\&lt;Esc&gt;"
endfunction
</code></p>

<p>… le test où le curseur se trouve au début d'un mot échoue
misérablement.</p>

<p>Pour le faire passer, on doit d'abord déplacer le curseur d'un cran
vers la droite:</p>

<p><code>vim autoload/quickmarkdown.vim
function! quickmarkdown#italic()
  execute "normal! lbi*\&lt;Esc&gt;ea*\&lt;Esc&gt;"
endfunction
</code></p>

<p>La prochaine fois on continue avec d'autres cas exceptionnels.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vim - Un plugin pour markdown - partie 7]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/03/30/vim-un-plugin-pour-markdown-partie-7/"/>
    <updated>2014-03-30T21:20:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/03/30/vim-un-plugin-pour-markdown-partie-7</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Pour mon plugin Vim qui aide à écrire du markdown, j'ai envie d'une
fonctionnalité pour mettre un mot en italique (et aussi en gras).
Si j'ai le texte suivant:</p>

<pre><code>foo bar baz
</code></pre>

<p>et que le curseur est dans le mot <code>bar</code>, je veux que la combinaison de
touches <code>&lt;Leader&gt;qi</code> donne ceci:</p>

<pre><code>foo *bar* baz
</code></pre>

<p>Pour implémenter ça, j'utiliserais encore le framework de test Vader.</p>

<!-- more -->


<p>Voici un premier test, pour le cas général:</p>

<p>``` raw
Given (some text):
  abc def ghi jkl mno</p>

<p>Execute (starting in middle of a word):
  execute &ldquo;normal! fe&rdquo;
  QuickMarkdownItalic</p>

<p>Expect (2nd word in italic):
  abc <em>def</em> ghi jkl mno
```</p>

<p>Le bloc <code>Execute</code> place d'abord le curseur sur le caractêre <code>e</code>,
autrement dit <em>à l'intérieur</em> du mot <code>def</code>. Il lance ensuite la fonction
<code>QuickMarkdownItalic</code> qui devra faire le travail.</p>

<p>Dans le fichier <code>plugin/quickmarkdown.vim</code>, j'ajoute la nouvelle
fonction:</p>

<p><code>vim plugin/quickmarkdown.vim
command! QuickMarkdownItalic call quickmarkdown#italic()
</code></p>

<p>Puis j'implémente la fonction de la manière la plus simple à laquelle
je puisse penser:</p>

<p><code>vim autoload/quickmarkdown.vim
function! quickmarkdown#italic()
  execute "normal! bi*\&lt;Esc&gt;ea*\&lt;Esc&gt;"
endfunction
</code></p>

<p>Décodage: <code>b</code> place le curseur au début du mot. <code>i*\&lt;Esc&gt;</code> passe en
mode insertion, ajoute un <code>*</code> et revient en mode normal. <code>e</code> place le
curseur à la fin du mot. <code>a*\&lt;Esc&gt;</code> passe en mode insertion <em>derrière</em>
le mot et ajoute un <code>*</code> puis revient encore en mode normal.</p>

<p>Cette fonction sera amenée à bouger une fois qu'on se sera occupé des
cas particuliers. Ce sera pour une prochaine fois.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
