<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : débutant | Xavier Nayrac]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/debutant/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2015-05-02T12:43:25+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Comment convertir un nombre décimal en binaire en Bash ?]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/05/02/comment-convertir-un-nombre-decimal-en-binaire-en-bash/"/>
    <updated>2015-05-02T12:20:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/05/02/comment-convertir-un-nombre-decimal-en-binaire-en-bash</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Pour convertir un nombre décimal en binaire, en Bash, suivez ce tweet :
<a href="https://twitter.com/climagic/status/593842202314420224">https://twitter.com/climagic/status/593842202314420224</a>.</p>

<p>Et voici la conversion du décimal 27 en son équivalent binaire :</p>

<p><code>bash
$ Dec2Bin=({0..1}{0..1}{0..1}{0..1}{0..1}{0..1}{0..1}{0..1});echo ${Dec2Bin[27]} 
00011011
</code></p>

<p>Alors, comment ça marche ?</p>

<p><img class="center" src="/images/binary.jpg"></p>

<!-- more -->

<p>Pour commencer, voici comment faire un tableau en bash, qui va contenir les 3
chaînes <code>foo</code>, <code>bar</code>, et <code>baz</code>. Ne soyez pas surpris par le manque de guillemets
autour des chaînes, Bash est fait pour traiter du texte.</p>

<p><code>bash
$ myarray=(foo bar baz)
</code></p>

<p>Et voici comment afficher le contenu de ce tableau.</p>

<p><code>bash
$ echo ${myarray[@]}
foo bar baz
</code></p>

<p>On peut bien sûr accéder aux éléments du tableau séparément :</p>

<p><code>bash
$ echo ${myarray[0]}
foo
$ echo ${myarray[1]}
bar
$ echo ${myarray[2]}
baz
</code></p>

<p>Pour connaître la taille d’un tableau, voici la syntaxe :</p>

<p><code>bash
$ echo ${#myarray[@]}
3
</code></p>

<p>Appliquons ce nouveau savoir au tableau <code>Dec2Bin</code>, qui contient…</p>

<p>…</p>

<p>…des trucs :</p>

<p><code>bash
$ Dec2Bin=({0..1}{0..1}{0..1}{0..1}{0..1}{0..1}{0..1}{0..1})
</code></p>

<p>Combien a-t-il d’éléments ?</p>

<p><code>bash
$ echo ${#Dec2Bin[@]}
256
</code></p>

<p>256 ? Et ça ressemble à quoi ?</p>

<p><code>bash
$ echo ${Dec2Bin[@]}
00000000 00000001 00000010 00000011 00000100 00000101 00000110 00000111 00001000 
00001001 00001010 00001011 00001100 00001101 00001110 00001111 00010000 00010001
...
11101010 11101011 11101100 11101101 11101110 11101111 11110000 11110001 11110010 
11110011 11110100 11110101 11110110 11110111 11111000 11111001 11111010 11111011 
11111100 11111101 11111110 11111111
</code></p>

<p>Tranquille, <code>Dec2Bin</code> est un tableau qui contient 256 chaînes représentant les
nombres binaires de 0 à 255.</p>

<p>Les crochets <code>{}</code> créent un <em>range</em> :</p>

<p><code>bash
$ echo {0..1}
0 1
$ echo {a..f}
a b c d e f
</code></p>

<p>Plusieurs crochets <code>{}</code> les uns à la suite des autres produisent toutes les
permutations possibles :</p>

<p><code>bash
$ echo {0..1}{0..1}
00 01 10 11
</code></p>

<p>Et on peut mettre tout ça dans un tableau :</p>

<p><code>bash
$ a=({0..1})
$ echo ${a[@]}
0 1
$ a=({0..1}{0..1})
$ echo ${a[@]}
00 01 10 11
$ a=({0..1}{0..1}{0..1})
$ echo ${a[@]}
000 001 010 011 100 101 110 111
</code></p>

<p>Et voilà, il faut encore savoir qu’ici, le point-virgule sert à joindre 2 lignes de
code en une seule :</p>

<p><code>bash
$ Dec2Bin=({0..1}{0..1}{0..1}{0..1}{0..1}{0..1}{0..1}{0..1})
$ echo ${Dec2Bin[27]}
00011011
</code></p>

<h2 id="bonus-1---le-mme-en-hexadcimal">Bonus 1 - Le même en hexadécimal</h2>

<p>Et si on voulait convertir un nombre décimal en hexadécimal plutôt qu’en
binaire ? Il faudrait générer toutes les permutations entre deux suites
<code>0 1 2 3 4 5 6 7 8 9 A B C D E F</code> :</p>

<p>
<code>bash
$ echo {{0..9},{A..F}}{{0..9},{A..F}}
00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F 10 11 12 13 14 15 16 17 18 19 1A 
1B 1C 1D 1E 1F 20 21 22 23 24 25 26 27 28 29 2A 2B 2C 2D 2E 2F 30 31 32 33 34 35 
36 37 38 39 3A 3B 3C 3D 3E 3F 40 41 42 43 44 45 46 47 48 49 4A 4B 4C 4D 4E 4F 50 
51 52 53 54 55 56 57 58 59 5A 5B 5C 5D 5E 5F 60 61 62 63 64 65 66 67 68 69 6A 6B 
6C 6D 6E 6F 70 71 72 73 74 75 76 77 78 79 7A 7B 7C 7D 7E 7F 80 81 82 83 84 85 86 
87 88 89 8A 8B 8C 8D 8E 8F 90 91 92 93 94 95 96 97 98 99 9A 9B 9C 9D 9E 9F A0 A1 
A2 A3 A4 A5 A6 A7 A8 A9 AA AB AC AD AE AF B0 B1 B2 B3 B4 B5 B6 B7 B8 B9 BA BB BC 
BD BE BF C0 C1 C2 C3 C4 C5 C6 C7 C8 C9 CA CB CC CD CE CF D0 D1 D2 D3 D4 D5 D6 D7 
D8 D9 DA DB DC DD DE DF E0 E1 E2 E3 E4 E5 E6 E7 E8 E9 EA EB EC ED EE EF F0 F1 F2 
F3 F4 F5 F6 F7 F8 F9 FA FB FC FD FE FF
</code>
</p>

<p>
<code>bash
$ Dec2Hex=({{0..9},{A..F}}{{0..9},{A..F}});echo ${Dec2Hex[27]}
1B
</code>
</p>

<h2 id="bonus-2---le-mme-en-ruby">Bonus 2 - Le même en Ruby</h2>

<p>On peut faire la même chose en Ruby en utilisant <code>repeated_permutation</code> :</p>

<p><code>irb
&gt;&gt; [0,1].repeated_permutation(8).to_a.each{|e| puts e.join}
00000000
00000001
00000010
00000011
00000100
00000101
...
11111010
11111011
11111100
11111101
11111110
11111111
</code></p>

<p>Il peut-être intéressant de comparer les deux versions :</p>

<p><code>bash
$ ruby -e "puts [0,1].repeated_permutation(8).to_a[27].join"
00011011
</code></p>

<p><code>bash
$ Dec2Bin=({0..1}{0..1}{0..1}{0..1}{0..1}{0..1}{0..1}{0..1});echo ${Dec2Bin[27]} 
00011011
</code></p>

<h2 id="bonus-3---encore-plus-court">Bonus 3 - Encore plus court</h2>

<p>Pour finir, on peut faire plus court avec Bash en utilisant <code>{0,1}</code> au lieu de
<code>{0..1}</code> puisqu’il y a seulement deux éléments :</p>

<p><code>bash
$ Dec2Bin=({0,1}{0,1}{0,1}{0,1}{0,1}{0,1}{0,1}{0,1});echo ${Dec2Bin[27]} 
00011011
</code></p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[3 réglages pour le langage R]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/04/23/3-reglages-pour-le-langage-r/"/>
    <updated>2015-04-23T15:17:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/04/23/3-reglages-pour-le-langage-r</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Voici trois astuces pour régler/personnaliser le comportement de
l’environnement du langage R, en utilisant des fichiers de configuration.
<em>(Attention, je ne sais absolument pas si ça fonctionne sous Windows.)</em></p>

<h2 id="le-prompt">1) Le prompt</h2>

<p>Pour personnaliser votre prompt dans R, ajoutez les lignes suivantes dans un
fichier <code>~/.Rprofile</code> (créez le pour l’occasion s’il n’existe pas).</p>

<p><code>r ~/.Rprofile
options(prompt = "R&gt; ")
options(continue = "+  ")
</code></p>

<p>Exemple :</p>

<pre><code>R&gt; add2 &lt;- function(n) {
+    n + 2
+  }
R&gt; 
</code></pre>

<!-- more -->

<h2 id="la-largeur-de-la-sortie-console">2) La largeur de la sortie console</h2>

<p>La largeur de la sortie console de R est de 80 caractères. Point barre !
Si votre console est plus large (100, 120, etc) R n’utilisera quand même que
80 caractères. En mettant une petite fonction dans un fichier à part
<code>~/.Rutils</code> (par exemple) et en référençant ce fichier depuis le <code>~/.Rprofile</code>,
on peut avoir quelque chose de <em>presque</em> dynamique.</p>

<p><code>r ~/.Rprofile
if (file.exists("~/.Rutils")) {
  source("~/.Rutils")
}
</code></p>

<p><code>r ~/.Rutils
tryCatch({
  options(width = as.integer(system('tput cols', intern = TRUE)))
}, error = function(err) {
  write("Width set to 80.", stderr());
  options(width = 80)
})
</code></p>

<p>Si vous redimensionnez votre console, il faut sourcer le fichier
(<code>source('~/.Rutils')</code>) pour prendre en compte la nouvelle largeur.</p>

<h2 id="le-dossier-des-bibliothques">3) Le dossier des bibliothèques</h2>

<p>Pour éviter que R vous crée un dossier <code>R</code> dans votre home, définissez vous
même un dossier pour stocker les packages, par exemple <code>~/local/R_libs/</code>.
Ensuite spécifiez le dans votre <code>~/.bashrc</code> :</p>

<p><code>bash
# Custom repo of libraries for R.
export R_LIBS=~/local/R_libs/
</code></p>

<p>Vous connaissez d’autres trucs et astuces pour configurer R ? Dites moi ça dans
un commentaire. À bientôt.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Comment mieux apprendre : La technique du rappel]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/04/21/comment-mieux-apprendre-la-technique-du-rappel/"/>
    <updated>2015-04-21T19:45:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/04/21/comment-mieux-apprendre-la-technique-du-rappel</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>J’ai participé récemment au MOOC
<a href="https://www.coursera.org/learn/learning-how-to-learn">Learning how to learn</a>
produit par
l’<a href="https://www.coursera.org/ucsd">université de San Diego, Californie</a>
et accessible sur <a href="https://www.coursera.org/courses">Coursera</a>.</p>

<p>Je cherchais des moyens, des trucs, des astuces, pour apprendre mieux. C’est à
dire plus rapidement et plus facilement. J’ai été servi. Les professeurs
Barbara Oakley et Terrence Sejnowski font un excellent travail. Je partagerai
avec vous quelques uns des trucs que j’ai appris en suivant ce cours, et je
vais commencer aujourd’hui par <strong>la technique du rappel</strong>.</p>

<p><img class="center" src="/images/total-recall.png"></p>

<!-- more -->

<h2 id="quoi">Quoi</h2>

<p>La technique du rappel (ou <em>recall</em> en anglais) consiste à faire un réel effort
après un bloc de travail pour se rappeler les points essentiels abordés pendant
ce bloc de travail.</p>

<p>Ça n’est vraiment pas plus que ça, mais ce simple truc va booster votre
capacité à apprendre en ancrant plus sûrement les connaissances toutes fraiches
dans votre mémoire.</p>

<p>Alors qu’est-ce que j’appelle <strong>un bloc de travail ?</strong> Ça peut être à peu près
tout et n’importe quoi ;) Un cours de 20 minutes, 30 minutes de lecture, une
conférence de 45 minutes, une séance de débugage d’une heure, une réunion de 3
heures, etc…</p>

<h2 id="pourquoi">Pourquoi</h2>

<p>Si on ne fait rien pour ancrer dans son cerveau les informations vues durant un
bloc de travail (tout spécialement si c’est de la théorie), celles-ci vont
disparaitre rapidement. Il est <strong>naturel</strong> que ces informations s’effacent si
on ne fait rien pour les retenir.</p>

<p>La technique du rappel évite aussi, dans une certaine mesure, l’<strong>illusion de
compétence</strong> (la fausse sensation d’avoir appris quelque chose) en mettant
l’accent très vite sur les points non acquis ou délicats.</p>

<h2 id="comment">Comment</h2>

<p>La meilleure mise en œuvre que j’ai pu trouver est de prendre quelques
dizaines de secondes (rarement plus d’une minute) à la fin d’un bloc de travail
pour écrire les points essentiels. Ça peut être 2 ou 3 phrases, une liste, un
schéma, ou tout ce que vous jugerez pertinent.</p>

<p>Deux remarques : (i) Prendre des notes pendant le bloc de travail ne dispense
pas de mettre en œuvre la technique du rappel, (ii) Penser aux quelques points
essentiels abordés pendant le bloc de travail ne suffit pas, il faut vraiment
les écrire.</p>

<p><strong>C’est une habitude toute simple, qui se prend très vite, et qui peut vraiment vous
permettre d’apprendre plus rapidement et plus facilement.</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les sous-ensembles de listes dans R]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/04/09/les-sous-ensembles-de-listes-dans-r/"/>
    <updated>2015-04-09T07:47:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/04/09/les-sous-ensembles-de-listes-dans-r</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Après avoir parlé des <a href="http://lkdjiin.github.io/blog/2015/04/07/les-sous-ensembles-dans-r/">sous-ensembles de vecteurs</a> dans le langage R,
c’est maintenant le tour des listes. En R, une liste peut contenir des
types différents, au contraire du vecteur, limité à un seul type.
Prenons par exemple la liste suivante :</p>

<p><code>rconsole
&gt; x &lt;- list(1, 2, c("a", "b"))
</code></p>

<p>À l’affichage, on remarque qu’il s’agit d’une liste grâce aux doubles crochets
(<code>[[]]</code>) :</p>

<p>``` rconsole
&gt; x
[[1]]
[1] 1</p>

<p>[[2]]
[1] 2</p>

<p>[[3]]
[1] “a” “b”
```</p>

<!-- more -->

<p>Les éléments d’une liste peuvent être nommés. Suivant votre langage de
prédilection, vous pouvez penser à une liste R comme à un hash, un dictionnaire,
un tableau associatif, etc :</p>

<p>``` rconsole
&gt; x &lt;- list(foo = 1, bar = 2, baz = c(“a”, “b”))
&gt; x
$foo
[1] 1</p>

<p>$bar
[1] 2</p>

<p>$baz
[1] “a” “b”
```</p>

<p>Que se passe-t-il si on utilise la même syntaxe qu’avec un vecteur pour extraire
un élément d’une liste ?</p>

<p><code>rconsole
&gt; x[3]
$baz
[1] "a" "b"
</code></p>

<p>L’idée c’est que l’opérateur <code>[]</code> renvoie le même type d’objet que l’objet sur
lequel il est appliqué. Donc utiliser <code>[]</code> sur une liste retourne une liste :</p>

<p><code>rconsole
&gt; class(x[3])
[1] "list"
</code></p>

<p>Pour aller chercher un élément, et pas une liste à un seul élément, il faut
utiliser l’opérateur double crochets (<code>[[]]</code>) :</p>

<p><code>rconsole
&gt; x[[3]]
[1] "a" "b"
</code></p>

<p>Lorsque les éléments sont nommés, on peut bien sûr utiliser leurs noms comme
clé :</p>

<p><code>rconsole
&gt; x$baz
[1] "a" "b"
</code></p>

<p>Nous pouvons extraire un sous-ensemble d’une liste en passant les indices à
l’opérateur crochet (<code>[]</code>) :</p>

<p>``` rconsole
&gt; x &lt;- list(1, “2”, 3, 4, 5)</p>

<blockquote>
  <p>x[c(1, 3, 5)]
[[1]]
[1] 1</p>
</blockquote>

<p>[[2]]
[1] 3</p>

<p>[[3]]
[1] 5
```</p>

<p>Ou bien en lui donnant un vecteur de booléens :</p>

<p>``` rconsole
&gt; x[c(F, T, F, T, F)]
[[1]]
[1] “2”</p>

<p>[[2]]
[1] 4
```</p>

<p>En faisant la même chose avec l’opérateur double crochets (<code>[[]]</code>) nous pouvons
extraire le nième élément d’un vecteur :</p>

<p>``` rconsole
&gt; x &lt;- list(c(1, 2, 3), c(“a”, “b”, “c”))</p>

<blockquote>
  <p>x[[c(2, 1)]]
[1] “a”
```</p>
</blockquote>

<p>Ce qu’on peut décomposer ainsi, d’abord le 2ème élément de la liste :</p>

<p><code>rconsole
&gt; x[[2]]
[1] "a" "b" "c"
</code></p>

<p>Puis le premier élément du vecteur, la syntaxe commence à devenir drôle :</p>

<p><code>rconsole
&gt; x[[2]][[1]]
[1] "a"
</code></p>

<p>Question pour les connaisseurs du langage R : le code précédent me suggère qu’un vecteur
<em>agit</em> aussi comme une liste et que l’opérateur double crochet (<code>[[]]</code>) n’est pas
limité aux listes. Par exemple :</p>

<p><code>rconsole
&gt; y &lt;- c("a", "b", "c")
&gt; y
[1] "a" "b" "c"
&gt; y[[2]]
[1] "b"
&gt; y[2]
[1] "b"
&gt; y[[2]] == y[2]
[1] TRUE
</code></p>

<p>Est-ce qu’il y a un intérêt à utiliser les double crochets avec des vecteurs ?</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les sous-ensembles dans R]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/04/07/les-sous-ensembles-dans-r/"/>
    <updated>2015-04-07T19:12:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/04/07/les-sous-ensembles-dans-r</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>J’apprends <a href="http://www.r-project.org/">le langage R</a> ! C’est cool d’apprendre de nouvelles choses.
C’est encore plus cool de les partager ;) Comme je suis vraiment tout neuf avec
R, c’est mon premier article sur ce langage. Et comme il faut bien commencer
quelque part, je vais vous parler de certains moyens d’obtenir des
sous-ensembles d’un vecteur (un vecteur c’est à peu près comme une liste).</p>

<p><img class="center" src="/images/subset.png"></p>

<!-- more -->

<p>On lance le REPL :</p>

<pre><code>$ R
</code></pre>

<p>On va créer un ensemble de notes (<em>grades</em>).  Le symbole <code>&lt;-</code> est l’opérateur
d’affectation. La fonction <code>c()</code>, elle, permet de fabriquer un vecteur, avec
ici 10 notes allant de 1 à 5. <code>c()</code> assure la concaténation :</p>

<pre><code>&gt; grades &lt;- c(1, 2, 3, 2, 3, 2, 1, 4, 5, 2)
</code></pre>

<p>On peut vérifier ce qu’il y a dans <code>grades</code>. Le <code>[1]</code> indique qu’il s’agit d’un
vecteur dont on commence l’affichage par le 1er élément. R indexe en commençant
par 1, et non pas comme souvent par zéro :</p>

<pre><code>&gt; grades
 [1] 1 2 3 2 3 2 1 4 5 2
</code></pre>

<p>Pour être sûr de comprendre cette histoire de vecteur et d’index, créons et
affichons un vecteur de 40 éléments à l’aide de la syntaxe <code>début:fin</code> :</p>

<pre><code>&gt; 1:40
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40
</code></pre>

<p>Alors ces sous-ensembles ? Et bien commençons par une indexation classique, avec
<code>[]</code>, pour retrouver un seul élément (en fait un vecteur d’un seul élément) :</p>

<pre><code>&gt; grades[1]
[1] 1
</code></pre>

<p>On peut aussi retrouver un <em>range</em>, par exemple du 6ème au 8ème élément :</p>

<pre><code>&gt; grades[6:8]
[1] 2 1 4
</code></pre>

<p>Pour retrouver seulement les notes au dessus de 2 on met la condition entre les
crochets :</p>

<pre><code>&gt; grades[grades &gt; 2]
[1] 3 3 4 5
</code></pre>

<p>Il est intéressant de voir ce qu’on obtient avec <code>grades &gt; 2</code> :</p>

<pre><code>&gt; grades &gt; 2
 [1] FALSE FALSE  TRUE FALSE  TRUE FALSE FALSE  TRUE  TRUE FALSE
</code></pre>

<p>On obtient un vecteur de valeurs booléennes ! <em>TRUE</em> si la note est supérieure
à 2, <em>FALSE</em> dans le cas contraire.</p>

<p>Rangeons ce vecteur de booléens dans une variable <code>mask</code> et servons nous de
cette nouvelle variable pour obtenir le sous-ensemble des notes supérieures
à 2 :</p>

<pre><code>&gt; mask &lt;- grades &gt; 2
&gt; grades[mask]
[1] 3 3 4 5
</code></pre>

<p>Pour finir, utilisons directement un vecteur de booléens pour récupérer les
éléments n° 4, 5, 6, 9 et 10 (<em>F</em> et <em>T</em> sont des raccourcis pour <em>FALSE</em> et
<em>TRUE</em>) :</p>

<pre><code>&gt; grades[c(F, F, F, T, T, T, F, F, T, T)]
[1] 2 3 2 5 2
</code></pre>

<p>Voilà, mon premier article sur R est terminé, je vais certainement en écrire
plein d’autres dans un futur proche. J’espère que ce sujet vous intéresse ;)</p>

<pre><code>&gt; q()
</code></pre>

<p></p>
]]></content>
  </entry>
  
</feed>
