<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : débutant | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/debutant/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2014-04-22T21:48:40+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Demandez conseil régulièrement]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/04/22/demandez-conseil-regulierement/"/>
    <updated>2014-04-22T21:43:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/04/22/demandez-conseil-regulierement</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Aujourd'hui je réparais un bug, rien de très compliqué, juste un
évènement qui n'était pas appelé. Et j'en ai profité pour faire un
refactoring: passer d'une grosse méthode de classe à quelque chose de
plus construit.</p>

<!-- more -->


<p>En gros on avait cette structure:</p>

<p>``` ruby
module Machin
  class Truc</p>

<pre><code>def self.foo(des, arguments)
  # Plusieurs
  # lignes
  # d'initialisation
  # de variables.
  # Plusieurs
  # lignes
  # de calculs
  # divers.
  # Et j'en passe
  # ...
end
</code></pre>

<p>  end
end
```</p>

<p>J'ai fait un refactoring dans ce genre:</p>

<p>```
module Machin
  class Truc</p>

<pre><code>def self.foo
  implementation = TrucImplementation.new(des, arguments)
  implementation.fait_ce_que_tu_as_a_faire
end

class TrucImplementation
  def initialize(des, arguments)
    # Initialisation.
  end

  def fait_ce_que_tu_as_a_faire
    # Ceci.
    # Cela.
  end

  private

  def ceci
    # ...
  end

  def cela
    # ...
  end
end
</code></pre>

<p>  end
end
```</p>

<p>Mais j'étais vraiment ennuyé avec ce nom <code>TrucImplementation</code>. Je trouvais
que ça ne faisait pas très Ruby. Bref j'avais un sentiment bizarre sur ce
code donc j'ai demandé aux collègues une revue de code en disant que
j'aimerais bien nommé ça autrement…</p>

<p>La réponse n'a pas tardée, simple et sybilline: «Tu passes juste les méthodes de
<code>TrucImplementation</code> dans <code>Truc</code> et plus de soucis».</p>

<p>Pourquoi je raconte ça ? Pour me rappeler que parfois, avoir le nez dans le
code trop longtemps fait que tu ne vois plus ce qui est évident. Il ne faut
pas hésiter à demander un coup de main ; un point de vue différent, ou juste
plus frais, peut vite faire une différence.</p>

<p>Je pense que je n'ai pas fini d'être chambré là-dessus ;)</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails 4.1 avec Spring, Rspec ou Minitest et Coco]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/04/21/rails-4-dot-1-avec-spring-rspec-ou-minitest-et-coco/"/>
    <updated>2014-04-21T21:15:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/04/21/rails-4-dot-1-avec-spring-rspec-ou-minitest-et-coco</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Rails 4.1 est sorti récemment. Une des nouveautés est qu'il est livré avec
<a href="https://github.com/rails/spring">Spring</a>, qui permet d'accélerer le
développement en gardant, en quelque sorte, l'application rails en mémoire.
Voici, très rapidement, comment configurer Rails 4.1 avec soit Rspec, soit
Minitest comme framework de test, et <a href="https://github.com/lkdjiin/coco">Coco</a> comme outil de <em>code coverage</em>.</p>

<!-- more -->


<p>Tout d'abord, l'installation de la dernière version de rails:</p>

<pre><code>gem install rails
</code></pre>

<p>Puis la création d'une application de test:</p>

<pre><code>rails new testappli -T
</code></pre>

<p>Ensuite, si vous utiliser <strong>Rspec</strong>, le Gemfile:</p>

<p>``` ruby Gemfile
group :development, :test do
  gem &lsquo;spring-commands-rspec&rsquo;
  gem &lsquo;rspec-rails&rsquo;
end</p>

<p>group :test do
  gem &lsquo;coco&rsquo;
end
```</p>

<p>L'installation des gems:</p>

<pre><code>bundle install
</code></pre>

<p>L'installation de rspec:</p>

<pre><code>rails g rspec:install
</code></pre>

<p>La création de <code>bin/rspec</code>:</p>

<pre><code>spring binstub --all
</code></pre>

<p>La mise en place de Coco dans le fichier <code>spec/spec_helper.rb</code>:</p>

<p>``` ruby spec/spec_helper.rb</p>

<h1>Toute dernière ligne (ou bien toute première, au choix)</h1>

<p>require &lsquo;coco&rsquo;
```</p>

<p>Finalement vous pouvez lancer les tests ainsi:</p>

<pre><code>bin/rspec
</code></pre>

<p>Si, au contraire, vous avez choisi <strong>Minitest</strong>, vous ajouterez ceci dans votre Gemfile:</p>

<p>``` ruby Gemfile
group :development, :test do
  gem &lsquo;minitest-rails&rsquo;, &lsquo;2.0.0.beta1&rsquo;
end</p>

<p>group :test do
  gem &lsquo;coco&rsquo;
end
```</p>

<p>Ensuite, l'installation:</p>

<pre><code>bundle install
rails g minitest:install 
</code></pre>

<p>La mise en place de Coco dans le fichier <code>test/test_helper.rb</code>:</p>

<p>``` ruby spec/spec_helper.rb</p>

<h1>Toute dernière ligne (ou bien toute première, au choix)</h1>

<p>require &lsquo;coco&rsquo;
```</p>

<p>Finalement vous pouvez lancer les tests ainsi:</p>

<pre><code>bin/rake
</code></pre>

<p>Ou bien:</p>

<pre><code>bin/rake test
</code></pre>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Plugin vim-refactor pour Ruby]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/04/15/plugin-vim-refactor-pour-ruby/"/>
    <updated>2014-04-15T21:23:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/04/15/plugin-vim-refactor-pour-ruby</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Voici un plugin Vim issu d'une expérience qu'on mène avec un collègue:
<a href="https://github.com/lkdjiin/vim-refactor">vim-refactor</a>.
Il fonctionne pour l'instant sur du code Ruby et permet d'extraire une
méthode.</p>

<!-- more -->


<p>À partir de ce genre de code:</p>

<p>``` ruby
class HelloWorld</p>

<p>  def greet</p>

<pre><code>greeting = "Hello World!"
puts greeting
</code></pre>

<p>  end</p>

<p>end
```</p>

<p>En étant positionné sur la ligne 4, et en appelant <code>:ExtractMethod</code>
(ou bien sûr un mapping quelconque) vous obtenez ceci:</p>

<p>``` ruby
class HelloWorld</p>

<p>  def greet</p>

<pre><code>puts greeting
</code></pre>

<p>  end</p>

<p>  def greeting</p>

<pre><code>"Hello World!"
</code></pre>

<p>  end
end
```</p>

<p>C'est vraiment une version <em>alpha</em>. On espère implémenter d'autres types
de refactoring et supporter d'autres langages.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Introduction à l'introspection en Ruby]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/04/08/introduction-a-lintrospection-en-ruby/"/>
    <updated>2014-04-08T21:23:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/04/08/introduction-a-lintrospection-en-ruby</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>L'introspection consiste à obtenir des informations sur un objet au
moment de l'exécution d'un programme. Voyons à quoi ça ressemble.</p>

<!-- more -->


<p>Créons une classe <code>Inspector</code> qui va extraire certaines informations
des objets qu'on lui donnera:</p>

<p>``` ruby introspection.rb
class Inspector
  class &lt;&lt; self</p>

<pre><code>def classname(o)
  o.class.name
end

def methods(c)
  c.instance_methods(false)
end

def parameters(o, m)
  o.method(m).parameters
end
</code></pre>

<p>  end
end
```</p>

<p>Dans cet exemple nous allons récupérer le nom de la classe, le nom des
méthodes et certaines informations sur les arguments des méthodes.</p>

<p>Voyons comment ça marche en récupérant le nom de la classe <code>Object</code>:</p>

<p>``` irb</p>

<blockquote><blockquote><p>load &lsquo;./introspection.rb&rsquo;
p Inspector.classname(Object.new)
&ldquo;Object&rdquo;
```</p></blockquote></blockquote>

<p>Maintenant ajoutons une classe <code>C</code> avec quelques méthodes:</p>

<p>``` ruby introspection.rb
class Inspector
  class &lt;&lt; self</p>

<pre><code>def classname(o)
  o.class.name
end

def methods(c)
  c.instance_methods(false)
end

def parameters(o, m)
  o.method(m).parameters
end
</code></pre>

<p>  end
end</p>

<p>class C
  def foo
  end</p>

<p>  def bar(arg1, arg2)
  end</p>

<p>  def baz(arg1, *args, &amp;block)
  end
end
```</p>

<p>Les méthodes de la classe <code>C</code> ne font rien. C'est normal, ce qui nous
intéresse ici c'est leur signature. D'abord le nom de la classe:</p>

<p>``` irb</p>

<blockquote><blockquote><p>load &lsquo;./introspection.rb&rsquo;
p Inspector.classname(C.new)
&ldquo;C&rdquo;
```</p></blockquote></blockquote>

<p>Facile. Maintenant récupérons les méthodes:</p>

<p>``` irb</p>

<blockquote><blockquote><p>p Inspector.methods&copy;
[:foo, :bar, :baz]
```</p></blockquote></blockquote>

<p>Pas mal. Encore plus fort, inspectons les arguments de chacune des
méthodes:</p>

<p>``` irb</p>

<blockquote><blockquote><p>Inspector.methods&copy;.each do |m|
?>   p Inspector.parameters(C.new, m)
end
[]
[[:req, :arg1], [:req, :arg2]]
[[:req, :arg1], [:rest, :args], [:block, :block]]
```</p></blockquote></blockquote>

<p>Voilà, c'était une rapide mise en bouche du <em>comment faire ?</em>.
Pour le <em>à quoi ça sert ?</em>, il faudra attendre un prochain article ;)</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Le duck typing avec Ruby]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/04/07/le-duck-typing-avec-ruby/"/>
    <updated>2014-04-07T21:19:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/04/07/le-duck-typing-avec-ruby</id>
    <content type="html"><![CDATA[<p>Vous faites du Ruby depuis peu ? Vous venez d'un langage
orienté objet plus <em>classique</em>, comme par exemple Java ?
Vous entendez parler de <strong>duck typing</strong> régulièrement sans
trop voir de quoi il retourne ?
Aujourd'hui on voit ce qu'est le duck typing.</p>

<!-- more -->


<p>Pour la petite histoire, nous allons faire marcher (<em>walk</em>) des
rats (<em>Rat</em>) et des souris (<em>Mice</em>). Rat et souris étants des
mammifères (<em>Mammal</em>).</p>

<p>En mimant un langage comme Java, nous allons d'abord créer
une classe de base qui implémente une méthode <code>walk</code>:</p>

<p>``` ruby
class Mammal
  def walk</p>

<pre><code>raise NotImplementedError
</code></pre>

<p>  end
end</p>

<p>Mammal.new.walk
```</p>

<p>Vous remarquez que cette méthode <code>walk</code> soulève une
exception si elle est appelée. Elle n'est ici que pour nous
rappeler que les classes filles devront l'implémenter:</p>

<p><code>raw
$ ruby duck.rb
duck.rb:3:in `walk': NotImplementedError (NotImplementedError)
</code></p>

<p>Poursuivons le mimétisme Java en créant les classes <code>Rat</code> et
<code>Mice</code> qui héritent de <code>Mammal</code>, et qui donc implémentent
conciencieusement la méthode <code>walk</code></p>

<p>``` ruby
class Mammal
  def walk</p>

<pre><code>raise NotImplementedError
</code></pre>

<p>  end
end</p>

<p>class Rat &lt; Mammal
  def walk</p>

<pre><code>"I am a Rat and I walk"
</code></pre>

<p>  end
end</p>

<p>class Mice &lt; Mammal
  def walk</p>

<pre><code>"I am a Mice and I walk"
</code></pre>

<p>  end
end</p>

<p>puts Rat.new.walk
puts Mice.new.walk
```</p>

<p>Le résultat est celui qu'on attend:</p>

<p><code>raw
$ ruby duck.rb
I am a Rat and I walk
I am a Mice and I walk
</code></p>

<p>Maintenant ajoutons une classe <code>Laboratory</code> qui a pour rôle
de manipuler nos animaux, en les faisant marcher à la
demande:</p>

<p>``` ruby
class Mammal
  def walk</p>

<pre><code>raise NotImplementedError
</code></pre>

<p>  end
end</p>

<p>class Rat &lt; Mammal
  def walk</p>

<pre><code>"I am a Rat and I walk"
</code></pre>

<p>  end
end</p>

<p>class Mice &lt; Mammal
  def walk</p>

<pre><code>"I am a Mice and I walk"
</code></pre>

<p>  end
end</p>

<p>class Laboratory
  def self.make_walk(pet)</p>

<pre><code>pet.walk
</code></pre>

<p>  end
end</p>

<p>puts Laboratory.make_walk(Rat.new)
puts Laboratory.make_walk(Mice.new)
```</p>

<p><code>raw
$ ruby duck.rb
I am a Rat and I walk
I am a Mice and I walk
</code></p>

<p>Et là, si vous venez d'un langage orienté objet dit
<em>classique</em>, vous devriez avoir tiqué, fait la grimace,
vous être gratté la barbe, etc. Et oui, la classe
<code>Laboratory</code> n'a <em>aucune connaissance</em> de la classe
<code>Mammal</code>. Et pourtant la ligne <code>pet.walk</code> fonctionne
comme un charme. C'est parce que nous sommes en Ruby,
un langage <em>dynamique</em>. On pourrait dire un langage qui
n'a que faire des <em>types</em> (bon c'est exagéré, hein).</p>

<p>Si <code>Laboratory</code> n'utilise pas <code>Mammal</code>, on pourrait
peut-être carrément la supprimer ?
On essaye :</p>

<p>``` ruby
class Rat
  def walk</p>

<pre><code>"I am a Rat and I walk"
</code></pre>

<p>  end
end</p>

<p>class Mice
  def walk</p>

<pre><code>"I am a Mice and I walk"
</code></pre>

<p>  end
end</p>

<p>class Laboratory
  def self.make_walk(pet)</p>

<pre><code>pet.walk
</code></pre>

<p>  end
end</p>

<p>puts Laboratory.make_walk(Rat.new)
puts Laboratory.make_walk(Mice.new)
```</p>

<p><code>raw
$ ruby duck.rb
I am a Rat and I walk
I am a Mice and I walk
</code></p>

<p>C'est ça le duck typing. On ne s'intéresse pas à ce
<strong>qu'est</strong> l'objet mais à ce <strong>qu'il sait faire</strong>.</p>

<p>Alors ça ne veut pas dire pour autant que l'héritage est
inutile ou inutilisé avec Ruby. Mais simplement qu'on
va l'utiliser moins qu'ailleurs parce que 1) on peut le
faire et 2) parce qu'on va se concentrer sur le
comportement et pas sur l'être.</p>

<p>Voilà, c'était une explication parmi d'autres du
duck typing.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
