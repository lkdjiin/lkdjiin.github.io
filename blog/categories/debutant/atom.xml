<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : débutant | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/debutant/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2014-04-13T21:52:43+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Introduction à l'introspection en Ruby]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/04/08/introduction-a-lintrospection-en-ruby/"/>
    <updated>2014-04-08T21:23:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/04/08/introduction-a-lintrospection-en-ruby</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>L'introspection consiste à obtenir des informations sur un objet au
moment de l'exécution d'un programme. Voyons à quoi ça ressemble.</p>

<!-- more -->


<p>Créons une classe <code>Inspector</code> qui va extraire certaines informations
des objets qu'on lui donnera:</p>

<p>``` ruby introspection.rb
class Inspector
  class &lt;&lt; self</p>

<pre><code>def classname(o)
  o.class.name
end

def methods(c)
  c.instance_methods(false)
end

def parameters(o, m)
  o.method(m).parameters
end
</code></pre>

<p>  end
end
```</p>

<p>Dans cet exemple nous allons récupérer le nom de la classe, le nom des
méthodes et certaines informations sur les arguments des méthodes.</p>

<p>Voyons comment ça marche en récupérant le nom de la classe <code>Object</code>:</p>

<p>``` irb</p>

<blockquote><blockquote><p>load &lsquo;./introspection.rb&rsquo;
p Inspector.classname(Object.new)
&ldquo;Object&rdquo;
```</p></blockquote></blockquote>

<p>Maintenant ajoutons une classe <code>C</code> avec quelques méthodes:</p>

<p>``` ruby introspection.rb
class Inspector
  class &lt;&lt; self</p>

<pre><code>def classname(o)
  o.class.name
end

def methods(c)
  c.instance_methods(false)
end

def parameters(o, m)
  o.method(m).parameters
end
</code></pre>

<p>  end
end</p>

<p>class C
  def foo
  end</p>

<p>  def bar(arg1, arg2)
  end</p>

<p>  def baz(arg1, *args, &amp;block)
  end
end
```</p>

<p>Les méthodes de la classe <code>C</code> ne font rien. C'est normal, ce qui nous
intéresse ici c'est leur signature. D'abord le nom de la classe:</p>

<p>``` irb</p>

<blockquote><blockquote><p>load &lsquo;./introspection.rb&rsquo;
p Inspector.classname(C.new)
&ldquo;C&rdquo;
```</p></blockquote></blockquote>

<p>Facile. Maintenant récupérons les méthodes:</p>

<p>``` irb</p>

<blockquote><blockquote><p>p Inspector.methods&copy;
[:foo, :bar, :baz]
```</p></blockquote></blockquote>

<p>Pas mal. Encore plus fort, inspectons les arguments de chacune des
méthodes:</p>

<p>``` irb</p>

<blockquote><blockquote><p>Inspector.methods&copy;.each do |m|
?>   p Inspector.parameters(C.new, m)
end
[]
[[:req, :arg1], [:req, :arg2]]
[[:req, :arg1], [:rest, :args], [:block, :block]]
```</p></blockquote></blockquote>

<p>Voilà, c'était une rapide mise en bouche du <em>comment faire ?</em>.
Pour le <em>à quoi ça sert ?</em>, il faudra attendre un prochain article ;)</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Le duck typing avec Ruby]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/04/07/le-duck-typing-avec-ruby/"/>
    <updated>2014-04-07T21:19:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/04/07/le-duck-typing-avec-ruby</id>
    <content type="html"><![CDATA[<p>Vous faites du Ruby depuis peu ? Vous venez d'un langage
orienté objet plus <em>classique</em>, comme par exemple Java ?
Vous entendez parler de <strong>duck typing</strong> régulièrement sans
trop voir de quoi il retourne ?
Aujourd'hui on voit ce qu'est le duck typing.</p>

<!-- more -->


<p>Pour la petite histoire, nous allons faire marcher (<em>walk</em>) des
rats (<em>Rat</em>) et des souris (<em>Mice</em>). Rat et souris étants des
mammifères (<em>Mammal</em>).</p>

<p>En mimant un langage comme Java, nous allons d'abord créer
une classe de base qui implémente une méthode <code>walk</code>:</p>

<p>``` ruby
class Mammal
  def walk</p>

<pre><code>raise NotImplementedError
</code></pre>

<p>  end
end</p>

<p>Mammal.new.walk
```</p>

<p>Vous remarquez que cette méthode <code>walk</code> soulève une
exception si elle est appelée. Elle n'est ici que pour nous
rappeler que les classes filles devront l'implémenter:</p>

<p><code>raw
$ ruby duck.rb
duck.rb:3:in `walk': NotImplementedError (NotImplementedError)
</code></p>

<p>Poursuivons le mimétisme Java en créant les classes <code>Rat</code> et
<code>Mice</code> qui héritent de <code>Mammal</code>, et qui donc implémentent
conciencieusement la méthode <code>walk</code></p>

<p>``` ruby
class Mammal
  def walk</p>

<pre><code>raise NotImplementedError
</code></pre>

<p>  end
end</p>

<p>class Rat &lt; Mammal
  def walk</p>

<pre><code>"I am a Rat and I walk"
</code></pre>

<p>  end
end</p>

<p>class Mice &lt; Mammal
  def walk</p>

<pre><code>"I am a Mice and I walk"
</code></pre>

<p>  end
end</p>

<p>puts Rat.new.walk
puts Mice.new.walk
```</p>

<p>Le résultat est celui qu'on attend:</p>

<p><code>raw
$ ruby duck.rb
I am a Rat and I walk
I am a Mice and I walk
</code></p>

<p>Maintenant ajoutons une classe <code>Laboratory</code> qui a pour rôle
de manipuler nos animaux, en les faisant marcher à la
demande:</p>

<p>``` ruby
class Mammal
  def walk</p>

<pre><code>raise NotImplementedError
</code></pre>

<p>  end
end</p>

<p>class Rat &lt; Mammal
  def walk</p>

<pre><code>"I am a Rat and I walk"
</code></pre>

<p>  end
end</p>

<p>class Mice &lt; Mammal
  def walk</p>

<pre><code>"I am a Mice and I walk"
</code></pre>

<p>  end
end</p>

<p>class Laboratory
  def self.make_walk(pet)</p>

<pre><code>pet.walk
</code></pre>

<p>  end
end</p>

<p>puts Laboratory.make_walk(Rat.new)
puts Laboratory.make_walk(Mice.new)
```</p>

<p><code>raw
$ ruby duck.rb
I am a Rat and I walk
I am a Mice and I walk
</code></p>

<p>Et là, si vous venez d'un langage orienté objet dit
<em>classique</em>, vous devriez avoir tiqué, fait la grimace,
vous être gratté la barbe, etc. Et oui, la classe
<code>Laboratory</code> n'a <em>aucune connaissance</em> de la classe
<code>Mammal</code>. Et pourtant la ligne <code>pet.walk</code> fonctionne
comme un charme. C'est parce que nous sommes en Ruby,
un langage <em>dynamique</em>. On pourrait dire un langage qui
n'a que faire des <em>types</em> (bon c'est exagéré, hein).</p>

<p>Si <code>Laboratory</code> n'utilise pas <code>Mammal</code>, on pourrait
peut-être carrément la supprimer ?
On essaye :</p>

<p>``` ruby
class Rat
  def walk</p>

<pre><code>"I am a Rat and I walk"
</code></pre>

<p>  end
end</p>

<p>class Mice
  def walk</p>

<pre><code>"I am a Mice and I walk"
</code></pre>

<p>  end
end</p>

<p>class Laboratory
  def self.make_walk(pet)</p>

<pre><code>pet.walk
</code></pre>

<p>  end
end</p>

<p>puts Laboratory.make_walk(Rat.new)
puts Laboratory.make_walk(Mice.new)
```</p>

<p><code>raw
$ ruby duck.rb
I am a Rat and I walk
I am a Mice and I walk
</code></p>

<p>C'est ça le duck typing. On ne s'intéresse pas à ce
<strong>qu'est</strong> l'objet mais à ce <strong>qu'il sait faire</strong>.</p>

<p>Alors ça ne veut pas dire pour autant que l'héritage est
inutile ou inutilisé avec Ruby. Mais simplement qu'on
va l'utiliser moins qu'ailleurs parce que 1) on peut le
faire et 2) parce qu'on va se concentrer sur le
comportement et pas sur l'être.</p>

<p>Voilà, c'était une explication parmi d'autres du
duck typing.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Comment réduire les erreurs de frappe dans la console]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/04/06/comment-reduire-les-erreurs-de-frappe-dans-la-console/"/>
    <updated>2014-04-06T20:52:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/04/06/comment-reduire-les-erreurs-de-frappe-dans-la-console</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Régulièrement j'analyse mon fichier <code>~/.bash_history</code>.
Régulièrement ça veut dire 2 ou 3 fois par an. Et je regarde ce qui revient
le plus pour voir si je peux en transformer certaines en alias.
Quel rapport avec les fautes de frappe ?</p>

<!-- more -->


<p>La dernière fois que je l'ai regardé, ce fameux fichier <code>~/.bash_history</code>,
j'ai trouvé un nombre non négligeable de lignes qui débutaient par <code>gti</code>.
Et oui, j'écris souvent <code>gti</code> au lieu de <code>git</code> ! On a tous des petits
défauts de ce type, non ?</p>

<p>J'imagine que nombre d'entre vous ont déjà ce genre de choses dans
leur fichier <code>~/.bashrc</code> (ou <code>~/.bash_profile</code>), mais pour ceux qui n'y
avait pas encore pensé, la solution consiste à faire un alias:</p>

<p><code>bash
alias gti='git'
</code></p>

<p>Alors d'accord, le titre de cet article ment un peu ;) Ça ne réduit pas
mes fautes de frappes, mais ça les rend transparentes, c'est déjà très bien.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vim - Un plugin pour markdown - partie 9]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/04/04/vim-un-plugin-pour-markdown-partie-9/"/>
    <updated>2014-04-04T21:26:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/04/04/vim-un-plugin-pour-markdown-partie-9</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Je voudrais maintenant tester que ma fonction pour passer un mot en
italique fonctionne sur le dernier mot de la phrase, lorsque celui-ci
n'a qu'un seul caractère…</p>

<!-- more -->


<p>Voilà le test Vader:</p>

<p>``` raw
Given (a line whose the last word is of length 1):
  abc def ghi j</p>

<p>Execute (starting at the end of the last word who is of length 1):
  execute &ldquo;normal! fj&rdquo;
  QuickMarkdownItalic</p>

<p>Expect (last word in italic):
  abc def ghi <em>j</em>
```</p>

<p>Et malheureusement, il échoue:</p>

<p>``` raw</p>

<pre><code>(4/4) [  GIVEN] a line whose the last word is of length 1
(4/4) [EXECUTE] starting at the end of the last word who is of length 1
(4/4) [ EXPECT] (X) last word in italic
  - Expected:
      abc def ghi *j*
  - Got:
      abc def ghi j
</code></pre>

<p>```</p>

<p>Je m'attendais à un échec, mais pas à celui-ci ! Je pensais obtenir ceci:</p>

<pre><code>abc def *ghi* j
</code></pre>

<p>Donc je trouve ça assez bizarre et j'écris deux autres tests sur le dernier
mot d'une phrase, quand ce mot est d'une longueur correcte:</p>

<p>```
Given (some text):
  abc def ghi jkl mno</p>

<p>Execute (from the beginning of the last word):
  execute &ldquo;normal! fm&rdquo;
  QuickMarkdownItalic</p>

<p>Expect (last word in italic):
  abc def ghi jkl <em>mno</em></p>

<p>Execute (from the end of the last word):
  execute &ldquo;normal! fo&rdquo;
  QuickMarkdownItalic</p>

<p>Expect (last word in italic):
  abc def ghi jkl <em>mno</em>
```</p>

<p>Là encore le test qui débute sur le dernier caractère échoue de la même
manière, c'est à dire sans avoir ajouter aucun <code>*</code>.</p>

<p>J'ai déjà entendu dire que Vim pouvait faire des choses bizarres quand
on se trouve à la fin d'une phrase. Je ne sais pas si c'est cela ou la
logique de ma fonction qui est en cause, c'est toujours un mystère et
j'espère avoir le temps ce week-end pour investiguer.</p>

<p>En attendant que je m'y mette, si vous avez des pistes, je suis preneur ;)</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ActiveRecord - Voir la requête SQL pendant l'écriture des tests]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/04/03/activerecord-voir-la-requete-sql-pendant-lecriture-des-tests/"/>
    <updated>2014-04-03T20:58:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/04/03/activerecord-voir-la-requete-sql-pendant-lecriture-des-tests</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Cet après-midi, avec un collègue, on écrivait des tests pour une requête
en base de données avec ActiveRecord. Et on a eu besoin d'étudier le
code SQL qui était généré.</p>

<!-- more -->


<p>On aurait pu lancer une console et jouer avec ActiveRecord dedans, mais
le setup nécessaire pour accéder à l'objet sur lequel on travaillait est
assez long à mettre en place. On voulait plutôt faire rapidement:</p>

<ol>
<li>On bidouille la requête ActiveRecord.</li>
<li>On lance le test.</li>
<li>On examine le code SQL.</li>
<li>On recommence tant que ça ne nous convient pas.</li>
</ol>


<p>Pour ça, placez la ligne suivante dans votre fichier de test et le tour
est joué.</p>

<p><code>ruby
ActiveRecord::Base.logger = Logger.new(STDOUT)
</code></p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
