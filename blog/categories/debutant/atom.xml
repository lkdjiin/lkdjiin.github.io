<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : débutant | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/debutant/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2013-10-24T10:34:09+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Apprendre Ruby en faisant des maths 2]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/10/23/apprendre-ruby-en-faisant-des-maths-2/"/>
    <updated>2013-10-23T09:54:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/10/23/apprendre-ruby-en-faisant-des-maths-2</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>On a vu, <a href="http://lkdjiin.github.io/blog/2013/10/21/apprendre-ruby-en-faisant-des-maths/">précédemment</a>,
comment savoir si un nombre d est un diviseur de n avec <code>8 % 2</code> et
comment obtenir une liste de nombre avec <code>1..8</code>. Maintenant on peut
apprendre à sélectionner les nombres qui nous intéressent dans cette liste.</p>

<!-- more -->


<p>Pour cela, nous allons utiliser la méthode <code>select</code>:</p>

<p>``` irb</p>

<blockquote><blockquote><p>(1..8).select {|int| 8 % int == 0 }
=> [1, 2, 4, 8]
```</p></blockquote></blockquote>

<p>Et voilà, nous avons nos diviseurs de 8. La méthode <code>select</code> utilise un
bloc d'instructions (ce qui se trouve entre les <code>{}</code>). Cette (ou ces)
instruction va être exécutée sur chaque éléments de <code>1..8</code>, c'est à dire
sur 1, 2, 3, 4, 5 ,6, 7 puis enfin 8. Ici, l'instruction exécutée sur les
éléments est <code>8 % int == 0</code>. En clair on teste si le reste de la division
de 8 par <code>int</code> égal zéro. Qu'est-ce que c'est que ce <code>int</code> ? Et bien c'est
l'élément en cours de traitement, c'est à dire 1, puis 2, et ensuite 3, etc
jusqu'à 8. <code>int</code> est simplement un nom qu'on a donné pour pouvoir se
référer à l'élément en cours, ce nom est indiqué entre deux caractères <code>|</code>,
comme dans <code>|int|</code>. On peut lui donner le nom qu'on veut, par exemple:</p>

<p>``` irb</p>

<blockquote><blockquote><p>(1..8).select {|xavier| 8 % xavier == 0 }
=> [1, 2, 4, 8]
```</p></blockquote></blockquote>

<p>Pour information, <em>int</em> est le diminutif de integer, qui signifie
nombre entier en anglais.</p>

<p>Comment Ruby sait qu'il doit sélectionner 2 et pas 3 ? Regardons cela de
plus près:</p>

<p>``` irb</p>

<blockquote><blockquote><p>8 % 2 == 0
=> true
8 % 3 == 0
=> false
```</p></blockquote></blockquote>

<p>Le résultat d'un test, ici l'égalité avec <code>==</code> est soit vrai (true), soit
faux (false). Lorsque l'instruction dans le bloc (<code>{}</code>) renvoie true, l'élément
est sélectionné, lorsqu'elle renvoie false, l'élément est éliminé.</p>

<p>Vous devriez vérifier maintenant que ça fonctionne bien avec n'importe
quel nombre entier positif:</p>

<p>``` irb</p>

<blockquote><blockquote><p>(1..1).select {|int| 1 % int == 0 }
=> [1]
(1..41).select {|int| 41 % int == 0 }
=> [1, 41]
(1..417).select {|int| 417 % int == 0 }
=> [1, 3, 139, 417]
(1..4179).select {|int| 4179 % int == 0 }
=> [1, 3, 7, 21, 199, 597, 1393, 4179]
```</p></blockquote></blockquote>

<p>La prochaine fois, on verra comment créer nos propres méthodes.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Apprendre Ruby en faisant des maths]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/10/21/apprendre-ruby-en-faisant-des-maths/"/>
    <updated>2013-10-21T21:09:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/10/21/apprendre-ruby-en-faisant-des-maths</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>J'ai eu récemment à aider quelqu'un en mathématique (niveau 3ème), et ce
quelqu'un connaissait un peu Ruby. On a joué avec le langage pour faire
des maths. C'était drôle et intéressant. Ça m'a donné l'idée de
continuer cette affaire sur mon blog. Cette nouvelle série d'articles
s'adresse à celles et ceux qui débutent Ruby et qui ont un niveau de math de
3ème.</p>

<!-- more -->


<p>Le premier problème auquel on va essayer de répondre en utilisant Ruby est
le suivant:</p>

<p><blockquote><p>Afficher toutes les paires de nombres amiables jusqu'à 10.000.</p></blockquote></p>

<p>Si vous avez besoin de vous rafraichir la mémoire sur les nombres
amiables, voici <a href="http://fr.wikipedia.org/wiki/Nombre_amical">l'article de wikipédia</a>.
Et en voici une définition rapide:</p>

<p>si <em>f</em>(n) est une fonction qui calcule la
somme des diviseurs stricts de n, alors n et m sont amiables si
<em>f</em>(n) = m et <em>f</em>(m) = n.</p>

<h2>Obtenir les diviseurs d'un nombre</h2>

<p>La première chose à faire est de calculer les diviseurs d'un nombre n.
Pour mémoire, les diviseurs de 8, par exemple, sont 1 ; 2 ; 4 et 8.
Pour les trouver, une méthode consiste à diviser 8 par chaque nombre de 1 à 8
et à regarder le reste de la division. Si il reste 0, c'est un diviseur, sinon
ce n'est pas un diviseur. En Ruby, calculer le reste d'une division se fait
avec l'opérateur <code>%</code> (le modulo):</p>

<p>``` irb
[~]⇒ irb</p>

<blockquote><blockquote><p>8 % 1
0
8 % 2
0
8 % 3
2
8 % 4
0
8 % 5
3
8 % 6
2
8 % 7
1
8 % 8
0
```</p></blockquote></blockquote>

<p>On voit bien que les diviseurs de 8, soit 1, 2, 4 et 8 renvoient bien 0.
Évidemment, il n'est pas question de se taper tout ces chiffres <em>à la main</em>,
imaginez un peu que vous vouliez connaitre les diviseurs de 123456789 !
Il nous faut quelque chose pour produire automatiquement les nombres de 1 à
n. En Ruby, on appelle ça un <code>Range</code>:</p>

<p>``` irb</p>

<blockquote><blockquote><p>1..8
1..8
```</p></blockquote></blockquote>

<p>Pour y voir plus clair, on va appeler la méthode <code>to_a</code> sur ce <code>Range</code>, qui
va nous le transformer en un tableau (<code>Array</code>). Vous pouvez pensez à un
tableau comme à une simple liste:</p>

<p>``` irb</p>

<blockquote><blockquote><p>(1..8).to_a
[1, 2, 3, 4, 5, 6, 7, 8]
```</p></blockquote></blockquote>

<p>On a bien une liste des nombres de 1 à 8. Notez que les parenthèses sont ici
nécessaires, sinon la méthode <code>to_a</code> serait appelée sur le chiffre 8, et
c'est pas bon:</p>

<p>``` irb</p>

<blockquote><blockquote><p>1..8.to_a
NoMethodError: undefined method `to_a' for 8:Fixnum
```</p></blockquote></blockquote>

<p>La prochaine fois on verra comment sélectionner dans cette liste seulement
les nombres qui nous intéressent, c'est à dire les diviseurs.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby 2.0: Tableaux littéraux pour les symboles]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/10/17/ruby-2-dot-0-tableaux-litteraux-pour-les-symboles/"/>
    <updated>2013-10-17T10:48:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/10/17/ruby-2-dot-0-tableaux-litteraux-pour-les-symboles</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>La version 2.0 de Ruby gagne une nouvelle syntaxe pour la définition
de tableaux de symboles : <code>%i</code>.</p>

<p>On a maintenant le choix pour définir un tableau de symboles entre les deux
syntaxes suivantes:</p>

<p>``` ruby
[:voici, :plusieurs, :symboles]</p>

<p>%i( voici plusieurs symboles )
```</p>

<!-- more -->


<p>On y gagne en clarté mais aussi, le langage y gagne en cohérence. On est
habitué à utiliser <code>%w</code> pour les tableaux de chaînes de caractères, il n'y
avait pas de raison pour qu'on ne puisse pas le faire avec des symboles.
J'aime beaucoup cette nouvelle possibilité, même si je ne vois pas
le rapport entre la lettre <code>i</code> et les symboles…</p>

<p>Il existe aussi une version qui permet l'interpolation, c'est <code>%I</code> (avec
un i majuscule). Vous pouvez voir la différence entre <code>%i</code> et <code>%I</code> dans la
session suivante:</p>

<p>``` irb</p>

<blockquote><blockquote><p>%i( #{&ldquo;bé&rdquo; + &ldquo;po&rdquo;} azerty )
[</p>

<pre><code>[0] :"\#{\"bé\"",
[1] :+,
[2] :"\"po\"}",
[3] :azerty
</code></pre>

<p>]
%I( #{&ldquo;bé&rdquo; + &ldquo;po&rdquo;} azerty )
[</p>

<pre><code>[0] :bépo,
[1] :azerty
</code></pre>

<p>]
```</p></blockquote></blockquote>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby 2.0: Les arguments nommés]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/10/14/ruby-2-dot-0-les-arguments-nommes/"/>
    <updated>2013-10-14T19:04:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/10/14/ruby-2-dot-0-les-arguments-nommes</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Les arguments nommés étaient absents de Ruby jusqu'à sa version 2.0, curieux
pour un langage qui fait tellement penser à Smalltalk.</p>

<!-- more -->


<p>Il était bien sûr possible de les <em>simuler</em> en utilisant un hash, un peu
comme ce qu'on fait en Javascript:</p>

<p><code>ruby
def person(opts = {})
  defaults = {name: "toto", age: 99}
  opts = defaults.merge opts
  puts opts[:name]
  puts opts[:age]
end
</code></p>

<p>Mais bof. Ça ressemble à tout sauf à du Ruby. C'est un <em>hack</em>, un truc, une
astuce, tout ce qu'on veut mais ça ne s'intègre pas au langage.
Voici la même méthode, avec cette fois-ci des arguments nommés:</p>

<p><code>ruby
def person(name: "toto", age: 99)
  puts name
  puts age
end
</code></p>

<p>Et voici comment différentes manières d'appeler cette méthode:</p>

<p><code>ruby
person
person name: "oscar"
person age: 18
person name: "oscar", age: 18
person age: 18, name: "oscar"
</code></p>

<p>Cool, ça fonctionne dans tous les sens. Par contre, pas question d'oublier
le nom de l'argument:</p>

<p><code>irb
person "oscar", 18
ArgumentError: wrong number of arguments (2 for 0)
</code></p>

<p>On peut aussi mélanger arguments normaux et nommés, à condition que les
arguments nommés viennent après. Le code suivant est valide:</p>

<p>``` ruby
def person(name, age: 99)
  puts name
  puts age
end</p>

<p>person &ldquo;oscar&rdquo;
```</p>

<p>Mais pas celui-ci:</p>

<p>``` irb</p>

<blockquote><blockquote><p>def person(age: 99, name)
end
SyntaxError: (irb):1: syntax error, unexpected tIDENTIFIER
def person(age: 99, name)</p>

<pre><code>                    ^
</code></pre>

<p>```</p></blockquote></blockquote>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vim: Créez des présentations avec Vimdeck]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/10/13/vim-creez-des-presentations-avec-vimdeck/"/>
    <updated>2013-10-13T13:17:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/10/13/vim-creez-des-presentations-avec-vimdeck</id>
    <content type="html"><![CDATA[<p>Vimdeck est un programme écrit en Ruby qui transforme un fichier texte au
format Markdown en plusieurs <em>slides</em> pour effectuer une présentation avec
l'éditeur de texte Vim !</p>

<!-- more -->


<h2>Installation</h2>

<p>Installez tout d'abord le plugin Vim <a href="https://github.com/vim-scripts/SyntaxRange">SyntaxRange</a>.</p>

<p>Ensuite, installez le programme de manière classique:</p>

<pre><code>gem install vimdeck
</code></pre>

<p>Note: J'ai eu un problème de dépendance (sur Debian) et il a fallu installer la
librairie systême <code>libmagickwand-dev</code> pour que tout fonctionne bien.</p>

<h2>Utilisation</h2>

<p>Maintenant on écrit notre présentation au format Markdown, par exemple:</p>

<pre><code># Premier slide

- Premier point
- Second point
- Troisième point


# Deuxième slide

- Premier
{~- Deuxième point~}
{~- Troisième point~}


# Troisième et dernier slide

```ruby
class Foo
  def bar
    puts "Hello Vimdeck!"
  end
end
```
</code></pre>

<p>Et on lance la présentation ainsi:</p>

<pre><code>vimdeck mon_fichier.md
</code></pre>

<p>Ensuite, on change de slide avec les touches PageUp/PageDown.</p>

<p>Vous pouvez voir des captures d'écrans sur le <a href="https://github.com/tybenz/vimdeck">site du projet</a>.</p>

<h2>Conclusion</h2>

<p>Bon, le projet est un peu jeune et pas mal buggé, mais l'idée est vraiment
intéressante. C'est totalement improbable, complêtement loufoque, inutilisable
avec des graphiques, donc
rigoureusement indispensable, ne serait-ce que pour frimer devant les
collègues: «Regardez comment je fais une présentation en 3 minutes avec mon
éditeur de texte…».</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
