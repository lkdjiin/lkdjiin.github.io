<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : débutant | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/debutant/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2013-11-07T18:19:59+01:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Prise en main de la gem chunky_png]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/11/07/prise-en-main-de-la-gem-chunky-png/"/>
    <updated>2013-11-07T17:32:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/11/07/prise-en-main-de-la-gem-chunky-png</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Pour un projet j'ai besoin de manipuler du format png et j'ai décidé
d'utiliser la gem <code>chunky_png</code> pour faire ça. Comme je ne la connais pas,
j'écris aujourd'hui une rapide prise en main de cette gem, histoire de me
familiariser avec.</p>

<p>Pour l'installer, c'est comme d'habitude:</p>

<pre><code>gem install chunky_png
</code></pre>

<!-- more -->


<p>Pour la documentation on pourra commencer par <a href="https://github.com/wvanbergen/chunky_png/wiki">le wiki</a> du projet.</p>

<p>La première chose que je veux faire c'est lire et écrire un fichier png.</p>

<p>``` ruby test.rb
require &ldquo;chunky_png&rdquo;</p>

<p>image = ChunkyPNG::Image.from_file(ARGV[0])
image.save(&ldquo;copy.png&rdquo;)
```</p>

<p>Après l'avoir lancé, ce programme crée une copie de l'image originale sous le
nom &ldquo;copy.png&rdquo;:</p>

<pre><code>[~]⇒ ruby test.rb test.png 
</code></pre>

<p>Super, bon début. Maintenant je voudrais accéder à la valeur RGB d'un pixel
quelconque de l'image. Voici le second programme:</p>

<p>``` ruby test2.rb
require &ldquo;chunky_png&rdquo;</p>

<p>image = ChunkyPNG::Image.from_file(ARGV[0])</p>

<p>p ChunkyPNG::Color.r(image[0, 0])
p ChunkyPNG::Color.g(image[20, 20])
p ChunkyPNG::Color.b(image[40, 40])
p ChunkyPNG::Color.to_hex(image[60, 60])
p ChunkyPNG::Color.to_truecolor_bytes(image[80, 80])
```</p>

<p>Et un exemple de sortie possible:</p>

<pre><code>[~]⇒ ruby test2.rb test.png 
255
255
255
"#000000ff"
[0, 0, 0]
</code></pre>

<p>L'image est vue comme un tableau à 2 dimensions: <code>image[x, y]</code>.
Les méthodes <code>r</code>, <code>g</code> et <code>b</code> renvoient respectivement la composante rouge,
verte ou bleue du pixel. La méthode <code>to_hex</code> formate <em>à la HTML</em> et la
méthode <code>to_truecolor_bytes</code> renvoie un tableau des trois composantes RGB.</p>

<p>J'aimerais maintenant dessiner un rectangle dans l'image:</p>

<p>``` ruby test3.rb
require &ldquo;chunky_png&rdquo;</p>

<p>image = ChunkyPNG::Image.from_file(ARGV[0])
image.rect(0, 0, 99, 99)
image.save(&ldquo;copy.png&rdquo;)
```</p>

<p>Si vous lancez ce programme (avec <code>ruby test3.rb test.png</code>), vous verrez
qu'il dessine bien un rectangle (x = 0, y = 0, largeur = 99, hauteur = 99).
Malheureusement, seul le <em>contour</em> du rectangle est dessiné.
Pour dessiner un rectangle rempli, il en faut un peu plus:</p>

<p>``` ruby test4.rb
require &ldquo;chunky_png&rdquo;</p>

<p>my_color = ChunkyPNG::Color.rgb(10, 100, 200)</p>

<p>image = ChunkyPNG::Image.from_file(ARGV[0])
image.rect(0, 0, 99, 99, my_color, my_color)
image.save(&ldquo;copy.png&rdquo;)
```</p>

<p>Cette fois on a bien un rectangle <em>rempli</em>. Et au passage on voit comment
définir une couleur au format RGB.</p>

<p>Pour finir, je voudrais créer une image:</p>

<p>``` ruby test5.png
require &ldquo;chunky_png&rdquo;</p>

<p>image = ChunkyPNG::Image.new(400,</p>

<pre><code>                         400,
                         ChunkyPNG::Color::WHITE)
</code></pre>

<p>my_color = ChunkyPNG::Color.rgb(10, 100, 200)
my_color2 = ChunkyPNG::Color.rgb(110, 10, 100)</p>

<p>image.rect(0, 0, 199, 199, my_color, my_color)
image.rect(200, 200, 399, 399, my_color2, my_color2)</p>

<p>image.save(&ldquo;new.png&rdquo;)
```</p>

<p>Le programme se lance avec <code>ruby test5.rb</code> et crée une nouvelle image <code>new.png</code>.
Le constructeur de <code>Image</code> prend tout simplement la largeur, la hauteur et
la couleur de fond de l'image.</p>

<p>En bref, <code>chunky_png</code> est une gem qui a l'air simple a utiliser.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Racket pour les rubyists 2: Produire une suite de nombre]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/11/06/racket-pour-les-rubyists-2-produire-une-suite-de-nombre/"/>
    <updated>2013-11-06T19:10:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/11/06/racket-pour-les-rubyists-2-produire-une-suite-de-nombre</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>La <a href="http://lkdjiin.github.io/blog/2013/11/03/racket-pour-les-rubyists-definir-une-fonction/">dernière fois</a>
on a vu comment définir une fonction en Racket. Aujourd'hui on va essayer
de traduire la méthode Ruby suivante:</p>

<p><code>ruby
def divisors(n)
  (1..n).select {|i| n % i == 0}
end
</code></p>

<!-- more -->


<p>Tout d'abord, j'ai envie découper cette méthode en trois parties plus petites:</p>

<ol>
<li><code>1..n</code>, pour produire une suite de nombre.</li>
<li><code>select</code>, qui est la méthode utilisée pour conserver/supprimer certains
éléments.</li>
<li><code>n % i == 0</code>, qui est un test pour savoir si i est un diviseur de n.</li>
</ol>


<h2>Produire une suite de nombre</h2>

<p>On s'intéresse d'abord à la 1ère partie. Racket possède la fonction <code>range</code>,
qui produit une liste de nombre. En fournissant un seul argument, n, <code>range</code>
produit une liste de 0 à n <em>non-inclus</em>:</p>

<pre><code>-&gt; (range 4)
'(0 1 2 3)
</code></pre>

<p>En fournissant deux arguments, m et n, <code>range</code> produit une liste de m à n
<em>non-inclus</em>:</p>

<pre><code>-&gt; (range 1 4)
'(1 2 3)
</code></pre>

<p>Pour être exhaustif, il existe une dernière possibilité, avec 3 arguments
m, n et p, pour produire une liste
de m à n <em>non-inclus</em> par pas de p:</p>

<pre><code>-&gt; (range 10 20 3)
'(10 13 16 19)
</code></pre>

<p>Pour produire une liste de m à n <em>inclus</em>, il faut falloir augmenter n de 1:</p>

<pre><code>-&gt; (define n 4)
-&gt; (range 1 (+ n 1))
'(1 2 3 4)
</code></pre>

<p>Vous notez au passage la manière de définir une variable, identique à la
définition d'une méthode, ainsi que la façon dont Racket écrit une liste:</p>

<ul>
<li>entre parenthèses</li>
<li>précédée par un apostrophe</li>
<li>pas de virgule pour séparer les éléments</li>
</ul>


<p>Le prochain article abordera le test d'égalité en Racket.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Racket pour les Rubyists: Définir une fonction]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/11/03/racket-pour-les-rubyists-definir-une-fonction/"/>
    <updated>2013-11-03T15:06:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/11/03/racket-pour-les-rubyists-definir-une-fonction</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Racket est un langage dérivé de Scheme que je suis en train d'apprendre.
Je vais m'inspirer de ma série d'articles
<a href="http://lkdjiin.github.io/blog/2013/10/21/apprendre-ruby-en-faisant-des-maths/">Apprendre Ruby en faisant des maths</a>
pour expliquer les bases de Racket en le comparant à Ruby. Si vous
connaissez un peu Ruby, j'espère que vous n'aurez aucun mal à suivre
ces articles. On commence aujourd'hui avec la définition d'une fonction.</p>

<!-- more -->


<p>J'utiliserais la version 5.3.6 de Racket et la version 2.0 de Ruby.
Au début, on va utiliser le REPL, pour Ruby on a <code>irb</code>, pour Racket on
a <code>racket</code>.</p>

<h2>Définir une fonction</h2>

<p>Racket a des fonctions et Ruby a des méthodes, mais ça ne fait aucune
différence pour l'instant. Voyons comment définir une fonction <code>addition</code>,
qui va calculer et renvoyer la somme de deux arguments, <code>a</code> et <code>b</code>:</p>

<pre><code>[~]⇒ racket
-&gt; (define (addition a b)
     (+ a b))
-&gt; (addition 12 34)
46
</code></pre>

<p>Comparons immédiatement avec la version Ruby:</p>

<pre><code>[~]⇒ irb
&gt;&gt; def addition(a, b)
&gt;&gt;   a + b
&gt;&gt; end
nil
&gt;&gt; addition 12, 34
46
</code></pre>

<p>Première remarque: avec Racket les parenthèses sont <strong>très importantes</strong>.
On est obligé de les utilisées, et de les utilisées correctement.</p>

<p>Deuxième remarque: Ruby utilise la notation <em>infix</em> (<code>a + b</code>) alors que
Racket utilise la notation <em>prefix</em> (<code>+ a b</code>). Étrange au début si vous
n'avez jamais utilisé ce genre de truc, on s'y fait très vite.</p>

<p>Troisième remarque: avec Racket les arguments ne sont pas séparés par des
virgules.</p>

<p>Enfin, Ruby utilise des mots clés (<code>def</code> et <code>end</code>) pour délimiter un
bloc/ensemble d'instructions alors que Racket utilise simplement les
parenthèses.</p>

<p><strong>Exercice</strong>: Sur le même modèle que la fonction <code>addition</code>, définissez et
utilsez les fonctions <code>soustraction</code> et <code>multiplication</code>. Voici les solutions:</p>

<p>``` racket
(define (soustraction a b)
  (&ndash; a b))</p>

<p>(soustraction 17 7)</p>

<p>(define (multiplication a b)
  (* a b))</p>

<p>(multiplication 2 3)
```</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vim: Coloration syntaxique des parenthèses]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/11/02/vim-coloration-syntaxique-des-parentheses/"/>
    <updated>2013-11-02T12:04:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/11/02/vim-coloration-syntaxique-des-parentheses</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Je l'ai annoncé sur ce blog, je suis en train d'apprendre Racket (dérivé de
Scheme, de Lisp). Donc un langage qui fait un très large usage des
parenthèses.</p>

<p><img src="/images/rainbow-parentheses.png"></p>

<!-- more -->


<p>C'est là que le plugin <a href="http://www.vim.org/scripts/script.php?script_id=3772">Rainbow Parentheses</a> peut aider.
Il colore les parenthèses différement suivant le niveau d'imbrication.
Il n'est pas activé par défaut, et c'est tant mieux: ce type de coloration
syntaxique n'est pas utile tout le temps, mais seulement à certains moments,
quand on se sent un peu perdu
(<em>sinon, bonjour l'effet sapin de Noël</em>). Pour l'activer/le désactiver, il suffit de
taper:</p>

<p><code>vim
:RainbowParenthesesToggle
</code></p>

<p>Si vous l'utilsez régulièrement, il sera sûrement utile de mapper la fonction
précédente. Par exemple pour l'avoir en tapant la touche <code>leader</code> puis <code>p</code>,
vous ajouterez ceci dans votre .vimrc:</p>

<p><code>vim
map &lt;Leader&gt;p :RainbowParenthesesToggle&lt;Enter&gt;
</code></p>

<p>Le plugin Rainbow Parentheses peut aussi colorer d'autres paires de caractères,
comme <code>[]</code>, <code>{}</code> et <code>&lt;&gt;</code>. Consultez le readme pour en savoir plus.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Apprendre Ruby en faisant des maths 6: méthodes utilitaires et module]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/11/01/apprendre-ruby-en-faisant-des-maths-6-methodes-utilitaires-et-module/"/>
    <updated>2013-11-01T21:54:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/11/01/apprendre-ruby-en-faisant-des-maths-6-methodes-utilitaires-et-module</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Dans les articles précédents, nous avons définis trois méthodes:
<code>divisors</code>, <code>proper_divisors</code> et <code>sum_of_proper_divisors</code>.
Ces trois méthodes commencent à former ce qu'on appelle une
collection, ou un ensemble, de méthodes utilitaires. Nous allons
aujourd'hui les regrouper dans un module.</p>

<!-- more -->


<p>Pour l'instant nous n'avons que trois méthodes, et elles portent toutes
sur les nombres. Mais nous allons bientôt en ajouter d'autres, peut-être
beaucoup d'autres. Certaines porteront peut-être sur la géométrie ou les
probabilités ? Il est plus propre de regrouper entre elles les méthodes
qui traitent du même sujet, alors pourquoi attendre ?</p>

<p>Voici comment on peut regrouper nos méthodes au sein du module <code>Number</code>:</p>

<p>``` ruby number.rb
module Number
  def self.divisors(n)</p>

<pre><code>(1..n).select {|i| n % i == 0 }
</code></pre>

<p>  end</p>

<p>  def self.proper_divisors(n)</p>

<pre><code>divisors(n)[0..-2]
</code></pre>

<p>  end</p>

<p>  def self.sum_of_proper_divisors(n)</p>

<pre><code>proper_divisors(n).reduce(:+)
</code></pre>

<p>  end
end
```</p>

<p>Vous voyez que les méthodes sont insérées à l'intérieur de:</p>

<p><code>ruby
module Number
end
</code></p>

<p>Vous voyez aussi qu'on a ajouté <code>self.</code> devant le nom de chaque méthode.
Cela indique à Ruby qu'on veut utiliser ces méthodes sans pour autant
avoir à créer un objet (<em>si vous ne savez pas encore ce qu'est un objet,
ne vous inquiétez pas, nous n'en avons pas besoin pour l'instant</em>).</p>

<p>Voici une seconde manière de regrouper nos méthodes au sein du module <code>Number</code>:</p>

<p>``` ruby number.rb
module Number
  class &lt;&lt; self</p>

<pre><code>def divisors(n)
  (1..n).select {|i| n % i == 0 }
end

def proper_divisors(n)
  divisors(n)[0..-2]
end

def sum_of_proper_divisors(n)
  proper_divisors(n).reduce(:+)
end
</code></pre>

<p>  end
end
```</p>

<p>Cette deuxième syntaxe, qui peut sembler un peu bizarre si vous la
rencontrez pour la première fois, fait exactement la même chose que
la première syntaxe. Avec Ruby, il y a souvent plusieurs façons de dire
une même chose.
Je ne vais pas expliquer cette syntaxe aujourd'hui, mais sachez qu'elle
est très prisée dans la communauté Ruby et que vous la rencontrerez
souvent. Vous pouvez choisir celle que vous voulez.</p>

<p>Notez que, <strong>par convention</strong>, le module Number doit être enregistré
dans le fichier <code>number.rb</code>. Il n'y a pas d'obligation, mais avouez
que ça facilite grandement les choses.</p>

<h2>Comment utiliser un module ?</h2>

<p><strong>Première solution</strong>, vous pouvez écrire votre code à la suite du module:</p>

<p>``` ruby number.rb
module Number
  class &lt;&lt; self</p>

<pre><code>def divisors(n)
  (1..n).select {|i| n % i == 0 }
end

def proper_divisors(n)
  divisors(n)[0..-2]
end

def sum_of_proper_divisors(n)
  proper_divisors(n).reduce(:+)
end
</code></pre>

<p>  end
end</p>

<p>puts Number.sum_of_proper_divisors 8
```</p>

<p>Puis vous lancez le programme:</p>

<pre><code>[~/]⇒ ruby number.rb 
7
</code></pre>

<p><strong>Deuxième solution</strong>, vous lancez irb, <em>dans le même dossier</em> que le fichier
<code>number.rb</code> et vous chargez le module:</p>

<pre><code>[~/]⇒ irb
&gt;&gt; require "./number"
true
&gt;&gt; Number.sum_of_proper_divisors 8
7
</code></pre>

<p><strong>Troisième solution</strong>, vous écrivez un programme dans un fichier séparé, par
exemple <code>test.rb</code>, <em>dans le même dossier</em> que le fichier
<code>number.rb</code>:</p>

<p>``` ruby test.rb
require &ldquo;./number&rdquo;</p>

<p>puts Number.sum_of_proper_divisors 8
```</p>

<p>Puis vous le lancez:</p>

<pre><code>[~/]⇒ ruby test.rb
7
</code></pre>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
