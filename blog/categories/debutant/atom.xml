<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : débutant | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/debutant/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2014-04-07T22:03:35+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Le duck typing avec Ruby]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/04/07/le-duck-typing-avec-ruby/"/>
    <updated>2014-04-07T21:19:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/04/07/le-duck-typing-avec-ruby</id>
    <content type="html"><![CDATA[<p>Vous faites du Ruby depuis peu ? Vous venez d'un langage
orienté objet plus <em>classique</em>, comme par exemple Java ?
Vous entendez parler de <strong>duck typing</strong> régulièrement sans
trop voir de quoi il retourne ?
Aujourd'hui on voit ce qu'est le duck typing.</p>

<!-- more -->


<p>Pour la petite histoire, nous allons faire marcher (<em>walk</em>) des
rats (<em>Rat</em>) et des souris (<em>Mice</em>). Rat et souris étants des
mammifères (<em>Mammal</em>).</p>

<p>En mimant un langage comme Java, nous allons d'abord créer
une classe de base qui implémente une méthode <code>walk</code>:</p>

<p>``` ruby
class Mammal
  def walk</p>

<pre><code>raise NotImplementedError
</code></pre>

<p>  end
end</p>

<p>Mammal.new.walk
```</p>

<p>Vous remarquez que cette méthode <code>walk</code> soulève une
exception si elle est appelée. Elle n'est ici que pour nous
rappeler que les classes filles devront l'implémenter:</p>

<p><code>raw
$ ruby duck.rb
duck.rb:3:in `walk': NotImplementedError (NotImplementedError)
</code></p>

<p>Poursuivons le mimétisme Java en créant les classes <code>Rat</code> et
<code>Mice</code> qui héritent de <code>Mammal</code>, et qui donc implémentent
conciencieusement la méthode <code>walk</code></p>

<p>``` ruby
class Mammal
  def walk</p>

<pre><code>raise NotImplementedError
</code></pre>

<p>  end
end</p>

<p>class Rat &lt; Mammal
  def walk</p>

<pre><code>"I am a Rat and I walk"
</code></pre>

<p>  end
end</p>

<p>class Mice &lt; Mammal
  def walk</p>

<pre><code>"I am a Mice and I walk"
</code></pre>

<p>  end
end</p>

<p>puts Rat.new.walk
puts Mice.new.walk
```</p>

<p>Le résultat est celui qu'on attend:</p>

<p><code>raw
$ ruby duck.rb
I am a Rat and I walk
I am a Mice and I walk
</code></p>

<p>Maintenant ajoutons une classe <code>Laboratory</code> qui a pour rôle
de manipuler nos animaux, en les faisant marcher à la
demande:</p>

<p>``` ruby
class Mammal
  def walk</p>

<pre><code>raise NotImplementedError
</code></pre>

<p>  end
end</p>

<p>class Rat &lt; Mammal
  def walk</p>

<pre><code>"I am a Rat and I walk"
</code></pre>

<p>  end
end</p>

<p>class Mice &lt; Mammal
  def walk</p>

<pre><code>"I am a Mice and I walk"
</code></pre>

<p>  end
end</p>

<p>class Laboratory
  def self.make_walk(pet)</p>

<pre><code>pet.walk
</code></pre>

<p>  end
end</p>

<p>puts Laboratory.make_walk(Rat.new)
puts Laboratory.make_walk(Mice.new)
```</p>

<p><code>raw
$ ruby duck.rb
I am a Rat and I walk
I am a Mice and I walk
</code></p>

<p>Et là, si vous venez d'un langage orienté objet dit
<em>classique</em>, vous devriez avoir tiqué, fait la grimace,
vous être gratté la barbe, etc. Et oui, la classe
<code>Laboratory</code> n'a <em>aucune connaissance</em> de la classe
<code>Mammal</code>. Et pourtant la ligne <code>pet.walk</code> fonctionne
comme un charme. C'est parce que nous sommes en Ruby,
un langage <em>dynamique</em>. On pourrait dire un langage qui
n'a que faire des <em>types</em> (bon c'est exagéré, hein).</p>

<p>Si <code>Laboratory</code> n'utilise pas <code>Mammal</code>, on pourrait
peut-être carrément la supprimer ?
On essaye :</p>

<p>``` ruby
class Rat
  def walk</p>

<pre><code>"I am a Rat and I walk"
</code></pre>

<p>  end
end</p>

<p>class Mice
  def walk</p>

<pre><code>"I am a Mice and I walk"
</code></pre>

<p>  end
end</p>

<p>class Laboratory
  def self.make_walk(pet)</p>

<pre><code>pet.walk
</code></pre>

<p>  end
end</p>

<p>puts Laboratory.make_walk(Rat.new)
puts Laboratory.make_walk(Mice.new)
```</p>

<p><code>raw
$ ruby duck.rb
I am a Rat and I walk
I am a Mice and I walk
</code></p>

<p>C'est ça le duck typing. On ne s'intéresse pas à ce
<strong>qu'est</strong> l'objet mais à ce <strong>qu'il sait faire</strong>.</p>

<p>Alors ça ne veut pas dire pour autant que l'héritage est
inutile ou inutilisé avec Ruby. Mais simplement qu'on
va l'utiliser moins qu'ailleurs parce que 1) on peut le
faire et 2) parce qu'on va se concentrer sur le
comportement et pas sur l'être.</p>

<p>Voilà, c'était une explication parmi d'autres du
duck typing.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Comment réduire les erreurs de frappe dans la console]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/04/06/comment-reduire-les-erreurs-de-frappe-dans-la-console/"/>
    <updated>2014-04-06T20:52:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/04/06/comment-reduire-les-erreurs-de-frappe-dans-la-console</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Régulièrement j'analyse mon fichier <code>~/.bash_history</code>.
Régulièrement ça veut dire 2 ou 3 fois par an. Et je regarde ce qui revient
le plus pour voir si je peux en transformer certaines en alias.
Quel rapport avec les fautes de frappe ?</p>

<!-- more -->


<p>La dernière fois que je l'ai regardé, ce fameux fichier <code>~/.bash_history</code>,
j'ai trouvé un nombre non négligeable de lignes qui débutaient par <code>gti</code>.
Et oui, j'écris souvent <code>gti</code> au lieu de <code>git</code> ! On a tous des petits
défauts de ce type, non ?</p>

<p>J'imagine que nombre d'entre vous ont déjà ce genre de choses dans
leur fichier <code>~/.bashrc</code> (ou <code>~/.bash_profile</code>), mais pour ceux qui n'y
avait pas encore pensé, la solution consiste à faire un alias:</p>

<p><code>bash
alias gti='git'
</code></p>

<p>Alors d'accord, le titre de cet article ment un peu ;) Ça ne réduit pas
mes fautes de frappes, mais ça les rend transparentes, c'est déjà très bien.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vim - Un plugin pour markdown - partie 9]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/04/04/vim-un-plugin-pour-markdown-partie-9/"/>
    <updated>2014-04-04T21:26:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/04/04/vim-un-plugin-pour-markdown-partie-9</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Je voudrais maintenant tester que ma fonction pour passer un mot en
italique fonctionne sur le dernier mot de la phrase, lorsque celui-ci
n'a qu'un seul caractère…</p>

<!-- more -->


<p>Voilà le test Vader:</p>

<p>``` raw
Given (a line whose the last word is of length 1):
  abc def ghi j</p>

<p>Execute (starting at the end of the last word who is of length 1):
  execute &ldquo;normal! fj&rdquo;
  QuickMarkdownItalic</p>

<p>Expect (last word in italic):
  abc def ghi <em>j</em>
```</p>

<p>Et malheureusement, il échoue:</p>

<p>``` raw</p>

<pre><code>(4/4) [  GIVEN] a line whose the last word is of length 1
(4/4) [EXECUTE] starting at the end of the last word who is of length 1
(4/4) [ EXPECT] (X) last word in italic
  - Expected:
      abc def ghi *j*
  - Got:
      abc def ghi j
</code></pre>

<p>```</p>

<p>Je m'attendais à un échec, mais pas à celui-ci ! Je pensais obtenir ceci:</p>

<pre><code>abc def *ghi* j
</code></pre>

<p>Donc je trouve ça assez bizarre et j'écris deux autres tests sur le dernier
mot d'une phrase, quand ce mot est d'une longueur correcte:</p>

<p>```
Given (some text):
  abc def ghi jkl mno</p>

<p>Execute (from the beginning of the last word):
  execute &ldquo;normal! fm&rdquo;
  QuickMarkdownItalic</p>

<p>Expect (last word in italic):
  abc def ghi jkl <em>mno</em></p>

<p>Execute (from the end of the last word):
  execute &ldquo;normal! fo&rdquo;
  QuickMarkdownItalic</p>

<p>Expect (last word in italic):
  abc def ghi jkl <em>mno</em>
```</p>

<p>Là encore le test qui débute sur le dernier caractère échoue de la même
manière, c'est à dire sans avoir ajouter aucun <code>*</code>.</p>

<p>J'ai déjà entendu dire que Vim pouvait faire des choses bizarres quand
on se trouve à la fin d'une phrase. Je ne sais pas si c'est cela ou la
logique de ma fonction qui est en cause, c'est toujours un mystère et
j'espère avoir le temps ce week-end pour investiguer.</p>

<p>En attendant que je m'y mette, si vous avez des pistes, je suis preneur ;)</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ActiveRecord - Voir la requête SQL pendant l'écriture des tests]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/04/03/activerecord-voir-la-requete-sql-pendant-lecriture-des-tests/"/>
    <updated>2014-04-03T20:58:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/04/03/activerecord-voir-la-requete-sql-pendant-lecriture-des-tests</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Cet après-midi, avec un collègue, on écrivait des tests pour une requête
en base de données avec ActiveRecord. Et on a eu besoin d'étudier le
code SQL qui était généré.</p>

<!-- more -->


<p>On aurait pu lancer une console et jouer avec ActiveRecord dedans, mais
le setup nécessaire pour accéder à l'objet sur lequel on travaillait est
assez long à mettre en place. On voulait plutôt faire rapidement:</p>

<ol>
<li>On bidouille la requête ActiveRecord.</li>
<li>On lance le test.</li>
<li>On examine le code SQL.</li>
<li>On recommence tant que ça ne nous convient pas.</li>
</ol>


<p>Pour ça, placez la ligne suivante dans votre fichier de test et le tour
est joué.</p>

<p><code>ruby
ActiveRecord::Base.logger = Logger.new(STDOUT)
</code></p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tester facilement vos dates avec Timecop]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/04/01/tester-facilement-vos-dates-avec-timecop/"/>
    <updated>2014-04-01T21:06:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/04/01/tester-facilement-vos-dates-avec-timecop</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p><a href="https://github.com/travisjeffery/timecop">Timecop</a>
n'est pas une nouvelle gem. Mais je ne la découvre qu'aujourd'hui.
Ça fait pourtant 4 ans que je travaille quotidiennement avec Ruby
et/ou Rails… Et je ne me suis jamais sentis très à l'aise pour tester
les dates. Avec Timecop, ça devient un jeu d'enfant.</p>

<!-- more -->


<p>Pour voir un souci possible, prenons la classe suivante qui représente
un article:</p>

<p>``` ruby article.rb
class Article
  def initialize(name)</p>

<pre><code>@name = name
@created_at = Time.now
</code></pre>

<p>  end</p>

<p>  attr_reader :name, :created_at
end
```</p>

<p>Dans le monde réel, ce serait surement un ActiveRecord, mais pour
l'exemple on se contentera bien de cette classe ;)</p>

<p>Maintenant testons la création d'un article:</p>

<p>``` ruby tc_article.rb
require_relative &ldquo;article&rdquo;
require &ldquo;test/unit&rdquo;</p>

<p>class TestArticle &lt; Test::Unit::TestCase
  def test_creation</p>

<pre><code>article = Article.new('Foo')
assert_equal 'Foo', article.name
assert_equal Time.now, article.created_at
</code></pre>

<p>  end
end
```</p>

<p>Et voilà le souci, à quelques nano-secondes près ça pète:</p>

<p>``` bash
$ ruby tc_article.rb
Run options:</p>

<h1>Running tests:</h1>

<p>[1/1] TestArticle#test_creation = 0.00 s
  1) Failure:
TestArticle#test_creation [tc_article.rb:8]:
&lt;2014-04-01 21:05:10 +0200> (204201[ns]) expected but was
&lt;2014-04-01 21:05:10 +0200> (176685[ns]).</p>

<p>Finished tests in 0.009979s, 100.2062 tests/s, 200.4125 assertions/s.
1 tests, 2 assertions, 1 failures, 0 errors, 0 skips
```</p>

<p>Timecop est la meilleure solution que j'ai vu jusqu'ici pour régler
ce type de problème. La gem propose tout simplement (entre autres)
<em>de geler le temps</em>:</p>

<p>``` ruby tc_article.rb
require_relative &ldquo;article&rdquo;
require &ldquo;test/unit&rdquo;
require &ldquo;timecop&rdquo;</p>

<p>class TestArticle &lt; Test::Unit::TestCase
  def test_creation</p>

<pre><code>Timecop.freeze do
  article = Article.new('Foo')
  assert_equal 'Foo', article.name
  assert_equal Time.now, article.created_at
end
</code></pre>

<p>  end
end
```</p>

<p>Et voilà le résultat:</p>

<p>``` bash
ruby tc_article.rb
Run options:</p>

<h1>Running tests:</h1>

<p>Finished tests in 0.010756s, 92.9747 tests/s, 185.9494 assertions/s.
1 tests, 2 assertions, 0 failures, 0 errors, 0 skips
```</p>

<p>J'aimerais bien savoir quelles solutions vous avez adoptés pour
régler ce genre de soucis…</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
