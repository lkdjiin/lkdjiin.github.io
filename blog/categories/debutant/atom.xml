<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : débutant | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/debutant/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2013-12-18T21:57:27+01:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Remplacer Sed et Awk par Ruby 13: Séparateurs en sortie]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/12/18/remplacer-sed-et-awk-par-ruby-13-separateurs-en-sortie/"/>
    <updated>2013-12-18T18:58:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/12/18/remplacer-sed-et-awk-par-ruby-13-separateurs-en-sortie</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>La dernière fois on a vu <a href="http://lkdjiin.github.io/blog/2013/12/17/remplacer-sed-et-awk-par-ruby-12-numero-de-ligne/">les numéros de lignes</a>, aujourd'hui on voit comment
modifier les séparateurs de champ et d'enregistrement.</p>

<!-- more -->


<p>On continue donc avec un exemple trivial, on a ce fichier de données:</p>

<p><code>raw data.txt
1,a
2,b
3,c
</code></p>

<p>On va intervertir les champs et modifier le séparateur de champs pour qu'il
devienne un point-virgule (pour le nom des variables prédéfinie, je vous
renvoie à l'article sur <a href="http://lkdjiin.github.io/blog/2013/12/14/remplacer-sed-et-awk-par-ruby-11-la-gem-english/">la gem English</a>):</p>

<p><code>ruby
BEGIN {
  require 'English'
  $FS = ','
  $OFS = ';'
}
$_ = $F.reverse.join
</code></p>

<p><code>join</code> va utiliser automatiquement le contenu de <code>$OFS</code>:</p>

<p><code>bash
[~]⇒ ruby -apl test1.rb data.txt
a;1
b;2
c;3
</code></p>

<p>Parfois on veut aussi modifier le séparateur d'enregistrements (les enregistrements
sont ici nos lignes du fichier). Par exemple, pour passer du caractère <em>newline</em> à
<code>:</code>:</p>

<p><code>ruby
BEGIN {
  require 'English'
  $FS = ','
  $OFS = ';'
  $ORS = ':'
}
$_ = $F.reverse.join
</code></p>

<p>Et le résultat:</p>

<p><code>bash
[~]⇒ ruby -apl test1.rb data.txt
a;1:b;2:c;3:
</code></p>

<p>Et bien sûr, si vous le voulez vraiment, vous pouvez toujours écrire ce
script en une ligne, directement dans la console:</p>

<p><code>bash
[~]⇒ ruby -aple 'BEGIN{$;=",";$,=";";$\=":"};$_=$F.reverse.join' data.txt
</code></p>

<p>Mais êtes-vous sûr de vouloir faire ça ?!</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Remplacer Sed et Awk par Ruby 12: Numéro de ligne]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/12/17/remplacer-sed-et-awk-par-ruby-12-numero-de-ligne/"/>
    <updated>2013-12-17T21:52:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/12/17/remplacer-sed-et-awk-par-ruby-12-numero-de-ligne</id>
    <content type="html"><![CDATA[<p>Après avoir vu l'utilité de <a href="http://lkdjiin.github.io/blog/2013/12/14/remplacer-sed-et-awk-par-ruby-11-la-gem-english/">la gem English</a>, on voit aujourd'hui une utilisation
des numéros de ligne pour créer un échantillon de données.</p>

<!-- more -->


<p>La variable prédéfinie <code>$.</code> contient le numéro de la ligne en cours de
traitement. Une utilisation de cette variable, que j'aime beaucoup, est
la création d'un petit échantillon (<em>sample</em>) de données, à partir d'un
long fichier.</p>

<p>Pour la démonstration, prenons un fichier de données de 33 lignes:</p>

<p><code>raw data.txt
1
2
3
.
.
.
33
</code></p>

<p>L'idée est de ne prendre qu'une ligne sur dix. Voilà le script:</p>

<p><code>ruby test.rb
puts $_ if $. % 10 == 0
</code></p>

<p>Ou, en utilisant la gem English:</p>

<p><code>ruby test1.rb
BEGIN { require 'English' }
puts $LAST_READ_LINE if $INPUT_LINE_NUMBER % 10 == 0
</code></p>

<p>La ligne en cours est affichée seulement quand le numéro de la ligne est
un multiple de 10:</p>

<p><code>bash
[~]⇒ ruby -n test.rb data.txt
10
20
30
</code></p>

<p>Intéressant quand on veut se créer rapidement un petit jeu de données pour
tester quelque chose…</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Remplacer Sed et Awk par Ruby 11: La gem English]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/12/14/remplacer-sed-et-awk-par-ruby-11-la-gem-english/"/>
    <updated>2013-12-14T16:59:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/12/14/remplacer-sed-et-awk-par-ruby-11-la-gem-english</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Après avoir vu <a href="http://lkdjiin.github.io/blog/2013/12/12/remplacer-sed-et-awk-par-ruby-10-un-exemple-dutilisation/">un exemple d'utilisation</a> du mode <em>sed/awk</em> de Ruby au travers
d'un <em>one liner</em>, on regarde aujourd'hui la gem English, qui facilite
énormement la
vie pour l'écriture des scripts.</p>

<!-- more -->


<p>On a vu jusqu'à présent deux variables globales, j'ai nommé <code>$_</code> et
<code>$;</code>. Ces noms sont justes barbares et imprononçables. Et des variables
globales de ce genre, il y en a quelques autres qui vont nous être utiles.
Voyons voir si vous êtes capable de deviner ce qu'elles représentent:
<code>$,</code>, <code>$\</code>, <code>$/</code> et <code>$.</code>. Vous avez deviné ? Non ? C'est là qu'entre en
jeu <a href="http://ruby-doc.org/stdlib-2.0.0/libdoc/English/rdoc/English.html">la gem English</a>. Cette gem va nous permettre d'accéder à ces
variables à l'aide de noms compréhensibles par le commun des mortels:</p>

<pre><code>   Nom court   Nom long
$; $FS         $FIELD_SEPARATOR
$, $OFS        $OUTPUT_FIELD_SEPARATOR 
$/ $RS         $INPUT_RECORD_SEPARATOR
$\ $ORS        $OUTPUT_RECORD_SEPARATOR
$. $NR         $INPUT_LINE_NUMBER
$_             $LAST_READ_LINE
</code></pre>

<p>Pour avoir accès à ceci dans un script, il faudra charger la gem dans
un bloc BEGIN:</p>

<p><code>ruby
BEGIN { require 'English' }
</code></p>

<p>Alors quand se servir des noms courts, des noms longs ? Tout dépend de
votre <em>background</em> et de votre tâche.</p>

<p>Si vous débutez en Ruby, si vous devez écrire un script long et/ou complexe,
si le script doit être maintenu pendant des mois ou plus, si il est maintenu
par plusieurs personnes, utilisez les noms longs.</p>

<p>Si vous (et votre équipe) avez une expérience de Awk, les noms courts peuvent
être une solution raisonnable.</p>

<p>Quand aux noms <em>barbares</em>, réservez les pour les <em>one liners</em>, les scripts
courts <em>one shot</em> et les séances de masochisme.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Remplacer Sed et Awk par Ruby 10: Un exemple d'utilisation]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/12/12/remplacer-sed-et-awk-par-ruby-10-un-exemple-dutilisation/"/>
    <updated>2013-12-12T21:05:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/12/12/remplacer-sed-et-awk-par-ruby-10-un-exemple-dutilisation</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Dans un <a href="http://lkdjiin.github.io/blog/2013/12/11/les-algorithmes-genetiques-demystifies-42-un-probleme-deconomie/">article précédent</a>
sur les algorithmes génétiques, je devais générer des valeurs aléatoires
<em>en dur</em> dans un fichier source Ruby. Le code ressemble à ce qui suit:</p>

<p>``` ruby
KnapsackItem.new(&lsquo;ACCOR&rsquo;, 32, 9, 60),
KnapsackItem.new(&lsquo;AIR_LIQUIDE&rsquo;, 97, 7, 32),
KnapsackItem.new(&lsquo;ALSTOM&rsquo;, 25, 5, 6),
KnapsackItem.new(&lsquo;ARCELORMITTAL_REG&rsquo;, 12, 9, 43),
KnapsackItem.new(&lsquo;AXA&rsquo;, 18, 2, 65),
KnapsackItem.new(&lsquo;BNP_PARIBAS&rsquo;, 53, 3, 24),</p>

<h1>&hellip;</h1>

<p>```</p>

<p>Le dernier nombre de chaque ligne doit être compris entre 1 et 100.
Voici comment faire en utilisant ce qu'on a appris depuis le début
de cette série <a href="http://lkdjiin.github.io/blog/2013/11/29/remplacer-sed-et-awk-par-ruby/">Remplacer Sed et Awk par Ruby</a>.</p>

<!-- more -->


<p>J'ai tout d'abord écrit mes lignes en mettant la chaîne <code>ABC</code> là où je voulais
un nombre aléatoire:</p>

<p>``` ruby
KnapsackItem.new(&lsquo;ACCOR&rsquo;, 32, 9, ABC),
KnapsackItem.new(&lsquo;AIR_LIQUIDE&rsquo;, 97, 7, ABC),
KnapsackItem.new(&lsquo;ALSTOM&rsquo;, 25, 5, ABC),
KnapsackItem.new(&lsquo;ARCELORMITTAL_REG&rsquo;, 12, 9, ABC),
KnapsackItem.new(&lsquo;AXA&rsquo;, 18, 2, ABC),
KnapsackItem.new(&lsquo;BNP_PARIBAS&rsquo;, 53, 3, ABC),</p>

<h1>&hellip;</h1>

<p>```</p>

<p>Cela va permettre au script de <em>trouver</em> l'endroit où substituer un nombre.</p>

<p>Puis, on lance le script suivant depuis une console:</p>

<p><code>bash
ruby -ple 'r=rand(100)+1;$_.sub!(/ABC/,r.to_s)' fichier_source
</code></p>

<p>Explications: <code>rand(100)+1</code> génère un nombre aléatoire entre 1 inclus et
100 inclus. <code>$_.sub!(/ABC/,r.to_s)</code> opère une substitution de la ligne en
cours de traitement: ABC est remplacé par le contenu de <code>r</code>, soit le nombre
aléatoire.</p>

<p>En réalité, je n'ai pas lancé ce script depuis une console, mais directement
dans Vim:</p>

<p><code>vim
:%! ruby -ple 'r=rand(100)+1;$_.sub\!(/ABC/,r.to_s)'
</code></p>

<p>Dans ce cas, il faut faire attention à échapper le <code>!</code>, sans quoi Vim
n'aimeras pas…</p>

<p>Voilà un exemple simple d'utilisation du mode <em>sed/awk</em> de Ruby.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Remplacer Sed et Awk par Ruby: 9 Utiliser la bibliothèque standard]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/12/10/remplacer-sed-et-awk-par-ruby-9-utiliser-la-bibliotheque-standard/"/>
    <updated>2013-12-10T18:40:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/12/10/remplacer-sed-et-awk-par-ruby-9-utiliser-la-bibliotheque-standard</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Se servir de Ruby pour remplacer Sed et Awk permet, entre autre, d'avoir accès
à la bibliothèque standard de Ruby (et même à n'importe quelle gem).  Pour un
script on peut charger les bibliothèques néccessaires dans un bloc BEGIN (avec
<code>require</code>), mais pour un <em>one liner</em>, ce serait beaucoup moins drôle. Ruby
permet de charger une gem sur la ligne de commande avec <code>-r</code>, une syntaxe plus
courte que <code>require</code>.</p>

<!-- more -->


<p>Tout au long de <a href="http://lkdjiin.github.io/blog/2013/11/29/remplacer-sed-et-awk-par-ruby/">cette série</a>, les exemples ont été triviaux et ça sera
encore le cas aujourd'hui. Prenons le fichier de données suivant:</p>

<p><code>raw data.txt
1
2
3
2
3
4
</code></p>

<p>L'objectif est d'afficher les différentes valeurs, <strong>sans doublons</strong>.
Pour le fichier ci-dessus, on veut donc obtenir: 1, 2, 3 et 4. Il y a plusieurs
solutions pour réaliser ça, l'une d'elles est d'utiliser <a href="http://ruby-doc.org/stdlib-2.0.0/libdoc/set/rdoc/Set.html">les sets</a>
fournis par la bibliothèque standard de Ruby.</p>

<p>Voici une ligne de commande qui réalise l'objectif:</p>

<p>``` bash
[~]⇒ ruby -nl -rset -e &lsquo;BEGIN{s=Set.new};s.add($_);END{p s}&rsquo; data.txt</p>

<h1>&lt;Set: {&ldquo;1&rdquo;, &ldquo;2&rdquo;, &ldquo;3&rdquo;, &ldquo;4&rdquo;}></h1>

<p>```</p>

<p>Le switch <code>-n</code> passe Ruby en <em>mode sed/awk</em>. Le switch <code>-l</code> s'occupe des
caractères de fin de ligne.</p>

<p>Le switch <code>-r</code> va charger la gem passée en argument. Donc <code>-rset</code> va charger
la gem «set».</p>

<p>Pour ce qui est du script, on commence par initialiser une variable <code>s</code> en
tant qu'objet Set:</p>

<pre><code>BEGIN { s = Set.new }
</code></pre>

<p>Puis on ajoute le contenu de chaque ligne dans ce set (comme il s'agit
justement d'un type Set, les doublons ne seront pas pris en compte):</p>

<pre><code>s.add($_)
</code></pre>

<p>Enfin, on affiche le résultat, <code>p s</code> étant un raccourci pour
<code>puts s.inspect</code>. Les raccourcis sont les bienvenus pour les <em>one liners</em>:</p>

<pre><code>END { p s }
</code></pre>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
