<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : débutant | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/debutant/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2013-12-14T17:41:27+01:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Remplacer Sed et Awk par Ruby 11: La gem English]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/12/14/remplacer-sed-et-awk-par-ruby-11-la-gem-english/"/>
    <updated>2013-12-14T16:59:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/12/14/remplacer-sed-et-awk-par-ruby-11-la-gem-english</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Après avoir vu <a href="http://lkdjiin.github.io/blog/2013/12/12/remplacer-sed-et-awk-par-ruby-10-un-exemple-dutilisation/">un exemple d'utilisation</a> du mode <em>sed/awk</em> de Ruby au travers
d'un <em>one liner</em>, on regarde aujourd'hui la gem English, qui facilite
énormement la
vie pour l'écriture des scripts.</p>

<!-- more -->


<p>On a vu jusqu'à présent deux variables globales, j'ai nommé <code>$_</code> et
<code>$;</code>. Ces noms sont justes barbares et imprononçables. Et des variables
globales de ce genre, il y en a quelques autres qui vont nous être utiles.
Voyons voir si vous êtes capable de deviner ce qu'elles représentent:
<code>$,</code>, <code>$\</code>, <code>$/</code> et <code>$.</code>. Vous avez deviné ? Non ? C'est là qu'entre en
jeu <a href="http://ruby-doc.org/stdlib-2.0.0/libdoc/English/rdoc/English.html">la gem English</a>. Cette gem va nous permettre d'accéder à ces
variables à l'aide de noms compréhensibles par le commun des mortels:</p>

<pre><code>   Nom court   Nom long
$; $FS         $FIELD_SEPARATOR
$, $OFS        $OUTPUT_FIELD_SEPARATOR 
$/ $RS         $INPUT_RECORD_SEPARATOR
$\ $ORS        $OUTPUT_RECORD_SEPARATOR
$. $NR         $INPUT_LINE_NUMBER
$_             $LAST_READ_LINE
</code></pre>

<p>Pour avoir accès à ceci dans un script, il faudra charger la gem dans
un bloc BEGIN:</p>

<p><code>ruby
BEGIN { require 'English' }
</code></p>

<p>Alors quand se servir des noms courts, des noms longs ? Tout dépend de
votre <em>background</em> et de votre tâche.</p>

<p>Si vous débutez en Ruby, si vous devez écrire un script long et/ou complexe,
si le script doit être maintenu pendant des mois ou plus, si il est maintenu
par plusieurs personnes, utilisez les noms longs.</p>

<p>Si vous (et votre équipe) avez une expérience de Awk, les noms courts peuvent
être une solution raisonnable.</p>

<p>Quand aux noms <em>barbares</em>, réservez les pour les <em>one liners</em>, les scripts
courts <em>one shot</em> et les séances de masochisme.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Remplacer Sed et Awk par Ruby 10: Un exemple d'utilisation]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/12/12/remplacer-sed-et-awk-par-ruby-10-un-exemple-dutilisation/"/>
    <updated>2013-12-12T21:05:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/12/12/remplacer-sed-et-awk-par-ruby-10-un-exemple-dutilisation</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Dans un <a href="http://lkdjiin.github.io/blog/2013/12/11/les-algorithmes-genetiques-demystifies-42-un-probleme-deconomie/">article précédent</a>
sur les algorithmes génétiques, je devais générer des valeurs aléatoires
<em>en dur</em> dans un fichier source Ruby. Le code ressemble à ce qui suit:</p>

<p>``` ruby
KnapsackItem.new(&lsquo;ACCOR&rsquo;, 32, 9, 60),
KnapsackItem.new(&lsquo;AIR_LIQUIDE&rsquo;, 97, 7, 32),
KnapsackItem.new(&lsquo;ALSTOM&rsquo;, 25, 5, 6),
KnapsackItem.new(&lsquo;ARCELORMITTAL_REG&rsquo;, 12, 9, 43),
KnapsackItem.new(&lsquo;AXA&rsquo;, 18, 2, 65),
KnapsackItem.new(&lsquo;BNP_PARIBAS&rsquo;, 53, 3, 24),</p>

<h1>&hellip;</h1>

<p>```</p>

<p>Le dernier nombre de chaque ligne doit être compris entre 1 et 100.
Voici comment faire en utilisant ce qu'on a appris depuis le début
de cette série <a href="http://lkdjiin.github.io/blog/2013/11/29/remplacer-sed-et-awk-par-ruby/">Remplacer Sed et Awk par Ruby</a>.</p>

<!-- more -->


<p>J'ai tout d'abord écrit mes lignes en mettant la chaîne <code>ABC</code> là où je voulais
un nombre aléatoire:</p>

<p>``` ruby
KnapsackItem.new(&lsquo;ACCOR&rsquo;, 32, 9, ABC),
KnapsackItem.new(&lsquo;AIR_LIQUIDE&rsquo;, 97, 7, ABC),
KnapsackItem.new(&lsquo;ALSTOM&rsquo;, 25, 5, ABC),
KnapsackItem.new(&lsquo;ARCELORMITTAL_REG&rsquo;, 12, 9, ABC),
KnapsackItem.new(&lsquo;AXA&rsquo;, 18, 2, ABC),
KnapsackItem.new(&lsquo;BNP_PARIBAS&rsquo;, 53, 3, ABC),</p>

<h1>&hellip;</h1>

<p>```</p>

<p>Cela va permettre au script de <em>trouver</em> l'endroit où substituer un nombre.</p>

<p>Puis, on lance le script suivant depuis une console:</p>

<p><code>bash
ruby -ple 'r=rand(100)+1;$_.sub!(/ABC/,r.to_s)' fichier_source
</code></p>

<p>Explications: <code>rand(100)+1</code> génère un nombre aléatoire entre 1 inclus et
100 inclus. <code>$_.sub!(/ABC/,r.to_s)</code> opère une substitution de la ligne en
cours de traitement: ABC est remplacé par le contenu de <code>r</code>, soit le nombre
aléatoire.</p>

<p>En réalité, je n'ai pas lancé ce script depuis une console, mais directement
dans Vim:</p>

<p><code>vim
:%! ruby -ple 'r=rand(100)+1;$_.sub\!(/ABC/,r.to_s)'
</code></p>

<p>Dans ce cas, il faut faire attention à échapper le <code>!</code>, sans quoi Vim
n'aimeras pas…</p>

<p>Voilà un exemple simple d'utilisation du mode <em>sed/awk</em> de Ruby.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Remplacer Sed et Awk par Ruby: 9 Utiliser la bibliothèque standard]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/12/10/remplacer-sed-et-awk-par-ruby-9-utiliser-la-bibliotheque-standard/"/>
    <updated>2013-12-10T18:40:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/12/10/remplacer-sed-et-awk-par-ruby-9-utiliser-la-bibliotheque-standard</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Se servir de Ruby pour remplacer Sed et Awk permet, entre autre, d'avoir accès
à la bibliothèque standard de Ruby (et même à n'importe quelle gem).  Pour un
script on peut charger les bibliothèques néccessaires dans un bloc BEGIN (avec
<code>require</code>), mais pour un <em>one liner</em>, ce serait beaucoup moins drôle. Ruby
permet de charger une gem sur la ligne de commande avec <code>-r</code>, une syntaxe plus
courte que <code>require</code>.</p>

<!-- more -->


<p>Tout au long de <a href="http://lkdjiin.github.io/blog/2013/11/29/remplacer-sed-et-awk-par-ruby/">cette série</a>, les exemples ont été triviaux et ça sera
encore le cas aujourd'hui. Prenons le fichier de données suivant:</p>

<p><code>raw data.txt
1
2
3
2
3
4
</code></p>

<p>L'objectif est d'afficher les différentes valeurs, <strong>sans doublons</strong>.
Pour le fichier ci-dessus, on veut donc obtenir: 1, 2, 3 et 4. Il y a plusieurs
solutions pour réaliser ça, l'une d'elles est d'utiliser <a href="http://ruby-doc.org/stdlib-2.0.0/libdoc/set/rdoc/Set.html">les sets</a>
fournis par la bibliothèque standard de Ruby.</p>

<p>Voici une ligne de commande qui réalise l'objectif:</p>

<p>``` bash
[~]⇒ ruby -nl -rset -e &lsquo;BEGIN{s=Set.new};s.add($_);END{p s}&rsquo; data.txt</p>

<h1>&lt;Set: {&ldquo;1&rdquo;, &ldquo;2&rdquo;, &ldquo;3&rdquo;, &ldquo;4&rdquo;}></h1>

<p>```</p>

<p>Le switch <code>-n</code> passe Ruby en <em>mode sed/awk</em>. Le switch <code>-l</code> s'occupe des
caractères de fin de ligne.</p>

<p>Le switch <code>-r</code> va charger la gem passée en argument. Donc <code>-rset</code> va charger
la gem «set».</p>

<p>Pour ce qui est du script, on commence par initialiser une variable <code>s</code> en
tant qu'objet Set:</p>

<pre><code>BEGIN { s = Set.new }
</code></pre>

<p>Puis on ajoute le contenu de chaque ligne dans ce set (comme il s'agit
justement d'un type Set, les doublons ne seront pas pris en compte):</p>

<pre><code>s.add($_)
</code></pre>

<p>Enfin, on affiche le résultat, <code>p s</code> étant un raccourci pour
<code>puts s.inspect</code>. Les raccourcis sont les bienvenus pour les <em>one liners</em>:</p>

<pre><code>END { p s }
</code></pre>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Remplacer Sed et Awk par Ruby 8: Script sur la ligne de commande]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/12/09/remplacer-sed-et-awk-par-ruby-8-script-sur-la-ligne-de-commande/"/>
    <updated>2013-12-09T20:36:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/12/09/remplacer-sed-et-awk-par-ruby-8-script-sur-la-ligne-de-commande</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Il est temps de se passer d'un fichier pour notre script… Lorsque celui-ci
est suffisament court, on peut l'écrire directement sur la ligne de
commande.</p>

<!-- more -->


<p>Si on reprend l'exemple tout simple du <a href="http://lkdjiin.github.io/blog/2013/12/08/remplacer-sed-et-awk-par-ruby-7-modifier-slash-sauvegarder-les-donnees/">dernier article</a>,
nous avions le fichier de données suivant à transformer <em>en place</em> en
majuscule:</p>

<p><code>raw data.txt
alice
bob
</code></p>

<p>Ce qu'on a fait à l'aide du script suivant:</p>

<p><code>ruby test.rb
$_.upcase!
</code></p>

<p>Autrement une seule ligne ! Est-ce que ça vaut vraiment la peine d'écrire
un fichier pour ça ? Bien sûr que non. On va donc se passer du fichier
script en donnant le code sur la ligne de commande grâce à l'option <code>-e</code>:</p>

<p><code>bash
ruby -p -i.2 -e '$_.upcase!' data.txt
</code></p>

<p>Et voilà, vous êtes maintenant prêts à écrire des <em>one liners</em>. Notez
quand même qu'il vaut mieux utiliser les guillemets simples (<code>'</code>) autour
du code plutôt que les doubles (<code>"</code>), pour empêcher Bash d'interpréter
certains caractères (comme ici le <code>!</code>).</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Remplacer Sed et Awk par Ruby 7: Modifier/sauvegarder les données]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/12/08/remplacer-sed-et-awk-par-ruby-7-modifier-slash-sauvegarder-les-donnees/"/>
    <updated>2013-12-08T19:30:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/12/08/remplacer-sed-et-awk-par-ruby-7-modifier-slash-sauvegarder-les-donnees</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Parfois on veut analyser un fichier, et parfois on veut le modifier.
Si on suit la logique de <a href="http://lkdjiin.github.io/blog/2013/11/29/remplacer-sed-et-awk-par-ruby/">cette série d'articles</a>, Ruby devrait offrir
un switch permettant de modifier un fichier sans avoir à l'enregistrer
explicitement. Et je ne vais pas vous surprendre
en vous apprenant qu'un tel switch existe, il s'agit de l'option
<code>-i</code>, qui permet aussi de sauvegarder l'ancien fichier.</p>

<!-- more -->


<p>L'exemple d'aujourd'hui est encore plus trivial que d'habitude ;) Voici
le fichier de données:</p>

<p><code>raw data.txt
alice
bob
</code></p>

<p>Ce que je voudrais, c'est simplement tout mettre en majuscule. Ce que
permet le script suivant:</p>

<p><code>ruby test.rb
$_.upcase!
</code></p>

<p>Si on lance le script comme on sait le faire maintenant
(voir par exemple <a href="http://lkdjiin.github.io/blog/2013/12/07/remplacer-sed-et-awk-par-ruby-6-separateur-de-champ/">l'article précédant</a>), on obtient un bel
affichage:</p>

<pre><code>[~/test]⇒ ruby -p test.rb data.txt 
ALICE
BOB
</code></pre>

<p>Mais le fichier lui-même n'a pas changé:</p>

<pre><code>[~/test]⇒ cat data.txt
alice
bob
</code></pre>

<p>Si on veut modifier le fichier, on doit se servir de l'option <code>-i</code> en
spécifiant l'extension qui sera ajouter au fichier original sauvegardé,
ici <code>.2</code>:</p>

<pre><code>[~/test]⇒ ruby -p -i.2 test.rb data.txt 
</code></pre>

<p>Et voilà, on a bien les deux fichiers attendus:</p>

<pre><code>[~/test]⇒ ls data*
data.txt  data.txt.2
</code></pre>

<p>Notre fichier est bien modifié:</p>

<pre><code>[~/test]⇒ cat data.txt
ALICE
BOB
</code></pre>

<p>Et il est bien sauvegardé:</p>

<pre><code>[~/test]⇒ cat data.txt.2
alice
bob
</code></pre>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
