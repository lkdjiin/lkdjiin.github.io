<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : débutant | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/debutant/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2013-11-13T09:45:22+01:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Racket pour les rubyists 6: Une première fonction]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/11/11/racket-pour-les-rubyists-6-une-premiere-fonction/"/>
    <updated>2013-11-11T20:41:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/11/11/racket-pour-les-rubyists-6-une-premiere-fonction</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Grâce à ce qu'on a appris depuis <a href="http://lkdjiin.github.io/blog/2013/11/03/racket-pour-les-rubyists-definir-une-fonction/">le début</a> de cette série d'articles,
il est enfin temps de traduire la méthode Ruby suivante en Racket:</p>

<p><code>ruby
def divisors(n)
  (1..n).select {|i| n % i == 0}
end
</code></p>

<!-- more -->


<h2>Une première fonction Racket</h2>

<p>Sans plus attendre, voici une traduction en Racket, qui suit le modèle
du <a href="http://lkdjiin.github.io/blog/2013/11/10/racket-pour-les-rubyists-5-definitions-imbriquees/">dernier article</a>:</p>

<p>``` racket
(define (divisors n)
  ; Is i a divisor of n?
  (define (divisor? i)</p>

<pre><code>(= 0 (remainder n i)))
</code></pre>

<p>  (filter divisor? (range 1 (+ n 1))))
```</p>

<p>Voici la fonction en action:</p>

<pre><code>-&gt; (divisors 1)
'(1)
-&gt; (divisors 8)
'(1 2 4 8)
-&gt; (divisors 17)
'(1 17)
-&gt; (divisors 171)
'(1 3 9 19 57 171)
</code></pre>

<p>Alors ça fait pas mal de code Racket comparé au code Ruby, mais attention de ne
pas juger le langage sur ce seul exemple. D'abord l'opérateur <code>..</code> de Ruby et
ses <em>blocks</em> permettent une syntaxe incroyablement concise, ensuite je
vous rappelle que <em>j'apprends</em> Racket, et que donc j'ai peut-être raté des
trucs…</p>

<p>Vous remarquez que je me suis senti obligé de commenté la fonction imbriquée
<code>divisor?</code>, ce qui n'est pas bon signe. Je suis un adepte du code court,
sous-entendu: une fonction devrait faire une seule chose. Or il me semble
qu'ici la fonction <code>divisors</code> fait trois choses:</p>

<ol>
<li>Elle regarde si un nombre i est un diviseur de n.</li>
<li>Elle produit une liste de 1 à n inclus.</li>
<li>Enfin, elle produit la liste des diviseurs de n.</li>
</ol>


<p>Donc <code>divisors</code> est un bon candidat au refactoring. Mais avant ça il va
falloir parler des tests unitaires avec Racket. Et avant de parler des
tests unitaires, il va falloir aborder la notion de module Racket. Si
ces sujets vous intéressent, restez à l'écoute de ce blog, c'est pour
bientôt.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Racket pour les rubyists 5: Définitions imbriquées]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/11/10/racket-pour-les-rubyists-5-definitions-imbriquees/"/>
    <updated>2013-11-10T21:17:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/11/10/racket-pour-les-rubyists-5-definitions-imbriquees</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Après avoir vu l'utilisation de la fonction <code>filter</code>, on passe aux
définitions de fonctions imbriquées en Racket, ce qui nous permet de
survoler la portée des variables.</p>

<!-- more -->


<h2>Fonctions Racket imbriquées</h2>

<p>Avec Racket les définitions de fonction peuvent s'imbriquer les unes dans les
autres.  Autrement dit, on peut définir une fonction B à l'intérieur d'une
fonction A. Dans l'exemple suivant, la fonction <code>bar</code> est définie à
l'intérieur de la fonction <code>foo</code>:</p>

<p>``` racket
(define (foo x)
  (define (bar y)</p>

<pre><code>(+ y 2))
</code></pre>

<p>  (bar x))
```</p>

<p>Dans le code ci-dessus, <code>bar</code> est une fonction qui ajoute 2 à son argument.
La fonction englobante <code>foo</code> appelle <code>bar</code> et donc son rôle est aussi d'ajouter
2 à son argument, comme on peut le voir dans la session racket suivante:</p>

<pre><code>-&gt; (foo 10)
12
</code></pre>

<p>Il est important de comprendre que <code>bar</code> est définie à l'intérieur de <code>foo</code>,
et donc <code>bar</code> est <em>indéfinie</em> à l'extérieur de <code>foo</code>:</p>

<pre><code>-&gt; (bar 10)
; bar: undefined;
;  cannot reference undefined identifier
</code></pre>

<h2>Méthodes Ruby imbriquées</h2>

<p>Ruby se comporte différement. Il permet bien de définir une méthode à
l'intérieur d'une autre:</p>

<p>``` irb</p>

<blockquote><blockquote><p>def foo(x)
  def bar(y)</p>

<pre><code>y + 2
</code></pre>

<p>  end
  bar x
end
nil
foo 10
12
```</p></blockquote></blockquote>

<p>Mais à la différence du comportement de Racket, la méthode Ruby <code>bar</code> est
<em>visible</em> à l'extérieur de <code>foo</code>:</p>

<p>``` irb</p>

<blockquote><blockquote><p>bar 10
12
```</p></blockquote></blockquote>

<p>Et c'est tout à fait normal. Il s'agit là d'une différence entre fonction
et méthode: une méthode est attachée à un objet.</p>

<h2>Retour à Racket</h2>

<p>La méthode <code>foo</code> peut être simplifiée. La revoici:</p>

<p>``` racket
(define (foo x)
  (define (bar y)</p>

<pre><code>(+ y 2))
</code></pre>

<p>  (bar x))
```</p>

<p>Pour la simplifier, il suffit de comprendre que l'argument <code>x</code> est <em>visible</em>
dans la fonction <code>bar</code>:</p>

<p>``` racket
(define (foo x)
  (define (bar)</p>

<pre><code>(+ x 2))
</code></pre>

<p>  (bar))
```</p>

<p>Évidemment, la vraie simplification serait celle-ci:</p>

<p><code>racket
(define (foo x)
  (+ x 2))
</code></p>

<p>Mais cet article parle de fonctions imbriquées…</p>

<p>La prochaine fois on réunira tout ce qu'on a appris jusqu'ici pour enfin
traduire en Racket la méthode Ruby suivante:</p>

<p><code>ruby
def divisors(n)
  (1..n).select {|i| n % i == 0}
end
</code></p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Racket pour les Rubyists 4: La fonction filter]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/11/09/racket-pour-les-rubyists-4-la-fonction-filter/"/>
    <updated>2013-11-09T18:39:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/11/09/racket-pour-les-rubyists-4-la-fonction-filter</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Aprés avoir vu comment faire un <a href="http://lkdjiin.github.io/blog/2013/11/08/racket-pour-les-rubyists-3-trouver-les-diviseurs/">test d'égalité</a>
en Racket, on s'intéresse aujourd'hui à la fonction <code>filter</code>, en la
comparant à la méthode Ruby <code>select</code>.</p>

<!-- more -->


<h2>select vs filter</h2>

<p>Pour obtenir les nombres impairs d'une liste, voici comment on pourrait
faire en Ruby:</p>

<p><code>ruby
[1, 2, 3, 4].select {|i| i.odd? } #=&gt; [1, 3]
</code></p>

<p>D'une manière générale, on a:</p>

<pre><code>liste.select bloc
</code></pre>

<p>Et voici la façon de faire en Racket:</p>

<p><code>racket
(filter odd? '(1 2 3 4)) ;=&gt; '(1 3)
</code></p>

<p>Qu'on généralise en:</p>

<pre><code>(filter fonction liste)
</code></pre>

<p>Comme Ruby, Racket place un point d'interrogation à la fin du nom d'une
fonction qui retourne vrai ou faux. <code>odd?</code> s'utilise ainsi:</p>

<p><code>racket
(odd? 1) ;=&gt; #t
(odd? 2) ;=&gt; #f
</code></p>

<p>On voit que dans <code>(filter odd? '(1 2 3 4))</code>, chaque élément de la liste est
fourni <em>implicitement</em> à la fonction <code>odd?</code>. De plus, on ne mets pas de
parenthèses autour de <code>odd?</code> car on ne veut pas l'évaluer mais seulement
fournir la référence. C'est quelque chose sur lequel je reviendrais souvent
et qu'il faudra expliquer plus en détail.</p>

<p>La prochaine fois on parlera des fonctions imbriquées en Racket.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Racket pour les Rubyists 3: Trouver les diviseurs]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/11/08/racket-pour-les-rubyists-3-trouver-les-diviseurs/"/>
    <updated>2013-11-08T19:17:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/11/08/racket-pour-les-rubyists-3-trouver-les-diviseurs</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Précédemment, on a vu comment produire une
<a href="http://lkdjiin.github.io/blog/2013/11/06/racket-pour-les-rubyists-2-produire-une-suite-de-nombre/">liste de nombre</a>
avec la fonction <code>range</code>. Aujourd'hui on va traduire les tests Ruby suivants
en Racket:</p>

<p><code>ruby
8 % 2 == 0 #=&gt; true
8 % 3 == 0 #=&gt; false
</code></p>

<!-- more -->


<h2>Reste d'une division</h2>

<p>Pour calculer le reste d'une division euclidienne, on utilise la fonction
<code>remainder</code>. Par exemple:</p>

<p><code>racket
(remainder 8 2) ;=&gt; 0
(remainder 8 3) ;=&gt; 2
</code></p>

<p>D'une manière plus générale, <code>(remainder a b)</code> calcule le reste de la
division de <code>a</code> par <code>b</code>. Vous remarquerez encore une fois la notation <em>prefix</em>
de Racket.</p>

<p>Au passage, vous notez que le signe pour débuter un commentaire est le
point-virgule (<code>;</code>).</p>

<h2>Les booléens</h2>

<p>En Ruby les deux valeurs booléennes sont <strong>true</strong> et <strong>false</strong>, en Racket
elles sont notées <strong>#t</strong> et <strong>#f</strong>:</p>

<h2>Tester l'égalité</h2>

<p>Quand Ruby utilise le signe <code>==</code>, comme beaucoup d'autres langages, Racket
utilise un seul signe <code>=</code>:</p>

<p><code>racket
(= 1 1) ;=&gt; #t
(= 1 2) ;=&gt; #f
</code></p>

<p>Attention, <code>=</code> ne fonctionne qu'avec les nombres comme vous pouvez le
constater dans la session suivante:</p>

<pre><code>-&gt; (= "xav" "xav")
; =: contract violation
;   expected: number?
;   given: "xav"
;   argument position: 1st
</code></pre>

<p>Donc, pour tester si le reste d'une division euclidienne est égal à zéro,
on pourra faire comme ça:</p>

<p><code>racket
(= 0 (remainder 8 2)) ;=&gt; #t
(= 0 (remainder 8 3)) ;=&gt; #f
</code></p>

<p>Et d'une manière générale, pour tester si <em>i</em> est un diviseur de <em>n</em>:</p>

<p><code>racket
(= 0 (remainder n i))
</code></p>

<p>La prochaine fois, on verra la fonction Racket <code>filter</code>, qui est le
pendant de la méthode <code>select</code> de Ruby.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Prise en main de la gem chunky_png]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/11/07/prise-en-main-de-la-gem-chunky-png/"/>
    <updated>2013-11-07T17:32:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/11/07/prise-en-main-de-la-gem-chunky-png</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Pour un projet j'ai besoin de manipuler du format png et j'ai décidé
d'utiliser la gem <code>chunky_png</code> pour faire ça. Comme je ne la connais pas,
j'écris aujourd'hui une rapide prise en main de cette gem, histoire de me
familiariser avec.</p>

<p>Pour l'installer, c'est comme d'habitude:</p>

<pre><code>gem install chunky_png
</code></pre>

<!-- more -->


<p>Pour la documentation on pourra commencer par <a href="https://github.com/wvanbergen/chunky_png/wiki">le wiki</a> du projet.</p>

<p>La première chose que je veux faire c'est lire et écrire un fichier png.</p>

<p>``` ruby test.rb
require &ldquo;chunky_png&rdquo;</p>

<p>image = ChunkyPNG::Image.from_file(ARGV[0])
image.save(&ldquo;copy.png&rdquo;)
```</p>

<p>Après l'avoir lancé, ce programme crée une copie de l'image originale sous le
nom &ldquo;copy.png&rdquo;:</p>

<pre><code>[~]⇒ ruby test.rb test.png 
</code></pre>

<p>Super, bon début. Maintenant je voudrais accéder à la valeur RGB d'un pixel
quelconque de l'image. Voici le second programme:</p>

<p>``` ruby test2.rb
require &ldquo;chunky_png&rdquo;</p>

<p>image = ChunkyPNG::Image.from_file(ARGV[0])</p>

<p>p ChunkyPNG::Color.r(image[0, 0])
p ChunkyPNG::Color.g(image[20, 20])
p ChunkyPNG::Color.b(image[40, 40])
p ChunkyPNG::Color.to_hex(image[60, 60])
p ChunkyPNG::Color.to_truecolor_bytes(image[80, 80])
```</p>

<p>Et un exemple de sortie possible:</p>

<pre><code>[~]⇒ ruby test2.rb test.png 
255
255
255
"#000000ff"
[0, 0, 0]
</code></pre>

<p>L'image est vue comme un tableau à 2 dimensions: <code>image[x, y]</code>.
Les méthodes <code>r</code>, <code>g</code> et <code>b</code> renvoient respectivement la composante rouge,
verte ou bleue du pixel. La méthode <code>to_hex</code> formate <em>à la HTML</em> et la
méthode <code>to_truecolor_bytes</code> renvoie un tableau des trois composantes RGB.</p>

<p>J'aimerais maintenant dessiner un rectangle dans l'image:</p>

<p>``` ruby test3.rb
require &ldquo;chunky_png&rdquo;</p>

<p>image = ChunkyPNG::Image.from_file(ARGV[0])
image.rect(0, 0, 99, 99)
image.save(&ldquo;copy.png&rdquo;)
```</p>

<p>Si vous lancez ce programme (avec <code>ruby test3.rb test.png</code>), vous verrez
qu'il dessine bien un rectangle (x = 0, y = 0, largeur = 99, hauteur = 99).
Malheureusement, seul le <em>contour</em> du rectangle est dessiné.
Pour dessiner un rectangle rempli, il en faut un peu plus:</p>

<p>``` ruby test4.rb
require &ldquo;chunky_png&rdquo;</p>

<p>my_color = ChunkyPNG::Color.rgb(10, 100, 200)</p>

<p>image = ChunkyPNG::Image.from_file(ARGV[0])
image.rect(0, 0, 99, 99, my_color, my_color)
image.save(&ldquo;copy.png&rdquo;)
```</p>

<p>Cette fois on a bien un rectangle <em>rempli</em>. Et au passage on voit comment
définir une couleur au format RGB.</p>

<p>Pour finir, je voudrais créer une image:</p>

<p>``` ruby test5.png
require &ldquo;chunky_png&rdquo;</p>

<p>image = ChunkyPNG::Image.new(400,</p>

<pre><code>                         400,
                         ChunkyPNG::Color::WHITE)
</code></pre>

<p>my_color = ChunkyPNG::Color.rgb(10, 100, 200)
my_color2 = ChunkyPNG::Color.rgb(110, 10, 100)</p>

<p>image.rect(0, 0, 199, 199, my_color, my_color)
image.rect(200, 200, 399, 399, my_color2, my_color2)</p>

<p>image.save(&ldquo;new.png&rdquo;)
```</p>

<p>Le programme se lance avec <code>ruby test5.rb</code> et crée une nouvelle image <code>new.png</code>.
Le constructeur de <code>Image</code> prend tout simplement la largeur, la hauteur et
la couleur de fond de l'image.</p>

<p>En bref, <code>chunky_png</code> est une gem qui a l'air simple a utiliser.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
