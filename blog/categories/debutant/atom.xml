<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : débutant | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/debutant/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2014-03-31T21:12:36+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Vim - Un plugin pour markdown - partie 8]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/03/31/vim-un-plugin-pour-markdown-partie-8/"/>
    <updated>2014-03-31T20:58:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/03/31/vim-un-plugin-pour-markdown-partie-8</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>On continue d'implémenter <a href="/blog/2014/03/30/vim-un-plugin-pour-markdown-partie-7/">la fonctionnalité commencée hier</a>
en testant deux cas exceptionnels, toujours à l'aide de Vader.</p>

<!-- more -->


<p>Revoici le fichier de test d'hier:</p>

<p>``` raw
Given (some text):
  abc def ghi jkl mno</p>

<p>Execute (starting in middle of a word):
  execute &ldquo;normal! fe&rdquo;
  QuickMarkdownItalic</p>

<p>Expect (2nd word in italic):
  abc <em>def</em> ghi jkl mno
```</p>

<p>Je vais ajouter deux tests. L'un pour voir ce qu'il se passe quand le
curseur se trouve au début d'un mot, et idem pour la fin d'un mot:</p>

<p>``` raw
Given (some text):
  abc def ghi jkl mno</p>

<p>Execute (starting in middle of a word):
  execute &ldquo;normal! fe&rdquo;
  QuickMarkdownItalic</p>

<p>Expect (2nd word in italic):
  abc <em>def</em> ghi jkl mno</p>

<p>Execute (starting at beginning of a word):
  execute &ldquo;normal! fd&rdquo;
  QuickMarkdownItalic</p>

<p>Expect (2nd word in italic):
  abc <em>def</em> ghi jkl mno</p>

<p>Execute (starting at the end of a word):
  execute &ldquo;normal! ff&rdquo;
  QuickMarkdownItalic</p>

<p>Expect (2nd word in italic):
  abc <em>def</em> ghi jkl mno
```</p>

<p>Et avec l'implémentation de la dernière fois:</p>

<p><code>vim autoload/quickmarkdown.vim
function! quickmarkdown#italic()
  execute "normal! bi*\&lt;Esc&gt;ea*\&lt;Esc&gt;"
endfunction
</code></p>

<p>… le test où le curseur se trouve au début d'un mot échoue
misérablement.</p>

<p>Pour le faire passer, on doit d'abord déplacer le curseur d'un cran
vers la droite:</p>

<p><code>vim autoload/quickmarkdown.vim
function! quickmarkdown#italic()
  execute "normal! lbi*\&lt;Esc&gt;ea*\&lt;Esc&gt;"
endfunction
</code></p>

<p>La prochaine fois on continue avec d'autres cas exceptionnels.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vim - Un plugin pour markdown - partie 7]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/03/30/vim-un-plugin-pour-markdown-partie-7/"/>
    <updated>2014-03-30T21:20:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/03/30/vim-un-plugin-pour-markdown-partie-7</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Pour mon plugin Vim qui aide à écrire du markdown, j'ai envie d'une
fonctionnalité pour mettre un mot en italique (et aussi en gras).
Si j'ai le texte suivant:</p>

<pre><code>foo bar baz
</code></pre>

<p>et que le curseur est dans le mot <code>bar</code>, je veux que la combinaison de
touches <code>&lt;Leader&gt;qi</code> donne ceci:</p>

<pre><code>foo *bar* baz
</code></pre>

<p>Pour implémenter ça, j'utiliserais encore le framework de test Vader.</p>

<!-- more -->


<p>Voici un premier test, pour le cas général:</p>

<p>``` raw
Given (some text):
  abc def ghi jkl mno</p>

<p>Execute (starting in middle of a word):
  execute &ldquo;normal! fe&rdquo;
  QuickMarkdownItalic</p>

<p>Expect (2nd word in italic):
  abc <em>def</em> ghi jkl mno
```</p>

<p>Le bloc <code>Execute</code> place d'abord le curseur sur le caractêre <code>e</code>,
autrement dit <em>à l'intérieur</em> du mot <code>def</code>. Il lance ensuite la fonction
<code>QuickMarkdownItalic</code> qui devra faire le travail.</p>

<p>Dans le fichier <code>plugin/quickmarkdown.vim</code>, j'ajoute la nouvelle
fonction:</p>

<p><code>vim plugin/quickmarkdown.vim
command! QuickMarkdownItalic call quickmarkdown#italic()
</code></p>

<p>Puis j'implémente la fonction de la manière la plus simple à laquelle
je puisse penser:</p>

<p><code>vim autoload/quickmarkdown.vim
function! quickmarkdown#italic()
  execute "normal! bi*\&lt;Esc&gt;ea*\&lt;Esc&gt;"
endfunction
</code></p>

<p>Décodage: <code>b</code> place le curseur au début du mot. <code>i*\&lt;Esc&gt;</code> passe en
mode insertion, ajoute un <code>*</code> et revient en mode normal. <code>e</code> place le
curseur à la fin du mot. <code>a*\&lt;Esc&gt;</code> passe en mode insertion <em>derrière</em>
le mot et ajoute un <code>*</code> puis revient encore en mode normal.</p>

<p>Cette fonction sera amenée à bouger une fois qu'on se sera occupé des
cas particuliers. Ce sera pour une prochaine fois.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby - extend self]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/03/28/ruby-extend-self/"/>
    <updated>2014-03-28T21:16:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/03/28/ruby-extend-self</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Vous débutez en Ruby et vous vous demandez ce que peut bien signifier
ce <code>extend self</code> qu'on rencontre parfois dans un module utilitaire ?</p>

<!-- more -->


<p>Voici un exemple:</p>

<p>``` ruby
module M
  extend self</p>

<p>  def foo</p>

<pre><code>puts 'foo'
</code></pre>

<p>  end
end</p>

<p>M.foo</p>

<h1>=> foo</h1>

<p>```</p>

<p>La ligne <code>extend self</code> nous permet de définir toutes les méthodes du
module comme étant des méthodes de classe. C'est pas plus compliqué que
ça.</p>

<p>On aurait pu écrire à la place:</p>

<p>``` ruby
module M
  def self.foo</p>

<pre><code>puts 'foo'
</code></pre>

<p>  end
end
```</p>

<p>Ou bien encore:</p>

<p>``` ruby
module M
  class &lt;&lt; self</p>

<pre><code>def foo
  puts 'foo'
end
</code></pre>

<p>  end
end
```</p>

<p>Il y a quand même une subtilité qui fait toute la différence !
Sinon ça ne serait pas drôle. En utilisant la syntaxe <code>extend self</code>,
<strong>toutes les méthodes sont des méthodes de classe</strong>, ou de module si
vous préférez ;) La différence est importante puisqu'ainsi on ne pourra
pas mélanger méthodes utilitaires et méthodes à inclure dans une classe.
Ce qui est parfois tentant, mais c'est mal. Mais tentant. Mais mal…</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vim - Comment ouvrir la fenêtre courante dans un nouvel onglet]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/03/26/vim-comment-ouvrir-la-fenetre-courante-dans-un-nouvel-onglet/"/>
    <updated>2014-03-26T21:09:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/03/26/vim-comment-ouvrir-la-fenetre-courante-dans-un-nouvel-onglet</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Vous avez un écran bien large ? Vous travaillez régulierement avec 4 ou 5
fenêtres dans le même onglet, voir plus ?
Parfois vous aimeriez bien ouvrir rapidement une de ces fenêtres dans un
nouvel onglet ?</p>

<!-- more -->


<p>Alors ça va peut-être bien être l'article le plus court de l'histoire de ce
blog:</p>

<p><code>vim
:tab sp
</code></p>

<p>Et la fenêtre courante s'ouvre dans un nouvel onglet (<code>sp</code> est l'abréviation
de <code>split</code>).</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[La méthode super en Ruby - partie 2]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/03/25/la-methode-super-en-ruby-partie-2/"/>
    <updated>2014-03-25T19:53:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/03/25/la-methode-super-en-ruby-partie-2</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Comme me le faisait remarquer ce matin un lecteur, il manque un cas à
mon article d'hier sur l'utilisation de <code>super</code> en Ruby. C'est d'autant
plus impardonnable que c'est un cas où, pour une fois, les parenthèses
sont <strong>obligatoires</strong> à la fin d'une méthode.</p>

<!-- more -->


<p>Voici donc une classe de base et une classe fille:</p>

<p>``` ruby
class Base
  def foo</p>

<pre><code>puts "Base#foo"
</code></pre>

<p>  end
end</p>

<p>class Child &lt; Base
  def foo(bar)</p>

<pre><code>super
puts "Child#foo with #{bar}"
</code></pre>

<p>  end
end
```</p>

<p>Et maintenant on essaye le tout:</p>

<p>``` ruby
child = Child.new
child.foo</p>

<h1>=> ArgumentError: wrong number of arguments (0 for 1)</h1>

<p>```</p>

<p>Boum ! Comme on l'a vu hier, <code>super</code> passe automatiquement tous les
paramètres de la méthode dans laquelle il est appelé vers la classe
de base. Et là, notre méthode <code>foo</code> dans la classe de base est sans
argument.</p>

<p>Pour résoudre ce problème, on est obligé de mettre des parenthèses
à la suite de <code>super</code>:</p>

<p>``` ruby
class Child &lt; Base
  def foo(bar)</p>

<pre><code>super()
puts "Child#foo with #{bar}"
</code></pre>

<p>  end
end
```</p>

<p><code>ruby
child = Child.new
child.foo('ok')
Base#foo
Child#foo with ok
</code></p>

<p>Voilà, oubli réparé.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
