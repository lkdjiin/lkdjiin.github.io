<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : débutant | Xavier Nayrac]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/debutant/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2015-02-26T12:21:58+01:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Les maths derrière V=RI]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/02/11/les-maths-derriere-v-equals-ri/"/>
    <updated>2015-02-11T11:22:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/02/11/les-maths-derriere-v-equals-ri</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>\(V = RI\), la formule est simple. V pour le voltage (en Volts), R pour la
résistance (en Ohms) et I pour l’intensité (en Ampères).  Grâce à elle nous
pouvons calculer l’ampérage si nous connaissons le voltage et la résistance:</p>

<p>$$
\begin{align}

  I= \frac{V}{R}
\end{align}
$$</p>

<p>Et nous pouvons aussi calculer la résistance si nous connaissons le voltage et
l’intensité:</p>

<p>$$
\begin{align}

  R= \frac{V}{I}
\end{align}
$$</p>

<p>Pas besoin d’être fort en math pour pouvoir appliquer ces 3 formules. On a
juste à faire une multiplication, ou bien une division. Mais si on veut
comprendre pourquoi les deux dernières formules <em>découlent</em> de la première, il
faut un minimum de bagage en math.</p>

<p><strong>Cet article est pour celles et ceux qui ont séchés les cours de math au
collège</strong> et qui voudraient maintenant comprendre pourquoi \(V = RI\) implique
nécessairement \(I = V / R\). Je vais tâcher de tirer et d’expliquer tous les
fils qui nous amène à déduire la seconde formule à partir de la première.</p>

<p><img class="center" src="/images/math.jpg"></p>

<!-- more -->

<h2 id="le-symbole-de-la-multiplication">Le symbole de la multiplication</h2>

<p>Le plus simple d’abord, \(RI\) est la multiplication de R par I.
Donc \(RI\) est la même chose que \(R \times I\).
Pour simplifier les choses (<em>ironie…</em>) on peut aussi
écrire le signe le la multiplication avec un point.
Les 3 lignes suivantes sont donc équivalentes:</p>

<p>$$
\begin{align}

  RI            <br />
  R \times I    <br />
  R \cdot I
\end{align}
$$</p>

<h2 id="lgalit">L’égalité</h2>

<p>Parlons maintenant du signe <code>=</code>. Il signifie qu’on a une égalité entre ce qui
se trouve à sa gauche et ce qui se trouve à sa droite. En d’autres termes, ce
qui est à gauche du signe <code>=</code> à la même valeur que ce qui est à sa droite.
Donc si V vaut 12 (c’est un exemple), alors R × I vaut
aussi exactement 12. Si je remplace V par 12 dans la formule, on voit bien que
RI vaut 12:</p>

<p>$$
\begin{align}

  12 = RI
\end{align}
$$</p>

<p>Ça ne nous
dit pas combien vaut exactement R ni combien vaut exactement I mais on sait
que la multiplication de ces deux là vaut 12. On a peut-être R = 1 et I = 12, ou
encore R = 3 et I = 4. Tout est possible du moment que \(R \times I = 12\).</p>

<p>Cette dernière égalité ( \(R \times I = 12\) ) m’amène à préciser ceci:
\(V = RI\) est la
même chose que \(RI = V\). Si vous avez du mal à penser avec des lettres,
n’hésitez pas à les remplacer régulièrement par des nombres pour voir de quoi
ça a l’air. Par exemple, si on dit que V = 12, R = 3 et I = 4, on peut écrire:</p>

<p>$$
\begin{align}

  12 = 3 \times 4
\end{align}
$$</p>

<p>Ou encore :</p>

<p>$$
\begin{align}

  3 \times 4 = 12
\end{align}
$$</p>

<p>C’est bien la même chose.</p>

<h2 id="jouons-avec-lgalit">Jouons avec l’égalité</h2>

<p>On peut faire subir aux deux cotés de l’égalité la même opération sans que cela
pose problème.</p>

<p>Par exemple on peut ajouter 1 de chaque coté:</p>

<p>$$
\begin{align}

  V + 1 = RI + 1
\end{align}
$$</p>

<p>Essayons avec des nombres. Si V = 12, R = 3 et I = 4 :</p>

<p>$$
\begin{align}

12 + 1 &amp;= 3 \times 4 + 1 <br />
13 &amp;= 12 + 1 <br />
13 &amp;= 13
\end{align}
$$</p>

<p>Ça marcherait aussi avec une soustraction ou tiens, avec une multiplication:</p>

<p>$$
\begin{align}

V \times 2 &amp;= R \times I \times 2 <br />
12 \times 2 &amp;= 3 \times 4 \times 2 <br />
24 &amp;= 12 \times 2 <br />
24 &amp;= 24
\end{align}
$$</p>

<p>Et bien sûr, ça fonctionne aussi avec la division, tant qu’on divise par
autre chose que zéro:</p>

<p>$$
\begin{align}

V / 2 &amp;= R \times I / 2 <br />
12 / 2 &amp;= 3 \times 4 / 2 <br />
6 &amp;= 12 / 2 <br />
6 &amp;= 6
\end{align}
$$</p>

<h2 id="un-truc-intressant--propos-de-la-division">Un truc intéressant à propos de la division</h2>

<p>Puisqu’on parle de division, voici un truc intéressant à propos de la division.
Quand on divise un nombre (n’importe lequel à part zéro) par lui-même on obtient toujours 1.
Toujours. Par exemple:</p>

<p>$$
\begin{align}

  12 / 12 = 1
\end{align}
$$</p>

<p>Si on généralise : \(A / A = 1\). Donc c’est pareil avec R ou I :</p>

<p>$$
\begin{align}

  R / R &amp;= 1 <br />
  I / I &amp;= 1
\end{align}
$$</p>

<h2 id="division-et-fraction">Division et fraction</h2>

<p>Jusqu’ici j’ai utilisé le signe <code>/</code> pour la division, mais celui-ci n’est pas
toujours très pratique et on le remplace souvent par une fraction. Et oui:
division et fraction c’est la même chose.</p>

<p>$$
\begin{align}

  X / Y= \frac{X}{Y}
\end{align}
$$</p>

<p>Reprenons notre formule de base :</p>

<p>$$
\begin{align}

  V = R \times I
\end{align}
$$</p>

<p>Si on divise les deux cotés par R, ça donne :</p>

<p>$$
\begin{align}

  \frac{V}{R}= \frac{R \times I}{R}
\end{align}
$$</p>

<p>On y est presque, je vous assure ! Il faut encore comprendre une dernière chose :</p>

<p>$$
\begin{align}

  \frac{R \times I}{R}=I
\end{align}
$$</p>

<p>Wait</p>

<p><img class="center" src="/images/wut.jpg"></p>

<p>Rappelez vous qu’une fraction, c’est la même chose qu’une division. Si je
généralise:</p>

<p>$$
\begin{align}

  \frac{X \times Y}{Z}=X \times Y / Z
\end{align}
$$</p>

<p>Il faut aussi savoir qu’il n’y a pas de priorité entre la multiplication et
la division, ainsi \(10 \times 2 / 5 = 4\), tout aussi bien que
\(10 / 5 \times 2 = 4\) ou que \(2 / 5 \times 10 = 4\).</p>

<p>Donc :</p>

<p>$$
\begin{align}

  \frac{R \times I}{R}
\end{align}
$$</p>

<p>Équivaut à :</p>

<p>$$
\begin{align}

  R \times I / R
\end{align}
$$</p>

<p>Ce qui est exactement pareil que :</p>

<p>$$
\begin{align}

  R / R \times I
\end{align}
$$</p>

<p>Et nous avons vu que <code>R / R</code> vaut 1, ce qui donne :</p>

<p>$$
\begin{align}

  1 \times I
\end{align}
$$</p>

<p>Ou plus simplement :</p>

<p>$$
\begin{align}

  I
\end{align}
$$</p>

<h2 id="conclusion">Conclusion</h2>

<p>Notre formule de base nous permet de calculer V à partir de R et de I:</p>

<p>$$
\begin{align}

  V = RI
\end{align}
$$</p>

<p>On joue avec en divisant chaque coté par R:</p>

<p>$$
\begin{align}

  \frac{V}{R} = \frac{RI}{R}
\end{align}
$$</p>

<p>Ce qui donne:</p>

<p>$$
\begin{align}

  \frac{V}{R} = I
\end{align}
$$</p>

<p>Qu’on remet dans le bon sens si on préfère, on peut maintenant calculer I à
partir de V et R:</p>

<p>$$
\begin{align}

  I = \frac{V}{R}
\end{align}
$$</p>

<p>Si nous avons un voltage de 5 Volts et une résistance de 1000 Ohms, combien
aurons nous d’ampères:</p>

<p>$$
\begin{align}

  I = \frac{5}{1000} = 0.005
\end{align}
$$</p>

<p>Vous venez de déduire une formule mathématique à partir d’une autre et de
l’utiliser !
Et de rattraper plusieurs heures de sèche du collège en quelques minutes ;)</p>

<p>À plus tard.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Une machine de Turing en Ruby - Une bande de données infinie]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/02/05/une-machine-de-turing-en-ruby-une-bande-de-donnees-infinie/"/>
    <updated>2015-02-05T18:13:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/02/05/une-machine-de-turing-en-ruby-une-bande-de-donnees-infinie</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Dans la définition d’une machine de Turing on trouve:</p>

<blockquote>
  <p>Le ruban est supposé être de longueur infinie vers la gauche ou vers la droite, en d’autres termes la machine doit toujours avoir assez de longueur de ruban pour son exécution.
— Wikipédia</p>
</blockquote>

<p>C’était une grande limitation de l’implémentation de <a href="https://github.com/lkdjiin/turing_machine">ma machine de Turing</a>
que d’avoir une bande de taille fixe. Avec la nouvelle version, cette limitation
est désormais levée.</p>

<p><img class="center" src="/images/infinity.jpg"></p>

<!-- more -->

<p>Permettre à la bande de grandir à l’infini (en théorie, hein, parce que en
pratique on est toujours limité par la mémoire de l’ordinateur) est finalement
très simple:</p>

<p>``` ruby lib/turing_machine/tape.rb
module TuringMachine</p>

<p>class Tape</p>

<pre><code>BLANK_SYMBOL = '0'

def initialize(data = BLANK_SYMBOL)
  @symbols = data.scan(/./)
  @index = 0
end

[...]

def shift_left
  if @index == 0
    @symbols.unshift(BLANK_SYMBOL)
  else
    @index -= 1
  end
end

def shift_right
  @symbols.push(BLANK_SYMBOL) if @index == @symbols.size - 1
  @index += 1
end

[...] ```
</code></pre>

<p>Voici quelques explications.</p>

<pre><code>@symbols = data.scan(/./)
</code></pre>

<p>Dans le constructeur, on se sert de <code>String#scan</code> pour construire un tableau
avec les données initiales de la bande. Par exemple:</p>

<p><code>irb
&gt;&gt; "110".scan(/./)
#=&gt;["1", "1", "0"]
</code></p>

<pre><code>@index = 0
</code></pre>

<p>Dans le constructeur toujours, la position de la tête de lecture est
initialement à zéro.</p>

<pre><code>def shift_left
  if @index == 0
    @symbols.unshift(BLANK_SYMBOL)
  else
    @index -= 1
  end
end
</code></pre>

<p>Lorsqu’on bouge la tête de lecture à gauche, nous avons deux cas possibles.
Soit la tête de lecture est déjà dans la position la plus à gauche
(<code>if @index == 0</code>) et dans ce cas il faut créer une nouvelle cellule en tête
du tableau:</p>

<p><code>irb
&gt;&gt; ["1", "2"].unshift("0")
#=&gt;["0", "1", "2"]
</code></p>

<p>Soit la tête de lecture est dans une autre position, et il suffit de la décaler
d’un cran vers la gauche (<code>@index -= 1</code>).</p>

<pre><code>def shift_right
  @symbols.push(BLANK_SYMBOL) if @index == @symbols.size - 1
  @index += 1
end
</code></pre>

<p>Lorsqu’on bouge la tête de lecture à droite, il faut ajouter une cellule à la
fin du tableau (<code>@symbols.push</code>) seulement si la tête de lecture est placée
toute à droite du tableau (<code>@index == @symbols.size - 1</code>).</p>

<p>Dans tous les cas, il faut déplacer la tête de lecture d’un cran à droite
(<code>@index += 1</code>).</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Une machine de Turing en Ruby - Le parser]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/02/02/une-machine-de-turing-en-ruby-le-parser/"/>
    <updated>2015-02-02T18:04:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/02/02/une-machine-de-turing-en-ruby-le-parser</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>La machine de Turing réalisée dans le <a href="/blog/2015/02/01/une-machine-de-turing-en-ruby/">dernier article</a>
était seulement un brouillon, et elle souffre de plusieurs limitations.
J’aimerais maintenant faire évoluer le programme en permettant à l’utilisateur
de charger un jeu d’instructions quelconque. Pour cela j’aurai besoin
d’un <em>parser</em>, qui sera vite écrit grâce à Ruby.</p>

<p><img class="center" src="/images/gears4.jpg"></p>

<!-- more -->

<p>Un jeu d’instruction pour la machine de Turing ressemblera à ceci (si vous avez
besoin du code, <a href="https://github.com/lkdjiin/turing_machine">il est ici</a>):</p>

<p><code>raw instruction_sets/busy_beaver_3
0 A =&gt; 1 R B
1 A =&gt; 1 L C
0 B =&gt; 1 L A
1 B =&gt; 1 R B
0 C =&gt; 1 L B
1 C =&gt; 1 R HALT
</code></p>

<p>C’est l’algorithme <em>busy beaver à 3 états</em> que j’ai utilisé pour coder la
première version de la machine. Il faut écrire un <em>parser</em> qui va transformer
ce <em>code source</em> en ce hash Ruby, utilisé en interne par la machine:</p>

<p><code>
{
  ['0', 'A'] =&gt; {write: '1', move: 'R', next_state: 'B'},
  ['1', 'A'] =&gt; {write: '1', move: 'L', next_state: 'C'},
  ['0', 'B'] =&gt; {write: '1', move: 'L', next_state: 'A'},
  ['1', 'B'] =&gt; {write: '1', move: 'R', next_state: 'B'},
  ['0', 'C'] =&gt; {write: '1', move: 'L', next_state: 'B'},
  ['1', 'C'] =&gt; {write: '1', move: 'R', next_state: 'HALT'},
}
</code></p>

<p>Voici le parser, qui est construit autour de la méthode <code>String#split</code>.</p>

<p>``` ruby lib/turing_machine/instructions_parser.rb
module TuringMachine</p>

<p>class InstructionsParser</p>

<pre><code>def initialize(raw_instructions)
  @lines = raw_instructions.split("\n")
  @instructions = {}
end

def parse
  build_instructions
  @instructions
end

private

def build_instructions
  @lines.each do |instruction|
    keys, value = instruction.split('=&gt;')
    key_symbol, key_state = keys.split
    write, move, next_state = value.split
    @instructions[[key_symbol, key_state]] = {
      write: write, move: move, next_state: next_state
    }
  end
end
</code></pre>

<p>end</p>

<p>end
```</p>

<p>On va l’utiliser comme ça:</p>

<p><code>ruby
raw_instructions = IO.read(ARGV[0])
parser = InstructionsParser.new(raw_instructions)
instructions = parser.parse
</code></p>

<p>Je vais expliquer plus en détail. Tout d’abord dans le constructeur, on divise
la grande chaîne de caractères en entrée en autant de lignes indépendantes:</p>

<pre><code>@lines = raw_instructions.split("\n")
</code></pre>

<p>Puis dans la méthode privée <code>build_instructions</code>, on itère sur chacune des
lignes pour construire le hash:</p>

<pre><code>@lines.each do |instruction|
</code></pre>

<p>Chaque ligne est d’abord divisé en deux parties, de chaque coté de <code>=&gt;</code>:</p>

<pre><code>keys, value = instruction.split('=&gt;')
</code></pre>

<p>La partie des clés (celle de gauche) est à son tour divisé en deux, le symbole
sous la tête de lecture et l’état de la machine:</p>

<pre><code>key_symbol, key_state = keys.split
</code></pre>

<p>Ensuite c’est au tour de la partie de droite, celle qui représente la prochaine
instruction:</p>

<pre><code>write, move, next_state = value.split
</code></pre>

<p>Enfin, on ajoute clé et valeur dans le hash:</p>

<pre><code>@instructions[[key_symbol, key_state]] = {
  write: write, move: move, next_state: next_state
}
</code></pre>

<p>Pour finir, voici mon premier jeu d’instructions pour une machine de Turing:</p>

<p><code>raw instruction_sets/write101
0 A =&gt; 1 R B
0 B =&gt; 0 R C
0 C =&gt; 1 R HALT
</code></p>

<p>Ça fait quoi ? Ça écrit 101, tout simplement :</p>

<pre><code> turing_machine instruction_sets/write101 
  1 0000000000000000000000000000000000000000 A -&gt; 1RB
                       ^
  2 0000000000000000000100000000000000000000 B -&gt; 0RC
                        ^
  3 0000000000000000000100000000000000000000 C -&gt; 1RHALT
                         ^
  4 0000000000000000000101000000000000000000 HALT
</code></pre>

<p>Je vous rappelle que vous pouvez consulter le code de la
<a href="https://github.com/lkdjiin/turing_machine">machine de Turing</a>.</p>

<p>Voilà, avec l’aide de <code>String#split</code> il est facile d’écrire un parser simple.
Alors bien sûr, ce parser n’est pas vraiment complet, il manque par exemple la
gestion des erreurs. Mais il y a des choses plus urgentes à implémenter, comme
le mouvement nul, le ruban infini, ou la possibilité de commencer le programme
avec un ruban qui contient des données…</p>

<p>À plus tard.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mieux utiliser le programme gem]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/01/23/mieux-utiliser-le-programme-gem/"/>
    <updated>2015-01-23T11:49:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/01/23/mieux-utiliser-le-programme-gem</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Le programme <code>gem</code> est bien connu des rubyistes, et ce pour une bonne raison:
il est au coeur de l’utilisation de Ruby. Si je veux par exemple profiter
de <a href="https://github.com/michaeldv/awesome_print">awesome_print</a>
dans ma console irb, je vais l’installer grâce à <code>gem</code>:</p>

<pre><code>$ gem install awesome_print
</code></pre>

<p>De même, avez-vous déjà vu une appli Rails se passer d’un Gemfile ?</p>

<p>``` ruby Gemfile
source ‘https://rubygems.org’
ruby ‘2.0.0’</p>

<p>gem ‘rails’, ‘4.0.0’
gem ‘pg’
…
```</p>

<p>En fait, si vous avez fait seulement 3 jours de Ruby dans votre vie, vous savez
utiliser <code>gem</code>. Mais l’utilisez-vous à fond ? Moi, non. Enfin pas encore.</p>

<p><img class="center" src="/images/diamond-1_512.png"></p>

<!-- more -->

<p>Depuis 5 ou 6 ans que j’utilise quotidiennement Ruby, je n’avais jamais
écrit <code>gem --help</code>. Jamais. Pas une seule fois.</p>

<pre><code>$ gem --help
RubyGems is a sophisticated package manager for Ruby.  This is a
...
  Further help:
    gem help commands            list all 'gem' commands
    gem help examples            show some examples of usage
    gem help gem_dependencies    gem dependencies file guide
    gem help platforms           gem platforms guide
    gem help &lt;COMMAND&gt;           show help on COMMAND
    gem server                   present a web page at
...
</code></pre>

<p>J’ai l’impression qu’il y a de quoi lire et de quoi faire. Voici donc un rapide
tour d’horizon des possibilités offertes par <code>gem</code>.</p>

<h2 id="gem-help-commands">gem help commands</h2>

<p>Commençons par regarder les différentes commandes:</p>

<pre><code>$ gem help commands
GEM commands are:

    build                  Build a gem from a gemspec
    cert                   Manage RubyGems certificates and signing settings
...
    wrappers               Re run generation of environment wrappers for gems.
    yank                   Remove a pushed gem from the index
...
Commands may be abbreviated, so long as they are unambiguous.
</code></pre>

<p>J’ai abrégé la sortie ci-dessus car il y a <strong>33 commandes</strong>, je n’avais vraiment
pas la moindre idée d’un nombre si important de commande. En voici la liste:</p>

<ul>
  <li>build</li>
  <li>cert</li>
  <li>check</li>
  <li>cleanup</li>
  <li>contents</li>
  <li>dependency</li>
  <li>environment</li>
  <li>fetch</li>
  <li>generate_index</li>
  <li>help</li>
  <li>install</li>
  <li>list</li>
  <li>lock</li>
  <li>mirror</li>
  <li>open</li>
  <li>outdated</li>
  <li>owner</li>
  <li>pristine</li>
  <li>push</li>
  <li>query</li>
  <li>rdoc</li>
  <li>regenerate_binstubs</li>
  <li>search</li>
  <li>server</li>
  <li>sources</li>
  <li>specification</li>
  <li>stale</li>
  <li>uninstall</li>
  <li>unpack</li>
  <li>update</li>
  <li>which</li>
  <li>wrappers</li>
  <li>yank</li>
</ul>

<p>Personnellement j’ai déjà utilisé <code>build</code>, <code>cleanup</code>, <code>install</code>, <code>list</code>,
<code>push</code>, <code>uninstall</code>, <code>update</code> et c’est tout. 7 commandes sur 33, je suis loin du compte.</p>

<p>En regardant d’un peu plus près la sortie de <code>gem help commands</code>,
je m’aperçois qu’on peut abréger chaque commande:</p>

<pre><code>$ gem install my_gem
</code></pre>

<p>seras donc identique à:</p>

<pre><code>$ gem i my_gem
</code></pre>

<p>J’aime beaucoup cette idée.</p>

<h2 id="gem-help-acommand">gem help a_command</h2>

<p>On peut obtenir de l’aide sur une commande spécifique.
Par exemple, avec <code>gem help install</code>, j’apprend que les options permettant de
ne pas générer la documentation:</p>

<pre><code>--no-rdoc
--no-ri
</code></pre>

<p>sont des options dépréciées. On peut maintenant utiliser:</p>

<pre><code>-N, --no-document
</code></pre>

<h2 id="gem-help-examples">gem help examples</h2>

<p>Évidemment cette commande affiche plusieurs exemples ;) Comme la manière
d’installer une version spécifique d’une gem:</p>

<pre><code>$ gem install rake --version 0.3.1
</code></pre>

<p>Je ne sais pas pourquoi je ne me souviens jamais de cette manière de faire,
pourtant évidente. Maintenant je n’aurais plus besoin de poser la question à
un moteur de recherche, je me contenterais de <code>gem help examples</code>.</p>

<h2 id="gem-server">gem server</h2>

<p>Une petite curiosité : <code>gem server</code> fournit une page html, à consulter à
l’adresse <code>localhost:8808</code> avec la liste des gems installées. Ça semble un peu
gadget, d’autant plus qu’on peut avoir ces informations rapidement dans la
console avec la commande <code>list</code>:</p>

<pre><code>$ gem list

*** LOCAL GEMS ***

awesome_print (1.6.1)
bigdecimal (1.2.6)
bundler (1.7.9)
...
</code></pre>

<p>Et puis avec <code>gem help list</code>, j’ai trouvé comment obtenir des détails sur les
gems:</p>

<pre><code>$ gem list -d

*** LOCAL GEMS ***

awesome_print (1.6.1)
    Author: Michael Dvorkin
    Homepage: http://github.com/michaeldv/awesome_print
    License: MIT
    Installed at: /home/xavier/.rvm/gems/ruby-2.2.0

    Pretty print Ruby objects with proper indentation and colors

bigdecimal (1.2.6)
    Authors: Kenta Murata, Zachary Scott, Shigeo Kobayashi
    Homepage: http://www.ruby-lang.org
    Installed at (default): /home/xavier/.rvm/rubies/ruby-2.2.0/lib/ruby/gems/2.2.0

Arbitrary-precision decimal floating-point number library.

...
</code></pre>

<h2 id="encore-du-boulot">Encore du boulot…</h2>

<p>Je n’ai pas fini de la lire, cette documentation. Elle semble prometteuse, et
je sens que je vais apprendre encore pas mal de choses.</p>

<p>J’espère vous avoir donné envie de regarder certaines commandes plus en détails.
Dans un monde idéal, il faudrait que je regarde les 33…</p>

<p>À bientôt.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby 2.2 - Une sélection des nouvelles méthodes]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/12/27/ruby-2-dot-2-une-selection-des-nouvelles-methodes/"/>
    <updated>2014-12-27T15:40:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/12/27/ruby-2-dot-2-une-selection-des-nouvelles-methodes</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Ça y est, noël est passé et Ruby 2.2.0 est arrivé.
Je vous ai préparé une sélection (personnelle) des nouveautés de cette dernière
version de Ruby.</p>

<p>Vous pouvez voir la liste exhaustive des changements ici:
<a href="https://github.com/ruby/ruby/blob/v2_2_0/NEWS">ruby v2.2.0 NEWS</a></p>

<!-- more -->

<h2 id="les-symboles-pour-les-cls-dun-hash-peuvent-tre-entre-guillemets">Les symboles pour les clés d’un Hash peuvent être entre guillemets</h2>

<p>Ce qui autorise l’utilisation des espaces.</p>

<p>``` irb
» hash = { “foo bar”: “baz” }
=&gt; {:”foo bar”=&gt;”baz”}</p>

<blockquote>
  <blockquote>
    <p>hash[:”foo bar”]
=&gt; “baz”
```</p>
  </blockquote>
</blockquote>

<h2 id="enumerableslicewhen">Enumerable#slice_when</h2>

<p>J’ai le tableau suivant:</p>

<p><code>irb
&gt;&gt; a = [1, 2, 4, 9, 10, 11, 12, 15, 16, 19, 20, 21]
</code></p>

<p>Je veux rassembler ensemble les séries de nombre qui se suivent. Autrement dit,
je veux obtenir ceci:</p>

<pre><code>[ [1, 2], [4], [9, 10, 11, 12], [15, 16], [19, 20, 21] ]
</code></pre>

<p><code>slice_when</code> me fait ça facilement:</p>

<p><code>irb
&gt;&gt; a.slice_when {|i, j| i+1 != j }.to_a
=&gt; [[1, 2], [4], [9, 10, 11, 12], [15, 16], [19, 20, 21]]
</code></p>

<h2 id="max-et-min-peuvent-retourner-plusieurs-valeurs">max et min peuvent retourner plusieurs valeurs</h2>

<p>Plutôt que d’obtenir la seule et unique valeur limite, on peut maintenant
obtenir une liste.</p>

<p>``` irb
» [1, 2, 3].max
=&gt; 3</p>

<blockquote>
  <blockquote>
    <p>[1, 2, 3].max(2)
=&gt; [3, 2]</p>
  </blockquote>
</blockquote>

<blockquote>
  <blockquote>
    <p>[1, 2, 3, 3].max(2)
=&gt; [3, 3]
```</p>
  </blockquote>
</blockquote>

<h2 id="methodcurry">Method#curry</h2>

<p>Tout d’abord, voici une méthode <code>add</code>, qui prend 3 arguments:</p>

<p><code>ruby
def add(a, b, c)
  a + b + c
end
</code></p>

<p>On <em>currifie</em> cette méthode:</p>

<p><code>irb
&gt;&gt; proc = self.method(:add).curry
=&gt; #&lt;Proc:0x8f945a4 (lambda)&gt;
</code></p>

<p>Je peux maintenant l’appliquer partiellement:</p>

<p>``` irb
» proc = proc.call(1, 2)
=&gt; #&lt;Proc:0x9407dfc (lambda)&gt;</p>

<blockquote>
  <blockquote>
    <p>proc.call(3)
=&gt; 6</p>
  </blockquote>
</blockquote>

<blockquote>
  <blockquote>
    <p>proc.call(10)
=&gt; 13
```</p>
  </blockquote>
</blockquote>

<h2 id="la-lib-etc">La lib Etc</h2>

<p>Pour finir, voici deux nouvelles méthodes de la bibliothèque standard <code>Etc</code>.</p>

<p>``` irb
» require ‘etc’</p>

<blockquote>
  <blockquote>
    <p>Etc.uname
=&gt; {:sysname=&gt;”Linux”, … }</p>
  </blockquote>
</blockquote>

<blockquote>
  <blockquote>
    <p>Etc.nprocessors
=&gt; 2
```</p>
  </blockquote>
</blockquote>

<script id="fb33k8u">(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>

<p></p>
]]></content>
  </entry>
  
</feed>
