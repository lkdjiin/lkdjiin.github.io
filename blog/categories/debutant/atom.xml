<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : débutant | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/debutant/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2014-03-16T21:21:19+01:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Vim - plugin pour markdown - la suite]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/03/15/vim-plugin-pour-markdown-la-suite/"/>
    <updated>2014-03-15T20:24:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/03/15/vim-plugin-pour-markdown-la-suite</id>
    <content type="html"><![CDATA[<p>L'embryon de plugin Vim pour les titres en markdown écrit
<a href="/blog/2014/03/12/vim-un-plugin-minimal-pour-les-titres-markdown/">la dernière fois</a>
ne me satisfait pas du tout. En effet, il ne fonctionne pas avec ma
configuration personnelle, adapté pour le clavier bépo.</p>

<!-- more -->


<p>La fonction pour faire un titre était la suivante:</p>

<p><code>vim autoload/quickmarkdown.vim
function! quickmarkdown#title1()
  execute "normal yypVr="
endfunction
</code></p>

<p>Chez moi, la touche pour la fonction de remplacement n'est pas <code>r</code>, mais <code>h</code>.
Voici donc une nouvelle fonction qui devrait marcher pour tout type de
configuration (enfin j'espère):</p>

<p><code>vim autoload/quickmarkdown.vim
function! quickmarkdown#title1()
  execute "normal yyp"
  execute ":s/./=/g"
endfunction
</code></p>

<p>Plutôt que de remplacer la ligne avec <code>Vr=</code>, on la remplace avec une
substitution. Pour être <em>vraiment</em> utilisable partout, il me reste à
trouver comment me passer du <code>yyp</code> pour dupliquer une ligne, histoire
que ça fonctionne même si vous avez remappé <code>y</code> ou <code>p</code>…</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vim - Un plugin minimal pour les titres markdown]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/03/12/vim-un-plugin-minimal-pour-les-titres-markdown/"/>
    <updated>2014-03-12T21:32:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/03/12/vim-un-plugin-minimal-pour-les-titres-markdown</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Hier on a vu <a href="/blog/2014/03/11/vim-cas-pratique-pour-les-debutants-les-titres-en-markdown/">comment faire rapidement des titres au format markdown</a>.
Aujourd'hui on transforme ça en plugin. Enfin, en un embryon de plugin.</p>

<!-- more -->


<p>Voici donc un plugin bricolé en deux minutes qui fait des titres de niveau 1
en markdown.</p>

<p>``` vim plugin/quickmarkdown.vim
if exists(&lsquo;g:loaded_quickmarkdown&rsquo;) || &amp;cp || v:version &lt; 700
  finish
endif
let g:loaded_quickmarkdown = 1</p>

<p>command! QuickMarkdownTitle1 call quickmarkdown#title1()
```</p>

<p><code>vim autoload/quickmarkdown.vim
function! quickmarkdown#title1()
  execute "normal yypVr="
endfunction
</code></p>

<p>Et en mettant ce qui suit dans votre vimrc, on peut l'activer avec
leader puis <code>=</code>:</p>

<p><code>vim
map&lt;Leader&gt;= :QuickMarkdownTitle1&lt;Enter&gt;
</code></p>

<p>Quand j'aurais le temps j'ajouterais les niveaux 2, 3, 4, etc. Et aussi
la documentation et quelques explications ;)</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vim - Cas pratique pour les débutants : les titres en markdown]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/03/11/vim-cas-pratique-pour-les-debutants-les-titres-en-markdown/"/>
    <updated>2014-03-11T21:09:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/03/11/vim-cas-pratique-pour-les-debutants-les-titres-en-markdown</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Vous débutez sur Vim ? Je vous propose aujourd'hui des exercices pratiques
pour définir des titres au format markdown.</p>

<!-- more -->


<p>Un titre de niveau 1 en markdown s'écrit comme ceci:</p>

<pre><code>Titre de niveau 1
=================
</code></pre>

<p>On est pas obligé de mettre autant de <code>=</code> que de caractères dans le titre
(de mémoire je crois que 3 suffisent), mais c'est quand même agréable à
l'œil.</p>

<p>La suite de commandes pour obtenir ça est: <code>yypVr=</code>. On décortique:</p>

<ul>
<li><code>yy</code> copie la ligne du titre dans un buffer.</li>
<li><code>p</code> affiche ce buffer sur la ligne du dessous et nous place sur cette
nouvelle ligne.</li>
<li><code>V</code> passe cette nouvelle ligne en mode selection.</li>
<li><code>r=</code> remplace toute la selection par autant de <code>=</code>.</li>
</ul>


<p>Pour les titres de niveau 2, on remplace le <code>=</code> par un <code>-</code>.</p>

<p>Voilà, la prochaine fois on en fera peut-être un plugin, allez savoir…</p>

<p>Et vous, vous faites comment ?</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby - Utiliser les blocs pour faire du refactoring - partie 2]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/03/10/ruby-utiliser-les-blocs-pour-faire-du-refactoring-partie-2/"/>
    <updated>2014-03-10T15:58:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/03/10/ruby-utiliser-les-blocs-pour-faire-du-refactoring-partie-2</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Suite à l'article d'hier
(<a href="/blog/2014/03/09/ruby-utiliser-les-blocs-pour-faire-du-refactoring/">Utiliser les blocs pour faire du refactoring</a>),
on m'a demandé la différence entre <code>block.call</code> et <code>yield</code>. C'est parti.</p>

<!-- more -->


<p>On s'était arrêté là:</p>

<p>``` ruby test.rb
class Bidule
  def un</p>

<pre><code>helper('un') { puts 'Au milieu de la méthode un' }
</code></pre>

<p>  end</p>

<p>  def deux</p>

<pre><code>helper('deux') do
  puts 'Ceci est le milieu de la méthode deux'
end
</code></pre>

<p>  end</p>

<p>  private</p>

<p>  def helper(argument, &amp;block)</p>

<pre><code>puts "Début de la méthode #{argument}"
block.call
puts "Fin de la méthode #{argument}"
</code></pre>

<p>  end
end</p>

<p>bidule = Bidule.new
bidule.un
bidule.deux
```</p>

<p>Essayons de remplacer <code>block.call</code> par <code>yield</code>:</p>

<p>``` ruby test.rb
class Bidule
  def un</p>

<pre><code>helper('un') { puts 'Au milieu de la méthode un' }
</code></pre>

<p>  end</p>

<p>  def deux</p>

<pre><code>helper('deux') do
  puts 'Ceci est le milieu de la méthode deux'
end
</code></pre>

<p>  end</p>

<p>  private</p>

<p>  def helper(argument, &amp;block)</p>

<pre><code>puts "Début de la méthode #{argument}"
yield
puts "Fin de la méthode #{argument}"
</code></pre>

<p>  end
end</p>

<p>bidule = Bidule.new
bidule.un
bidule.deux
```</p>

<p>Lorsqu'on lance le programme, on voit qu'il n'y a pas de différences:</p>

<p><code>bash
$ ruby test.rb
Début de la méthode un
Au milieu de la méthode un
Fin de la méthode un
Début de la méthode deux
Ceci est le milieu de la méthode deux
Fin de la méthode deux
</code></p>

<p>Ok, donc <code>block.call</code> et <code>yield</code> c'est pareil ? Attends encore. Essayons
maintenant de supprimer le <code>&amp;block</code>:</p>

<p>``` ruby test.rb
class Bidule
  def un</p>

<pre><code>helper('un') { puts 'Au milieu de la méthode un' }
</code></pre>

<p>  end</p>

<p>  def deux</p>

<pre><code>helper('deux') do
  puts 'Ceci est le milieu de la méthode deux'
end
</code></pre>

<p>  end</p>

<p>  private</p>

<p>  def helper(argument)</p>

<pre><code>puts "Début de la méthode #{argument}"
yield
puts "Fin de la méthode #{argument}"
</code></pre>

<p>  end
end</p>

<p>bidule = Bidule.new
bidule.un
bidule.deux
```</p>

<p>Toujours pas de différences ! Par contre, on ne pourra pas appeler
<code>block.call</code> sans avoir défini <code>&amp;block</code>:</p>

<p>``` ruby
  def helper(argument)</p>

<pre><code>puts "Début de la méthode #{argument}"
block.call
puts "Fin de la méthode #{argument}"
</code></pre>

<p>  end
```</p>

<p>Le code ci-dessus donnera évidemment une erreur:</p>

<p><code>`` bash
$ ruby test.rb
Début de la méthode un
test.rb:16:in</code>helper': undefined local variable or method `block' for</p>

<h1>&lt;Bidule:0x9eaf6ec> (NameError)</h1>

<p>```</p>

<p>Toutes ces expérimentations nous ammène à une première conclusion: <em>Les
blocs sont implicites, et donc ils sont partout</em>. Ce que confirme, s'il en
est encore besoin, la session irb suivante:</p>

<p>``` irb</p>

<blockquote><blockquote><p>def foo(arg)
  puts arg
end
=> :foo
foo(&lsquo;ok&rsquo;) { puts &lsquo;I am in a block&rsquo; }
ok
```</p></blockquote></blockquote>

<p>Le contenu du bloc n'est jamais évalué, mais ne provoque pas d'erreur
lors de l'appel de <code>foo</code>.</p>

<p>Seconde conclusion, <code>block.call</code> et <code>yield</code> fonctionnent à l'identique.
Bien que je préfère <code>block.call</code>, qui me force à documenter la méthode
avec le <code>&amp;block</code>.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby - Utiliser les blocs pour faire du refactoring]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/03/09/ruby-utiliser-les-blocs-pour-faire-du-refactoring/"/>
    <updated>2014-03-09T15:50:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/03/09/ruby-utiliser-les-blocs-pour-faire-du-refactoring</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Suivant le(s) langage(s) que vous pratiquiez avant de vous mettre à Ruby,
les blocs peuvent vous sembler plus ou moins obscurs. Voici un
exemple d'utilisation possible, lorsque vous faites du refactoring.</p>

<!-- more -->


<p>Prenons le programme suivant:</p>

<p>``` ruby test1.rb
class Bidule
  def un</p>

<pre><code>puts 'Début de la méthode un'
puts 'Au milieu de la méthode un'
puts 'Fin de la méthode un'
</code></pre>

<p>  end</p>

<p>  def deux</p>

<pre><code>puts 'Début de la méthode deux'
puts 'Au milieu de la méthode deux'
puts 'Fin de la méthode deux'
</code></pre>

<p>  end
end</p>

<p>bidule = Bidule.new
bidule.un
bidule.deux
```</p>

<p>Voici ce que ça donne quand on le lance:</p>

<p><code>bash
$ ruby test1.rb
Début de la méthode un
Au milieu de la méthode un
Fin de la méthode un
Début de la méthode deux
Au milieu de la méthode deux
Fin de la méthode deux
</code></p>

<p>Le problème de la classe <code>Bidule</code> est que ses méthodes <code>un</code> et <code>deux</code>
sont identiques (ou presque). On aura donc intérêt à extraire une
méthode helper:</p>

<p>``` ruby test1.rb
class Bidule
  def un</p>

<pre><code>helper('un')
</code></pre>

<p>  end</p>

<p>  def deux</p>

<pre><code>helper('deux')
</code></pre>

<p>  end</p>

<p>  private</p>

<p>  def helper(argument)</p>

<pre><code>puts "Début de la méthode #{argument}"
puts "Au milieu de la méthode #{argument}"
puts "Fin de la méthode #{argument}"
</code></pre>

<p>  end
end
```</p>

<p>Voilà, c'était du refactoring classique.</p>

<p>Maintenant imaginons que la classe <code>Bidule</code> soit ainsi:</p>

<p>``` ruby test1.rb
class Bidule
  def un</p>

<pre><code>puts 'Début de la méthode un'
puts 'Au milieu de la méthode un'
puts 'Fin de la méthode un'
</code></pre>

<p>  end</p>

<p>  def deux</p>

<pre><code>puts 'Début de la méthode deux'
puts 'Ceci est le milieu de la méthode deux'
puts 'Fin de la méthode deux'
</code></pre>

<p>  end
end
```</p>

<p>Vous avez remarqué la différence:</p>

<p>``` ruby
  def un</p>

<pre><code>#
puts 'Au milieu de la méthode un'
#
</code></pre>

<p>  end</p>

<p>  def deux</p>

<pre><code>#
puts 'Ceci est le milieu de la méthode deux'
#
</code></pre>

<p>  end
```</p>

<p>Cette fois les méthodes <code>un</code> et <code>deux</code> se distinguent un peu plus, bien
que la logique reste identique. On peux donc tirer avantage des blocs:</p>

<p>``` ruby test1.rb
class Bidule
  def un</p>

<pre><code>helper('un') { puts 'Au milieu de la méthode un' }
</code></pre>

<p>  end</p>

<p>  def deux</p>

<pre><code>helper('deux') do
  puts 'Ceci est le milieu de la méthode deux'
end
</code></pre>

<p>  end</p>

<p>  private</p>

<p>  def helper(argument, &amp;block)</p>

<pre><code>puts "Début de la méthode #{argument}"
block.call
puts "Fin de la méthode #{argument}"
</code></pre>

<p>  end
end
```</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
