<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : débutant | Xavier Nayrac]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/debutant/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2015-03-03T10:38:11+01:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Un jeu de Simon - Étape 1]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/03/01/un-jeu-de-simon-etape-1/"/>
    <updated>2015-03-01T21:00:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/03/01/un-jeu-de-simon-etape-1</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Lors d’un projet du dimanche avec ma fille, j’ai commencé un
<a href="http://fr.wikipedia.org/wiki/Simon_%28jeu%29">jeu de Simon</a> sur l’Arduino.
Nous avons simplifié les règles au maximum (ma fille n’a pas 3 ans) et obtenu
ce que je vous propose dans cet article.</p>

<p>C’est seulement un point de départ, j’ai bien envie d’implémenter le jeu en
entier et d’en faire un objet réel. Il devrait donc y avoir d’autres articles…</p>

<p><img class="center" src="/images/simon-1.jpg"></p>

<!-- more -->

<h2 id="les-rgles">Les règles</h2>

<p>J’ai réduit les règles du jeu au plus simple : Il y a deux couleurs, rouge et
vert. La machine donne une couleur en allumant une LED et le joueur répond en
appuyant sur un bouton de couleur. Si la réponse est juste le joueur gagne et
une nouvelle partie commence. Si la réponse est fausse les LEDs clignotent
quelque temps pour signaler que le jeu est perdu et une nouvelle partie
commence.</p>

<p>Difficile de faire plus simple, hein ?</p>

<h2 id="les-composants">Les composants</h2>

<p>Nous aurons besoin de :</p>

<ul>
  <li>2 LEDs, une rouge et une verte</li>
  <li>2 boutons momentanés, si possible un rouge et un vert (sinon les gris
moches ça marche aussi)</li>
  <li>2 résistances de 220 Ohms pour les LEDs</li>
  <li>2 résistances de 10 kilo Ohms pour les boutons</li>
  <li>du câble</li>
</ul>

<h2 id="lassemblage">L’assemblage</h2>

<p><img class="center" src="/images/simon-etape1-bb.png"></p>

<h2 id="le-code">Le code</h2>

<p>Rien de spécial à dire pour le code, si ce n’est qu’il a été écrit sous la
pression de ma fille et la patience n’est pas son fort. Ça pourrait expliquer
pourquoi le code n’est pas très joli.</p>

<p>``` c
const byte RED = 0;
const byte GREEN = 1;</p>

<p>byte buttonRed = 8;
byte buttonGreen = 9;
byte ledRed = 2;
byte ledGreen = 3;
byte computerTurn = 1;
byte lastPly;</p>

<p>void setup() {
  pinMode(buttonRed, INPUT);
  pinMode(buttonGreen, INPUT);
  pinMode(ledRed, OUTPUT);
  pinMode(ledGreen, OUTPUT);</p>

<p>randomSeed(analogRead(0));
}</p>

<p>void loop() {
  if(computerTurn) {
    lastPly = random(2);
    allLedsOff();
    if(lastPly == RED) {
      digitalWrite(ledRed, HIGH);
    } else {
      digitalWrite(ledGreen, HIGH);
    }
    delay(300);
    allLedsOff();
    computerTurn = 0;
  } else {
    int stateRed = digitalRead(buttonRed);
    int stateGreen = digitalRead(buttonGreen);
    if(stateRed || stateGreen) {
      if(stateRed) {
        lightTheLed(ledRed);
      } else {
        lightTheLed(ledGreen);
      }
      if(stateRed &amp;&amp; lastPly == RED) {
        delay(2000);
      } else if(stateGreen &amp;&amp; lastPly == GREEN) {
        delay(2000);
      } else if((stateRed &amp;&amp; lastPly == GREEN) || (stateGreen &amp;&amp; lastPly == RED)) {
        blinkLeds();
        delay(2000);
      }
      computerTurn = 1;
    }
    delay(1);
  }
}</p>

<p>void allLedsOff() {
  digitalWrite(ledRed, LOW);
  digitalWrite(ledGreen, LOW);
}</p>

<p>void lightTheLed(byte led) {
  digitalWrite(led, HIGH);
  delay(200);
  digitalWrite(led, LOW);
}</p>

<p>void blinkLeds() {
  for(int i = 0; i &lt; 10; i++) {
    digitalWrite(ledRed, HIGH);
    digitalWrite(ledGreen, HIGH);
    delay(100);
    allLedsOff();
    delay(100);
  }
}
```</p>

<h2 id="la-suite">La suite</h2>

<p>Il reste beaucoup de choses à faire… Ajouter le bleu et le jaune ; ajouter du son ;
enregistrer les séquences de couleur ; le vrai jeu de Simon, quoi.
Et ensuite il faudra en faire un objet autonome, sans Arduino.</p>

<p>Alors à la prochaine.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les maths derrière V=RI]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/02/11/les-maths-derriere-v-equals-ri/"/>
    <updated>2015-02-11T11:22:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/02/11/les-maths-derriere-v-equals-ri</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>\(V = RI\), la formule est simple. V pour le voltage (en Volts), R pour la
résistance (en Ohms) et I pour l’intensité (en Ampères).  Grâce à elle nous
pouvons calculer l’ampérage si nous connaissons le voltage et la résistance:</p>

<p>$$
\begin{align}

  I= \frac{V}{R}
\end{align}
$$</p>

<p>Et nous pouvons aussi calculer la résistance si nous connaissons le voltage et
l’intensité:</p>

<p>$$
\begin{align}

  R= \frac{V}{I}
\end{align}
$$</p>

<p>Pas besoin d’être fort en math pour pouvoir appliquer ces 3 formules. On a
juste à faire une multiplication, ou bien une division. Mais si on veut
comprendre pourquoi les deux dernières formules <em>découlent</em> de la première, il
faut un minimum de bagage en math.</p>

<p><strong>Cet article est pour celles et ceux qui ont séchés les cours de math au
collège</strong> et qui voudraient maintenant comprendre pourquoi \(V = RI\) implique
nécessairement \(I = V / R\). Je vais tâcher de tirer et d’expliquer tous les
fils qui nous amène à déduire la seconde formule à partir de la première.</p>

<p><img class="center" src="/images/math.jpg"></p>

<!-- more -->

<h2 id="le-symbole-de-la-multiplication">Le symbole de la multiplication</h2>

<p>Le plus simple d’abord, \(RI\) est la multiplication de R par I.
Donc \(RI\) est la même chose que \(R \times I\).
Pour simplifier les choses (<em>ironie…</em>) on peut aussi
écrire le signe le la multiplication avec un point.
Les 3 lignes suivantes sont donc équivalentes:</p>

<p>$$
\begin{align}

  RI            <br />
  R \times I    <br />
  R \cdot I
\end{align}
$$</p>

<h2 id="lgalit">L’égalité</h2>

<p>Parlons maintenant du signe <code>=</code>. Il signifie qu’on a une égalité entre ce qui
se trouve à sa gauche et ce qui se trouve à sa droite. En d’autres termes, ce
qui est à gauche du signe <code>=</code> à la même valeur que ce qui est à sa droite.
Donc si V vaut 12 (c’est un exemple), alors R × I vaut
aussi exactement 12. Si je remplace V par 12 dans la formule, on voit bien que
RI vaut 12:</p>

<p>$$
\begin{align}

  12 = RI
\end{align}
$$</p>

<p>Ça ne nous
dit pas combien vaut exactement R ni combien vaut exactement I mais on sait
que la multiplication de ces deux là vaut 12. On a peut-être R = 1 et I = 12, ou
encore R = 3 et I = 4. Tout est possible du moment que \(R \times I = 12\).</p>

<p>Cette dernière égalité ( \(R \times I = 12\) ) m’amène à préciser ceci:
\(V = RI\) est la
même chose que \(RI = V\). Si vous avez du mal à penser avec des lettres,
n’hésitez pas à les remplacer régulièrement par des nombres pour voir de quoi
ça a l’air. Par exemple, si on dit que V = 12, R = 3 et I = 4, on peut écrire:</p>

<p>$$
\begin{align}

  12 = 3 \times 4
\end{align}
$$</p>

<p>Ou encore :</p>

<p>$$
\begin{align}

  3 \times 4 = 12
\end{align}
$$</p>

<p>C’est bien la même chose.</p>

<h2 id="jouons-avec-lgalit">Jouons avec l’égalité</h2>

<p>On peut faire subir aux deux cotés de l’égalité la même opération sans que cela
pose problème.</p>

<p>Par exemple on peut ajouter 1 de chaque coté:</p>

<p>$$
\begin{align}

  V + 1 = RI + 1
\end{align}
$$</p>

<p>Essayons avec des nombres. Si V = 12, R = 3 et I = 4 :</p>

<p>$$
\begin{align}

12 + 1 &amp;= 3 \times 4 + 1 <br />
13 &amp;= 12 + 1 <br />
13 &amp;= 13
\end{align}
$$</p>

<p>Ça marcherait aussi avec une soustraction ou tiens, avec une multiplication:</p>

<p>$$
\begin{align}

V \times 2 &amp;= R \times I \times 2 <br />
12 \times 2 &amp;= 3 \times 4 \times 2 <br />
24 &amp;= 12 \times 2 <br />
24 &amp;= 24
\end{align}
$$</p>

<p>Et bien sûr, ça fonctionne aussi avec la division, tant qu’on divise par
autre chose que zéro:</p>

<p>$$
\begin{align}

V / 2 &amp;= R \times I / 2 <br />
12 / 2 &amp;= 3 \times 4 / 2 <br />
6 &amp;= 12 / 2 <br />
6 &amp;= 6
\end{align}
$$</p>

<h2 id="un-truc-intressant--propos-de-la-division">Un truc intéressant à propos de la division</h2>

<p>Puisqu’on parle de division, voici un truc intéressant à propos de la division.
Quand on divise un nombre (n’importe lequel à part zéro) par lui-même on obtient toujours 1.
Toujours. Par exemple:</p>

<p>$$
\begin{align}

  12 / 12 = 1
\end{align}
$$</p>

<p>Si on généralise : \(A / A = 1\). Donc c’est pareil avec R ou I :</p>

<p>$$
\begin{align}

  R / R &amp;= 1 <br />
  I / I &amp;= 1
\end{align}
$$</p>

<h2 id="division-et-fraction">Division et fraction</h2>

<p>Jusqu’ici j’ai utilisé le signe <code>/</code> pour la division, mais celui-ci n’est pas
toujours très pratique et on le remplace souvent par une fraction. Et oui:
division et fraction c’est la même chose.</p>

<p>$$
\begin{align}

  X / Y= \frac{X}{Y}
\end{align}
$$</p>

<p>Reprenons notre formule de base :</p>

<p>$$
\begin{align}

  V = R \times I
\end{align}
$$</p>

<p>Si on divise les deux cotés par R, ça donne :</p>

<p>$$
\begin{align}

  \frac{V}{R}= \frac{R \times I}{R}
\end{align}
$$</p>

<p>On y est presque, je vous assure ! Il faut encore comprendre une dernière chose :</p>

<p>$$
\begin{align}

  \frac{R \times I}{R}=I
\end{align}
$$</p>

<p>Wait</p>

<p><img class="center" src="/images/wut.jpg"></p>

<p>Rappelez vous qu’une fraction, c’est la même chose qu’une division. Si je
généralise:</p>

<p>$$
\begin{align}

  \frac{X \times Y}{Z}=X \times Y / Z
\end{align}
$$</p>

<p>Il faut aussi savoir qu’il n’y a pas de priorité entre la multiplication et
la division, ainsi \(10 \times 2 / 5 = 4\), tout aussi bien que
\(10 / 5 \times 2 = 4\) ou que \(2 / 5 \times 10 = 4\).</p>

<p>Donc :</p>

<p>$$
\begin{align}

  \frac{R \times I}{R}
\end{align}
$$</p>

<p>Équivaut à :</p>

<p>$$
\begin{align}

  R \times I / R
\end{align}
$$</p>

<p>Ce qui est exactement pareil que :</p>

<p>$$
\begin{align}

  R / R \times I
\end{align}
$$</p>

<p>Et nous avons vu que <code>R / R</code> vaut 1, ce qui donne :</p>

<p>$$
\begin{align}

  1 \times I
\end{align}
$$</p>

<p>Ou plus simplement :</p>

<p>$$
\begin{align}

  I
\end{align}
$$</p>

<h2 id="conclusion">Conclusion</h2>

<p>Notre formule de base nous permet de calculer V à partir de R et de I:</p>

<p>$$
\begin{align}

  V = RI
\end{align}
$$</p>

<p>On joue avec en divisant chaque coté par R:</p>

<p>$$
\begin{align}

  \frac{V}{R} = \frac{RI}{R}
\end{align}
$$</p>

<p>Ce qui donne:</p>

<p>$$
\begin{align}

  \frac{V}{R} = I
\end{align}
$$</p>

<p>Qu’on remet dans le bon sens si on préfère, on peut maintenant calculer I à
partir de V et R:</p>

<p>$$
\begin{align}

  I = \frac{V}{R}
\end{align}
$$</p>

<p>Si nous avons un voltage de 5 Volts et une résistance de 1000 Ohms, combien
aurons nous d’ampères:</p>

<p>$$
\begin{align}

  I = \frac{5}{1000} = 0.005
\end{align}
$$</p>

<p>Vous venez de déduire une formule mathématique à partir d’une autre et de
l’utiliser !
Et de rattraper plusieurs heures de sèche du collège en quelques minutes ;)</p>

<p>À plus tard.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Une machine de Turing en Ruby - Une bande de données infinie]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/02/05/une-machine-de-turing-en-ruby-une-bande-de-donnees-infinie/"/>
    <updated>2015-02-05T18:13:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/02/05/une-machine-de-turing-en-ruby-une-bande-de-donnees-infinie</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Dans la définition d’une machine de Turing on trouve:</p>

<blockquote>
  <p>Le ruban est supposé être de longueur infinie vers la gauche ou vers la droite, en d’autres termes la machine doit toujours avoir assez de longueur de ruban pour son exécution.
— Wikipédia</p>
</blockquote>

<p>C’était une grande limitation de l’implémentation de <a href="https://github.com/lkdjiin/turing_machine">ma machine de Turing</a>
que d’avoir une bande de taille fixe. Avec la nouvelle version, cette limitation
est désormais levée.</p>

<p><img class="center" src="/images/infinity.jpg"></p>

<!-- more -->

<p>Permettre à la bande de grandir à l’infini (en théorie, hein, parce que en
pratique on est toujours limité par la mémoire de l’ordinateur) est finalement
très simple:</p>

<p>``` ruby lib/turing_machine/tape.rb
module TuringMachine</p>

<p>class Tape</p>

<pre><code>BLANK_SYMBOL = '0'

def initialize(data = BLANK_SYMBOL)
  @symbols = data.scan(/./)
  @index = 0
end

[...]

def shift_left
  if @index == 0
    @symbols.unshift(BLANK_SYMBOL)
  else
    @index -= 1
  end
end

def shift_right
  @symbols.push(BLANK_SYMBOL) if @index == @symbols.size - 1
  @index += 1
end

[...] ```
</code></pre>

<p>Voici quelques explications.</p>

<pre><code>@symbols = data.scan(/./)
</code></pre>

<p>Dans le constructeur, on se sert de <code>String#scan</code> pour construire un tableau
avec les données initiales de la bande. Par exemple:</p>

<p><code>irb
&gt;&gt; "110".scan(/./)
#=&gt;["1", "1", "0"]
</code></p>

<pre><code>@index = 0
</code></pre>

<p>Dans le constructeur toujours, la position de la tête de lecture est
initialement à zéro.</p>

<pre><code>def shift_left
  if @index == 0
    @symbols.unshift(BLANK_SYMBOL)
  else
    @index -= 1
  end
end
</code></pre>

<p>Lorsqu’on bouge la tête de lecture à gauche, nous avons deux cas possibles.
Soit la tête de lecture est déjà dans la position la plus à gauche
(<code>if @index == 0</code>) et dans ce cas il faut créer une nouvelle cellule en tête
du tableau:</p>

<p><code>irb
&gt;&gt; ["1", "2"].unshift("0")
#=&gt;["0", "1", "2"]
</code></p>

<p>Soit la tête de lecture est dans une autre position, et il suffit de la décaler
d’un cran vers la gauche (<code>@index -= 1</code>).</p>

<pre><code>def shift_right
  @symbols.push(BLANK_SYMBOL) if @index == @symbols.size - 1
  @index += 1
end
</code></pre>

<p>Lorsqu’on bouge la tête de lecture à droite, il faut ajouter une cellule à la
fin du tableau (<code>@symbols.push</code>) seulement si la tête de lecture est placée
toute à droite du tableau (<code>@index == @symbols.size - 1</code>).</p>

<p>Dans tous les cas, il faut déplacer la tête de lecture d’un cran à droite
(<code>@index += 1</code>).</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Une machine de Turing en Ruby - Le parser]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/02/02/une-machine-de-turing-en-ruby-le-parser/"/>
    <updated>2015-02-02T18:04:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/02/02/une-machine-de-turing-en-ruby-le-parser</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>La machine de Turing réalisée dans le <a href="/blog/2015/02/01/une-machine-de-turing-en-ruby/">dernier article</a>
était seulement un brouillon, et elle souffre de plusieurs limitations.
J’aimerais maintenant faire évoluer le programme en permettant à l’utilisateur
de charger un jeu d’instructions quelconque. Pour cela j’aurai besoin
d’un <em>parser</em>, qui sera vite écrit grâce à Ruby.</p>

<p><img class="center" src="/images/gears4.jpg"></p>

<!-- more -->

<p>Un jeu d’instruction pour la machine de Turing ressemblera à ceci (si vous avez
besoin du code, <a href="https://github.com/lkdjiin/turing_machine">il est ici</a>):</p>

<p><code>raw instruction_sets/busy_beaver_3
0 A =&gt; 1 R B
1 A =&gt; 1 L C
0 B =&gt; 1 L A
1 B =&gt; 1 R B
0 C =&gt; 1 L B
1 C =&gt; 1 R HALT
</code></p>

<p>C’est l’algorithme <em>busy beaver à 3 états</em> que j’ai utilisé pour coder la
première version de la machine. Il faut écrire un <em>parser</em> qui va transformer
ce <em>code source</em> en ce hash Ruby, utilisé en interne par la machine:</p>

<p><code>
{
  ['0', 'A'] =&gt; {write: '1', move: 'R', next_state: 'B'},
  ['1', 'A'] =&gt; {write: '1', move: 'L', next_state: 'C'},
  ['0', 'B'] =&gt; {write: '1', move: 'L', next_state: 'A'},
  ['1', 'B'] =&gt; {write: '1', move: 'R', next_state: 'B'},
  ['0', 'C'] =&gt; {write: '1', move: 'L', next_state: 'B'},
  ['1', 'C'] =&gt; {write: '1', move: 'R', next_state: 'HALT'},
}
</code></p>

<p>Voici le parser, qui est construit autour de la méthode <code>String#split</code>.</p>

<p>``` ruby lib/turing_machine/instructions_parser.rb
module TuringMachine</p>

<p>class InstructionsParser</p>

<pre><code>def initialize(raw_instructions)
  @lines = raw_instructions.split("\n")
  @instructions = {}
end

def parse
  build_instructions
  @instructions
end

private

def build_instructions
  @lines.each do |instruction|
    keys, value = instruction.split('=&gt;')
    key_symbol, key_state = keys.split
    write, move, next_state = value.split
    @instructions[[key_symbol, key_state]] = {
      write: write, move: move, next_state: next_state
    }
  end
end
</code></pre>

<p>end</p>

<p>end
```</p>

<p>On va l’utiliser comme ça:</p>

<p><code>ruby
raw_instructions = IO.read(ARGV[0])
parser = InstructionsParser.new(raw_instructions)
instructions = parser.parse
</code></p>

<p>Je vais expliquer plus en détail. Tout d’abord dans le constructeur, on divise
la grande chaîne de caractères en entrée en autant de lignes indépendantes:</p>

<pre><code>@lines = raw_instructions.split("\n")
</code></pre>

<p>Puis dans la méthode privée <code>build_instructions</code>, on itère sur chacune des
lignes pour construire le hash:</p>

<pre><code>@lines.each do |instruction|
</code></pre>

<p>Chaque ligne est d’abord divisé en deux parties, de chaque coté de <code>=&gt;</code>:</p>

<pre><code>keys, value = instruction.split('=&gt;')
</code></pre>

<p>La partie des clés (celle de gauche) est à son tour divisé en deux, le symbole
sous la tête de lecture et l’état de la machine:</p>

<pre><code>key_symbol, key_state = keys.split
</code></pre>

<p>Ensuite c’est au tour de la partie de droite, celle qui représente la prochaine
instruction:</p>

<pre><code>write, move, next_state = value.split
</code></pre>

<p>Enfin, on ajoute clé et valeur dans le hash:</p>

<pre><code>@instructions[[key_symbol, key_state]] = {
  write: write, move: move, next_state: next_state
}
</code></pre>

<p>Pour finir, voici mon premier jeu d’instructions pour une machine de Turing:</p>

<p><code>raw instruction_sets/write101
0 A =&gt; 1 R B
0 B =&gt; 0 R C
0 C =&gt; 1 R HALT
</code></p>

<p>Ça fait quoi ? Ça écrit 101, tout simplement :</p>

<pre><code> turing_machine instruction_sets/write101 
  1 0000000000000000000000000000000000000000 A -&gt; 1RB
                       ^
  2 0000000000000000000100000000000000000000 B -&gt; 0RC
                        ^
  3 0000000000000000000100000000000000000000 C -&gt; 1RHALT
                         ^
  4 0000000000000000000101000000000000000000 HALT
</code></pre>

<p>Je vous rappelle que vous pouvez consulter le code de la
<a href="https://github.com/lkdjiin/turing_machine">machine de Turing</a>.</p>

<p>Voilà, avec l’aide de <code>String#split</code> il est facile d’écrire un parser simple.
Alors bien sûr, ce parser n’est pas vraiment complet, il manque par exemple la
gestion des erreurs. Mais il y a des choses plus urgentes à implémenter, comme
le mouvement nul, le ruban infini, ou la possibilité de commencer le programme
avec un ruban qui contient des données…</p>

<p>À plus tard.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mes premiers pas avec Arduino]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/01/25/mes-premiers-pas-avec-arduino/"/>
    <updated>2015-01-25T18:04:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/01/25/mes-premiers-pas-avec-arduino</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Ça faisait un ou deux ans que l’envie me titillait. Jouer avec Arduino,
Raspberry Pi, etc. Mais essentiellement par manque de temps, je n’avais pas
encore franchi le pas. Et puis dernièrement, on m’a offert le
<a href="http://arduino.cc/en/Main/ArduinoStarterKit">Starter Kit Arduino</a>. Plus de faux pretextes, je devais m’y mettre ;)</p>

<p><img class="center" src="/images/projet-1-paral.jpg"></p>

<!-- more -->

<h2 id="les-premiers-projets-du-bouquin">Les premiers projets du bouquin</h2>

<p>Le premier projet pose les très grandes bases de l’éléctricité. Tu apprends
à allumer une LED avec un ou deux boutons, en série puis en parallèle.
Tu révises aussi la <a href="http://fr.wikipedia.org/wiki/Loi_d%27Ohm">loi d’Ohm</a>:</p>

<p><strong><em>V = R x I</em></strong></p>

<p>Avec <strong>V</strong> pour voltage (mesuré en volts), <strong>R</strong> pour résistance (mesuré en ohms)
et <strong>I</strong> pour intensité (mesuré en ampères). J’avais appris cette loi au lycée
sous la forme U = RxI,
en français le <strong>V</strong> devient donc <strong>U</strong>, pour des raisons de normalisation de
l’AFNOR.</p>

<p>Dans le second projet, tu allumes plusieurs LEDs, avec un peu de code pour les
faire clignoter. Pour le troisième projet, toujours des LEDs à allumer mais
cette fois-ci à l’aide d’un détecteur de chaleur.</p>

<p>Le quatrième projet te propose devine quoi ? Gagné ! il te propose d’allumer
une LED, cette fois en la contrôlant avec des photo-résistances:</p>

<p><img class="center" src="/images/projet-4.jpg"></p>

<h2 id="lenvironnement-de-dveloppement">L’environnement de développement</h2>

<p>Arduino est aussi un IDE, dans lequel tu tapes du code, avec lequel tu compiles
tes programmes arduino, etc. Mais comment te dire, quand tu es habitué à bosser
avec autre chose (Vim dans mon cas), tu n’imagines pas une seconde devoir
utiliser cet IDE Arduino.</p>

<p>J’ai trouvé <a href="http://inotool.org">ino</a> qui permet de travailler en console, c’est parfait pour moi.
Pour pouvoir installer ino, il faut le gestionnaire de package <code>pip</code> pour
Python.</p>

<p>Pour installer (et comprendre) pip:
<a href="http://sametmax.com/votre-python-aime-les-pip/">Sam et Max - Votre python aime les pip</a>.</p>

<p>Pour ensuite installer ino: <a href="http://inotool.org/">inotool.org</a>.</p>

<p>Maintenant vous avez accès à ces commandes:</p>

<pre><code>ino init
ino build
ino upload
ino serial # C-A C-X pour sortir ?
</code></pre>

<p>Le fichier qui nous intéresse, celui où l’on va écrire notre code, est créé
par <code>ino init</code>. C’est le fichier <code>src/sketch.ino</code>.</p>

<pre><code>$ tree
.
├── lib
└── src
    └── sketch.ino
</code></pre>

<p>Pour finir, si vous avez besoin d’un fichier de syntaxe pour Vim, c’est ici:
<a href="https://github.com/sudar/vim-arduino-syntax">sudar/vim-arduino-syntax</a>.</p>

<p>Vivement les prochains projets, qui vont me faire contrôler des servo-moteurs,
produire de la musique, etc. Parce que j’en ai un peu marre d’allumer des
LEDs ;)</p>

<p></p>
]]></content>
  </entry>
  
</feed>
