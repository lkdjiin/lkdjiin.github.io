<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : débutant | Xavier Nayrac]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/debutant/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2015-04-09T08:30:11+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Les sous-ensembles de listes dans R]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/04/09/les-sous-ensembles-de-listes-dans-r/"/>
    <updated>2015-04-09T07:47:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/04/09/les-sous-ensembles-de-listes-dans-r</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Après avoir parlé des <a href="http://lkdjiin.github.io/blog/2015/04/07/les-sous-ensembles-dans-r/">sous-ensembles de vecteurs</a> dans le langage R,
c’est maintenant le tour des listes. En R, une liste peut contenir des
types différents, au contraire du vecteur, limité à un seul type.
Prenons par exemple la liste suivante :</p>

<p><code>rconsole
&gt; x &lt;- list(1, 2, c("a", "b"))
</code></p>

<p>À l’affichage, on remarque qu’il s’agit d’une liste grâce aux doubles crochets
(<code>[[]]</code>) :</p>

<p>``` rconsole
&gt; x
[[1]]
[1] 1</p>

<p>[[2]]
[1] 2</p>

<p>[[3]]
[1] “a” “b”
```</p>

<!-- more -->

<p>Les éléments d’une liste peuvent être nommés. Suivant votre langage de
prédilection, vous pouvez penser à une liste R comme à un hash, un dictionnaire,
un tableau associatif, etc :</p>

<p>``` rconsole
&gt; x &lt;- list(foo = 1, bar = 2, baz = c(“a”, “b”))
&gt; x
$foo
[1] 1</p>

<p>$bar
[1] 2</p>

<p>$baz
[1] “a” “b”
```</p>

<p>Que se passe-t-il si on utilise la même syntaxe qu’avec un vecteur pour extraire
un élément d’une liste ?</p>

<p><code>rconsole
&gt; x[3]
$baz
[1] "a" "b"
</code></p>

<p>L’idée c’est que l’opérateur <code>[]</code> renvoie le même type d’objet que l’objet sur
lequel il est appliqué. Donc utiliser <code>[]</code> sur une liste retourne une liste :</p>

<p><code>rconsole
&gt; class(x[3])
[1] "list"
</code></p>

<p>Pour aller chercher un élément, et pas une liste à un seul élément, il faut
utiliser l’opérateur double crochets (<code>[[]]</code>) :</p>

<p><code>rconsole
&gt; x[[3]]
[1] "a" "b"
</code></p>

<p>Lorsque les éléments sont nommés, on peut bien sûr utiliser leurs noms comme
clé :</p>

<p><code>rconsole
&gt; x$baz
[1] "a" "b"
</code></p>

<p>Nous pouvons extraire un sous-ensemble d’une liste en passant les indices à
l’opérateur crochet (<code>[]</code>) :</p>

<p>``` rconsole
&gt; x &lt;- list(1, “2”, 3, 4, 5)</p>

<blockquote>
  <p>x[c(1, 3, 5)]
[[1]]
[1] 1</p>
</blockquote>

<p>[[2]]
[1] 3</p>

<p>[[3]]
[1] 5
```</p>

<p>Ou bien en lui donnant un vecteur de booléens :</p>

<p>``` rconsole
&gt; x[c(F, T, F, T, F)]
[[1]]
[1] “2”</p>

<p>[[2]]
[1] 4
```</p>

<p>En faisant la même chose avec l’opérateur double crochets (<code>[[]]</code>) nous pouvons
extraire le nième élément d’un vecteur :</p>

<p>``` rconsole
&gt; x &lt;- list(c(1, 2, 3), c(“a”, “b”, “c”))</p>

<blockquote>
  <p>x[[c(2, 1)]]
[1] “a”
```</p>
</blockquote>

<p>Ce qu’on peut décomposer ainsi, d’abord le 2ème élément de la liste :</p>

<p><code>rconsole
&gt; x[[2]]
[1] "a" "b" "c"
</code></p>

<p>Puis le premier élément du vecteur, la syntaxe commence à devenir drôle :</p>

<p><code>rconsole
&gt; x[[2]][[1]]
[1] "a"
</code></p>

<p>Question pour les connaisseurs du langage R : le code précédent me suggère qu’un vecteur
<em>agit</em> aussi comme une liste et que l’opérateur double crochet (<code>[[]]</code>) n’est pas
limité aux listes. Par exemple :</p>

<p><code>rconsole
&gt; y &lt;- c("a", "b", "c")
&gt; y
[1] "a" "b" "c"
&gt; y[[2]]
[1] "b"
&gt; y[2]
[1] "b"
&gt; y[[2]] == y[2]
[1] TRUE
</code></p>

<p>Est-ce qu’il y a un intérêt à utiliser les double crochets avec des vecteurs ?</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les sous-ensembles dans R]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/04/07/les-sous-ensembles-dans-r/"/>
    <updated>2015-04-07T19:12:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/04/07/les-sous-ensembles-dans-r</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>J’apprends <a href="http://www.r-project.org/">le langage R</a> ! C’est cool d’apprendre de nouvelles choses.
C’est encore plus cool de les partager ;) Comme je suis vraiment tout neuf avec
R, c’est mon premier article sur ce langage. Et comme il faut bien commencer
quelque part, je vais vous parler de certains moyens d’obtenir des
sous-ensembles d’un vecteur (un vecteur c’est à peu près comme une liste).</p>

<p><img class="center" src="/images/subset.png"></p>

<!-- more -->

<p>On lance le REPL :</p>

<pre><code>$ R
</code></pre>

<p>On va créer un ensemble de notes (<em>grades</em>).  Le symbole <code>&lt;-</code> est l’opérateur
d’affectation. La fonction <code>c()</code>, elle, permet de fabriquer un vecteur, avec
ici 10 notes allant de 1 à 5. <code>c()</code> assure la concaténation :</p>

<pre><code>&gt; grades &lt;- c(1, 2, 3, 2, 3, 2, 1, 4, 5, 2)
</code></pre>

<p>On peut vérifier ce qu’il y a dans <code>grades</code>. Le <code>[1]</code> indique qu’il s’agit d’un
vecteur dont on commence l’affichage par le 1er élément. R indexe en commençant
par 1, et non pas comme souvent par zéro :</p>

<pre><code>&gt; grades
 [1] 1 2 3 2 3 2 1 4 5 2
</code></pre>

<p>Pour être sûr de comprendre cette histoire de vecteur et d’index, créons et
affichons un vecteur de 40 éléments à l’aide de la syntaxe <code>début:fin</code> :</p>

<pre><code>&gt; 1:40
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40
</code></pre>

<p>Alors ces sous-ensembles ? Et bien commençons par une indexation classique, avec
<code>[]</code>, pour retrouver un seul élément (en fait un vecteur d’un seul élément) :</p>

<pre><code>&gt; grades[1]
[1] 1
</code></pre>

<p>On peut aussi retrouver un <em>range</em>, par exemple du 6ème au 8ème élément :</p>

<pre><code>&gt; grades[6:8]
[1] 2 1 4
</code></pre>

<p>Pour retrouver seulement les notes au dessus de 2 on met la condition entre les
crochets :</p>

<pre><code>&gt; grades[grades &gt; 2]
[1] 3 3 4 5
</code></pre>

<p>Il est intéressant de voir ce qu’on obtient avec <code>grades &gt; 2</code> :</p>

<pre><code>&gt; grades &gt; 2
 [1] FALSE FALSE  TRUE FALSE  TRUE FALSE FALSE  TRUE  TRUE FALSE
</code></pre>

<p>On obtient un vecteur de valeurs booléennes ! <em>TRUE</em> si la note est supérieure
à 2, <em>FALSE</em> dans le cas contraire.</p>

<p>Rangeons ce vecteur de booléens dans une variable <code>mask</code> et servons nous de
cette nouvelle variable pour obtenir le sous-ensemble des notes supérieures
à 2 :</p>

<pre><code>&gt; mask &lt;- grades &gt; 2
&gt; grades[mask]
[1] 3 3 4 5
</code></pre>

<p>Pour finir, utilisons directement un vecteur de booléens pour récupérer les
éléments n° 4, 5, 6, 9 et 10 (<em>F</em> et <em>T</em> sont des raccourcis pour <em>FALSE</em> et
<em>TRUE</em>) :</p>

<pre><code>&gt; grades[c(F, F, F, T, T, T, F, F, T, T)]
[1] 2 3 2 5 2
</code></pre>

<p>Voilà, mon premier article sur R est terminé, je vais certainement en écrire
plein d’autres dans un futur proche. J’espère que ce sujet vous intéresse ;)</p>

<pre><code>&gt; q()
</code></pre>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Arduino : Un métronome tap tempo]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/04/03/arduino-un-metronome-tap-tempo/"/>
    <updated>2015-04-03T18:35:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/04/03/arduino-un-metronome-tap-tempo</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>J’aimerais fabriquer un métronome <em>tap tempo</em> avec l’arduino. C’est un projet à
moyen terme, et
comme souvent, il pourrait être bénéfique de diviser le projet en plusieurs
petites parties. Donc, avant de tenter la programmation du tap tempo, je vais
faire un métronome tout simple avec juste une LED.</p>

<h2 id="les-composants">Les composants</h2>

<p>Coté composants, on a seulement besoin d’une LED et d’une résistance (220 Ohms
ça ira).</p>

<p><img class="center" src="/images/metronome1_bb.png"></p>

<!-- more -->

<h2 id="un-premier-code-naif">Un premier code naif</h2>

<p>Le premier jet est tout simple :</p>

<p>``` cpp
const byte LED_PIN = 2;</p>

<p>void setup() {
  pinMode(LED_PIN, OUTPUT);
}</p>

<p>void loop() {
  digitalWrite(LED_PIN, HIGH);
  delay(100);
  digitalWrite(LED_PIN, LOW);
  delay(600);
}
```</p>

<p>Une fois compilé et envoyé dans l’arduino, la LED clignote toutes les 0,7
secondes. Nous avons un métronome visuel !</p>

<p>C’est simple, non ? Mouais. Trop simple, bien sûr. Ce code est problèmatique
pour la fabrication d’un métronome. Alors afin de comprendre pourquoi, parlons
un peu du tempo.</p>

<h2 id="le-tempo">Le tempo</h2>

<p>Pour le musicien, le tempo est une suite de clics (ou tic, ou tac, ou poum, ou
tchak, ou clac). Ces clics, qui ont la particularité de se succéder à
intervalles réguliers, marquent la <strong>vitesse</strong> de la musique.</p>

<p>Le tempo (donc la vitesse de la musique) est indiqué à l’aide d’un nombre qui
représente le nombre de clics par minute.
Par exemple un tempo de 60 nous indique qu’il doit y avoir 60 clics dans une minute,
ou plus simplement 1 clic par seconde. Autre exemple, un tempo de 120 indique
120 clics par minute, soit 2 clics par seconde, ou encore 1 clic toutes les
0,5 secondes.</p>

<p>Voyons maintenant quelques formules. Pour trouver la fréquence F, en secondes,
il faut diviser 60 par le tempo (noté T) :</p>

<p>$$
\begin{align}

F = 60 / T
\end{align}
$$</p>

<p>Pour obtenir cette fréquence en millisecondes, il faut multiplier le résultat
précédent par 1000 ;</p>

<p>$$
\begin{align}

F = 60 / T \times 1000
\end{align}
$$</p>

<p>Le code arduino ci-dessus envoit un clic toutes les 0,7 secondes, à quel
tempo cela correspond-t-il ? Pour calculer le tempo, on divise 60 par la
fréquence en secondes :</p>

<p>$$
\begin{align}

T = 60 / F
\end{align}
$$</p>

<p>Donc, une fréquence de 0,7 seconde, comme celle de notre code arduino,
correspond à un tempo de \(60 / 0,7\). Soit à peu près 86.</p>

<h2 id="le-problme-de-la-boucle-de-code">Le problème de la boucle de code</h2>

<p>Maintenant on peut regarder le souci de ce code :</p>

<p><code>cpp
void loop() {
  digitalWrite(LED_PIN, HIGH);
  delay(100);
  digitalWrite(LED_PIN, LOW);
  delay(600);
}
</code></p>

<p>Partons de l’hypothèse qu’en plus des deux <code>digitalWrite</code>, mon code doit
aussi :</p>

<ul>
  <li>calculer l’intensité de la LED suivant le beat.</li>
  <li>jouer du son et ausssi calculer son intensité suivant le beat.</li>
  <li>s’occuper de plusieurs LEDs, peut-être avec des motifs.</li>
  <li>écrire le tempo et d’autres informations sur un écran LCD.</li>
  <li>tout ce que vous pourrez imaginer d’autre ;)</li>
</ul>

<p>Imaginons maintenant que l’ensemble de ces actions prennent 30 millisecondes
(0,03 secondes). Dans ce cas le tempo sera de \(60 / 0,73\). Soit à peu près 82.
Donc plus du tout la valeur de 86 qu’on avait trouvé tout à l’heure. <strong>Notre
métronome n’est pas fiable !</strong> Il ne vaut rien, arg.</p>

<p><img class="center" src="/images/facepalm.jpg"></p>

<h2 id="faire-et-ne-pas-attendre">Faire et ne pas attendre</h2>

<p>Pour remédier à ce problème nous demandons à l’arduino d’allumer la LED toutes
les 700 millisecondes et non pas <strong>d’attendre</strong> pendant 700 millisecondes.
Pour cela nous gardons une trace du dernier moment où la LED a été allumée
(dans <code>oldTime</code>) et nous comparons cette trace avec le moment présent
(<code>currentTime</code>) à chaque passage dans la boucle :</p>

<p>``` cpp
const byte LED_PIN = 2;
// In millisecondes.
const long FREQUENCY = 700;</p>

<p>long currentTime;
long oldTime;</p>

<p>void setup() {
  pinMode(LED_PIN, OUTPUT);
  currentTime = 0;
  oldTime = 0;
}</p>

<p>void loop() {
  currentTime = millis();</p>

<p>if(currentTime &gt;= oldTime + FREQUENCY) {
    digitalWrite(LED_PIN, HIGH);
    delay(100);
    digitalWrite(LED_PIN, LOW);
    oldTime = currentTime;
  }
}
```</p>

<p>Ça fonctionne pour notre métronome, bien qu’il reste encore 100 millisecondes
gachées (avec <code>delay(100);</code>). La prochaine fois on verra un moyen de se
débarasser de cette attente inutile.</p>

<p></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vim : Pourquoi les touches HJKL ?]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/04/02/vim-pourquoi-les-touches-hjkl/"/>
    <updated>2015-04-02T11:46:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/04/02/vim-pourquoi-les-touches-hjkl</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Pourquoi utilise-t-on les touches HJKL pour les déplacements de base dans Vim ?
Par déplacement de base, j’entends un caractère à gauche ou à droite (H et L) et
une ligne au-dessus ou en dessous (J et K). Pourquoi ne pas utiliser les
touches fléchées, par exemple, ou même la main gauche ?</p>

<p><img class="center" src="/images/ADM-3A.jpg"></p>

<!-- more -->

<p><strong>Pourquoi pas les touches fléchées ?</strong></p>

<p>En fait, on peut bien sûr se servir des touches fléchées pour se déplacer dans
Vim.  C’est utile si vous êtes débutant, mais vous devriez essayer rapidement
de perdre l’habitude de les utiliser : Elles sont trop loin du <em>home row</em> (voir
plus bas).</p>

<p>On peut carrément les désactiver ou mieux, s’en servir pour autre chose, comme
pour changer de fenêtre, modifier la taille des fenêtres, etc…</p>

<p><strong>Pourquoi pas les touches à main gauche ?</strong></p>

<p>Le créateur de Vim était droitier, donc on se sert de la main droite !
Évidemment non, puisque les joueurs utilisent sans problèmes WASD pour se
diriger (ZQSD en azerty).</p>

<p><strong>Le home row</strong></p>

<p>Quelle est la bonne façon de placer ses doigts sur un clavier ?  Selon les
règles de la dactylographie, les doigts des deux mains doivent se placer sur le
<em>home row</em>. Ça minimise énormément le déplacement des doigts et des mains et la
fatigue musculaire tout en augmentant la vitesse de frappe.</p>

<p><img class="center" src="/images/keyboard-home-row.png"></p>

<p><strong>Mais alors pourquoi utiliser HJKL pour se déplacer et pas JKL; ?</strong></p>

<p>À cause de la force des doigts peut-être ? Le petit n’étant pas très fort ?
Non. C’est tout simplement parce que Vi, l’ancêtre de Vim, a été créé sur
<a href="http://en.wikipedia.org/wiki/ADM-3A">le terminal ADM-3A</a>.
Regardez bien ce qu’on trouve sur les touches HJKL :</p>

<p><img class="center" src="/images/keyboard-ADM-3A.png"></p>

<p>Au passage, notez l’emplacement de la touche ESC ;-)</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Pas de logique dans les vues Rails]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/03/28/pas-de-logique-dans-les-vues-rails/"/>
    <updated>2015-03-28T09:10:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/03/28/pas-de-logique-dans-les-vues-rails</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Je dis souvent aux personnes avec qui je travaille qu’introduire de la logique
dans les vues est une mauvaise idée.</p>

<p>Pour moi, une vue n’est pas vraiment un fichier comme les autres. C’est avant tout du
HTML, donc normalement rien de bien compliqué. Et à ce titre, j’ai rencontré beaucoup de
développeurs, certains par ailleurs très doués, pour qui les vues sont
inconsciemment les poubelles d’un projet Rails. Leurs modèles et leurs
contrôleurs sont très bien écrits, concis, testés, refactorés, parfois même
documentés ;) Mais leurs vues sont incompréhensibles et compliquées à outrance.</p>

<p><img class="center" src="/images/complexity_512.jpg"></p>

<!-- more -->

<p>Pourquoi ? J’explique ça surtout par le nombre de langages qui peuvent se
côtoyer au sein d’une vue :</p>

<ul>
  <li>HTML</li>
  <li>le langage de templating</li>
  <li>Ruby</li>
  <li>parfois même du Javascript</li>
</ul>

<p>C’est déjà assez dur de produire du bon code avec un seul
langage, alors imaginez s’il faut jongler entre trois ou quatre !</p>

<p>Je me suis aperçu aussi que lorsque je dis <strong>pas de logique dans les vues Rails</strong>
de nombreux développeurs vont acquiescer. Ils seront d’accord avec moi sur le
principe, mais ne sauront pas pour autant comment éviter d’introduire cette
logique.</p>

<p>Pour ne pas avoir à embarquer trop de code Ruby dans les vues (c’est une autre
manière de dire «pas de logique») Rails propose pourtant une solution simple et parfaitement intégrée :
les <em>helpers</em>. Voyons comment ça fonctionne.</p>

<h2 id="avec-logique-dans-les-vues">Avec logique dans les vues</h2>

<p>Prenons une vue très simple qui va lister tous les posts d’une collection
nommée <code>@feed</code>. Nos posts contiennent uniquement un corps de texte, nommé
<code>body</code> :</p>

<p><code>erb app/views/posts/index.html.erb
&lt;% @feed.each do |post| %&gt;
  &lt;p class='post-body'&gt;
    &lt;%= post.body %&gt;
  &lt;/p&gt;
&lt;% end %&gt;
</code></p>

<p>Maintenant votre produit évolue : les posts peuvent contenir une photo, ou non.
Et le texte d’un post <strong>avec</strong> photo doit s’afficher différemment du texte d’un
post <strong>sans</strong> photo. On pourrait faire comme ça :</p>

<p><code>erb app/views/posts/index.html.erb
&lt;% @feed.each do |post| %&gt;
  &lt;p class='post-body &lt;%= post.post_type %&gt;'&gt;
    &lt;%= post.body %&gt;
  &lt;/p&gt;
  &lt;% if post.photo? %&gt;
    &lt;%= image_tag "photos/#{post.filename}", alt: post.filename,
        class: 'photo' %&gt;
  &lt;% end %&gt;
&lt;% end %&gt;
</code></p>

<p>Bien sûr ça va fonctionner. Et cette première version n’est pas si mauvaise.
Mais le fait d’avoir mis un simple <code>if</code> ici fait que
la semaine prochaine nous aurons un second <code>if</code>, dans 15 jours on ajoutera un
<code>else</code>, puis dans 1 mois un <code>if</code> imbriqué avec une condition complexe, etc.</p>

<h2 id="sans-logique-dans-les-vues">Sans logique dans les vues</h2>

<p>Qu’est-ce qu’on veut vraiment, du point de vue de la vue ?
On veut afficher une photo. C’est tout :</p>

<p><code>erb app/views/posts/index.html.erb
&lt;% @feed.each do |post| %&gt;
  &lt;p class='post-body &lt;%= post.post_type %&gt;'&gt;
    &lt;%= post.body %&gt;
  &lt;/p&gt;
  &lt;%= photo_for(post) %&gt;
&lt;% end %&gt;
</code></p>

<p>On a pas besoin d’en écrire plus dans la vue. Le code Ruby, la logique, ira
dans un <em>helper</em> :</p>

<p>``` ruby app/helpers/posts_helper.rb
module postsHelper</p>

<p>def photo_for(post)
    if post.photo?
      path = “photos/#{post.filename}”
      image_tag(path, alt: post.filename, class: ‘photo’)
    end
  end</p>

<p>end
```</p>

<p>Quand le post n’est pas une photo, la méthode <code>photo_for</code> renverra <code>nil</code>, valeur
qui ne sera pas affichée dans la vue.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
