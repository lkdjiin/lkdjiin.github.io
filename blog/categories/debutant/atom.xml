<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : débutant | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/debutant/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2013-12-31T16:00:45+01:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[La fonction d'auto-application en Lambda Calculus]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/12/31/la-fonction-dauto-application-en-lambda-calculus/"/>
    <updated>2013-12-31T15:51:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/12/31/la-fonction-dauto-application-en-lambda-calculus</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>La dernière fois on a vu <a href="http://lkdjiin.github.io/blog/2013/12/28/la-fonction-didentite-en-lambda-calculus/">la fonction d'identité</a>, cette fois ci on
va parler de la fonction d'auto-application en λ calculus.</p>

<!-- more -->


<h2>La fonction d'auto-application : λs.(s s)</h2>

<p>Appliquée à un argument A, la fonction d'auto-application crée une nouvelle
application, dont la fonction et l'argument sont A. Décortiquons d'abord un peu cette
fonction:</p>

<pre><code>λs.(s s)
</code></pre>

<p>Le premier <code>s</code>, coincé entre le caractère lambda et le point est la
variable liée. À droite du point, nous avons le corps de la fonction :</p>

<pre><code>(s s)
</code></pre>

<p>qui est une application.</p>

<h2>(λs.(s s) foo)</h2>

<p>Voyons ce qu'il se passe quand la fonction d'auto-application est appliquée
à l'argument <code>foo</code>:</p>

<pre><code>(λs.(s s) foo)
</code></pre>

<p>On remplace, dans le corps de la fonction, chaque occurence de la variable liée
par l'argument. Et c'est ce corps de fonction, après substitution, qui
est renvoyé:</p>

<pre><code>(foo foo)
</code></pre>

<p><code>foo</code> étant un nom, il s'évalue en tant que lui-même, et on ne peut donc
pas aller plus loin.</p>

<h2>(λs.(s s) λx.x)</h2>

<p>Voyons maintenant l'application de la fonction d'auto-application à la
fonction d'identité, vue la dernière fois:</p>

<pre><code>(λs.(s s) λx.x)
</code></pre>

<p>Comme précédement, on remplace chaque occurence de <code>s</code> dans le corps de
la fonction:</p>

<pre><code>(λx.x λx.x)
</code></pre>

<p>Cette fois, l'application peut être évaluée. On a vu la dernière fois
que la fonction d'identité renvoyait l'argument, donc:</p>

<pre><code>λx.x
</code></pre>

<p>La prochaine fois, on verra ce qu'il se passe quand la fonction
d'auto-application est appliquée sur elle-même. En fait, si vous avez
compris le mécanisme, vous pouvez d'ores et déjà essayer par vous même…</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby 2.1: Les nouvelles méthodes de Set]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/12/30/ruby-2-dot-1-les-nouvelles-methodes-de-set/"/>
    <updated>2013-12-30T19:10:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/12/30/ruby-2-dot-1-les-nouvelles-methodes-de-set</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Avec la sortie de Ruby 2.1, la bibliothèque standard <code>Set</code> s'enrichie de
deux méthodes supplémentaires: <code>disjoint?</code> et <code>intersect?</code>.</p>

<!-- more -->


<p><code>Set</code> permet de créer un ensemble d'éléments uniques:</p>

<p>``` irb</p>

<blockquote><blockquote><p>require &lsquo;set&rsquo;
Set.new [1, 2, 1, 2, 2]
=> #&lt;Set: {1, 2}>
```</p></blockquote></blockquote>

<p>La nouvelle méthode <code>intersect?</code> permet de tester si deux sets ont au moins
un élément en commun:</p>

<p>``` irb</p>

<blockquote><blockquote><p>s1 = Set.new [1, 2, 3]
s2 = Set.new [4, 5, 6]
s3 = Set.new [1, 8, 9]</p>

<p>s1.intersect? s2
=> false
s1.intersect? s3
=> true
```</p></blockquote></blockquote>

<p>La seconde méthode, <code>disjoint?</code>, est son opposée. Elle teste si deux sets n'ont
aucuns éléments communs:</p>

<p>``` irb</p>

<blockquote><blockquote><p>s1.disjoint? s2
=> true
s1.disjoint? s3
=> false
```</p></blockquote></blockquote>

<p>Ce genre de méthode n'est pas très compliqué à coder soi-même, comme le
montre le code source de <code>intersect?</code>:</p>

<p>``` ruby
def intersect?(set)
  set.is_a?(Set) or raise ArgumentError, &ldquo;value must be a set&rdquo;
  if size &lt; set.size</p>

<pre><code>any? { |o| set.include?(o) }
</code></pre>

<p>  else</p>

<pre><code>set.any? { |o| include?(o) }
</code></pre>

<p>  end
end
```</p>

<p>Mais l'avoir en standard permet de ne pas réinventer la roue…
Quant au code source de <code>disjoint?</code>, c'est très exactement comme je
le disais plus haut, l'opposé de <code>intersect?</code>:</p>

<p><code>ruby
def disjoint?(set)
  !intersect?(set)
end
</code></p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby 2.1: la méthode Array#to_h]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/12/29/ruby-2-dot-1-la-methode-array-number-to-h/"/>
    <updated>2013-12-29T11:31:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/12/29/ruby-2-dot-1-la-methode-array-number-to-h</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>La version 2.1 de Ruby est sortie comme promis à Noël. La classe Array y gagne
une nouvelle méthode: <code>to_h</code>.</p>

<!-- more -->


<p>Pour transformer ce tableau:</p>

<p><code>ruby
[[:key1, "one"], [:key2, "two"], [:key3, "three"]]
</code></p>

<p>en un Hash:</p>

<p><code>ruby
{:key1=&gt;"one", :key2=&gt;"two", :key3=&gt;"three"}
</code></p>

<p>La méthode était jusqu'ici la suivante:</p>

<p>``` irb</p>

<blockquote><blockquote><p>my_array = [[:key1, &ldquo;one&rdquo;], [:key2, &ldquo;two&rdquo;], [:key3, &ldquo;three&rdquo;]]
Hash[*my_array.flatten]
=> {:key1=>&ldquo;one&rdquo;, :key2=>&ldquo;two&rdquo;, :key3=>&ldquo;three&rdquo;}
```</p></blockquote></blockquote>

<p>Ruby 2.1 rend ceci plus simple, plus lisse, en ajoutant une méthode
de transformation à la classe Array, <code>to_h</code>:</p>

<p>``` irb</p>

<blockquote><blockquote><p>my_array.to_h
=> {:key1=>&ldquo;one&rdquo;, :key2=>&ldquo;two&rdquo;, :key3=>&ldquo;three&rdquo;}
```</p></blockquote></blockquote>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[La fonction d'identité en lambda calculus]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/12/28/la-fonction-didentite-en-lambda-calculus/"/>
    <updated>2013-12-28T20:49:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/12/28/la-fonction-didentite-en-lambda-calculus</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Après avoir introduit les expressions du λ calculus, on voit
aujourd'hui comment appliquer une fonction sur un argument, à
travers la fonction d'identité.</p>

<!-- more -->


<p>La fonction d'identité est <code>λx.x</code>. Sa particularité est qu'elle renvoie
l'argument sur lequel elle est appliquée. Les noms utilisés n'ont aucune
importance: on pourrait l'écrire <code>λa.a</code>, ou encore <code>λtruc.truc</code>.</p>

<p>Voyons le mécanisme pour appliquer une fonction, en appliquant la fonction
d'identité sur l'argument <code>foo</code>:</p>

<pre><code>(λx.x foo)
</code></pre>

<p>Les parenthèses nous disent qu'il s'agit d'une application. L'expression qui
tient lieu de fonction est la fonction:</p>

<pre><code>λx.x
</code></pre>

<p>Et l'expression qui tient lieu d'argument est le nom:</p>

<pre><code>foo
</code></pre>

<p>Dans la fonction <code>λx.x</code>, le premier <code>x</code> est la variable liée, le second
<code>x</code> est le corps de la fonction.</p>

<p>Pour appliquer la fonction <code>λx.x</code> sur <code>foo</code>, il faut substituer chaque
occurences de la variable liée (x) dans le corps de la fonction par l'argument.
Le nom <code>x</code> dans le corps de la fonction est substitué par le nom
<code>foo</code>. Le résultat est donc:</p>

<pre><code>foo
</code></pre>

<p>Voilà, j'ai cherché à décomposer au maximum ce mécanisme fort simple de
substitution. N'ayez pas peur, il se pourrait que cela se complique
quelque peu par la suite ;&ndash;)</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Introduction à Lambda Calculus]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/12/27/introduction-a-lambda-calculus/"/>
    <updated>2013-12-27T14:53:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/12/27/introduction-a-lambda-calculus</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Pour mieux comprendre la programmation fonctionnelle, j'ai décidé
de plonger aux racines de ce paradigme, à savoir le langage λ calculus
(λ se prononce lambda).
Je rédigerais quelques articles sur ce sujet, en tentant à chaque fois
d'expliquer le plus simplement possible ce que j'aurais compris de ce
langage.</p>

<!-- more -->


<p>Le langage λ calculus, inventé dans la décennie 1930 par
<a href="http://en.wikipedia.org/wiki/Alonzo_Church">Alonzo Church</a>, repose sur
3 types d'expressions:</p>

<ol>
<li>Les noms</li>
<li>Les fonctions</li>
<li>Les applications</li>
</ol>


<h2>Les noms</h2>

<p>Un nom peut être n'importe quelle suite de caractères affichables, à
l'exception des caractères utilisés pour définir une fonction ou
une application. Voici quelques exemples de noms possibles en
lambda calculus:</p>

<pre><code>x
xavier
1
123
0,345
foo_BAR
-
@!^
</code></pre>

<p>Autrement dit, tout et n'importe quoi.</p>

<h2>Les fonctions</h2>

<p>Une fonction débute par le caractère lambda, est suivie d'un nom, puis d'un
point et enfin du corps de la fonction. Le corps de la fonction est
une expression, ce qui signifie que cela peut être un nom, une fonction ou
même une application.
Quelques exemples:</p>

<pre><code>λx.x
λfoo.bar
λa.λb.c
λfoo.(λbar.ba truc)
</code></pre>

<p>Il faut noter que les fonctions lambda sont anonymes, elles n'ont pas de noms.
Le nom qui suit le caractère λ n'est donc pas le nom de la fonction, mais le
nom d'une variable liée, ou <em>bound variable</em>, qui sera utilisée dans les
applications pour transformer le corps de la fonction.</p>

<p>Si on décortique la fonction <code>λa.λb.c</code>, cela donne:</p>

<pre><code>variable liée: a
corps        : λb.c
</code></pre>

<h2>Les applications</h2>

<p>Plutôt que d'<em>appeler</em> une fonction, en λ calculus on va <em>appliquer</em> une
fonction à un argument. Pour cela on écrit entre parenthèses une fonction,
suivie d'un argument. Par exemple:</p>

<pre><code>(λx.x foo)
</code></pre>

<p>signifie que l'on applique la fonction <code>λx.x</code> à l'argument <code>foo</code>.</p>

<p>Il faut encore signaler qu'en λ calculus tout est fonction. Donc:</p>

<pre><code>(a b)
</code></pre>

<p>est une application valide.</p>

<p>La prochaine fois, on verra comment évaluer une application.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
