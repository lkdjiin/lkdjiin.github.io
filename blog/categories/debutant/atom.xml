<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : débutant | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/debutant/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2013-12-22T21:05:21+01:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Remplacer Sed et Awk par Ruby: Un dernier exemple]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/12/22/remplacer-sed-et-awk-par-ruby-un-dernier-exemple/"/>
    <updated>2013-12-22T20:58:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/12/22/remplacer-sed-et-awk-par-ruby-un-dernier-exemple</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Avant de mettre un terme à cette série d'articles, j'aimerais donner
un dernier exemple concret de l'utilisation de Ruby en <em>mode</em> Sed/Awk.
Il y a quelques jours, j'ai ajouté un bouton «flattr» à la fin des
quelques 160 articles de ce blog. Voici comment j'ai fait…</p>

<!-- more -->


<p>Tout d'abord le script Ruby:</p>

<p>``` ruby script.rb
BEGIN{code= &ldquo;code à insérer&rdquo;}</p>

<p>if $<em>.start_with?(&ldquo;À demain.&rdquo;)
  $</em> = &ldquo;\n\n#{code}\n\n#{$_}&rdquo;
end
```</p>

<p>Je cherche à insérer le code avant la chaîne &ldquo;À demain.&rdquo;, qui termine
chacun de mes articles. Si vous avez suivi cette série d'articles depuis
le début, j'espère que ce script parle de lui-même…
Notez quand même que ce script demande une version de Ruby supérieure
ou égale à 2.0, ou alors il faudra ajouter un commentaire <em>magique</em> pour
spécifier l'encodage utf-8.</p>

<p>Maintenant, comment appliquer ce script à chacun des articles. J'ai choisi
d'utiliser une boucle en Bash:</p>

<p><code>bash
[~]⇒ for i in *.markdown; do ruby -p -i script.rb $i; done
</code></p>

<p>Si vous avez besoin d'explications sur cette ligne de commande, je vous
renvoie à ces articles:</p>

<ul>
<li><a href="http://lkdjiin.github.io/blog/2013/12/04/remplacer-sed-et-awk-par-ruby-4-les-options-p-et-l/">ruby -p</a></li>
<li><a href="http://lkdjiin.github.io/blog/2013/12/08/remplacer-sed-et-awk-par-ruby-7-modifier-slash-sauvegarder-les-donnees/">ruby -i</a></li>
<li><a href="http://lkdjiin.github.io/blog/2013/08/23/bash-ajouter-une-ligne-a-la-fin-de-plusieurs-fichiers/">Les boucles en Bash</a></li>
</ul>


<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Remplacer Sed et Awk par Ruby: Flip flop]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/12/21/remplacer-sed-et-awk-par-ruby-flip-flop/"/>
    <updated>2013-12-21T18:44:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/12/21/remplacer-sed-et-awk-par-ruby-flip-flop</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Comment faire pour travailler sur un groupe de lignes, quand ce groupe
de lignes commence avec un marqueur et fini avec un autre ?
Par exemple, avec le fichier de données suivant, on cherche à afficher
les lignes depuis «start» jusqu'à «end»:</p>

<p><code>raw data.txt
1
2
3
start
4
5
6
end
7
8
9
</code></p>

<!-- more -->


<p>C'est ce qu'on appelle un <em>flip flop</em> : On commence le traitement sur une
condition de départ, puis on traite toutes les lignes jusqu'à une
condition d'arrêt. C'est un principe très utilisé avec Sed ou Awk.
Pour faire la même chose en Ruby, on va se servir d'un <em>range</em>:</p>

<p><code>ruby flip_flop.rb
puts $_ if $_.start_with?("start")..$_.start_with?("end")
</code></p>

<p><code>bash
[~]⇒ ruby -n flip_flop.rb data.txt
start
4
5
6
end
</code></p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Remplacer Sed et Awk par Ruby 13: Séparateurs en sortie]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/12/18/remplacer-sed-et-awk-par-ruby-13-separateurs-en-sortie/"/>
    <updated>2013-12-18T18:58:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/12/18/remplacer-sed-et-awk-par-ruby-13-separateurs-en-sortie</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>La dernière fois on a vu <a href="http://lkdjiin.github.io/blog/2013/12/17/remplacer-sed-et-awk-par-ruby-12-numero-de-ligne/">les numéros de lignes</a>, aujourd'hui on voit comment
modifier les séparateurs de champ et d'enregistrement.</p>

<!-- more -->


<p>On continue donc avec un exemple trivial, on a ce fichier de données:</p>

<p><code>raw data.txt
1,a
2,b
3,c
</code></p>

<p>On va intervertir les champs et modifier le séparateur de champs pour qu'il
devienne un point-virgule (pour le nom des variables prédéfinie, je vous
renvoie à l'article sur <a href="http://lkdjiin.github.io/blog/2013/12/14/remplacer-sed-et-awk-par-ruby-11-la-gem-english/">la gem English</a>):</p>

<p><code>ruby
BEGIN {
  require 'English'
  $FS = ','
  $OFS = ';'
}
$_ = $F.reverse.join
</code></p>

<p><code>join</code> va utiliser automatiquement le contenu de <code>$OFS</code>:</p>

<p><code>bash
[~]⇒ ruby -apl test1.rb data.txt
a;1
b;2
c;3
</code></p>

<p>Parfois on veut aussi modifier le séparateur d'enregistrements (les enregistrements
sont ici nos lignes du fichier). Par exemple, pour passer du caractère <em>newline</em> à
<code>:</code>:</p>

<p><code>ruby
BEGIN {
  require 'English'
  $FS = ','
  $OFS = ';'
  $ORS = ':'
}
$_ = $F.reverse.join
</code></p>

<p>Et le résultat:</p>

<p><code>bash
[~]⇒ ruby -apl test1.rb data.txt
a;1:b;2:c;3:
</code></p>

<p>Et bien sûr, si vous le voulez vraiment, vous pouvez toujours écrire ce
script en une ligne, directement dans la console:</p>

<p><code>bash
[~]⇒ ruby -aple 'BEGIN{$;=",";$,=";";$\=":"};$_=$F.reverse.join' data.txt
</code></p>

<p>Mais êtes-vous sûr de vouloir faire ça ?!</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Remplacer Sed et Awk par Ruby 12: Numéro de ligne]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/12/17/remplacer-sed-et-awk-par-ruby-12-numero-de-ligne/"/>
    <updated>2013-12-17T21:52:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/12/17/remplacer-sed-et-awk-par-ruby-12-numero-de-ligne</id>
    <content type="html"><![CDATA[<p>Après avoir vu l'utilité de <a href="http://lkdjiin.github.io/blog/2013/12/14/remplacer-sed-et-awk-par-ruby-11-la-gem-english/">la gem English</a>, on voit aujourd'hui une utilisation
des numéros de ligne pour créer un échantillon de données.</p>

<!-- more -->


<p>La variable prédéfinie <code>$.</code> contient le numéro de la ligne en cours de
traitement. Une utilisation de cette variable, que j'aime beaucoup, est
la création d'un petit échantillon (<em>sample</em>) de données, à partir d'un
long fichier.</p>

<p>Pour la démonstration, prenons un fichier de données de 33 lignes:</p>

<p><code>raw data.txt
1
2
3
.
.
.
33
</code></p>

<p>L'idée est de ne prendre qu'une ligne sur dix. Voilà le script:</p>

<p><code>ruby test.rb
puts $_ if $. % 10 == 0
</code></p>

<p>Ou, en utilisant la gem English:</p>

<p><code>ruby test1.rb
BEGIN { require 'English' }
puts $LAST_READ_LINE if $INPUT_LINE_NUMBER % 10 == 0
</code></p>

<p>La ligne en cours est affichée seulement quand le numéro de la ligne est
un multiple de 10:</p>

<p><code>bash
[~]⇒ ruby -n test.rb data.txt
10
20
30
</code></p>

<p>Intéressant quand on veut se créer rapidement un petit jeu de données pour
tester quelque chose…</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Remplacer Sed et Awk par Ruby 11: La gem English]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/12/14/remplacer-sed-et-awk-par-ruby-11-la-gem-english/"/>
    <updated>2013-12-14T16:59:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/12/14/remplacer-sed-et-awk-par-ruby-11-la-gem-english</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Après avoir vu <a href="http://lkdjiin.github.io/blog/2013/12/12/remplacer-sed-et-awk-par-ruby-10-un-exemple-dutilisation/">un exemple d'utilisation</a> du mode <em>sed/awk</em> de Ruby au travers
d'un <em>one liner</em>, on regarde aujourd'hui la gem English, qui facilite
énormement la
vie pour l'écriture des scripts.</p>

<!-- more -->


<p>On a vu jusqu'à présent deux variables globales, j'ai nommé <code>$_</code> et
<code>$;</code>. Ces noms sont justes barbares et imprononçables. Et des variables
globales de ce genre, il y en a quelques autres qui vont nous être utiles.
Voyons voir si vous êtes capable de deviner ce qu'elles représentent:
<code>$,</code>, <code>$\</code>, <code>$/</code> et <code>$.</code>. Vous avez deviné ? Non ? C'est là qu'entre en
jeu <a href="http://ruby-doc.org/stdlib-2.0.0/libdoc/English/rdoc/English.html">la gem English</a>. Cette gem va nous permettre d'accéder à ces
variables à l'aide de noms compréhensibles par le commun des mortels:</p>

<pre><code>   Nom court   Nom long
$; $FS         $FIELD_SEPARATOR
$, $OFS        $OUTPUT_FIELD_SEPARATOR 
$/ $RS         $INPUT_RECORD_SEPARATOR
$\ $ORS        $OUTPUT_RECORD_SEPARATOR
$. $NR         $INPUT_LINE_NUMBER
$_             $LAST_READ_LINE
</code></pre>

<p>Pour avoir accès à ceci dans un script, il faudra charger la gem dans
un bloc BEGIN:</p>

<p><code>ruby
BEGIN { require 'English' }
</code></p>

<p>Alors quand se servir des noms courts, des noms longs ? Tout dépend de
votre <em>background</em> et de votre tâche.</p>

<p>Si vous débutez en Ruby, si vous devez écrire un script long et/ou complexe,
si le script doit être maintenu pendant des mois ou plus, si il est maintenu
par plusieurs personnes, utilisez les noms longs.</p>

<p>Si vous (et votre équipe) avez une expérience de Awk, les noms courts peuvent
être une solution raisonnable.</p>

<p>Quand aux noms <em>barbares</em>, réservez les pour les <em>one liners</em>, les scripts
courts <em>one shot</em> et les séances de masochisme.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
