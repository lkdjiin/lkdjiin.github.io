<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : débutant | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/debutant/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2014-03-10T16:46:01+01:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ruby - Utiliser les blocs pour faire du refactoring - partie 2]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/03/10/ruby-utiliser-les-blocs-pour-faire-du-refactoring-partie-2/"/>
    <updated>2014-03-10T15:58:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/03/10/ruby-utiliser-les-blocs-pour-faire-du-refactoring-partie-2</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Suite à l'article d'hier
(<a href="/blog/2014/03/09/ruby-utiliser-les-blocs-pour-faire-du-refactoring/">Utiliser les blocs pour faire du refactoring</a>),
on m'a demandé la différence entre <code>block.call</code> et <code>yield</code>. C'est parti.</p>

<!-- more -->


<p>On s'était arrêté là:</p>

<p>``` ruby test.rb
class Bidule
  def un</p>

<pre><code>helper('un') { puts 'Au milieu de la méthode un' }
</code></pre>

<p>  end</p>

<p>  def deux</p>

<pre><code>helper('deux') do
  puts 'Ceci est le milieu de la méthode deux'
end
</code></pre>

<p>  end</p>

<p>  private</p>

<p>  def helper(argument, &amp;block)</p>

<pre><code>puts "Début de la méthode #{argument}"
block.call
puts "Fin de la méthode #{argument}"
</code></pre>

<p>  end
end</p>

<p>bidule = Bidule.new
bidule.un
bidule.deux
```</p>

<p>Essayons de remplacer <code>block.call</code> par <code>yield</code>:</p>

<p>``` ruby test.rb
class Bidule
  def un</p>

<pre><code>helper('un') { puts 'Au milieu de la méthode un' }
</code></pre>

<p>  end</p>

<p>  def deux</p>

<pre><code>helper('deux') do
  puts 'Ceci est le milieu de la méthode deux'
end
</code></pre>

<p>  end</p>

<p>  private</p>

<p>  def helper(argument, &amp;block)</p>

<pre><code>puts "Début de la méthode #{argument}"
yield
puts "Fin de la méthode #{argument}"
</code></pre>

<p>  end
end</p>

<p>bidule = Bidule.new
bidule.un
bidule.deux
```</p>

<p>Lorsqu'on lance le programme, on voit qu'il n'y a pas de différences:</p>

<p><code>bash
$ ruby test.rb
Début de la méthode un
Au milieu de la méthode un
Fin de la méthode un
Début de la méthode deux
Ceci est le milieu de la méthode deux
Fin de la méthode deux
</code></p>

<p>Ok, donc <code>block.call</code> et <code>yield</code> c'est pareil ? Attends encore. Essayons
maintenant de supprimer le <code>&amp;block</code>:</p>

<p>``` ruby test.rb
class Bidule
  def un</p>

<pre><code>helper('un') { puts 'Au milieu de la méthode un' }
</code></pre>

<p>  end</p>

<p>  def deux</p>

<pre><code>helper('deux') do
  puts 'Ceci est le milieu de la méthode deux'
end
</code></pre>

<p>  end</p>

<p>  private</p>

<p>  def helper(argument)</p>

<pre><code>puts "Début de la méthode #{argument}"
yield
puts "Fin de la méthode #{argument}"
</code></pre>

<p>  end
end</p>

<p>bidule = Bidule.new
bidule.un
bidule.deux
```</p>

<p>Toujours pas de différences ! Par contre, on ne pourra pas appeler
<code>block.call</code> sans avoir défini <code>&amp;block</code>:</p>

<p>``` ruby
  def helper(argument)</p>

<pre><code>puts "Début de la méthode #{argument}"
block.call
puts "Fin de la méthode #{argument}"
</code></pre>

<p>  end
```</p>

<p>Le code ci-dessus donnera évidemment une erreur:</p>

<p><code>`` bash
$ ruby test.rb
Début de la méthode un
test.rb:16:in</code>helper': undefined local variable or method `block' for</p>

<h1>&lt;Bidule:0x9eaf6ec> (NameError)</h1>

<p>```</p>

<p>Toutes ces expérimentations nous ammène à une première conclusion: <em>Les
blocs sont implicites, et donc ils sont partout</em>. Ce que confirme, s'il en
est encore besoin, la session irb suivante:</p>

<p>``` irb</p>

<blockquote><blockquote><p>def foo(arg)
  puts arg
end
=> :foo
foo(&lsquo;ok&rsquo;) { puts &lsquo;I am in a block&rsquo; }
ok
```</p></blockquote></blockquote>

<p>Le contenu du bloc n'est jamais évalué, mais ne provoque pas d'erreur
lors de l'appel de <code>foo</code>.</p>

<p>Seconde conclusion, <code>block.call</code> et <code>yield</code> fonctionnent à l'identique.
Bien que je préfère <code>block.call</code>, qui me force à documenter la méthode
avec le <code>&amp;block</code>.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby - Utiliser les blocs pour faire du refactoring]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/03/09/ruby-utiliser-les-blocs-pour-faire-du-refactoring/"/>
    <updated>2014-03-09T15:50:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/03/09/ruby-utiliser-les-blocs-pour-faire-du-refactoring</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Suivant le(s) langage(s) que vous pratiquiez avant de vous mettre à Ruby,
les blocs peuvent vous sembler plus ou moins obscurs. Voici un
exemple d'utilisation possible, lorsque vous faites du refactoring.</p>

<!-- more -->


<p>Prenons le programme suivant:</p>

<p>``` ruby test1.rb
class Bidule
  def un</p>

<pre><code>puts 'Début de la méthode un'
puts 'Au milieu de la méthode un'
puts 'Fin de la méthode un'
</code></pre>

<p>  end</p>

<p>  def deux</p>

<pre><code>puts 'Début de la méthode deux'
puts 'Au milieu de la méthode deux'
puts 'Fin de la méthode deux'
</code></pre>

<p>  end
end</p>

<p>bidule = Bidule.new
bidule.un
bidule.deux
```</p>

<p>Voici ce que ça donne quand on le lance:</p>

<p><code>bash
$ ruby test1.rb
Début de la méthode un
Au milieu de la méthode un
Fin de la méthode un
Début de la méthode deux
Au milieu de la méthode deux
Fin de la méthode deux
</code></p>

<p>Le problème de la classe <code>Bidule</code> est que ses méthodes <code>un</code> et <code>deux</code>
sont identiques (ou presque). On aura donc intérêt à extraire une
méthode helper:</p>

<p>``` ruby test1.rb
class Bidule
  def un</p>

<pre><code>helper('un')
</code></pre>

<p>  end</p>

<p>  def deux</p>

<pre><code>helper('deux')
</code></pre>

<p>  end</p>

<p>  private</p>

<p>  def helper(argument)</p>

<pre><code>puts "Début de la méthode #{argument}"
puts "Au milieu de la méthode #{argument}"
puts "Fin de la méthode #{argument}"
</code></pre>

<p>  end
end
```</p>

<p>Voilà, c'était du refactoring classique.</p>

<p>Maintenant imaginons que la classe <code>Bidule</code> soit ainsi:</p>

<p>``` ruby test1.rb
class Bidule
  def un</p>

<pre><code>puts 'Début de la méthode un'
puts 'Au milieu de la méthode un'
puts 'Fin de la méthode un'
</code></pre>

<p>  end</p>

<p>  def deux</p>

<pre><code>puts 'Début de la méthode deux'
puts 'Ceci est le milieu de la méthode deux'
puts 'Fin de la méthode deux'
</code></pre>

<p>  end
end
```</p>

<p>Vous avez remarqué la différence:</p>

<p>``` ruby
  def un</p>

<pre><code>#
puts 'Au milieu de la méthode un'
#
</code></pre>

<p>  end</p>

<p>  def deux</p>

<pre><code>#
puts 'Ceci est le milieu de la méthode deux'
#
</code></pre>

<p>  end
```</p>

<p>Cette fois les méthodes <code>un</code> et <code>deux</code> se distinguent un peu plus, bien
que la logique reste identique. On peux donc tirer avantage des blocs:</p>

<p>``` ruby test1.rb
class Bidule
  def un</p>

<pre><code>helper('un') { puts 'Au milieu de la méthode un' }
</code></pre>

<p>  end</p>

<p>  def deux</p>

<pre><code>helper('deux') do
  puts 'Ceci est le milieu de la méthode deux'
end
</code></pre>

<p>  end</p>

<p>  private</p>

<p>  def helper(argument, &amp;block)</p>

<pre><code>puts "Début de la méthode #{argument}"
block.call
puts "Fin de la méthode #{argument}"
</code></pre>

<p>  end
end
```</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Quelques raccourcis pour Firefox]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/03/07/quelques-raccourcis-pour-firefox/"/>
    <updated>2014-03-07T20:50:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/03/07/quelques-raccourcis-pour-firefox</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>C'est vendredi. Fin de la semaine. Je vais la faire courte. Voici trois
raccourcis clavier pour Firefox, dont deux que je viens de découvrir
aujourd'hui, et un qui ne fonctionne que sur OS X.</p>

<!-- more -->


<p><strong>Ctrl $</strong></p>

<p>Permet d'afficher le groupe d'onglets suivants. Je l'ai découvert
aujourd'hui par hasard. Fonctionne sur OS X, mais pas sur Linux :(</p>

<p><strong>/</strong></p>

<p>Affiche une boite de dialogue pour chercher du texte dans la page.
Appuyez sur F3 pour chercher le suivant.</p>

<p><strong>&lsquo;</strong></p>

<p>Affiche une boite de dialogue pour chercher du texte dans la page <em>seulement
dans les liens</em>.
Là aussi, appuyez sur F3 pour chercher le suivant.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Apprenez Vim comme vous voulez]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/03/05/apprenez-vim-comme-vous-voulez/"/>
    <updated>2014-03-05T20:51:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/03/05/apprenez-vim-comme-vous-voulez</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Un jour j'ai commis ça : <a href="/blog/2013/07/14/bien-debuter-avec-vim-conseil-numero-trois/">Ayez confiance dans le mode normal</a>.
En gros, j'expliquai dans cet article qu'un débutant sur Vim doit se
<em>forcer</em> à rester le plus longtemps possible en mode normal. Parce que
c'est le mode le plus important de Vim, que c'est la <em>Vim way</em>, toussa…</p>

<p><strong>Bullshit !</strong></p>

<!-- more -->


<p>En le relisant, cet article, j'ai pensé à toutes celles et ceux qui ont
tentés de passer à Vim de cette manière, et qui sont revenus en arrière,
parfois plusieurs fois ; à celles et ceux qui voudraient franchir le pas
mais qui n'osent pas, ou qui remettent à plus tard, à cause de personnes
comme moi, qui disent «c'est ainsi qu'il faut faire et pas autrement».</p>

<p>Alors <em>mea culpa</em>, en y refléchissant un peu mieux, je ne vois <em>aucunes</em>
raisons pour ne pas vous mettre à Vim de la manière qui vous plaira. Ce
que je décrivais dans cet ancien article a fonctionné pour moi. Et ça
ne dois pas avoir valeur universelle. Faites comme vous l'entendez.
On peut très bien apprendre Vim en étant scotché en mode insertion pendant
des semaines, et en introduisant les autres modes tout doucement.
Si ça vous semble plus naturel, allez y comme ça. Ce qui compte vraiment, c'est
de franchir le pas, pas la manière dont on le franchit.</p>

<p>Bon Vim…</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[La commande cat peut aussi afficher les numéros de lignes]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/02/27/la-commande-cat-peut-aussi-afficher-les-numeros-de-lignes/"/>
    <updated>2014-02-27T20:48:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/02/27/la-commande-cat-peut-aussi-afficher-les-numeros-de-lignes</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Je crois bien que je n'avais jamais regardé la documentation de la commande
unix <code>cat</code> jusqu'à il y a quelques jours. Je viens donc tout juste
d'apprendre qu'on pouvait afficher les numéros de lignes.</p>

<!-- more -->


<p>Afficher un fichier avec <code>cat</code>:</p>

<p><code>bash
$ cat exemple
Je suis
un fichier
exemple.
</code></p>

<p>Afficher avec les numéros de ligne:</p>

<p>``` bash
$ cat -n exemple</p>

<pre><code> 1  Je suis
 2  un fichier
 3  exemple.
</code></pre>

<p>```</p>

<p>Voilà, ça peut servir de temps en temps…</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
