<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : débutant | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/debutant/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2013-11-27T19:03:17+01:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Du nouveau dans Ruby 2.1: Argument nommé et requis]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/11/27/du-nouveau-dans-ruby-2-dot-1-argument-nomme-et-requis/"/>
    <updated>2013-11-27T18:14:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/11/27/du-nouveau-dans-ruby-2-dot-1-argument-nomme-et-requis</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Ruby 2.0 a introduit les arguments nommés, appelés <em>keyword argument</em>
dans la langue de Shakespeare, soit: «argument mot-clé». Ruby 2.1 ajoute
la notion d'argument nommé <strong>et</strong> requis.</p>

<p>Voilà à quoi ça ressemble, un argument nommé:</p>

<!-- more -->


<p>``` ruby
def foo(arg: &ldquo;hello&rdquo;)
  puts arg
end</p>

<p>foo #=> &ldquo;hello&rdquo;
```</p>

<h2>Avant Ruby 2.1</h2>

<p>Mais en Ruby 2.0, vous êtes obligé de donner une valeur par défaut:</p>

<pre><code>[~]⇒ rvm use 2.0.0
[~]⇒ irb
</code></pre>

<p>``` irb</p>

<blockquote><blockquote><p>def foo(arg:)
  puts arg
end
SyntaxError: (irb):10: syntax error, unexpected &lsquo;)&rsquo;
```</p></blockquote></blockquote>

<p>Imaginez que ça soit pareil avec les arguments dit
<em>normaux</em>. On ne pourrait pas écrire:</p>

<pre><code>def foo(arg)
</code></pre>

<p>On serait obligé d'écrire à la place:</p>

<pre><code>def foo(arg="hello")
</code></pre>

<p>Un peu bizarre, non ?</p>

<h2>Avec Ruby 2.1</h2>

<p>On peut maintenant définir un argument nommé sans valeur par défaut, et
donc faire en sorte qu'il soit requis:</p>

<pre><code>[~]⇒ rvm use 2.1.0-preview1
[~]⇒ irb
</code></pre>

<p>``` irb</p>

<blockquote><blockquote><p>def foo(arg:)
  puts arg
end
=> :foo
foo
ArgumentError: missing keyword: arg
foo &ldquo;hello&rdquo;
ArgumentError: missing keyword: arg
foo arg: &ldquo;hello&rdquo;
hello
```</p></blockquote></blockquote>

<p><strong>Source (pdf)</strong> <a href="http://www.atdot.net/~ko1/activities/toruby05-ko1.pdf">toruby</a></p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Du nouveau dans Ruby 2.1: Le suffixe f pour les chaînes de caractères]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/11/26/du-nouveau-dans-ruby-2-dot-1-le-suffixe-f-pour-les-chaines-de-caracteres/"/>
    <updated>2013-11-26T20:33:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/11/26/du-nouveau-dans-ruby-2-dot-1-le-suffixe-f-pour-les-chaines-de-caracteres</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Aujourd'hui c'est au tour du nouveau suffixe <code>f</code> (comme frozen) d'être passé
en revue.</p>

<!-- more -->


<h2>Avant Ruby 2.1</h2>

<p>Les chaînes de caractères en Ruby sont des objets <em>mutables</em>. Ce qui
signifie qu'à chaque fois que l'interpréteur rencontre <code>"foo"</code>, il crée
un nouvel objet:</p>

<pre><code>[~]⇒ rvm use 2.0.0
[~]⇒ irb
&gt;&gt; "foo".object_id
74667700
&gt;&gt; "foo".object_id
74664050
</code></pre>

<p>Ce qui peut influer sur les performances d'un programme quand on compare
beaucoup de chaînes. Voici un exemple trivial:</p>

<p><code>ruby
def foo?(string)
  foo = "foo"
  p foo.object_id
  string == foo
end
</code></p>

<p>Encore une fois, on peut constater qu'un nouvel objet est créé à chaque
appel de la méthode:</p>

<p>``` irb</p>

<blockquote><blockquote><p>foo? &ldquo;bépo&rdquo;
76675080
false
foo? &ldquo;bar&rdquo;
76669680
false
```</p></blockquote></blockquote>

<p>Et géler (<em>freeze</em>) l'objet n'empêchera pas sa création à chaque appel:</p>

<p>``` irb</p>

<blockquote><blockquote><p>def foo
  foo = &ldquo;foo&rdquo;.freeze
  foo.object_id
end
nil
foo
82081130
foo
82079520
```</p></blockquote></blockquote>

<h2>Avec Ruby 2.1</h2>

<pre><code>[~]⇒ rvm use 2.1.0-preview1
[~]⇒ irb
</code></pre>

<p>Le suffixe <code>f</code> permet de géler (<em>freeze</em>) les chaînes de
caractères:</p>

<p>``` irb</p>

<blockquote><blockquote><p>a = &ldquo;foo"f
=> "foo&rdquo;
a.reverse!
RuntimeError: can&rsquo;t modify frozen String
```</p></blockquote></blockquote>

<p>Et surtout, le suffixe <code>f</code> les gèlent une fois pour toutes.
L'exemple précédent donne ceci:</p>

<p>``` irb</p>

<blockquote><blockquote><p>def foo?(string)
  foo = &ldquo;foo"f
  p foo.object_id
  string == foo
end
=> :foo?
foo? "bépo&rdquo;
79029020
=> false
foo? &ldquo;bar&rdquo;
79029020
=> false
```</p></blockquote></blockquote>

<p><strong>Source (pdf)</strong> <a href="http://www.atdot.net/~ko1/activities/toruby05-ko1.pdf">toruby</a></p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Du nouveau dans Ruby 2.1: Le suffixe r]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/11/25/du-nouveau-dans-ruby-2-dot-1-le-suffixe-r/"/>
    <updated>2013-11-25T23:56:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/11/25/du-nouveau-dans-ruby-2-dot-1-le-suffixe-r</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Aujourd'hui on voit une nouvelle façon d'écrire un nombre rationnel dans
Ruby 2.1.</p>

<!-- more -->


<p>Jusqu'ici pour écrire un nombre rationnel, on devait faire ceci:</p>

<p><code>ruby
Rational('1/3')
</code></p>

<p>Ce qui est loin d'être concis:</p>

<pre><code>[~]⇒ rvm use 2.0.0
[~]⇒ irb
&gt;&gt; Rational('1/3') + Rational('1/9')
4/9
</code></pre>

<p>Désormais, avec Ruby 2.1, on pourra se servir du suffixe <code>r</code>:</p>

<pre><code>[~]⇒ rvm use 2.1.0-preview1
[~]⇒ irb
&gt;&gt; 1/3r + 1/9r
=&gt; (4/9)
</code></pre>

<p>Encore un peu plus de sucre dans notre langage ;)</p>

<p><strong>Source (pdf)</strong> <a href="http://www.atdot.net/~ko1/activities/toruby05-ko1.pdf">toruby</a></p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Racket: première approche de lambda]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/11/21/racket-premiere-approche-de-lambda/"/>
    <updated>2013-11-21T19:53:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/11/21/racket-premiere-approche-de-lambda</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Dans un <a href="http://lkdjiin.github.io/blog/2013/11/11/racket-pour-les-rubyists-6-une-premiere-fonction/">article précédent</a>, j'ai écrit une fonction Racket pour calculer
les diviseurs d'un nombre n:</p>

<p>``` racket</p>

<h1>lang racket</h1>

<p>(define (divisors n)
  ; Is i a divisor of n?
  (define (divisor? i)</p>

<pre><code>(= 0 (remainder n i)))
</code></pre>

<p>  (filter divisor? (range 1 (+ n 1))))</p>

<p>(provide divisors)
```</p>

<p>Puis on a vu comment <a href="http://lkdjiin.github.io/blog/2013/11/17/racket-pour-les-rubyists-8-tests-unitaires-simples/">faire des tests unitaires</a>.
Il est temps maintenant de faire un peu de refactoring.</p>

<!-- more -->


<p>Tout d'abord, le plus simple, on va extraire une fonction qui calcule
un <em>range</em> de 1 à n inclus:</p>

<p>``` racket number.rkt</p>

<h1>lang racket</h1>

<p>; divisors : integer &ndash;> list of integers
; Get divisors of a number n.
(define (divisors n)
  ; Is i a divisor of n?
  (define (divisor? i)</p>

<pre><code>(= 0 (remainder n i)))
</code></pre>

<p>  (filter divisor? (range-inclusive n)))</p>

<p>; range-inclusive : integer &ndash;> list of integers
; Build a list from 1 to n inclusive.
(define (range-inclusive n)
  (range 1 (+ n 1)))</p>

<p>(provide divisors)
```</p>

<p>Vous noterez au passage que j'ai commencé à documenter mes fonctions en
spécifiant les types de données en entrée et en sortie. Vous remarquez aussi
que <code>range-inclusive</code> ne fait pas partie de l'API du module:
<code>(provide divisors)</code>.</p>

<p>Maintenant il nous faut extraire la fonction qui regarde si un nombre <em>i</em> est
un diviseur de <em>n</em>:</p>

<p><code>racket
; divisor-of? : integer integer -&gt; boolean
; Tells if i is a divisor of n.
(define (divisor-of? n i)
  (= 0 (remainder n i)))
</code></p>

<p>Le nom de la fonction a changé au passage pour <code>divisor-of?</code>. Mais surtout
nous avons du inclure <em>n</em> dans les arguments de la fonction.</p>

<p>On doit maintenant <em>insérer</em> cette fonction dans le code de la fonction
principale <code>divisors</code>. Voici une première tentative un peu naive:</p>

<p><code>racket
; Attention, ce code ne fonctionne pas.
(define (divisors n)
  (filter (divisor-of? n i) (range-inclusive n)))
</code></p>

<p>Évidemment ça ne marche pas, puisque Racket ne connait pas <em>i</em>, mais
ça nous donne une orientation. Pour que Racket sache ce que nous voulons
placer dans <em>i</em>, à savoir l'élément en cours de traitement par la fonction
<code>filter</code>, on va passer par une fonction anonyme:</p>

<p><code>racket
(define (divisors n)
  (filter (lambda (i) (divisor-of? n i)) (range-inclusive n)))
</code></p>

<p>Une fonction anonyme (lambda) prend un argument (ou plusieurs) et une
expression. À chaque itération, <code>filter</code> passe un élément tiré de
<code>(range-inclusive n)</code> à la fonction anonyme <code>(lambda (i) (divisors-of? n i))</code>.</p>

<p>Voilà donc notre module, après refactoring:</p>

<p>``` racket number.rkt</p>

<h1>lang racket</h1>

<p>; divisors : integer &ndash;> list of integers
; Get divisors of a number n.
(define (divisors n)
  (filter (lambda (i) (divisor-of? n i)) (range-inclusive n)))</p>

<p>; divisor-of? : integer integer &ndash;> boolean
; Tells if i is a divisor of n.
(define (divisor-of? n i)
  (= 0 (remainder n i)))</p>

<p>; range-inclusive : integer &ndash;> list of integers
; Build a list from 1 to n inclusive.
(define (range-inclusive n)
  (range 1 (+ n 1)))</p>

<p>(provide divisors)
```</p>

<p>On aurait aussi pu écrire ce qui suit, à la place des trois fonctions ci-dessus:</p>

<p><code>racket
; divisors : integer -&gt; list of integers
; Get divisors of a number n.
(define (divisors n)
  (filter (lambda (i) (= 0 (remainder n i))) (range 1 (+ n 1))))
</code></p>

<p>Ça fait bien sûr beaucoup moins de code… Peut-être est-ce parceque je ne suis
pas encore habitué à Racket, mais je trouve aussi cela bien moins lisible.
Si on doit réutiliser les fonctions <code>divisor-of?</code> et <code>range-inclusive</code>, il
n'y a pas de question à se poser. Sinon…? Si vous connaissez bien
Racket/Scheme/Lisp laissez donc un commentaire pour me dire quelle version
est la plus idiomatique de ce type de langages.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Racket pour les Rubyists 8: Tests unitaires simples]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/11/17/racket-pour-les-rubyists-8-tests-unitaires-simples/"/>
    <updated>2013-11-17T19:04:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/11/17/racket-pour-les-rubyists-8-tests-unitaires-simples</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Maintenant que l'on sait <a href="http://lkdjiin.github.io/blog/2013/11/15/racket-pour-les-rubyists-7-module-basique/">écrire un module pour Racket</a>, on va pouvoir
faire des tests unitaires simples avec RackUnit, le framework de test
fournit avec le langage Racket.</p>

<!-- more -->


<h2>Notre module</h2>

<p>On va tout d'abord mettre notre fonction <code>divisors</code> dans le fichier
<code>number.rkt</code>:</p>

<p>``` racket</p>

<h1>lang racket</h1>

<p>(define (divisors n)
  ; Is i a divisor of n?
  (define (divisor? i)</p>

<pre><code>(= 0 (remainder n i)))
</code></pre>

<p>  (filter divisor? (range 1 (+ n 1))))</p>

<p>(provide divisors)
```</p>

<p>Puis on s'assure que tout fonctionne bien en appelant la fonction <code>divisors</code>
depuis une session racket:</p>

<pre><code>[~]⇒ racket
Welcome to Racket v5.3.6.
-&gt; (require "number.rkt")
-&gt; (divisors 17)
'(1 17)
-&gt; (exit)
</code></pre>

<h2>Le framework RackUnit</h2>

<p>Tout comme Ruby est fournit avec test/unit, Racket est livré avec RackUnit.
C'est un framework de tests unitaires relativement simple, surtout dans son
<em>utilisation basique</em> comme on va le voir ici.</p>

<p>Comme notre fichier à tester se nomme <code>number.rkt</code>, nous allons nommer le
fichier comportant les tests <code>number-test.rkt</code> et le placer dans le même
dossier:</p>

<p>``` racket</p>

<h1>lang racket</h1>

<p>(require rackunit</p>

<pre><code>     "number.rkt")
</code></pre>

<p>```</p>

<p>On requiert la bibliothèque <code>rackunit</code> ainsi que le fichier à tester. <em>On verra
dans un autre article pourquoi <code>rackunit</code> n'est pas placé entre guillemets.</em>
Maintenant on peut effectuer un test avec la fonction:</p>

<pre><code>(check-equal? A B)
</code></pre>

<p>qui s'assure que l'expression A est égale à l'expression B. Par exemple:</p>

<p>``` racket</p>

<h1>lang racket</h1>

<p>(require rackunit</p>

<pre><code>     "number.rkt")
</code></pre>

<p>(check-equal? (divisors 8) &lsquo;(1 2 4 8))
```</p>

<p>Et on lance les tests comme ceci:</p>

<pre><code>[~]⇒ racket number-test.rkt
[~]⇒ 
</code></pre>

<p>Quand tout les tests passent, RackUnit est silencieux.
Si on modifie notre fonction <code>divisors</code> ainsi:</p>

<pre><code>(filter divisor? (range 2 (+ n 1))))
</code></pre>

<p>On peut voir le genre de sortie produit par RackUnit sur un test qui
échoue:</p>

<pre><code>[~]⇒ racket number-test.rkt
--------------------
FAILURE
actual:     (2 4 8)
expected:   (1 2 4 8)
name:       check-equal?
location:   (#&lt;path:/number-test.rkt&gt; 7 0 92 38)
expression: (check-equal? (divisors 8) (quote (1 2 4 8)))

Check failure
--------------------
</code></pre>

<h2>Comparaison avec Ruby et unit/test</h2>

<p>Voici un test similaire pour Ruby, écrit avec le framework test/unit:</p>

<p>``` ruby
require_relative &ldquo;number&rdquo;
require &ldquo;test/unit&rdquo;</p>

<p>class TestNumber &lt; Test::Unit::TestCase
  def test_divisors</p>

<pre><code>assert_equal [1, 2, 4, 8], Number.divisors(8)
</code></pre>

<p>  end
end
```</p>

<p>Ruby est loin d'être un langage verbeux et pourtant on peut voir qu'ici il
faut écrire une classe et utiliser l'héritage rien que pour un simple petit
test de rien du tout. Alors je ne dis pas que les <em>test cases</em> sont
inutiles (et Racket permet aussi d'organiser les tests de plusieurs
manières différentes), seulement dans le cas d'un programme aussi simple
que le notre je trouve la façon de faire de Racket plus <em>naturelle</em>.</p>

<p>La prochaine fois on passera au refactoring de notre méthode <code>divisors</code>.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
