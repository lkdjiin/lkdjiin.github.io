<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : opal | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/opal/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2014-10-08T13:13:14+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Le jeu de la vie dans sept langages différents]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/10/08/le-jeu-de-la-vie-dans-sept-langages-differents/"/>
    <updated>2014-10-08T12:30:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/10/08/le-jeu-de-la-vie-dans-sept-langages-differents</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Je vais écrire le <a href="http://en.wikipedia.org/wiki/Conway%27s_Game_of_Life">jeu de la vie</a> dans 7 langages, et
en utilisant le TDD (sauf pour l'affichage).
Ça va me permettre de réviser certains langages et d'en apprendre de nouveaux
d'une manière amusante. Après tout, quoi de plus <em>fun</em> qu'un jeu pour zéro
joueur.</p>

<h2>L'algorithme</h2>

<p>L'idée directrice, c'est de faire au plus simple.
L'algorithme général sera le suivant :</p>

<ol>
<li>obtenir une première génération au hasard</li>
<li>afficher la génération</li>
<li>calculer la nouvelle génération et retour au point 2.</li>
</ol>


<p>Discutons un peu chacun des trois points.</p>

<!-- more -->


<h3>Obtenir une première génération au hasard</h3>

<p>Cette génération sera stockée dans un tableau (une liste). Suivant le
langage, j'utiliserais un tableau à 1 ou 2 dimensions.</p>

<h3>Afficher la génération</h3>

<p>Il s'agit d'afficher à l'écran le tableau calculé précédement. Chaque élément
du tableau représente une cellule du jeu de la vie, et une cellule sera
représentée à l'écran par un pixel. Alors un pixel pour une cellule, ça risque
d'être assez moche sur la plupart des dispositifs, mais c'est le plus simple.
J'améliorerais peut-être cet affichage plus tard.</p>

<h3>Calculer la nouvelle génération</h3>

<p>Là encore, j'essaye d'aller au plus simple. On va calculer la
nouvelle génération dans un second tableau. Une fois ce calcul effectué, ce
second tableau remplacera le premier.</p>

<p>Pour calculer le nouvel état d'une cellule, on devra observer la cellule et
ces 8 voisins. Autrement dit on observe une fenêtre de 9 cellules et on veut
connaitre le nouvel état de la cellule centrale. Il y a 3 cas possibles:</p>

<ol>
<li>Si la somme des cellules vivantes est 3, alors la nouvelle cellule sera
vivante.</li>
<li>Si la somme des cellules vivantes est 4, alors la nouvelle cellule conserve
son ancien état.</li>
<li>Dans tous les autres cas, la nouvelle cellule est morte.</li>
</ol>


<p>Il faut encore parler du cas des cellules qui se trouvent sur les bords du
<em>plateau de jeu</em>. Normalement, le jeu de la vie est infini. Mais l'infini, c'est
pas simple. Dans une première itération, le <em>plateau de jeu</em> aura des
dimensions finies et les cellules qui se trouvent sur les bords se verront
ajoutées arbitrairement des voisins morts.</p>

<p>Une seconde itération pourrait implémenter une espèce de <a href="http://en.wikipedia.org/wiki/Torus">tore</a> pour avoir une surface
de jeu sans bordures.</p>

<h2>Les langages ciblés</h2>

<p>Je vais écrire le jeu de la vie dans 7 langages différents:</p>

<ul>
<li>ruby</li>
<li>javascript</li>
<li>racket</li>
<li>logo</li>
<li>julia</li>
<li>haskell</li>
<li>rust</li>
</ul>


<h3>Pourquoi ces langages ?</h3>

<p><strong>Ruby</strong></p>

<p>Ça peut paraitre bizarre. Après tout j'écris en Ruby toute la journée, c'est
mon métier. Pourquoi vouloir en faire encore pendant mon temps libre ?
En fait, ce qui m'intéresse vraiment ici, c'est <a href="http://opalrb.org/">Opal.rb</a>. Peut-être aussi
que j'en ferais une seconde version avec <a href="http://www.libgosu.org/">Gosu</a>.</p>

<p><strong>Javascript</strong></p>

<p>Après des années passées à tenter d'éviter d'écrire la moindre ligne de
Javascript, je m'intéresse de nouveau à ce langage. Après tout, c'est un
incontournable du Web et il commence à me plaire. Et puis j'ai trop tardé à
faire du TDD avec Javascript, je crois que <a href="http://jasmine.github.io/">Jasmine</a> est devenu très bon.</p>

<p><strong>Racket</strong></p>

<p>Je crois que tout développeur devrait étudier un <em>Lisp like</em>. Lisp t'oblige à
penser autrement et du coup tu trouves des solutions différentes à des
problèmes de programmation de tout les jours.</p>

<p><strong>Logo</strong></p>

<p>Le <a href="http://fr.wikipedia.org/wiki/Logo_%28langage%29">Logo</a>, c'est ma <a href="http://fr.wikipedia.org/wiki/Madeleine_%28cuisine%29#La_madeleine_de_Proust">madeleine de Proust</a> ! Voilà. Encore un <em>Lisp like</em>,
mais différent (on l'appelait Lisp sans parenthèses). J'espère que je trouverais
encore des ressources pour celui-ci.</p>

<p><strong>Julia</strong></p>

<p>Je pense que les langages fonctionnels ont un grand avenir. Ils résolvent au
moins deux soucis. En ce concentrant sur la transformation des données plutôt
que sur l'état de ces données, ils facilitent les tests et l'utilisation des
multi-coeurs.</p>

<p><strong>Haskell</strong></p>

<p>Encore un langage fonctionnel, et celui-ci me fait un peu peur. Mais je me dis
que je devrais y goûter.</p>

<p><strong>Rust</strong></p>

<p>Je voulais un langage système dans cette liste, ce sera <a href="http://www.rust-lang.org/">Rust</a>.</p>

<h2>Fréquence de publication</h2>

<p>Je ne m'avancerais pas sur une fréquence de publication. J'imagine qu'il y
aura 3 ou 4 articles par langage. Et suivant le temps dont je disposerais, ça
pourrat-être aussi bien un article par mois ou trois articles par semaine.</p>

<p>Allez, la prochaine fois on commence avec Ruby/Opal.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les tours de Hanoi - partie 3]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/07/07/les-tours-de-hanoi-partie-3/"/>
    <updated>2014-07-07T21:13:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/07/07/les-tours-de-hanoi-partie-3</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>On commence à coder l'algorithme génétique pour solutionner les tours de
Hanoi.</p>

<pre><code>$ tree
.
├── ga.rb
├── lib
│   ├── hanoi
│   │   ├── board.rb
│   │   ├── game.rb
│   │   └── rules.rb
│   └── hanoi.rb
└── spec
    ├── board_spec.rb
    ├── game_spec.rb
    ├── integration
    │   └── game_spec.rb
    └── spec_helper.rb
</code></pre>

<!-- more -->


<p>``` ruby ga.rb
require &lsquo;./lib/hanoi/board&rsquo;
require &lsquo;./lib/hanoi/game&rsquo;
require &lsquo;./lib/hanoi/rules&rsquo;</p>

<p>class Chromosome
  attr_reader :genes
  def initialize(number_of_pieces)</p>

<pre><code>@genes = Array.new(2 ** number_of_pieces - 1) { rand(6) }
</code></pre>

<p>  end
end</p>

<p>class Population
  def initialize(size, number_of_pieces)</p>

<pre><code>@population = Array.new(size) { Chromosome.new(number_of_pieces) }
</code></pre>

<p>  end</p>

<p>  def each(&amp;block)</p>

<pre><code>@population.each(&amp;block)
</code></pre>

<p>  end
end</p>

<p>class GA</p>

<p>  def initialize</p>

<pre><code>@population = Population.new(20, 3)
</code></pre>

<p>  end</p>

<p>  def evaluate</p>

<pre><code>@population.each do |chromosome|
  board = ::Hanoi::Board.new(3)
  game = ::Hanoi::Game.new(board)
  chromosome.genes.each do |gene|
    case gene
    when 0 then game.move from: 1, to: 2
    when 1 then game.move from: 1, to: 3
    when 2 then game.move from: 2, to: 1
    when 3 then game.move from: 2, to: 3
    when 4 then game.move from: 3, to: 1
    when 5 then game.move from: 3, to: 2
    end
  end
  p board.eval
end
</code></pre>

<p>  end
end</p>

<p>ga = GA.new
ga.evaluate
```</p>

<p>Voilà de quoi commencer, des chromosomes, une population et l'évaluation
de chaque chromosome.</p>

<p>Ça fonctionne:</p>

<pre><code>$ ruby ga.rb 
0
5
4
2
2
4
5
5
4
4
4
1
5
4
1
0
0
2
0
4
</code></pre>

<p>Mais la fonction <code>GA#evaluate</code> me dérange. D'abord elle est trop longue, mais
rien qui ne puisse s'arranger avec un refactoring. Ce qui me dérange surtout
c'est qu'elle délègue la <em>vraie</em> évaluation à <code>Board</code>. Or, l'évaluation
dévrait faire partie intégrante de l'algorithme génétique, et pas de la
mécanique du jeu. C'est donc un point à améliorer avant d'aller plus loin.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les tours de hanoi - partie 2]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/07/06/les-tours-de-hanoi-partie-2/"/>
    <updated>2014-07-06T13:02:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/07/06/les-tours-de-hanoi-partie-2</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Je termine l'implémentation de la mécanique du jeu, pour pouvoir passer ensuite
à la construction de l'algorithme génétique.</p>

<pre><code>$ tree
.
├── lib
│   ├── hanoi
│   │   ├── board.rb
│   │   ├── game.rb
│   │   └── rules.rb
│   └── hanoi.rb
└── spec
    ├── board_spec.rb
    ├── game_spec.rb
    ├── integration
    │   └── game_spec.rb
    └── spec_helper.rb
</code></pre>

<!-- more -->


<p>J'ai mis <a href="https://github.com/lkdjiin/hanoi">le code</a> sur Github pour que vous puissiez le voir dans son
ensemble.</p>

<p>La classe <code>Board</code> gagne une méthode <code>move</code>, sans intelligence aucune:</p>

<p>``` ruby
module Hanoi</p>

<p>  class Board</p>

<pre><code>def initialize(number_of_pieces)
  @pegs = [ (1..number_of_pieces).to_a.reverse, [], [] ]
end

def position
  @pegs
end

def position=(pegs)
  @pegs = pegs
end

def eval
  @pegs[1].reduce(0, :+) + 2 * @pegs[2].reduce(0, :+)
end

def move(from, to)
  piece = @pegs[from - 1].pop
  @pegs[to - 1].push(piece)
end
</code></pre>

<p>  end</p>

<p>end
```</p>

<p>La mécanique du jeu est assurée par la classe <code>Game</code>, qui délègue à <code>Board</code> et
se repose sur un module <code>Rules</code> pour les décisions:</p>

<p>``` ruby
module Hanoi</p>

<p>  class Game</p>

<pre><code>def initialize(board)
  @board = board
end

def move(from: 1, to: 1)
  @board.move(from, to) if Rules.valid?(@board, from, to)
end

def win?
  Rules.win?(@board)
end

def position
  @board.position
end
</code></pre>

<p>  end</p>

<p>end
```</p>

<p>``` ruby
module Hanoi::Rules</p>

<p>  def self.valid?(board, from, to)</p>

<pre><code>return false if board.position[from - 1].empty?
return true if board.position[to - 1].empty?
if board.position[from - 1][0] &lt; board.position[to - 1][0]
  true
else
  false
end
</code></pre>

<p>  end</p>

<p>  def self.win?(board)</p>

<pre><code>if board.position[0].empty? &amp;&amp; board.position[1].empty?
  true
else
  false
end
</code></pre>

<p>  end</p>

<p>end
```</p>

<p>Voilà, notre futur algorithme génétique a maintenant les moyens d'évaluer
une suite de mouvements, reste plus qu'à le coder ;)</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les tours de Hanoi - partie 1]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/07/05/les-tours-de-hanoi-partie-1/"/>
    <updated>2014-07-05T15:25:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/07/05/les-tours-de-hanoi-partie-1</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Je vais commencer par implémenter une classe <code>Board</code>, dont la tâche est
de retenir l'état du plateau de jeu, c'est à dire la position des pièces.
J'ai envie de faire des tests avec Rspec, donc voici les premiers fichiers:</p>

<pre><code>$ tree
.
├── board.rb
└── spec
    └── board_spec.rb
</code></pre>

<!-- more -->


<p>Voici les tests de <code>Board</code>, qui décrivent ce que j'attend de cette classe:</p>

<p>``` ruby spec/board_spec.rb
require &lsquo;./board&rsquo;</p>

<p>describe Board do</p>

<p>  before { @board = Board.new(3) }</p>

<p>  it &lsquo;has a position&rsquo; do</p>

<pre><code>expect(@board.position).to eq [ [3, 2, 1], [], [] ]
</code></pre>

<p>  end</p>

<p>  it &lsquo;accepts a position&rsquo; do</p>

<pre><code>@board.position = [ [], [3], [2, 1] ]
expect(@board.position).to eq [ [], [3], [2, 1] ]
</code></pre>

<p>  end</p>

<p>  describe &lsquo;position evalution&rsquo; do</p>

<pre><code>specify { expect(@board.eval).to eq 0 }

specify do
  @board.position = [ [], [3], [2, 1] ]
  expect(@board.eval).to eq 9
end

specify do
  @board.position = [ [], [], [3, 2, 1] ]
  expect(@board.eval).to eq 12
end
</code></pre>

<p>  end</p>

<p>end
```</p>

<p>On doit pouvoir l'initialiser avec un nombre de pièces:</p>

<pre><code>before { @board = Board.new(3) }
</code></pre>

<p>À l'initialisation, les pièces sont en position de départ:</p>

<pre><code>it 'has a position' do
  expect(@board.position).to eq [ [3, 2, 1], [], [] ]
end
</code></pre>

<p>On peut modifier la position à volonté:</p>

<pre><code>it 'accepts a position' do
  @board.position = [ [], [3], [2, 1] ]
  expect(@board.position).to eq [ [], [3], [2, 1] ]
end
</code></pre>

<p>Enfin, la position actuelle peut être évaluée:</p>

<pre><code>describe 'position evalution' do

  specify { expect(@board.eval).to eq 0 }

  specify do
    @board.position = [ [], [3], [2, 1] ]
    expect(@board.eval).to eq 9
  end

  specify do
    @board.position = [ [], [], [3, 2, 1] ]
    expect(@board.eval).to eq 12
  end

end
</code></pre>

<p>Pour finir, l'implémentation minimum:</p>

<p>``` ruby board.rb
class Board</p>

<p>  def initialize(number_of_pieces)</p>

<pre><code>@pegs = [ (1..number_of_pieces).to_a.reverse, [], [] ]
</code></pre>

<p>  end</p>

<p>  def position</p>

<pre><code>@pegs
</code></pre>

<p>  end</p>

<p>  def position=(pegs)</p>

<pre><code>@pegs = pegs
</code></pre>

<p>  end</p>

<p>  def eval</p>

<pre><code>@pegs[1].reduce(0, :+) + 2 * @pegs[2].reduce(0, :+)
</code></pre>

<p>  end</p>

<p>end
```</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Un algorithme génétique pour les tours de Hanoi avec Opal.rb]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/07/04/un-algorithme-genetique-pour-les-tours-de-hanoi-avec-opal-dot-rb/"/>
    <updated>2014-07-04T21:07:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/07/04/un-algorithme-genetique-pour-les-tours-de-hanoi-avec-opal-dot-rb</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Pour débuter la résolution du jeu des tours de Hanoi à l'aide d'un algorithme
génétique, j'ai envie de commencer par réfléchir à la représentation des
chromosomes, aux règles de mouvement, à la fonction d'évaluation, sans
forcément commencer à coder.</p>

<!-- more -->


<p>Les règles sont sur <a href="http://fr.wikipedia.org/wiki/Tours_de_Hano%C3%AF">wikipédia</a>.</p>

<p>J'apprend un truc qui va me servir, il faut 2<sup>n</sup> &ndash; 1 coups au minimum pour
solutionner le problème (n est le nombre de disques). Du coup, mes chromosomes
devront posséder 2<sup>n</sup> &ndash; 1 gènes. Ce qui ira sans trop de soucis jusqu'à une
dizaines de disques, mais au delà c'est pas gagné.</p>

<p>Pour faire simple, un gène va représenter un mouvement à l'aide d'un nombre:</p>

<pre><code>0 -&gt; du 1er poteau au 2ème poteau
1 -&gt; du 1er poteau au 3ème poteau
2 -&gt; du 2ème poteau au 1er poteau
3 -&gt; du 2ème poteau au 3ème poteau
4 -&gt; du 3ème poteau au 1er poteau
5 -&gt; du 3ème poteau au 2ème poteau
</code></pre>

<p>Que faire quand un mouvement est illégal ? Le plus simple est de l'ignorer,
c'est donc ce que je vais faire.</p>

<p>La fonction d'évaluation, maintenant ? J'ai envie de donner un <em>poids</em> à
chaque disque suivant le poteau où il se trouve. Sur le premier poteau, un
disque vaut 0 point. Sur le second poteau, il vaut 1 point, et sur le
troisième, il vaut 2 points.</p>

<p>Par exemple, si je commence avec seulement 3 disques, la position suivante
vaut 0 point:</p>

<pre><code>  x|x      |       |   
 xx|xx     |       |   
xxx|xxx    |       |    
</code></pre>

<p>Alors que la suivante vaut 6 points:</p>

<pre><code>   |       |      x|x   
   |       |     xx|xx 
   |       |    xxx|xxx
</code></pre>

<p>C'est pas suffisant pour différencier certaines solutions, donc on appliquera
un multiplicateur suivant la taille du disque, 1 pour le plus petit, 2 pour
le suivant et 3 pour le plus grand. Je vous laisse faire les calculs, ça me
prend trop de temps de faire les petits dessins ;)</p>

<p>Allez, la prochaine fois on code…</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
