<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : opal | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/opal/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2014-07-05T15:45:26+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Les tours de Hanoi - partie 1]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/07/05/les-tours-de-hanoi-partie-1/"/>
    <updated>2014-07-05T15:25:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/07/05/les-tours-de-hanoi-partie-1</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Je vais commencer par implémenter une classe <code>Board</code>, dont la tâche est
de retenir l'état du plateau de jeu, c'est à dire la position des pièces.
J'ai envie de faire des tests avec Rspec, donc voici les premiers fichiers:</p>

<pre><code>$ tree
.
├── board.rb
└── spec
    └── board_spec.rb
</code></pre>

<!-- more -->


<p>Voici les tests de <code>Board</code>, qui décrivent ce que j'attend de cette classe:</p>

<p>``` ruby spec/board_spec.rb
require &lsquo;./board&rsquo;</p>

<p>describe Board do</p>

<p>  before { @board = Board.new(3) }</p>

<p>  it &lsquo;has a position&rsquo; do</p>

<pre><code>expect(@board.position).to eq [ [3, 2, 1], [], [] ]
</code></pre>

<p>  end</p>

<p>  it &lsquo;accepts a position&rsquo; do</p>

<pre><code>@board.position = [ [], [3], [2, 1] ]
expect(@board.position).to eq [ [], [3], [2, 1] ]
</code></pre>

<p>  end</p>

<p>  describe &lsquo;position evalution&rsquo; do</p>

<pre><code>specify { expect(@board.eval).to eq 0 }

specify do
  @board.position = [ [], [3], [2, 1] ]
  expect(@board.eval).to eq 9
end

specify do
  @board.position = [ [], [], [3, 2, 1] ]
  expect(@board.eval).to eq 12
end
</code></pre>

<p>  end</p>

<p>end
```</p>

<p>On doit pouvoir l'initialiser avec un nombre de pièces:</p>

<pre><code>before { @board = Board.new(3) }
</code></pre>

<p>À l'initialisation, les pièces sont en position de départ:</p>

<pre><code>it 'has a position' do
  expect(@board.position).to eq [ [3, 2, 1], [], [] ]
end
</code></pre>

<p>On peut modifier la position à volonté:</p>

<pre><code>it 'accepts a position' do
  @board.position = [ [], [3], [2, 1] ]
  expect(@board.position).to eq [ [], [3], [2, 1] ]
end
</code></pre>

<p>Enfin, la position actuelle peut être évaluée:</p>

<pre><code>describe 'position evalution' do

  specify { expect(@board.eval).to eq 0 }

  specify do
    @board.position = [ [], [3], [2, 1] ]
    expect(@board.eval).to eq 9
  end

  specify do
    @board.position = [ [], [], [3, 2, 1] ]
    expect(@board.eval).to eq 12
  end

end
</code></pre>

<p>Pour finir, l'implémentation minimum:</p>

<p>``` ruby board.rb
class Board</p>

<p>  def initialize(number_of_pieces)</p>

<pre><code>@pegs = [ (1..number_of_pieces).to_a.reverse, [], [] ]
</code></pre>

<p>  end</p>

<p>  def position</p>

<pre><code>@pegs
</code></pre>

<p>  end</p>

<p>  def position=(pegs)</p>

<pre><code>@pegs = pegs
</code></pre>

<p>  end</p>

<p>  def eval</p>

<pre><code>@pegs[1].reduce(0, :+) + 2 * @pegs[2].reduce(0, :+)
</code></pre>

<p>  end</p>

<p>end
```</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Un algorithme génétique pour les tours de Hanoi avec Opal.rb]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/07/04/un-algorithme-genetique-pour-les-tours-de-hanoi-avec-opal-dot-rb/"/>
    <updated>2014-07-04T21:07:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/07/04/un-algorithme-genetique-pour-les-tours-de-hanoi-avec-opal-dot-rb</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Pour débuter la résolution du jeu des tours de Hanoi à l'aide d'un algorithme
génétique, j'ai envie de commencer par réfléchir à la représentation des
chromosomes, aux règles de mouvement, à la fonction d'évaluation, sans
forcément commencer à coder.</p>

<!-- more -->


<p>Les règles sont sur <a href="http://fr.wikipedia.org/wiki/Tours_de_Hano%C3%AF">wikipédia</a>.</p>

<p>J'apprend un truc qui va me servir, il faut 2<sup>n</sup> &ndash; 1 coups au minimum pour
solutionner le problème (n est le nombre de disques). Du coup, mes chromosomes
devront posséder 2<sup>n</sup> &ndash; 1 gènes. Ce qui ira sans trop de soucis jusqu'à une
dizaines de disques, mais au delà c'est pas gagné.</p>

<p>Pour faire simple, un gène va représenter un mouvement à l'aide d'un nombre:</p>

<pre><code>0 -&gt; du 1er poteau au 2ème poteau
1 -&gt; du 1er poteau au 3ème poteau
2 -&gt; du 2ème poteau au 1er poteau
3 -&gt; du 2ème poteau au 3ème poteau
4 -&gt; du 3ème poteau au 1er poteau
5 -&gt; du 3ème poteau au 2ème poteau
</code></pre>

<p>Que faire quand un mouvement est illégal ? Le plus simple est de l'ignorer,
c'est donc ce que je vais faire.</p>

<p>La fonction d'évaluation, maintenant ? J'ai envie de donner un <em>poids</em> à
chaque disque suivant le poteau où il se trouve. Sur le premier poteau, un
disque vaut 0 point. Sur le second poteau, il vaut 1 point, et sur le
troisième, il vaut 2 points.</p>

<p>Par exemple, si je commence avec seulement 3 disques, la position suivante
vaut 0 point:</p>

<pre><code>  x|x      |       |   
 xx|xx     |       |   
xxx|xxx    |       |    
</code></pre>

<p>Alors que la suivante vaut 6 points:</p>

<pre><code>   |       |      x|x   
   |       |     xx|xx 
   |       |    xxx|xxx
</code></pre>

<p>C'est pas suffisant pour différencier certaines solutions, donc on appliquera
un multiplicateur suivant la taille du disque, 1 pour le plus petit, 2 pour
le suivant et 3 pour le plus grand. Je vous laisse faire les calculs, ça me
prend trop de temps de faire les petits dessins ;)</p>

<p>Allez, la prochaine fois on code…</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Un algorithme génétique avec Opal.rb ?]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/06/29/un-algorithme-genetique-avec-opal-dot-rb/"/>
    <updated>2014-06-29T20:59:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/06/29/un-algorithme-genetique-avec-opal-dot-rb</id>
    <content type="html"><![CDATA[<p>Aujourd'hui c'est dimanche, pas d'article technique. Par contre une idée
pour la suite. Un algorithme génétique pour résoudre le jeu des tours de
Hanoi.</p>

<!-- more -->


<p>Ça fait longtemps que j'ai envie de faire un algorithme génétique en rapport
avec un jeu, où on pourrait visualiser de manière graphique et ludique
l'avancée de l'algorithme. J'ai déjà fait une tentative <em>graphique</em> en
utilisant javascript, mais le résultat n'a pas été à la hauteur de mes
espérances, même si ça fonctionnait. Avec Opal, je pourrais utiliser un
langage que je connais bien.</p>

<p>Je suis pressé de commencer ;)</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
