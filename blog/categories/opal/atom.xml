<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : opal | Xavier Nayrac]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/opal/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2015-04-07T19:33:49+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Le jeu de la vie en ruby (opal) - partie 3]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/10/29/le-jeu-de-la-vie-en-ruby-opal-partie-3/"/>
    <updated>2014-10-29T07:18:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/10/29/le-jeu-de-la-vie-en-ruby-opal-partie-3</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Il est temps de tout assembler, pour ça on va écrire une classe <code>Game</code> qui va
jouer le rôle de chef d’orchestre.</p>

<!-- more -->

<h2 id="la-classe-game">La classe Game</h2>

<p>``` ruby
class Game</p>

<p>def initialize(generation, canvas, iterations)
    @iterations = iterations
    @height = generation.size
    @width = generation.first.size
    @generation = generation
    @canvas = canvas
  end</p>

<p>def start
    draw
    @iterations -= 1
    if @iterations &gt; 0
      update
      after_ms(500) { start }
    end
  end</p>

<p>def draw
    @canvas.clear
    @generation.each_with_index do |line, y|
      line.each_with_index do |cell, x|
        @canvas.pixel(x, y) if cell == 1
      end
    end
  end</p>

<p>def update
    new_generation = (0…@height).map do |y|
      (0…@width).map do |x|
        extractor = NeighborhoodExtractor.new(@generation, x, y)
        Neighborhood.new(extractor.cells).next_state
      end
    end
    @generation = new_generation
  end</p>

<p>end
```</p>

<p>Rien d’exceptionnel dans ce code, à part la ligne suivante, extraite de la
méthode <code>start</code>:</p>

<p><code>ruby
      after_ms(500) { start }
</code></p>

<p>Qu’est-ce que c’est que cette méthode <code>after_ms</code> ?</p>

<p>Je ne peux pas faire une bête boucle <code>loop</code>, ou un appel récursif à <code>start</code>
puisqu’on est en Opal.rb, et pas <em>vraiment</em> en Ruby. Le code qui tourne, au
final, sera du Javascript. Et si on n’insère pas des petites pauses, le
navigateur ne va pas aimer du tout. Et puisqu’en Javascript il n’existe pas de
fonction <code>pause</code>, il n’y en a pas non plus en Opal.rb.</p>

<p>J’avoue que je me suis gratter un peu la tête avant de trouver une solution
toute simple. Il suffit d’écrire un <em>wrapper</em> autour de la fonction Javascript
<code>setTimeout</code>:</p>

<p>``` ruby app/kernel.rb
module Kernel</p>

<p>def after_ms(n, &amp;block)
    <code>setTimeout(function() {</code>
      block.call
    <code>}, n);</code>
  end</p>

<p>end
```</p>

<h2 id="mise--lchelle-de-laffichage">Mise à l’échelle de l’affichage</h2>

<p>Ça, c’est très simple.</p>

<p>``` html index.html
&lt;!DOCTYPE html&gt;</p>
<html>
  ...
  <body>
    <canvas width="400" height="400" id="canvas" />
    <script src="build.js"></script>
  </body>
</html>
<p>```</p>

<p>``` ruby app/canvas.rb
class Canvas</p>

<p>SCALE = 4</p>

<p>def initialize
    @canvas  = <code>document.getElementById('canvas')</code>
    @context = <code>#@canvas.getContext('2d')</code>
    @height  = <code>#@canvas.height</code>
    @width   = <code>#@canvas.width</code>
  end</p>

<p>def clear
    draw_rect(0, 0, @width, @height, ‘black’)
  end</p>

<p>def pixel(x, y)
    draw_rect(x * SCALE, y * SCALE, SCALE, SCALE, ‘white’)
  end</p>

<p>private</p>

<p>def draw_rect(x, y, w, h, color)
    <code>#@context.fillStyle = #{color}</code>
    <code>#@context.fillRect(#{x}, #{y}, #{w}, #{h})</code>
  end</p>

<p>end
```</p>

<h2 id="supprimer-les-bordures">Supprimer les bordures</h2>

<p>Ça, c’est très ennuyeux, vous pouvez sauter directement à la fin de l’article.</p>

<p>Je désactive les tests des bordures, puis je les réécrit un par un.</p>

<p>``` ruby spec/neighborhood_extractor_spec.rb
require ‘./app/neighborhood_extractor.rb’</p>

<p>describe NeighborhoodExtractor do</p>

<p>let(:generation) do
    [
      [0, 1, 0, 1],
      [1, 0, 1, 0],
      [0, 1, 1, 0]
    ]
  end</p>

<p>…</p>

<p>describe ‘borders’ do
    specify ‘x=1 y=0’ do
      extractor = NeighborhoodExtractor.new(generation, 1, 0)
      expect(extractor.cells).to eq [0, 1, 1, 0, 1, 0, 1, 0, 1]
    end</p>

<pre><code># specify 'x=2 y=2' do
#   extractor = NeighborhoodExtractor.new(generation, 2, 2)
#   expect(extractor.cells).to eq [0, 1, 0, 1, 1, 0, 0, 0, 0]
# end

# specify 'x=0 y=1' do
#   extractor = NeighborhoodExtractor.new(generation, 0, 1)
#   expect(extractor.cells).to eq [0, 0, 1, 0, 1, 0, 0, 0, 1]
# end

# specify 'x=3 y=1' do
#   extractor = NeighborhoodExtractor.new(generation, 3, 1)
#   expect(extractor.cells).to eq [0, 1, 0, 1, 0, 0, 1, 0, 0]
# end
</code></pre>

<p>end
end
```</p>

<p><code>ruby app/neighborhood_extractor.rb
  def group_of_tree(row_index)
    if row_index &lt; 0
      generation[generation.size-1][x-1..x+1]
    elsif row_index == generation.size
      [0, 0, 0]
    else
      if x == 0
        [ 0, *generation[row_index][x..x+1] ]
      elsif x == generation.first.size - 1
        [*generation[row_index][x-1..x], 0]
      else
        generation[row_index][x-1..x+1]
      end
    end
  end
</code></p>

<p>Après refactoring</p>

<p>``` ruby app/neighborhood_extractor.rb
class NeighborhoodExtractor &lt; Struct.new(:generation, :x, :y)</p>

<p>def cells
    [ *extract(y - 1), *extract(y), *extract(y + 1) ]
  end</p>

<p>private</p>

<p>def extract(row_index)
    row_index = generation.size - 1 if row_index &lt; 0
    group_of_tree(row_index)
  end</p>

<p>def group_of_tree(row_index)
    if row_index == generation.size
      [0, 0, 0]
    else
      if x == 0
        [ 0, <em>generation[row_index][x..x+1] ]
      elsif x == generation.first.size - 1
        [</em>generation[row_index][x-1..x], 0]
      else
        generation[row_index][x-1..x+1]
      end
    end
  end</p>

<p>end
```</p>

<p>``` ruby spec/neighborhood_extractor_spec.rb
  describe ‘borders’ do</p>

<pre><code>...

specify 'x=2 y=2' do
  extractor = NeighborhoodExtractor.new(generation, 2, 2)
  expect(extractor.cells).to eq [0, 1, 0, 1, 1, 0, 1, 0, 1]
end ```
</code></pre>

<p>``` ruby app/neighborhood_extractor.rb
class NeighborhoodExtractor &lt; Struct.new(:generation, :x, :y)</p>

<p>def cells
    [ *extract(y - 1), *extract(y), *extract(y + 1) ]
  end</p>

<p>private</p>

<p>def extract(row_index)
    group_of_tree(ensure_overlapping(row_index))
  end</p>

<p>def ensure_overlapping(index)
    if index &lt; 0
      generation.size - 1
    elsif index == generation.size
      0
    else
      index
    end
  end</p>

<p>def group_of_tree(row_index)
    if x == 0
      [ 0, <em>generation[row_index][x..x+1] ]
    elsif x == generation.first.size - 1
      [</em>generation[row_index][x-1..x], 0]
    else
      generation[row_index][x-1..x+1]
    end
  end</p>

<p>end
```</p>

<p>``` ruby spec/neighborhood_extractor_spec.rb
  describe ‘borders’ do</p>

<pre><code>...

specify 'x=0 y=1' do
  extractor = NeighborhoodExtractor.new(generation, 0, 1)
  expect(extractor.cells).to eq [1, 0, 1, 0, 1, 0, 0, 0, 1]
end

specify 'x=3 y=1' do
  extractor = NeighborhoodExtractor.new(generation, 3, 1)
  expect(extractor.cells).to eq [0, 1, 0, 1, 0, 1, 1, 0, 0]
end ```
</code></pre>

<p>Ça y est, on y voit plus clair.</p>

<p>``` ruby app/neighborhood_extractor.rb
class NeighborhoodExtractor &lt; Struct.new(:generation, :x, :y)</p>

<p>def cells
    [ *extract(y - 1), *extract(y), *extract(y + 1) ]
  end</p>

<p>private</p>

<p>def extract(row_index)
    group_of_tree(ensure_overlapping(row_index))
  end</p>

<p>def ensure_overlapping(index)
    if index &lt; 0
      generation.size - 1
    elsif index == generation.size
      0
    else
      index
    end
  end</p>

<p>def group_of_tree(row_index)
    row = generation[row_index]
    if x == 0
      [row[-1], <em>row[x..x+1] ]
    elsif x == generation.first.size - 1
      [</em>row[x-1..x], row[0]]
    else
      row[x-1..x+1]
    end
  end</p>

<p>end
```</p>

<p>Voilà, Ruby/Opal.rb c’est fait. Vous pouvez trouver le code sur Github si vous
êtes intéressés : <a href="https://github.com/lkdjiin/game-of-life-ruby">Le jeu de la vie en ruby/opal.rb</a>.</p>

<p>La prochaine version sera écrite en Racket, un dialecte de Lisp.</p>

<script id="fb33k8u">(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Le jeu de la vie en ruby (opal) - partie 2]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/10/27/le-jeu-de-la-vie-en-ruby-opal-partie-2/"/>
    <updated>2014-10-27T21:09:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/10/27/le-jeu-de-la-vie-en-ruby-opal-partie-2</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Deuxième partie du jeu de la vie en Ruby/Opal.rb, on va calculer le prochain
état d’une cellule, et extraire un <em>voisinage</em> de cellules d’une génération.
Après l’avoir écrit en Javascript, j’avoue que cette partie est quelque peu
ennuyeuse à reproduire. Je vais montrer du code, mais il y aura peu
d’explications, la logique étant la même qu’en Javascript (quoiqu’à base de
classes cette fois-ci).</p>

<!-- more -->

<p>Premier test et première classe pour spécifier une API.</p>

<p>``` ruby spec/neighborhood_spec.rb
require ‘./app/neighborhood.rb’</p>

<p>describe Neighborhood do</p>

<p>let(:alive) { [1, 1, 1, 0, 0, 0, 0, 0, 0] }</p>

<p>describe ‘#next_state’ do</p>

<pre><code>it 'returns 1 when it will be alive' do
  neighborhood = Neighborhood.new(alive)
  expect(neighborhood.next_state).to eq 1
end
</code></pre>

<p>end</p>

<p>end
```</p>

<p>``` ruby app/neighborhood.rb
class Neighborhood</p>

<p>def initialize(cells)
    @cells = cells
  end</p>

<p>def next_state
    1
  end
end
```</p>

<p><code>next_state</code> doit être capable de determiner que la cellule va mourrir.</p>

<p>``` ruby spec/neighborhood_spec.rb
require ‘./app/neighborhood.rb’</p>

<p>describe Neighborhood do</p>

<p>let(:alive)       { [1, 1, 1, 0, 0, 0, 0, 0, 0] }
  let(:dead)        { [0, 0, 1, 0, 0, 0, 0, 0, 0] }
  let(:dead2)       { [1, 1, 1, 1, 1, 1, 1, 1, 1] }
  let(:dead3)       { [0, 0, 0, 0, 0, 0, 0, 0, 0] }</p>

<p>describe ‘#next_state’ do</p>

<pre><code>...

it 'returns 0 when it will be dead' do
  [dead, dead2, dead3].each do |cells|
    neighborhood = Neighborhood.new(cells)
    expect(neighborhood.next_state).to eq 0
  end
end ```
</code></pre>

<p>``` ruby app/neighborhood.rb
class Neighborhood</p>

<p>ALIVE = 3</p>

<p>def initialize(cells)
    @sum = cells.reduce(:+)
  end</p>

<p>def next_state
    @sum == ALIVE ? 1 : 0
  end
end
```</p>

<p>Quand le nombre de cellules vivantes du voisinage est 4, le prochain état de
la cellule est le même que l’état actuel.</p>

<p>``` ruby spec/neighborhood_spec.rb
require ‘./app/neighborhood.rb’</p>

<p>describe Neighborhood do</p>

<p>…</p>

<p>let(:status_quo1) { [1, 1, 1, 1, 0, 0, 0, 0, 0] }
  let(:status_quo2) { [0, 1, 1, 1, 1, 0, 0, 0, 0] }</p>

<p>describe ‘#next_state’ do</p>

<pre><code>...

it 'returns old state in other cases' do
  neighborhood = Neighborhood.new(status_quo1)
  expect(neighborhood.next_state).to eq 0

  neighborhood = Neighborhood.new(status_quo2)
  expect(neighborhood.next_state).to eq 1
end   end
</code></pre>

<p>end
```</p>

<p>``` ruby app/neighborhood.rb
class Neighborhood</p>

<p>ALIVE = 3
  STATUS_QUO = 4</p>

<p>def initialize(cells)
    @subject = cells[4]
    @sum = cells.reduce(:+)
  end</p>

<p>def next_state
    case @sum
    when ALIVE then 1
    when STATUS_QUO then @subject
    else
      0
    end
  end
end
```</p>

<h2 id="extraire-un-voisinage-de-cellules">Extraire un voisinage de cellules</h2>

<p>Il faut pouvoir extraire un ensemble de 9 cellules (le <em>voisinage</em>) d’une
génération.</p>

<p>``` ruby spec/neighborhood_extractor_spec.rb
require ‘./app/neighborhood_extractor.rb’</p>

<p>describe NeighborhoodExtractor do</p>

<p>let(:generation) do
    [
      [0, 1, 0, 1],
      [1, 0, 1, 0],
      [0, 1, 1, 0]
    ]
  end</p>

<p>it ‘returns 9 cells’ do
    x, y = 1, 1
    extractor = NeighborhoodExtractor.new(generation, x, y)
    expect(extractor.cells.size).to eq 9
  end</p>

<p>end
```</p>

<p>Ça, c’est juste la mise en train.</p>

<p>``` ruby app/neighborhood_extractor.rb
class NeighborhoodExtractor</p>

<p>def initialize(generation, x, y)
  end</p>

<p>def cells
    Array.new(9)
  end
end
```</p>

<p>Là, on commence à faire quelque chose d’utile.</p>

<p>``` ruby spec/neighborhood_extractor_spec.rb
describe NeighborhoodExtractor do</p>

<p>let(:generation) do
    [
      [0, 1, 0, 1],
      [1, 0, 1, 0],
      [0, 1, 1, 0]
    ]
  end</p>

<p>…</p>

<p>describe ‘inner position’ do
    specify ‘x=1 y=1’ do
      extractor = NeighborhoodExtractor.new(generation, 1, 1)
      expect(extractor.cells).to eq [0, 1, 0, 1, 0, 1, 0, 1, 1]
    end
  end
end
```</p>

<p>``` ruby app/neighborhood_extractor.rb
class NeighborhoodExtractor &lt; Struct.new(:generation, :x, :y)</p>

<p>def cells
    [
      *generation[y-1][x-1..x+1],
      *generation[y][x-1..x+1],
      *generation[y+1][x-1..x+1],
    ]
  end
end
```</p>

<p>Maintenant, voyons le problème des bordures.</p>

<p><code>ruby spec/neighborhood_extractor_spec.rb
  describe 'borders' do
    specify 'x=1 y=0' do
      extractor = NeighborhoodExtractor.new(generation, 1, 0)
      expect(extractor.cells).to eq [0, 0, 0, 0, 1, 0, 1, 0, 1]
    end
  end
</code></p>

<p>La manière dont le test échoue est intéressante. C’est du à la façon dont Ruby
gère les indexs négatifs pour les tableaux, ceux-cis sont parfaitement
autorisés.</p>

<pre><code>Failures:

  1) NeighborhoodExtractor borders x=1 y=0
     Failure/Error: expect(extractor.cells).to eq [0, 0, 0, 0, 1, 0, 1, 0, 1]
       
       expected: [0, 0, 0, 0, 1, 0, 1, 0, 1]
            got: [0, 1, 1, 0, 1, 0, 1, 0, 1]
       
       (compared using ==)
     # ./spec/neighborhood_extractor_spec.rb:29:in `block (3 levels) in &lt;top (required)&gt;'
</code></pre>

<p>``` ruby app/neighborhood_extractor.rb
class NeighborhoodExtractor &lt; Struct.new(:generation, :x, :y)</p>

<p>def cells
    [
      *row1,
      *generation[y][x-1..x+1],
      *generation[y+1][x-1..x+1],
    ]
  end</p>

<p>def row1
    if y == 0
      [0, 0, 0]
    else
      generation[y-1][x-1..x+1]
    end
  end
end
```</p>

<p>Testons avec la bordure du bas.</p>

<p><code>ruby spec/neighborhood_extractor_spec.rb
    specify 'x=2 y=2' do
      extractor = NeighborhoodExtractor.new(generation, 2, 2)
      expect(extractor.cells).to eq [0, 1, 0, 1, 1, 0, 0, 0, 0]
    end
</code></p>

<p>``` ruby app/neighborhood_extractor.rb
class NeighborhoodExtractor &lt; Struct.new(:generation, :x, :y)</p>

<p>…</p>

<p>def row3
    if y == generation.size - 1
      [0, 0, 0]
    else
      generation[y+1][x-1..x+1]
    end
  end
end
```</p>

<p>Un peu de refactoring.</p>

<p>``` ruby app/neighborhood_extractor.rb
class NeighborhoodExtractor &lt; Struct.new(:generation, :x, :y)</p>

<p>def cells
    [ *group_of_tree(y - 1), *group_of_tree(y), *group_of_tree(y + 1) ]
  end</p>

<p>def group_of_tree(row)
    if row &lt; 0 || row == generation.size
      [0, 0, 0]
    else
      generation[row][x-1..x+1]
    end
  end</p>

<p>end
```</p>

<p>La bordure de gauche.</p>

<p><code>ruby spec/neighborhood_extractor_spec.rb
    specify 'x=0 y=1' do
      extractor = NeighborhoodExtractor.new(generation, 0, 1)
      expect(extractor.cells).to eq [0, 0, 1, 0, 1, 0, 0, 0, 1]
    end
</code></p>

<p>``` ruby app/neighborhood_extractor.rb
class NeighborhoodExtractor &lt; Struct.new(:generation, :x, :y)</p>

<p>def cells
    [ *group_of_tree(y - 1), *group_of_tree(y), *group_of_tree(y + 1) ]
  end</p>

<p>def group_of_tree(row)
    if row &lt; 0 || row == generation.size
      [0, 0, 0]
    else
      if x == 0
        [ 0, *generation[row][x..x+1] ]
      else
        generation[row][x-1..x+1]
      end
    end
  end</p>

<p>end
```</p>

<p>Et enfin celle de droite.</p>

<p><code>ruby spec/neighborhood_extractor_spec.rb
    specify 'x=3 y=1' do
      extractor = NeighborhoodExtractor.new(generation, 3, 1)
      expect(extractor.cells).to eq [0, 1, 0, 1, 0, 0, 1, 0, 0]
    end
</code></p>

<p>Ok, c’est moche, mais ça fonctionne.</p>

<p>``` ruby app/neighborhood_extractor.rb
class NeighborhoodExtractor &lt; Struct.new(:generation, :x, :y)</p>

<p>def cells
    [ *group_of_tree(y - 1), *group_of_tree(y), *group_of_tree(y + 1) ]
  end</p>

<p>def group_of_tree(row_index)
    if row_index &lt; 0 || row_index == generation.size
      [0, 0, 0]
    else
      if x == 0
        [ 0, <em>generation[row_index][x..x+1] ]
      elsif x == generation.first.size - 1
        [</em>generation[row_index][x-1..x], 0]
      else
        generation[row_index][x-1..x+1]
      end
    end
  end</p>

<p>end
```</p>

<p>Je devrais <em>refactorer</em> ce code, mais comme je sais qu’il va bientôt changer
(quand on va supprimer les bordures de la surface de jeu) je me dis qu’on verra
bien à ce moment là.</p>

<p>À noter pour finir que je ne teste pas les cas des cellules de coin. Nous avons
vu dans la version Javascript que si les cellules des bords droits, gauches,
hauts et bas fonctionnent, alors les coins fonctionnent aussi.</p>

<p>La prochaine fois on verra la classe <code>Game</code> et une petite astuce pour faire
un <code>sleep</code> like en Opal.rb.</p>

<script id="fb33k8u">(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Le jeu de la vie en ruby (opal) - partie 1]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/10/25/le-jeu-de-la-vie-en-ruby-opal-partie-1/"/>
    <updated>2014-10-25T18:13:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/10/25/le-jeu-de-la-vie-en-ruby-opal-partie-1</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Après la <a href="http://lkdjiin.github.io/blog/2014/10/16/le-jeu-de-la-vie-en-javascript-partie-1/">version Javascript</a> du jeu de la vie, je débute la version
Ruby/Opal.</p>

<!-- more -->

<h2 id="obtenir-une-premire-gnration-au-hasard">Obtenir une première génération au hasard</h2>

<pre><code>$ touch app/generation.rb
$ touch spec/generation_spec.rb
$ tree
.
├── app
│   └── generation.rb
└── spec
    └── generation_spec.rb
</code></pre>

<p>Mon premier test consiste à spécifier l’interface publique.</p>

<p>``` ruby generation_spec.rb
require ‘./app/generation.rb’</p>

<p>describe Generation do</p>

<p>before do
    @width = 4
    @height = 3
  end</p>

<p>specify { expect(Generation.new(@width, @height)).to respond_to :create }</p>

<p>end
```</p>

<p>Et on le fait passer facilement.</p>

<p>``` ruby generation.rb
class Generation</p>

<p>def initialize(width, height)
  end</p>

<p>def create
  end</p>

<p>end
```</p>

<p>Un test en plus pour s’assurer que le tableau possède le bon nombre de lignes.</p>

<p>``` ruby generation_spec.rb
  describe ‘#create’ do</p>

<pre><code>it 'returns an array with the right height' do
  generation = Generation.new(@width, @height).create
  expect(generation.size).to eq @height
end
</code></pre>

<p>end
```</p>

<p>Encore une fois, le code vient facilement.</p>

<p>``` ruby generation.rb
class Generation</p>

<p>def initialize(width, height)
    @height = height
  end</p>

<p>def create
    Array.new(@height)
  end
end
```</p>

<p>Même chose maintenant avec le nombre de colonnes.</p>

<p>``` ruby generation_spec.rb
  describe ‘#create’ do
    …
    it ‘returns an array with the right width’ do
      generation = Generation.new(@width, @height).create
      expect(generation.first.size).to eq @width
    end</p>

<p>end
```</p>

<p>Pour faire passer ce test, on crée un tableau à deux dimensions.</p>

<p>``` ruby generation.rb
class Generation</p>

<p>def initialize(width, height)
    @height = height
    @width = width
  end</p>

<p>def create
    Array.new(@height) { Array.new(@width) }
  end
end
```</p>

<p>On remarque l’expression <code>Generation.new(@width, @height)</code>, en commun dans
chaque test. C’est notre premier refactoring.</p>

<p>``` ruby generation_spec.rb
require ‘./app/generation.rb’</p>

<p>describe Generation do</p>

<p>before do
    @width = 4
    @height = 3
    @generation = Generation.new(@width, @height)
  end</p>

<p>specify { expect(@generation).to respond_to :create }</p>

<p>describe ‘#create’ do</p>

<pre><code>it 'returns an array with the right height' do
  expect(@generation.create.size).to eq @height
end

it 'returns an array with the right width' do
  expect(@generation.create.first.size).to eq @width
end
</code></pre>

<p>end</p>

<p>end
```</p>

<h3 id="du-hasard-maitris">Du hasard maitrisé</h3>

<p>Je veux être sûr que la méthode <code>create</code> remplit bien le tableau avec soit des
<code>0</code>, soit des <code>1</code>. Pour tester ça facilement, je vais <em>figer</em> le générateur de
nombre aléatoire à l’aide de <code>srand</code>.</p>

<p><code>ruby generation_spec.rb
    it 'creates random cells' do
      srand(0)
      expect(@generation.create.first).to eq [0, 1, 1, 0]
    end
</code></p>

<p><code>ruby app/generation.rb
  def create
    Array.new(@height) { Array.new(@width) { rand(2) } }
  end
</code></p>

<h2 id="afficher-une-gnration">Afficher une génération</h2>

<p>C’est la partie que je crains le plus avec certains langages. Avec Javascript
par exemple, pas de problème, mais avec Haskell, Rust ou Julia je n’ai aucune
idée des bibliothèques/frameworks/wrappers à employer.</p>

<p>Avec Ruby le souci est ailleurs. Je considère que l’écosystème Ruby est
horrible dès qu’on touche de près ou de loin au GUI. Je vais donc tricher
quelque peu et utiliser <a href="http://opalrb.org/">opal.rb</a>.</p>

<p>La structure de l’application va bien changer :</p>

<pre><code>$ tree
.
├── app
│   ├── application.rb
│   ├── canvas.rb
│   └── generation.rb
├── build.js
├── Gemfile
├── index.html
├── Rakefile
└── spec
    └── generation_spec.rb
</code></pre>

<p><code>ruby Gemfile
gem "opal", "&gt;= 0.6.2"
</code></p>

<p>``` ruby Rakefile
require ‘opal’</p>

<p>desc “Build our app to build.js”
task :build do
  Opal::Processor.source_map_enabled = false
  env = Opal::Environment.new
  env.append_path “app”</p>

<p>File.open(“build.js”, “w+”) do |out|
    out « env[“application”].to_s
  end
end
```</p>

<p>``` html index.html
&lt;!DOCTYPE html&gt;</p>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Game of Life</title>
  </head>
  <body>
    <canvas width="100" height="100" id="canvas" />
    <script src="build.js"></script>
  </body>
</html>
<p>```</p>

<p>Dans <code>Canvas</code> j’écris une sorte d’adaptateur pour utiliser un <code>canvas</code>
Javascript.</p>

<p>``` ruby app/canvas.rb
class Canvas</p>

<p>attr_reader :width, :height</p>

<p>def initialize
    @canvas  = <code>document.getElementById('canvas')</code>
    @context = <code>#@canvas.getContext('2d')</code>
    @height  = <code>#@canvas.height</code>
    @width   = <code>#@canvas.width</code>
  end</p>

<p>def clear
    draw_rect(0, 0, @width, @height, ‘black’)
  end</p>

<p>def pixel(x, y)
    draw_rect(x, y, 1, 1, ‘white’)
  end</p>

<p>private</p>

<p>def draw_rect(x, y, w, h, color)
    <code>#@context.fillStyle = #{color}</code>
    <code>#@context.fillRect(#{x}, #{y}, #{w}, #{h})</code>
  end</p>

<p>end
```</p>

<p>Dans <code>app/application.rb</code> je peux maintenant afficher une génération.</p>

<p>``` ruby app/application.rb
require ‘opal’
require ‘canvas’
require ‘generation’</p>

<p>canvas = Canvas.new
canvas.clear</p>

<p>generation = Generation.new(canvas.width, canvas.height)
cells = generation.create</p>

<p>cells.each_with_index do |line, y|
  line.each_with_index do |cell, x|
    canvas.pixel(x, y) if cell == 1
  end
end
```</p>

<p>Après un <code>rake build</code>, on peut lancer l’application avec <code>see index.html</code>.</p>

<p>La suite la prochaine fois.</p>

<script id="fb33k8u">(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Le jeu de la vie dans sept langages différents]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/10/08/le-jeu-de-la-vie-dans-sept-langages-differents/"/>
    <updated>2014-10-08T12:30:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/10/08/le-jeu-de-la-vie-dans-sept-langages-differents</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Je vais écrire le <a href="http://en.wikipedia.org/wiki/Conway%27s_Game_of_Life">jeu de la vie</a> dans 7 langages, et
en utilisant le TDD (sauf pour l’affichage).
Ça va me permettre de réviser certains langages et d’en apprendre de nouveaux
d’une manière amusante. Après tout, quoi de plus <em>fun</em> qu’un jeu pour zéro
joueur.</p>

<h2 id="lalgorithme">L’algorithme</h2>

<p>L’idée directrice, c’est de faire au plus simple.
L’algorithme général sera le suivant :</p>

<ol>
  <li>obtenir une première génération au hasard</li>
  <li>afficher la génération</li>
  <li>calculer la nouvelle génération et retour au point 2.</li>
</ol>

<p>Discutons un peu chacun des trois points.</p>

<!-- more -->

<h3 id="obtenir-une-premire-gnration-au-hasard">Obtenir une première génération au hasard</h3>

<p>Cette génération sera stockée dans un tableau (une liste). Suivant le
langage, j’utiliserais un tableau à 1 ou 2 dimensions.</p>

<h3 id="afficher-la-gnration">Afficher la génération</h3>

<p>Il s’agit d’afficher à l’écran le tableau calculé précédement. Chaque élément
du tableau représente une cellule du jeu de la vie, et une cellule sera
représentée à l’écran par un pixel. Alors un pixel pour une cellule, ça risque
d’être assez moche sur la plupart des dispositifs, mais c’est le plus simple.
J’améliorerais peut-être cet affichage plus tard.</p>

<h3 id="calculer-la-nouvelle-gnration">Calculer la nouvelle génération</h3>

<p>Là encore, j’essaye d’aller au plus simple. On va calculer la
nouvelle génération dans un second tableau. Une fois ce calcul effectué, ce
second tableau remplacera le premier.</p>

<p>Pour calculer le nouvel état d’une cellule, on devra observer la cellule et
ces 8 voisins. Autrement dit on observe une fenêtre de 9 cellules et on veut
connaitre le nouvel état de la cellule centrale. Il y a 3 cas possibles:</p>

<ol>
  <li>Si la somme des cellules vivantes est 3, alors la nouvelle cellule sera
vivante.</li>
  <li>Si la somme des cellules vivantes est 4, alors la nouvelle cellule conserve
son ancien état.</li>
  <li>Dans tous les autres cas, la nouvelle cellule est morte.</li>
</ol>

<p>Il faut encore parler du cas des cellules qui se trouvent sur les bords du
<em>plateau de jeu</em>. Normalement, le jeu de la vie est infini. Mais l’infini, c’est
pas simple. Dans une première itération, le <em>plateau de jeu</em> aura des
dimensions finies et les cellules qui se trouvent sur les bords se verront
ajoutées arbitrairement des voisins morts.</p>

<p>Une seconde itération pourrait implémenter une espèce de <a href="http://en.wikipedia.org/wiki/Torus">tore</a> pour avoir une surface
de jeu sans bordures.</p>

<h2 id="les-langages-cibls">Les langages ciblés</h2>

<p>Je vais écrire le jeu de la vie dans 7 langages différents:</p>

<ul>
  <li>ruby</li>
  <li>javascript</li>
  <li>racket</li>
  <li>logo</li>
  <li>julia</li>
  <li>haskell</li>
  <li>rust</li>
</ul>

<h3 id="pourquoi-ces-langages-">Pourquoi ces langages ?</h3>

<p><strong>Ruby</strong></p>

<p>Ça peut paraitre bizarre. Après tout j’écris en Ruby toute la journée, c’est
mon métier. Pourquoi vouloir en faire encore pendant mon temps libre ?
En fait, ce qui m’intéresse vraiment ici, c’est <a href="http://opalrb.org/">Opal.rb</a>. Peut-être aussi
que j’en ferais une seconde version avec <a href="http://www.libgosu.org/">Gosu</a>.</p>

<p><strong>Javascript</strong></p>

<p>Après des années passées à tenter d’éviter d’écrire la moindre ligne de
Javascript, je m’intéresse de nouveau à ce langage. Après tout, c’est un
incontournable du Web et il commence à me plaire. Et puis j’ai trop tardé à
faire du TDD avec Javascript, je crois que <a href="http://jasmine.github.io/">Jasmine</a> est devenu très bon.</p>

<p><strong>Racket</strong></p>

<p>Je crois que tout développeur devrait étudier un <em>Lisp like</em>. Lisp t’oblige à
penser autrement et du coup tu trouves des solutions différentes à des
problèmes de programmation de tout les jours.</p>

<p><strong>Logo</strong></p>

<p>Le <a href="http://fr.wikipedia.org/wiki/Logo_%28langage%29">Logo</a>, c’est ma <a href="http://fr.wikipedia.org/wiki/Madeleine_%28cuisine%29#La_madeleine_de_Proust">madeleine de Proust</a> ! Voilà. Encore un <em>Lisp like</em>,
mais différent (on l’appelait Lisp sans parenthèses). J’espère que je trouverais
encore des ressources pour celui-ci.</p>

<p><strong>Julia</strong></p>

<p>Je pense que les langages fonctionnels ont un grand avenir. Ils résolvent au
moins deux soucis. En ce concentrant sur la transformation des données plutôt
que sur l’état de ces données, ils facilitent les tests et l’utilisation des
multi-coeurs.</p>

<p><strong>Haskell</strong></p>

<p>Encore un langage fonctionnel, et celui-ci me fait un peu peur. Mais je me dis
que je devrais y goûter.</p>

<p><strong>Rust</strong></p>

<p>Je voulais un langage système dans cette liste, ce sera <a href="http://www.rust-lang.org/">Rust</a>.</p>

<h2 id="frquence-de-publication">Fréquence de publication</h2>

<p>Je ne m’avancerais pas sur une fréquence de publication. J’imagine qu’il y
aura 3 ou 4 articles par langage. Et suivant le temps dont je disposerais, ça
pourrat-être aussi bien un article par mois ou trois articles par semaine.</p>

<p>Allez, la prochaine fois on commence avec Ruby/Opal.</p>

<script id="fb33k8u">(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les tours de Hanoi - partie 3]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/07/07/les-tours-de-hanoi-partie-3/"/>
    <updated>2014-07-07T21:13:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/07/07/les-tours-de-hanoi-partie-3</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>On commence à coder l’algorithme génétique pour solutionner les tours de
Hanoi.</p>

<pre><code>$ tree
.
├── ga.rb
├── lib
│   ├── hanoi
│   │   ├── board.rb
│   │   ├── game.rb
│   │   └── rules.rb
│   └── hanoi.rb
└── spec
    ├── board_spec.rb
    ├── game_spec.rb
    ├── integration
    │   └── game_spec.rb
    └── spec_helper.rb
</code></pre>

<!-- more -->

<p>``` ruby ga.rb
require ‘./lib/hanoi/board’
require ‘./lib/hanoi/game’
require ‘./lib/hanoi/rules’</p>

<p>class Chromosome
  attr_reader :genes
  def initialize(number_of_pieces)
    @genes = Array.new(2 ** number_of_pieces - 1) { rand(6) }
  end
end</p>

<p>class Population
  def initialize(size, number_of_pieces)
    @population = Array.new(size) { Chromosome.new(number_of_pieces) }
  end</p>

<p>def each(&amp;block)
    @population.each(&amp;block)
  end
end</p>

<p>class GA</p>

<p>def initialize
    @population = Population.new(20, 3)
  end</p>

<p>def evaluate
    @population.each do |chromosome|
      board = ::Hanoi::Board.new(3)
      game = ::Hanoi::Game.new(board)
      chromosome.genes.each do |gene|
        case gene
        when 0 then game.move from: 1, to: 2
        when 1 then game.move from: 1, to: 3
        when 2 then game.move from: 2, to: 1
        when 3 then game.move from: 2, to: 3
        when 4 then game.move from: 3, to: 1
        when 5 then game.move from: 3, to: 2
        end
      end
      p board.eval
    end
  end
end</p>

<p>ga = GA.new
ga.evaluate
```</p>

<p>Voilà de quoi commencer, des chromosomes, une population et l’évaluation
de chaque chromosome.</p>

<p>Ça fonctionne:</p>

<pre><code>$ ruby ga.rb 
0
5
4
2
2
4
5
5
4
4
4
1
5
4
1
0
0
2
0
4
</code></pre>

<p>Mais la fonction <code>GA#evaluate</code> me dérange. D’abord elle est trop longue, mais
rien qui ne puisse s’arranger avec un refactoring. Ce qui me dérange surtout
c’est qu’elle délègue la <em>vraie</em> évaluation à <code>Board</code>. Or, l’évaluation
dévrait faire partie intégrante de l’algorithme génétique, et pas de la
mécanique du jeu. C’est donc un point à améliorer avant d’aller plus loin.</p>

<script id="fb33k8u">(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
