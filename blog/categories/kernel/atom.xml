<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : kernel | Xavier Nayrac]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/kernel/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2016-02-13T16:37:27+01:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ruby: Les méthodes du module Kernel 3]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/09/29/ruby-les-methodes-du-module-kernel-3/"/>
    <updated>2013-09-29T12:51:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/09/29/ruby-les-methodes-du-module-kernel-3</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Aujourd’hui c’est dimanche, l’article sera court, on voit deux méthodes
utiles pour le débugage ou pour les fichiers
de log: <code>__method__</code> et <code>__dir__</code>.</p>

<!-- more -->

<h2 id="method"><code>__method__</code></h2>

<p><code>__method__</code> renvoit le nom de la méthode courante comme un type Symbol:</p>

<p><code>irb
&gt;&gt; def foo
&gt;&gt; __method__
&gt;&gt; end
nil
&gt;&gt; foo
:foo
</code></p>

<p>Et si vous avez besoin de récupérer une chaîne de caractère:</p>

<p><code>irb
&gt;&gt; def bar
&gt;&gt; __method__.to_s
&gt;&gt; end
nil
&gt;&gt; bar
"bar"
</code></p>

<h2 id="dir"><code>__dir__</code></h2>

<p>Comme son nom l’indique presque, cette méthode renvoit le nom (complet)
du répértoire du fichier dans lequel la méthode est appelée:</p>

<p>``` ruby ~/test/dir.rb
def this_dir
  <strong>dir</strong>
end</p>

<p>puts this_dir
```</p>

<pre><code>[~/test]⇒ rvm use 2.0.0
Using /home/xavier/.rvm/gems/ruby-2.0.0-p247
[~/test]⇒ ruby dir.rb 
/home/xavier/test
</code></pre>

<script id="fb33k8u">(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>

<p>À demain.</p>

<p></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby: Les méthodes du module Kernel 2]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/09/28/ruby-les-methodes-du-module-kernel-2/"/>
    <updated>2013-09-28T13:59:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/09/28/ruby-les-methodes-du-module-kernel-2</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>On continue l’exploration du module Kernel avec quatre
autres méthodes de conversions, pour les nombres:</p>

<ul>
  <li>Complex</li>
  <li>Float</li>
  <li>Integer</li>
  <li>Rational</li>
</ul>

<!-- more -->

<p>Voyons d’abord <code>Integer</code>. On peut lui passer une chaîne de caractère:</p>

<p><code>irb
&gt;&gt; Integer("123")
123
</code></p>

<p>Ça fonctionne avec les préfixes. En octal, hexadécimal et binaire:</p>

<p><code>irb
&gt;&gt; Integer("0123")
83
&gt;&gt; Integer("0x123")
291
&gt;&gt; Integer("0b111")
7
</code></p>

<p>On peut aussi spécifier la base:</p>

<p><code>irb
&gt;&gt; Integer("0123", 10)
123
</code></p>

<p>On peut aussi passer en argument un objet répondant à <code>to_int</code> ou <code>to_i</code>:</p>

<p><code>irb
&gt;&gt; class Foo
&gt;&gt;   def to_i
&gt;&gt;     123
&gt;&gt;   end
&gt;&gt; end
nil
&gt;&gt; Integer(Foo.new)
123
</code></p>

<p>Passons maintenant à <code>Float(arg)</code> qui convertit un argument en type <code>Float</code>.
Soit l’argument est de type <code>Numeric</code>:</p>

<p><code>irb
&gt;&gt; Float(123)
123.0
&gt;&gt; Float(Rational("1/2"))
0.5
</code></p>

<p>Soit la méthode fait appel à <code>to_f</code>:</p>

<p><code>irb
&gt;&gt; class Foo
&gt;&gt;   def to_f
&gt;&gt;     1.23
&gt;&gt;   end
&gt;&gt; end
nil
&gt;&gt; Float(Foo.new)
1.23
</code></p>

<p>Au tour de la méthode <code>Rational</code> qui convertit son (ses) argument(s) en un
nombre rationnel (de classe <code>Rational</code>), autrement dit une fraction:</p>

<p><code>irb
&gt;&gt; Rational("1/3")
1/3
&gt;&gt; Rational(1, 3)
1/3
&gt;&gt; x = Rational("1/3")
1/3
&gt;&gt; x + x
2/3
</code></p>

<p>Reste la méthode <code>Complex</code>, qui convertit son (ses) argument(s) en un nombre
complexe. Je la signale pour être exhaustif, mais les nombres complexes
dépassent largement mes compétences en mathématique.</p>

<script id="fb33k8u">(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>

<p>À demain.</p>

<p></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby: Les méthodes du module Kernel]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/09/21/ruby-les-methodes-du-module-kernel/"/>
    <updated>2013-09-21T13:53:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/09/21/ruby-les-methodes-du-module-kernel</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Les méthodes définies dans le module Kernel de Ruby sont <em>à priori</em> des
méthodes très importantes. En effet le module Kernel est inclus d’office
dans la classe Object, et donc, ses méthodes sont toujours disponibles.
Elles s’utilisent directement sous la forme <code>method_name</code> et non pas
<code>object_name.method_name</code>. C’est cette différence de traitement qui
me donne à penser qu’elles sont importantes. Dans cette série d’articles,
je me propose de passer en revue chacune des méthodes du module Kernel
de Ruby version 2.0.</p>

<!-- more -->

<p>Aujourd’hui on voit les méthodes suivantes:</p>

<ul>
  <li>Array(<em>arg</em>)</li>
  <li>Hash(<em>arg</em>)</li>
  <li>String(<em>arg</em>)</li>
</ul>

<p>Ce sont toutes les trois des méthodes de conversions. Elles transforment
respectivement l’argument en un type Array, Hash ou String. Pour effectuer
cette conversion elles utilisent la méthode <code>to_*</code> sur l’argument. Par
exemple <code>String(self)</code> utilise <code>self.to_s</code>:</p>

<p><code>irb
[~]⇒ irb
&gt;&gt; String(self)
"main"
&gt;&gt; self.to_s
"main
</code></p>

<p>La particularité de ces méthodes est que leur nom débutent par une majuscule,
ce qui va à l’encontre des conventions en Ruby et les fait ressembler un
peu comme à un constructeur en Java et consorts. D’un autre coté, le langage
n’empêche pas de nommer les méthodes ainsi:</p>

<p><code>irb
&gt;&gt; def Foo(arg)
&gt;&gt;   puts arg
&gt;&gt; end
nil
&gt;&gt; Foo("hello")
hello
nil
</code></p>

<p>J’imagine que si ces méthodes débutent par une majuscule, c’est pour
permettre aux développeurs d’utiliser <code>array</code>, <code>hash</code> et <code>string</code> comme
nom de variable. Par contre je n’arrive pas à trouver une utilité à
ces méthodes… Je veux dire pourquoi utiliser <code>String(arg)</code> plutôt que
<code>arg.to_s</code> ?</p>

<p>Si toi, Lecteur, tu as une réponse, n’hésite pas à laisser un commentaire ;-)</p>

<script id="fb33k8u">(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>

<p>À demain.</p>

<p></p>

]]></content>
  </entry>
  
</feed>
