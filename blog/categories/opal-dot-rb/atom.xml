<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : opal.rb | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/opal-dot-rb/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2014-06-25T21:10:04+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Un space invaders avec Opal.rb - partie 14]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/06/23/un-space-invaders-avec-opal-dot-rb-partie-14/"/>
    <updated>2014-06-23T21:19:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/06/23/un-space-invaders-avec-opal-dot-rb-partie-14</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Lorsque le joueur faisait feu, le tir prenait naissance dans le coin
supérieur gauche du joueur. On le voudrait plutôt au milieu.</p>

<!-- more -->


<p>Voici donc la nouvelle classe <code>Fire</code>:</p>

<p>``` ruby app/fire.rb
class Fire
  SIDE = 4
  DELTA = 5</p>

<p>  attr_reader :x, :y</p>

<p>  def initialize(player)</p>

<pre><code>@x = player.x + player.w / 2
@y = player.y - SIDE
</code></pre>

<p>  end</p>

<p>  def w; SIDE; end</p>

<p>  def h; SIDE; end</p>

<p>  def color; &ldquo;white&rdquo;; end</p>

<p>  def update_position</p>

<pre><code>@y -= DELTA
</code></pre>

<p>  end
end
```</p>

<p>Dans <code>initialize</code>, on calcule la position d'origine du tir par rapport
au joueur, passé en argument.</p>

<p>Il faut donc changer aussi la méthode <code>fire</code> de la classe <code>Game</code>:</p>

<p>``` ruby
class Game</p>

<p>  &hellip;</p>

<p>  def fire</p>

<pre><code>@fires &lt;&lt; Fire.new(@player)
</code></pre>

<p>  end</p>

<p>  &hellip;
end
```</p>

<p>Voilà, ça c'est fait. N'oubliez pas que le code est maintenant disponible
sur <a href="https://github.com/lkdjiin/space-invaders-in-opal-rb">Github</a>.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Un space invaders in Opal.rb - partie 13]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/06/22/un-space-invaders-in-opal-dot-rb-partie-13/"/>
    <updated>2014-06-22T13:42:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/06/22/un-space-invaders-in-opal-dot-rb-partie-13</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Voici un extrait de la classe <code>SpaceCanvas</code> actuelle:</p>

<p>``` ruby app/space_canvas
class SpaceCanvas</p>

<p>  &hellip;</p>

<p>  def draw_player(player)</p>

<pre><code>draw_rect(player.x, player.y, player.w, player.h, player.color)
</code></pre>

<p>  end</p>

<p>  def draw_enemy(enemy)</p>

<pre><code>draw_rect(enemy.x, enemy.y, enemy.w, enemy.h, enemy.color)
</code></pre>

<p>  end</p>

<p>  def draw_fire(fire)</p>

<pre><code>draw_rect(fire.x, fire.y, fire.w, fire.h, fire.color)
</code></pre>

<p>  end</p>

<p>  &hellip;</p>

<p>end
```</p>

<p>Pas bien ! Le code est dupliqué, et si j'aime l'idée d'avoir trois méthodes
différentes, dont le nom est explicite, je ne veux pas avoir à réécrire
le même code chaque fois que j'ajouterais ce genre de méthode (<code>draw_ship</code>,
<code>draw_special_fire</code>, <code>draw_bomb</code>, etc).</p>

<!-- more -->


<p>La solution réside dans l'utilisation de <code>alias_method</code>:</p>

<p>``` ruby app/space_canvas
class SpaceCanvas</p>

<p>  &hellip;</p>

<p>  def draw_object(object)</p>

<pre><code>draw_rect(object.x, object.y, object.w, object.h, object.color)
</code></pre>

<p>  end
  alias_method :draw_player, :draw_object
  alias_method :draw_enemy, :draw_object
  alias_method :draw_fire, :draw_object</p>

<p>  &hellip;</p>

<p>end
```</p>

<p>Il n'y a plus de duplication, et l'ajout d'une nouvelle méthode se fait
simplement en ajoutant un nouvel alias.</p>

<p>Le code de cette série d'articles est désormais sur Github ici :
<a href="https://github.com/lkdjiin/space-invaders-in-opal-rb">space-invaders-in-opal-rb</a>,
et le jeu lui-même (du moins dans son état actuel, c'est à dire pas grand chose) est visible ici : <a href="http://lkdjiin.github.io/space-invaders-in-opal-rb/">http://lkdjiin.github.io/space-invaders-in-opal-rb/</a>.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Un space invaders avec Opal.rb - partie 12]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/06/21/un-space-invaders-avec-opal-dot-rb-partie-12/"/>
    <updated>2014-06-21T16:25:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/06/21/un-space-invaders-avec-opal-dot-rb-partie-12</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>On commence aujourd'hui à ajouter les tirs du joueur. Le code que je vous
propose est un brouillon, qu'il faudra améliorer successivement.</p>

<p>D'abord dans la classe <code>Game</code>, j'ajoute un champ <code>@fires</code>:</p>

<p>``` ruby
class Game</p>

<p>  def initialize</p>

<pre><code>@canvas = SpaceCanvas.new
@player = Player.new
@enemies = Enemies.new(@canvas.width)
@fires = []
</code></pre>

<p>  end
```</p>

<!-- more -->


<p>On déclenchera la méthode <code>fire</code> lors d'un appui sur la barre d'espace (32):</p>

<p>``` ruby
  def init_keyboard</p>

<pre><code>%x(
  window.addEventListener("keydown",
    function(e) {
      if(e.keyCode == 32) { #{fire} }
      if(e.keyCode == 37) { #{@player.move_left} }
      if(e.keyCode == 39) { #{@player.move_right} }
    },
    false);
)
</code></pre>

<p>  end
```</p>

<p>Voici la méthode <code>fire</code>, qui ajoute simplement un objet à la collection:</p>

<p>``` ruby
  def fire</p>

<pre><code>@fires &lt;&lt; Fire.new(@player.x, @player.y)
</code></pre>

<p>  end
```</p>

<p>Et maintenant une méthode qui met à jour les tirs du joueur:</p>

<p>``` ruby
  def update_fires</p>

<pre><code>@fires.each do |fire|
  fire.update_position
  @canvas.draw_fire(fire)
end
@fires.select! {|fire| fire.y &gt;= 0 }
</code></pre>

<p>  end
```</p>

<p>La dernière ligne de cette méthode supprime de la collection les tirs qui
ne sont plus visibles à l'écran.</p>

<p>Pour finir, voici la classe <code>Fire</code>:</p>

<p>``` ruby app/fire.rb
class Fire
  WIDTH = 4
  DELTA = 5</p>

<p>  attr_reader :x, :y</p>

<p>  def initialize(x, y)</p>

<pre><code>@x = x
@y = y
</code></pre>

<p>  end</p>

<p>  def w; WIDTH; end</p>

<p>  def h; WIDTH; end</p>

<p>  def color; &ldquo;white&rdquo;; end</p>

<p>  def update_position</p>

<pre><code>@y -= DELTA
</code></pre>

<p>  end
end
```</p>

<p>Tout ce code pose un certain nombre de problèmes sur lesquels je reviendrais
dans les prochains jours. Demain je pense que je mettrais le code sur Github.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Un space invaders avec Opal.rb - partie 11]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/06/20/un-space-invaders-avec-opal-dot-rb-partie-11/"/>
    <updated>2014-06-20T21:16:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/06/20/un-space-invaders-avec-opal-dot-rb-partie-11</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Je continue le refactoring de la méthode <code>update</code>:</p>

<p>``` ruby
  def update</p>

<pre><code>@enemies.each do |e|
  if e.x &lt;= 10 || e.x + e.w &gt;= 690
    change_enemies_direction
    enemies_down
    break
  end
end
@enemies.map {|enemy| enemy.move(@direction) }
</code></pre>

<p>  end
```</p>

<p>Je n'aime pas la condition multiple après le <code>if</code>. Je préfère:</p>

<!-- more -->


<p>``` ruby
  def update</p>

<pre><code>@enemies.each do |enemy|
  if side?(enemy)
    change_enemies_direction
    enemies_down
    break
  end
end
@enemies.map {|enemy| enemy.move(@direction) }
</code></pre>

<p>  end
```</p>

<p>C'est bien mieux. La définition de la méthode <code>side?</code> pourrait être:</p>

<p>``` ruby
  private</p>

<p>  def side?(enemy)</p>

<pre><code>enemy.x &lt;= 10 || enemy.x + enemy.w &gt;= 690
</code></pre>

<p>  end
```</p>

<p>Mais il reste des nombres magiques. En particulier le nombre 690, qui
signifie 10 pixel <em>avant</em> la largeur du canvas. J'ai donc besoin d'ajouter
ces notions à la classe <code>Enemies</code>:</p>

<p>``` ruby
class Enemies
  include Enumerable
  ENEMIES_PER_ROW = 10
  SIDE_MARGIN = 10</p>

<p>  def initialize(world_width)</p>

<pre><code>@world_width = world_width
.
.
.
</code></pre>

<p>```</p>

<p>La méthode <code>side?</code> devient donc:</p>

<p>``` ruby
  def side?(enemy)</p>

<pre><code>enemy.x &lt;= SIDE_MARGIN || enemy.x + enemy.w &gt;= @world_width - SIDE_MARGIN
</code></pre>

<p>  end
```</p>

<p>C'est pas encore le top, mais ça ira pour l'instant. On voir pouvoir
ajouter quelques nouvelles fonctionnalités.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Un space invaders avec Opal.rb - partie 10]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/06/19/un-space-invaders-avec-opal-dot-rb-partie-10/"/>
    <updated>2014-06-19T21:04:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/06/19/un-space-invaders-avec-opal-dot-rb-partie-10</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Le code suivant ne me convient toujours pas :</p>

<p>``` ruby</p>

<pre><code>@enemies.map do |enemy|
  @direction == :left ? enemy.move_left : enemy.move_right
end
</code></pre>

<p>```</p>

<p>Pourquoi ne pas dire
simplement à la classe <code>Enemy</code> ce qu'elle doit faire en une seule fois:</p>

<p>``` ruby</p>

<pre><code>@enemies.map {|enemy| enemy.move(@direction) }
</code></pre>

<p>```</p>

<!-- more -->


<p>C'est quand même bien plus simple ! Bien sûr, pour que ça fonctionne il
faut ajouter une méthode à la classe <code>Enemy</code>:</p>

<p>``` ruby
  def move(direction)</p>

<pre><code>direction == :left ? move_left : move_right
</code></pre>

<p>  end
```</p>

<p>Et tant qu'on y est, on fait pareil avec la méthode <code>enemies_down</code>.</p>

<p>Avant:</p>

<p>``` ruby
  def enemies_down</p>

<pre><code>@enemies.each do |e|
  e.y = e.y + 4
end
</code></pre>

<p>  end
```</p>

<p>Après:</p>

<p>``` ruby
  def enemies_down</p>

<pre><code>@enemies.map(&amp;:move_down)
</code></pre>

<p>  end
```</p>

<p>Et on ajoute ceci à <code>Enemy</code>:</p>

<p>``` ruby
  def move_down</p>

<pre><code>@y += 4
</code></pre>

<p>  end
```</p>

<p>Pour terminer cet article,
voici le code des classes <code>Enemy</code> et <code>Enemies</code>:</p>

<p>``` ruby app/enemy.rb
class Enemy
  DELTA = 2</p>

<p>  attr_accessor :x, :y, :w, :h, :color</p>

<p>  def initialize(x, y, w, h, color)</p>

<pre><code>@x = x
@y = y
@w = w
@h = h
@color = color
</code></pre>

<p>  end</p>

<p>  def move_left</p>

<pre><code>@x -= DELTA
</code></pre>

<p>  end</p>

<p>  def move_right</p>

<pre><code>@x += DELTA
</code></pre>

<p>  end</p>

<p>  def move(direction)</p>

<pre><code>direction == :left ? move_left : move_right
</code></pre>

<p>  end</p>

<p>  def move_down</p>

<pre><code>@y += 4
</code></pre>

<p>  end
end
```</p>

<p>``` ruby app/enemies.rb
class Enemies
  include Enumerable
  ENEMIES_PER_ROW = 10</p>

<p>  def initialize</p>

<pre><code>@enemies = []
@direction = :right
build(60, '#0000ff')
build(120, '#0000dd')
build(180, '#0000bb')
build(240, '#000099')
build(300, '#000077')
</code></pre>

<p>  end</p>

<p>  def each(&amp;block)</p>

<pre><code>@enemies.each(&amp;block)
</code></pre>

<p>  end</p>

<p>  def update</p>

<pre><code>@enemies.each do |e|
  if e.x &lt;= 10 || e.x + e.w &gt;= 690
    change_enemies_direction
    enemies_down
    break
  end
end
@enemies.map {|enemy| enemy.move(@direction) }
</code></pre>

<p>  end</p>

<p>  private</p>

<p>  def change_enemies_direction</p>

<pre><code>if @direction == :left
  @direction = :right
else
  @direction = :left
end
</code></pre>

<p>  end</p>

<p>  def enemies_down</p>

<pre><code>@enemies.map(&amp;:move_down)
</code></pre>

<p>  end</p>

<p>  def build(y, color)</p>

<pre><code>(1..ENEMIES_PER_ROW).each do |i|
  @enemies &lt;&lt; Enemy.new(50 + i * 60, y, 40, 40, color)
end
</code></pre>

<p>  end</p>

<p>end
```</p>

<p>Il reste encore un peu de travail…</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
