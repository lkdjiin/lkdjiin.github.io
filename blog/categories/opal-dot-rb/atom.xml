<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : opal.rb | lkdjiin]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/opal-dot-rb/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2015-01-23T14:24:46+01:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Un space invaders avec Opal.rb - partie 16]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/06/27/un-space-invaders-avec-opal-dot-rb-partie-16/"/>
    <updated>2014-06-27T21:23:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/06/27/un-space-invaders-avec-opal-dot-rb-partie-16</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Hier on a vu comment lancer une appli rack pour le développement. Seulement
je n'ai pas envie de choisir entre les deux méthodes. Je veux les deux !
Le serveur rack pour le développement, et le build classique du fichier
javascript pour la mise en production.</p>

<p>On va se bricoler deux tâches <code>rake</code> en quelques minutes pour obtenir ça.</p>

<!-- more -->


<p>Alors j'avertis tout de suite : le script n'est pas parfait. C'est malgré une
bonne base pour commencer.</p>

<p>Voici le nouveau <code>Rakefile</code>, dans lequel j'ai ajouté une tâche <code>development</code>
et une tâche <code>production</code>:</p>

<p>``` ruby Rakefile
require &lsquo;opal&rsquo;
require &lsquo;opal-jquery&rsquo;</p>

<p>desc &ldquo;Build our app to build.js&rdquo;
task :build do
  env = Opal::Environment.new
  env.append_path &ldquo;app&rdquo;</p>

<p>  File.open(&ldquo;build.js&rdquo;, &ldquo;w+&rdquo;) do |out|</p>

<pre><code>out &lt;&lt; env["application"].to_s
</code></pre>

<p>  end
end</p>

<p>desc &lsquo;Build app for production&rsquo;
task :production => :build do
  cp &lsquo;app/templates/index_production.html&rsquo;, &lsquo;index.html&rsquo;
end</p>

<p>desc &lsquo;Run development server&rsquo;
task :development do
  cp &lsquo;app/templates/index_development.html&rsquo;, &lsquo;index.html&rsquo;
  <code>bundle exec rackup</code>
end
```</p>

<p>Pour que le fichier <code>index.html</code> reflète le bon environnement, j'ai
ajouté un dossier <code>templates</code>, avec une version de chaque:</p>

<pre><code>$ tree app
app
├── application.rb
├── enemies.rb
├── enemy.rb
├── fire.rb
├── game.rb
├── player.rb
├── space_canvas.rb
└── templates
    ├── index_development.html
    └── index_production.html
</code></pre>

<p>Pour info, voici le contenu des templates:</p>

<p>``` html app/templates/index_development.html
&lt;!DOCTYPE html>
<html>
  <head></p>

<pre><code>&lt;meta charset="utf-8" /&gt;
&lt;script src="http://code.jquery.com/jquery-1.11.0.min.js"&gt;&lt;/script&gt;
</code></pre>

<p>  </head>
  <body></p>

<pre><code>&lt;canvas width="700" height="600" id="canvas"&gt;&lt;/canvas&gt;
&lt;script src="assets/application.js"&gt;&lt;/script&gt;
</code></pre>

<p>  </body>
</html>
```</p>

<p>``` html app/templates/index_production.html
&lt;!DOCTYPE html>
<html>
  <head></p>

<pre><code>&lt;meta charset="utf-8" /&gt;
&lt;script src="http://code.jquery.com/jquery-1.11.0.min.js"&gt;&lt;/script&gt;
</code></pre>

<p>  </head>
  <body></p>

<pre><code>&lt;canvas width="700" height="600" id="canvas"&gt;&lt;/canvas&gt;
&lt;script src="build.js"&gt;&lt;/script&gt;
</code></pre>

<p>  </body>
</html>
```</p>

<p>Alors oui, les templates sont redondants. Et si on doit modifier le contenu
de <code>index.html</code>, il faudra faire la modification sur les deux templates.
J'avais prévenu que ça n'était pas parfait ;) Par contre, pour cette appli
c'est bien suffisant.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Un space invaders avec Opal.rb - partie 15]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/06/26/un-space-invaders-avec-opal-dot-rb-partie-15/"/>
    <updated>2014-06-26T21:09:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/06/26/un-space-invaders-avec-opal-dot-rb-partie-15</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Vous en avez peut-être marre de tapez <code>rake build</code> à chaque petite
modification de votre code ? Moi, oui. En utilisant Sprockets, on peut
rendre le build automatique. Cool.</p>

<!-- more -->


<p>La marche à suivre est décrite dans la <a href="http://opalrb.org/docs/using_sprockets/">documentation d'Opal</a>.
Basiquement, on ajoute un fichier <code>config.ru</code> à la racine:</p>

<p>``` ruby config.ru
require &lsquo;bundler&rsquo;
Bundler.require</p>

<p>run Opal::Server.new { |s|
  s.append_path &lsquo;app&rsquo;
  s.main = &lsquo;application&rsquo;
  s.index_path = &lsquo;index.html&rsquo;
}
```</p>

<p>Et on change la localisation du script dans <code>index.html</code>:</p>

<p>``` html index.html
&lt;!DOCTYPE html>
<html>
  <head></p>

<pre><code>&lt;meta charset="utf-8" /&gt;
&lt;script src="http://code.jquery.com/jquery-1.11.0.min.js"&gt;&lt;/script&gt;
</code></pre>

<p>  </head>
  <body></p>

<pre><code>&lt;canvas width="700" height="600" id="canvas"&gt;&lt;/canvas&gt;
&lt;script src="assets/application.js"&gt;&lt;/script&gt;
</code></pre>

<p>  </body>
</html>
```</p>

<p>Après quoi on lance l'application rack:</p>

<pre><code>$ bundle exec rackup
</code></pre>

<p>Et votre appli est accessible à l'adresse <code>localhost:9292</code>.</p>

<p>Maintenant tout changement de code demande seulement un raffraichіssement
dans le navigateur.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Un space invaders avec Opal.rb - partie 14]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/06/23/un-space-invaders-avec-opal-dot-rb-partie-14/"/>
    <updated>2014-06-23T21:19:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/06/23/un-space-invaders-avec-opal-dot-rb-partie-14</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Lorsque le joueur faisait feu, le tir prenait naissance dans le coin
supérieur gauche du joueur. On le voudrait plutôt au milieu.</p>

<!-- more -->


<p>Voici donc la nouvelle classe <code>Fire</code>:</p>

<p>``` ruby app/fire.rb
class Fire
  SIDE = 4
  DELTA = 5</p>

<p>  attr_reader :x, :y</p>

<p>  def initialize(player)</p>

<pre><code>@x = player.x + player.w / 2
@y = player.y - SIDE
</code></pre>

<p>  end</p>

<p>  def w; SIDE; end</p>

<p>  def h; SIDE; end</p>

<p>  def color; &ldquo;white&rdquo;; end</p>

<p>  def update_position</p>

<pre><code>@y -= DELTA
</code></pre>

<p>  end
end
```</p>

<p>Dans <code>initialize</code>, on calcule la position d'origine du tir par rapport
au joueur, passé en argument.</p>

<p>Il faut donc changer aussi la méthode <code>fire</code> de la classe <code>Game</code>:</p>

<p>``` ruby
class Game</p>

<p>  &hellip;</p>

<p>  def fire</p>

<pre><code>@fires &lt;&lt; Fire.new(@player)
</code></pre>

<p>  end</p>

<p>  &hellip;
end
```</p>

<p>Voilà, ça c'est fait. N'oubliez pas que le code est maintenant disponible
sur <a href="https://github.com/lkdjiin/space-invaders-in-opal-rb">Github</a>.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Un space invaders in Opal.rb - partie 13]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/06/22/un-space-invaders-in-opal-dot-rb-partie-13/"/>
    <updated>2014-06-22T13:42:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/06/22/un-space-invaders-in-opal-dot-rb-partie-13</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Voici un extrait de la classe <code>SpaceCanvas</code> actuelle:</p>

<p>``` ruby app/space_canvas
class SpaceCanvas</p>

<p>  &hellip;</p>

<p>  def draw_player(player)</p>

<pre><code>draw_rect(player.x, player.y, player.w, player.h, player.color)
</code></pre>

<p>  end</p>

<p>  def draw_enemy(enemy)</p>

<pre><code>draw_rect(enemy.x, enemy.y, enemy.w, enemy.h, enemy.color)
</code></pre>

<p>  end</p>

<p>  def draw_fire(fire)</p>

<pre><code>draw_rect(fire.x, fire.y, fire.w, fire.h, fire.color)
</code></pre>

<p>  end</p>

<p>  &hellip;</p>

<p>end
```</p>

<p>Pas bien ! Le code est dupliqué, et si j'aime l'idée d'avoir trois méthodes
différentes, dont le nom est explicite, je ne veux pas avoir à réécrire
le même code chaque fois que j'ajouterais ce genre de méthode (<code>draw_ship</code>,
<code>draw_special_fire</code>, <code>draw_bomb</code>, etc).</p>

<!-- more -->


<p>La solution réside dans l'utilisation de <code>alias_method</code>:</p>

<p>``` ruby app/space_canvas
class SpaceCanvas</p>

<p>  &hellip;</p>

<p>  def draw_object(object)</p>

<pre><code>draw_rect(object.x, object.y, object.w, object.h, object.color)
</code></pre>

<p>  end
  alias_method :draw_player, :draw_object
  alias_method :draw_enemy, :draw_object
  alias_method :draw_fire, :draw_object</p>

<p>  &hellip;</p>

<p>end
```</p>

<p>Il n'y a plus de duplication, et l'ajout d'une nouvelle méthode se fait
simplement en ajoutant un nouvel alias.</p>

<p>Le code de cette série d'articles est désormais sur Github ici :
<a href="https://github.com/lkdjiin/space-invaders-in-opal-rb">space-invaders-in-opal-rb</a>,
et le jeu lui-même (du moins dans son état actuel, c'est à dire pas grand chose) est visible ici : <a href="http://lkdjiin.github.io/space-invaders-in-opal-rb/">http://lkdjiin.github.io/space-invaders-in-opal-rb/</a>.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Un space invaders avec Opal.rb - partie 12]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/06/21/un-space-invaders-avec-opal-dot-rb-partie-12/"/>
    <updated>2014-06-21T16:25:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/06/21/un-space-invaders-avec-opal-dot-rb-partie-12</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>On commence aujourd'hui à ajouter les tirs du joueur. Le code que je vous
propose est un brouillon, qu'il faudra améliorer successivement.</p>

<p>D'abord dans la classe <code>Game</code>, j'ajoute un champ <code>@fires</code>:</p>

<p>``` ruby
class Game</p>

<p>  def initialize</p>

<pre><code>@canvas = SpaceCanvas.new
@player = Player.new
@enemies = Enemies.new(@canvas.width)
@fires = []
</code></pre>

<p>  end
```</p>

<!-- more -->


<p>On déclenchera la méthode <code>fire</code> lors d'un appui sur la barre d'espace (32):</p>

<p>``` ruby
  def init_keyboard</p>

<pre><code>%x(
  window.addEventListener("keydown",
    function(e) {
      if(e.keyCode == 32) { #{fire} }
      if(e.keyCode == 37) { #{@player.move_left} }
      if(e.keyCode == 39) { #{@player.move_right} }
    },
    false);
)
</code></pre>

<p>  end
```</p>

<p>Voici la méthode <code>fire</code>, qui ajoute simplement un objet à la collection:</p>

<p>``` ruby
  def fire</p>

<pre><code>@fires &lt;&lt; Fire.new(@player.x, @player.y)
</code></pre>

<p>  end
```</p>

<p>Et maintenant une méthode qui met à jour les tirs du joueur:</p>

<p>``` ruby
  def update_fires</p>

<pre><code>@fires.each do |fire|
  fire.update_position
  @canvas.draw_fire(fire)
end
@fires.select! {|fire| fire.y &gt;= 0 }
</code></pre>

<p>  end
```</p>

<p>La dernière ligne de cette méthode supprime de la collection les tirs qui
ne sont plus visibles à l'écran.</p>

<p>Pour finir, voici la classe <code>Fire</code>:</p>

<p>``` ruby app/fire.rb
class Fire
  WIDTH = 4
  DELTA = 5</p>

<p>  attr_reader :x, :y</p>

<p>  def initialize(x, y)</p>

<pre><code>@x = x
@y = y
</code></pre>

<p>  end</p>

<p>  def w; WIDTH; end</p>

<p>  def h; WIDTH; end</p>

<p>  def color; &ldquo;white&rdquo;; end</p>

<p>  def update_position</p>

<pre><code>@y -= DELTA
</code></pre>

<p>  end
end
```</p>

<p>Tout ce code pose un certain nombre de problèmes sur lesquels je reviendrais
dans les prochains jours. Demain je pense que je mettrais le code sur Github.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
