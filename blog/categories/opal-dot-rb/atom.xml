<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : opal.rb | Xavier Nayrac]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/opal-dot-rb/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2015-02-13T18:15:09+01:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Un space invaders avec Opal.rb - partie 16]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/06/27/un-space-invaders-avec-opal-dot-rb-partie-16/"/>
    <updated>2014-06-27T21:23:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/06/27/un-space-invaders-avec-opal-dot-rb-partie-16</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Hier on a vu comment lancer une appli rack pour le développement. Seulement
je n’ai pas envie de choisir entre les deux méthodes. Je veux les deux !
Le serveur rack pour le développement, et le build classique du fichier
javascript pour la mise en production.</p>

<p>On va se bricoler deux tâches <code>rake</code> en quelques minutes pour obtenir ça.</p>

<!-- more -->

<p>Alors j’avertis tout de suite : le script n’est pas parfait. C’est malgré une
bonne base pour commencer.</p>

<p>Voici le nouveau <code>Rakefile</code>, dans lequel j’ai ajouté une tâche <code>development</code>
et une tâche <code>production</code>:</p>

<p>``` ruby Rakefile
require ‘opal’
require ‘opal-jquery’</p>

<p>desc “Build our app to build.js”
task :build do
  env = Opal::Environment.new
  env.append_path “app”</p>

<p>File.open(“build.js”, “w+”) do |out|
    out « env[“application”].to_s
  end
end</p>

<p>desc ‘Build app for production’
task :production =&gt; :build do
  cp ‘app/templates/index_production.html’, ‘index.html’
end</p>

<p>desc ‘Run development server’
task :development do
  cp ‘app/templates/index_development.html’, ‘index.html’
  <code>bundle exec rackup</code>
end
```</p>

<p>Pour que le fichier <code>index.html</code> reflète le bon environnement, j’ai
ajouté un dossier <code>templates</code>, avec une version de chaque:</p>

<pre><code>$ tree app
app
├── application.rb
├── enemies.rb
├── enemy.rb
├── fire.rb
├── game.rb
├── player.rb
├── space_canvas.rb
└── templates
    ├── index_development.html
    └── index_production.html
</code></pre>

<p>Pour info, voici le contenu des templates:</p>

<p>``` html app/templates/index_development.html
&lt;!DOCTYPE html&gt;</p>
<html>
  <head>
    <meta charset="utf-8" />
    <script src="http://code.jquery.com/jquery-1.11.0.min.js"></script>
  </head>
  <body>
    <canvas width="700" height="600" id="canvas" />
    <script src="assets/application.js"></script>
  </body>
</html>
<p>```</p>

<p>``` html app/templates/index_production.html
&lt;!DOCTYPE html&gt;</p>
<html>
  <head>
    <meta charset="utf-8" />
    <script src="http://code.jquery.com/jquery-1.11.0.min.js"></script>
  </head>
  <body>
    <canvas width="700" height="600" id="canvas" />
    <script src="build.js"></script>
  </body>
</html>
<p>```</p>

<p>Alors oui, les templates sont redondants. Et si on doit modifier le contenu
de <code>index.html</code>, il faudra faire la modification sur les deux templates.
J’avais prévenu que ça n’était pas parfait ;) Par contre, pour cette appli
c’est bien suffisant.</p>

<script id="fb33k8u">(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Un space invaders avec Opal.rb - partie 15]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/06/26/un-space-invaders-avec-opal-dot-rb-partie-15/"/>
    <updated>2014-06-26T21:09:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/06/26/un-space-invaders-avec-opal-dot-rb-partie-15</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Vous en avez peut-être marre de tapez <code>rake build</code> à chaque petite
modification de votre code ? Moi, oui. En utilisant Sprockets, on peut
rendre le build automatique. Cool.</p>

<!-- more -->

<p>La marche à suivre est décrite dans la <a href="http://opalrb.org/docs/using_sprockets/">documentation d’Opal</a>.
Basiquement, on ajoute un fichier <code>config.ru</code> à la racine:</p>

<p>``` ruby config.ru
require ‘bundler’
Bundler.require</p>

<p>run Opal::Server.new { |s|
  s.append_path ‘app’
  s.main = ‘application’
  s.index_path = ‘index.html’
}
```</p>

<p>Et on change la localisation du script dans <code>index.html</code>:</p>

<p>``` html index.html
&lt;!DOCTYPE html&gt;</p>
<html>
  <head>
    <meta charset="utf-8" />
    <script src="http://code.jquery.com/jquery-1.11.0.min.js"></script>
  </head>
  <body>
    <canvas width="700" height="600" id="canvas" />
    <script src="assets/application.js"></script>
  </body>
</html>
<p>```</p>

<p>Après quoi on lance l’application rack:</p>

<pre><code>$ bundle exec rackup
</code></pre>

<p>Et votre appli est accessible à l’adresse <code>localhost:9292</code>.</p>

<p>Maintenant tout changement de code demande seulement un raffraichіssement
dans le navigateur.</p>

<script id="fb33k8u">(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Un space invaders avec Opal.rb - partie 14]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/06/23/un-space-invaders-avec-opal-dot-rb-partie-14/"/>
    <updated>2014-06-23T21:19:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/06/23/un-space-invaders-avec-opal-dot-rb-partie-14</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Lorsque le joueur faisait feu, le tir prenait naissance dans le coin
supérieur gauche du joueur. On le voudrait plutôt au milieu.</p>

<!-- more -->

<p>Voici donc la nouvelle classe <code>Fire</code>:</p>

<p>``` ruby app/fire.rb
class Fire
  SIDE = 4
  DELTA = 5</p>

<p>attr_reader :x, :y</p>

<p>def initialize(player)
    @x = player.x + player.w / 2
    @y = player.y - SIDE
  end</p>

<p>def w; SIDE; end</p>

<p>def h; SIDE; end</p>

<p>def color; “white”; end</p>

<p>def update_position
    @y -= DELTA
  end
end
```</p>

<p>Dans <code>initialize</code>, on calcule la position d’origine du tir par rapport
au joueur, passé en argument.</p>

<p>Il faut donc changer aussi la méthode <code>fire</code> de la classe <code>Game</code>:</p>

<p>``` ruby
class Game</p>

<p>…</p>

<p>def fire
    @fires « Fire.new(@player)
  end</p>

<p>…
end
```</p>

<p>Voilà, ça c’est fait. N’oubliez pas que le code est maintenant disponible
sur <a href="https://github.com/lkdjiin/space-invaders-in-opal-rb">Github</a>.</p>

<script id="fb33k8u">(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Un space invaders in Opal.rb - partie 13]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/06/22/un-space-invaders-in-opal-dot-rb-partie-13/"/>
    <updated>2014-06-22T13:42:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/06/22/un-space-invaders-in-opal-dot-rb-partie-13</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Voici un extrait de la classe <code>SpaceCanvas</code> actuelle:</p>

<p>``` ruby app/space_canvas
class SpaceCanvas</p>

<p>…</p>

<p>def draw_player(player)
    draw_rect(player.x, player.y, player.w, player.h, player.color)
  end</p>

<p>def draw_enemy(enemy)
    draw_rect(enemy.x, enemy.y, enemy.w, enemy.h, enemy.color)
  end</p>

<p>def draw_fire(fire)
    draw_rect(fire.x, fire.y, fire.w, fire.h, fire.color)
  end</p>

<p>…</p>

<p>end
```</p>

<p>Pas bien ! Le code est dupliqué, et si j’aime l’idée d’avoir trois méthodes
différentes, dont le nom est explicite, je ne veux pas avoir à réécrire
le même code chaque fois que j’ajouterais ce genre de méthode (<code>draw_ship</code>,
<code>draw_special_fire</code>, <code>draw_bomb</code>, etc).</p>

<!-- more -->

<p>La solution réside dans l’utilisation de <code>alias_method</code>:</p>

<p>``` ruby app/space_canvas
class SpaceCanvas</p>

<p>…</p>

<p>def draw_object(object)
    draw_rect(object.x, object.y, object.w, object.h, object.color)
  end
  alias_method :draw_player, :draw_object
  alias_method :draw_enemy, :draw_object
  alias_method :draw_fire, :draw_object</p>

<p>…</p>

<p>end
```</p>

<p>Il n’y a plus de duplication, et l’ajout d’une nouvelle méthode se fait
simplement en ajoutant un nouvel alias.</p>

<p>Le code de cette série d’articles est désormais sur Github ici :
<a href="https://github.com/lkdjiin/space-invaders-in-opal-rb">space-invaders-in-opal-rb</a>,
et le jeu lui-même (du moins dans son état actuel, c’est à dire pas grand chose) est visible ici : <a href="http://lkdjiin.github.io/space-invaders-in-opal-rb/">http://lkdjiin.github.io/space-invaders-in-opal-rb/</a>.</p>

<script id="fb33k8u">(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Un space invaders avec Opal.rb - partie 12]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/06/21/un-space-invaders-avec-opal-dot-rb-partie-12/"/>
    <updated>2014-06-21T16:25:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/06/21/un-space-invaders-avec-opal-dot-rb-partie-12</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>On commence aujourd’hui à ajouter les tirs du joueur. Le code que je vous
propose est un brouillon, qu’il faudra améliorer successivement.</p>

<p>D’abord dans la classe <code>Game</code>, j’ajoute un champ <code>@fires</code>:</p>

<p>``` ruby
class Game</p>

<p>def initialize
    @canvas = SpaceCanvas.new
    @player = Player.new
    @enemies = Enemies.new(@canvas.width)
    @fires = []
  end
```</p>

<!-- more -->

<p>On déclenchera la méthode <code>fire</code> lors d’un appui sur la barre d’espace (32):</p>

<p><code>ruby
  def init_keyboard
    %x(
      window.addEventListener("keydown",
        function(e) {
          if(e.keyCode == 32) { #{fire} }
          if(e.keyCode == 37) { #{@player.move_left} }
          if(e.keyCode == 39) { #{@player.move_right} }
        },
        false);
    )
  end
</code></p>

<p>Voici la méthode <code>fire</code>, qui ajoute simplement un objet à la collection:</p>

<p><code>ruby
  def fire
    @fires &lt;&lt; Fire.new(@player.x, @player.y)
  end
</code></p>

<p>Et maintenant une méthode qui met à jour les tirs du joueur:</p>

<p><code>ruby
  def update_fires
    @fires.each do |fire|
      fire.update_position
      @canvas.draw_fire(fire)
    end
    @fires.select! {|fire| fire.y &gt;= 0 }
  end
</code></p>

<p>La dernière ligne de cette méthode supprime de la collection les tirs qui
ne sont plus visibles à l’écran.</p>

<p>Pour finir, voici la classe <code>Fire</code>:</p>

<p>``` ruby app/fire.rb
class Fire
  WIDTH = 4
  DELTA = 5</p>

<p>attr_reader :x, :y</p>

<p>def initialize(x, y)
    @x = x
    @y = y
  end</p>

<p>def w; WIDTH; end</p>

<p>def h; WIDTH; end</p>

<p>def color; “white”; end</p>

<p>def update_position
    @y -= DELTA
  end
end
```</p>

<p>Tout ce code pose un certain nombre de problèmes sur lesquels je reviendrais
dans les prochains jours. Demain je pense que je mettrais le code sur Github.</p>

<script id="fb33k8u">(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
