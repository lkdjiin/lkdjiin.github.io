<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : terminal | Xavier Nayrac]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/terminal/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2015-04-05T21:05:09+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Un éditeur pour le terminal - partie 9]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/03/13/un-editeur-pour-le-terminal-partie-9/"/>
    <updated>2014-03-13T21:04:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/03/13/un-editeur-pour-le-terminal-partie-9</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Dans le programme d’aujourd’hui, on s’occupe de déplacer le curseur.</p>

<!-- more -->

<p>``` ruby
require ‘curses’
include Curses</p>

<p>begin
  init_screen
  cbreak
  noecho
  stdscr.keypad(true)
  x = 0
  y = 0</p>

<p>while (ch = getch) != KEY_F1
    case ch
    when KEY_LEFT then x -= 1
    when KEY_RIGHT then x += 1
    when KEY_UP then y -= 1
    when KEY_DOWN then y += 1
    end
    setpos(y, x)
    refresh
  end
ensure
  close_screen
end
```</p>

<p>Les détails:</p>

<p>Pour éviter que les caractères s’affiche sur le terminal:</p>

<p><code>ruby
  noecho
</code></p>

<p>Pour rappel, le code suivant permet d’activer le pavé numérique, les
flèches, etc.</p>

<p><code>ruby
  stdscr.keypad(true)
</code></p>

<p>Positionner le curseur est aussi simple que ce qui suit. Comme toujours,
attention, c’est y d’abord et x ensuite:</p>

<p><code>ruby
    setpos(y, x)
</code></p>

<p>Par contre, si vous jouer un peu avec ce programme, on voit que les
sauts de lignes ne sont pas gérer automatiquement (quand j’arrive à la
fin de la ligne et que j’appuie sur flèche droite, on ne passe pas à
la ligne suivante par exemple). Ce sera à nous de le gérer…</p>

<p>Si on veut utiliser HJKL (comme dans Vim) pour se déplacer, on peut
remplacer le contenu du <code>case</code> par:</p>

<p><code>ruby
    when ?h then x -= 1
    when ?l then x += 1
    when ?k then y -= 1
    when ?j then y += 1
</code></p>

<p>Voilà.</p>

<script id="fb33k8u">(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>

<p>À demain.</p>

<p></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Un éditeur pour le terminal - partie 8]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/03/06/un-editeur-pour-le-terminal-partie-8/"/>
    <updated>2014-03-06T20:59:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/03/06/un-editeur-pour-le-terminal-partie-8</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Dans l’article d’aujourd’hui, on regarde comment utiliser la couleur.</p>

<!-- more -->

<p>``` ruby
require ‘curses’
include Curses</p>

<p>begin
  init_screen
  unless has_colors?
    close_screen
    puts “Your terminal has no colors”
    exit 1
  end
  start_color
  init_pair(1, COLOR_RED, COLOR_BLACK)
  attron(color_pair(1))
  setpos(10, 10)
  addstr(“In colors…”)
  attroff(color_pair(1))
  refresh
  getch
ensure
  close_screen
end
```</p>

<p>On peut savoir si le terminal est capable d’afficher en couleur grâce à
<code>has_colors?</code>:</p>

<p><code>ruby
  unless has_colors?
</code></p>

<p>Avant de pouvoir utiliser la couleur, il faut faire appel à <code>start_color</code>:</p>

<p><code>ruby
  start_color
</code></p>

<p>On crée un «assemblage» de couleurs avec <code>init_pair</code>, en lui passant un
identifiant, auquel on pourra se référer plus tard, une couleur de premier
plan et une couleur d’arrière plan:</p>

<p><code>ruby
  init_pair(1, COLOR_RED, COLOR_BLACK)
</code></p>

<p>On active un «assemblage» comme ceci:</p>

<p><code>ruby
  attron(color_pair(1))
</code></p>

<p>Et on le désactive comme cela:</p>

<p><code>ruby
  attroff(color_pair(1))
</code></p>

<p>Voilà.</p>

<script id="fb33k8u">(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>

<p>À demain.</p>

<p></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Écrire un éditeur pour le terminal - partie 7]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/03/04/ecrire-un-editeur-pour-le-terminal-partie-7/"/>
    <updated>2014-03-04T21:04:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/03/04/ecrire-un-editeur-pour-le-terminal-partie-7</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Notre futur éditeur aura un certain nombre de fenêtre (au sens de
<em>curses</em>) et pour les gérer, on sera bien inspiré d’utiliser un peu
de POO.
Voici donc une réécriture du programme vu
<a href="/blog/2014/03/02/ecrire-un-editeur-pour-le-terminal-partie-5/">ici</a>.</p>

<!-- more -->

<p>``` ruby
#!/usr/bin/env ruby</p>

<p>require ‘curses’
include Curses</p>

<p>class StatusWindow
  def initialize(filename)
    @filename = filename
    @win = Window.new(1, cols, 0, 0)
  end</p>

<p>def display
    @win.setpos(0, (@win.maxx - @filename.size) / 2)
    @win.addstr(@filename)
    @win.refresh
  end</p>

<p>def close
    @win.close
  end
end</p>

<p>class FileWindow
  def initialize(filename)
    @filename = filename
    @win = Window.new(lines - 2, cols, 2, 0)
  end</p>

<p>def display
    @win.setpos(0, 0)
    File.open(@filename).each {|line| @win.addstr(line) }
    @win.refresh
  end</p>

<p>def close
    @win.close
  end
end</p>

<p>begin
  init_screen
  refresh
  status_window = StatusWindow.new(ARGV[0])
  file_window = FileWindow.new(ARGV[0])
  status_window.display
  file_window.display
  getch
  status_window.close
  file_window.close
ensure
  close_screen
end
```</p>

<p>Le code est plus conséquent, c’est vrai, mais la structure sera plus
claire, surtout quand on coupera le code en plusieurs fichiers, et
qu’on utilisera un peu, ou plutôt beaucoup, d’héritage.</p>

<p>Le détail à retenir, curieusement, est celui-ci:</p>

<p><code>ruby
begin
  init_screen
  refresh
</code></p>

<p>Il faut rafraichir l’écran juste après l’initialisation de <em>curses</em>, sinon
aucune fenêtre ne s’affichera…</p>

<script id="fb33k8u">(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>

<p>À demain.</p>

<p></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Écrire un éditeur pour le terminal - partie 6]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/03/03/ecrire-un-editeur-pour-le-terminal-partie-6/"/>
    <updated>2014-03-03T21:10:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/03/03/ecrire-un-editeur-pour-le-terminal-partie-6</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Après avoir vu
<a href="/blog/2014/03/01/ecrire-un-editeur-pour-le-terminal-partie-4/">comment centrer du texte</a>
et
<a href="/blog/2014/03/02/ecrire-un-editeur-pour-le-terminal-partie-5/">comment faire du fenêtrage</a>,
on peut réunir les deux pour afficher un fichier, et le nom de ce fichier
centré sur la première ligne du terminal.</p>

<!-- more -->

<p>``` ruby test.rb
#!/usr/bin/env ruby</p>

<p>require ‘curses’
include Curses</p>

<p>def display_filename
  setpos(0, (cols - ARGV[0].size) / 2)
  addstr(ARGV[0])
end</p>

<p>def display_file
  setpos(2, 0)
  File.open(ARGV[0]).each {|line| addstr(line) }
end</p>

<p>begin
  init_screen
  display_filename
  display_file
  refresh
  getch
ensure
  close_screen
end
```</p>

<p>Et voilà.</p>

<script id="fb33k8u">(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>

<p>À demain.</p>

<p></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Écrire un éditeur pour le terminal - partie 5]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/03/02/ecrire-un-editeur-pour-le-terminal-partie-5/"/>
    <updated>2014-03-02T20:54:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/03/02/ecrire-un-editeur-pour-le-terminal-partie-5</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>La bibliothèque <em>curses</em> sait gérer le fenêtrage. Voici un programme qui
montre comment faire.</p>

<!-- more -->

<p>C’est une traduction en ruby d’un programme C issu d’un tutoriel
sur <em>ncurses</em> (dont je ne retrouve plus la référence dans l’immédiat).</p>

<p>``` ruby
require ‘curses’
include Curses</p>

<p>def create_newwin(height, width, top, left)
  local_win = Window.new(height, width, top, left)
  local_win.box(?|, ?-)
  local_win.refresh
  local_win
end</p>

<p>def destroy_win(w)
  w.clear
  w.refresh
  w.close
end</p>

<p>begin
  init_screen
  cbreak
  stdscr.keypad(true)
  height = 3
  width = 10
  top = (lines - height) / 2
  left = (cols - width) / 2
  addstr(“Press F1 to exit”)
  refresh
  my_win = create_newwin(height, width, top, left)</p>

<p>while (ch = getch) != KEY_F1
    case ch
    when KEY_LEFT then left -= 1
    when KEY_RIGHT then left += 1
    when KEY_UP then top -= 1
    when KEY_DOWN then top += 1
    end
    destroy_win(my_win)
    my_win = create_newwin(height, width, top, left)
  end
ensure
  close_screen
end
```</p>

<p>En étudiant ce programme avec en parallèle la documentation ruby
de <a href="http://ruby-doc.org/stdlib-2.1.0/libdoc/curses/rdoc/Curses.html">curses</a>,
vous devriez comprendre sans problèmes la gestion des fenêtres.</p>

<script id="fb33k8u">(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>

<p>À demain.</p>

<p></p>

]]></content>
  </entry>
  
</feed>
