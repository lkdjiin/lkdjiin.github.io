<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : terminal | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/terminal/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2014-02-16T14:40:34+01:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Curses et ncurses en Ruby]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/02/16/curses-et-ncurses-en-ruby/"/>
    <updated>2014-02-16T14:29:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/02/16/curses-et-ncurses-en-ruby</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Tiens, j'ai envie d'écrire en Ruby un embryon d'éditeur pour le terminal, qui
serait fortement inspiré de Vim. Juste histoire de voir comment ça marche.
La première étape sera d'utiliser la bibliothèque curses (ou ncurses) à
partir de Ruby.</p>

<!-- more -->


<h2>Curses</h2>

<p>La bibliothèque <em>curses</em> permet de gérer toutes les interactions
clavier et souris avec un terminal. Jusqu'à la version 2.1 de Ruby, elle
faisait partie de la bibliothèque standard. Donc, si vous utilisez
Ruby 2.1, n'oubliez pas de faire:</p>

<pre><code>gem install curses
</code></pre>

<p>Si vous utilisez Ruby 2.0 où inférieur, vous possédez déjà la bibliothèque
<em>curses</em>.</p>

<p>Voici donc un <em>hello world</em>:</p>

<p>``` ruby
require &lsquo;curses&rsquo;</p>

<p>include Curses</p>

<p>begin
  init_screen
  setpos(0, 0)
  addstr(&lsquo;Hello, world!&rsquo;)
  refresh
  getch
ensure
  close_screen
end
```</p>

<p>On remarque tout d'abord la paire:</p>

<pre><code>init_screen
close_screen
</code></pre>

<p>Il faut toujours appeler <code>close_screen</code> à la fin de votre programme, pour
remettre le terminal dans l'état où il se trouvait avant le lancement de
votre programme.</p>

<p>Pour positionner le curseur, on utilise:</p>

<pre><code>setpos(0, 0)
</code></pre>

<p>Attention, le premier nombre est le numéro de la ligne, et le second est le
numéro de la colonne. Et lignes et colonnes se comptent à partir de 0…</p>

<p>Pour écrire une chaîne de caractère à la position du curseur:</p>

<pre><code>addstr('Hello, world!')
refresh
</code></pre>

<p>Curses n'écrit directement dans le terminal, mais dans un buffer en mémoire,
c'est pourquoi il faut appeler <code>refresh</code> pour voir les changements.</p>

<p>Ensuite, on attends l'appui sur une touche du clavier avec:</p>

<pre><code>getch
</code></pre>

<h2>Ncurses</h2>

<p>Il existe aussi la bibliothèque <em>ncurses</em>, un peu plus puissante. Il existe
plusieurs wrappers pour Ruby. J'utilise personnelement <a href="https://github.com/seanohalpin/ffi-ncurses">ffi-ncurses</a>.</p>

<p>Le même programme que le précédent, mais pour ncurses:</p>

<p>``` ruby
require &lsquo;ffi-ncurses&rsquo;</p>

<p>include FFI::NCurses</p>

<p>begin
  initscr
  printw &ldquo;Hello World !!!&rdquo;
  refresh
  getch
ensure
  endwin
end
```</p>

<p>Les deux programmes se ressemblent beaucoup. Et pour cause, <em>ncurses</em> fait
la même chose que <em>curses</em>, avec des extensions en plus.</p>

<h2>Choisir entre curses et ncurses</h2>

<p>L'une et l'autre ont leurs avantages et leurs inconvénients. <em>curses</em> à
l'avantage d'avoir été distribuée en standard avec Ruby jusqu'à la version
2.0 incluse, et est donc très bien intégrée. Je pense qu'on doit pouvoir
l'utiliser facilement, même sur Windows. <em>ncurses</em> est plus puissante mais
requiert plus de dépendances, et il n'est pas toujours évident de trouver
un wrapper qui fonctionne avec une version récente de Ruby, même sur Linux.</p>

<p>Si je devais écrire un programme grand public, j'utiliserais <em>curses</em>, mais
comme il s'agit juste d'un programme exemple pour ce blog, je vais me faire
plaisir et utiliser <em>ncurses</em>…</p>

<p>La prochaine fois on commencera à écrire l'éditeur.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Raccourcis clavier pour le terminal]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/01/17/raccourcis-clavier-pour-le-terminal/"/>
    <updated>2014-01-17T21:06:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/01/17/raccourcis-clavier-pour-le-terminal</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Aujourd'hui je parle des raccourcis clavier du terminal. Pas tous, il y
en a des tonnes, seulement ceux que j'utilise régulièrement.</p>

<!-- more -->


<h2>Linux et OS X</h2>

<p>Les raccourcis qui suivent fonctionnent aussi bien sous Linux et
OS X:</p>

<pre><code>Crtl-a   Aller en début de ligne
Crtl-e   Aller en fin de ligne
Crtl-k   Supprimer du curseur à la fin de la ligne
Crtl-u   Supprimer avant le curseur
Crtl-w   Supprimer le mot avant le curseur
Crtl-t   Échanger les 2 caractères avant le curseur
Esc-t    Échanger les 2 mots avant le curseur
</code></pre>

<p>Pour voir la liste de tous les mappings:</p>

<p><code>bash
bind -P
</code></p>

<h2>Linux seulement</h2>

<pre><code>Shift-Ctrl-c  Copier le texte sélectionné
Shift-Ctrl-v  Coller le texte
</code></pre>

<h2>OS X seulement</h2>

<pre><code>Meta-c        Copier le texte sélectionné
Meta-v        Coller le texte
</code></pre>

<p>En bonus, voici un truc très pratique sous OS X, qu'un collègue
(<a href="https://twitter.com/julienXX">@julienXX</a>) m'a
montré la semaine dernière: Un triple clic sur une ligne la sélectionne en
entier, avec le caractère de fin de ligne mais sans le prompt. On peut ensuite
faire un copier/coller avec <code>Shift-Meta-v</code>, ce qui lance la commande
directement.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
