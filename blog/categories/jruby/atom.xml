<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : jruby | Xavier Nayrac]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/jruby/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2018-10-17T15:57:14+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Un désassembleur pour Chip8]]></title>
    <link href="http://lkdjiin.github.io/blog/2016/01/31/un-desassembleur-pour-chip8/"/>
    <updated>2016-01-31T10:25:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2016/01/31/un-desassembleur-pour-chip8</id>
    <content type="html"><![CDATA[<p>En ce moment je bricole un émulateur pour
<a href="https://fr.wikipedia.org/wiki/CHIP-8">Chip8</a> en JRuby.  Un des outils que j’ai
écrit en Ruby pour cet émulateur est <strong>c8dasm</strong>, un
<a href="https://fr.wikipedia.org/wiki/D%C3%A9sassembleur">désassembleur</a> pour Chip8.</p>

<p><img class="center" src="/images/vintage.jpg"></p>

<!-- more -->

<p>Si vous avez besoin d’un tel outil, si vous voulez étudier l’intérieur d’un
désassembleur, ou si vous êtes simplement curieux, vous trouverez
<a href="https://github.com/lkdjiin/c8dasm">le code en ligne</a>.</p>

<p>Si vous voulez voir ce que ça donne, voici un exemple:</p>

<pre><code>$ c8dasm MAZE
200:a21e  LD I, 21e     ;Puts 21e into register I.
202:c201  RND V2, 01    ;Puts random byte AND 01 into register V2.
204:3201  SE V2, 01     ;Skip next instruction if V2 = 01.
206:a21a  LD I, 21a     ;Puts 21a into register I.
208:d014  DRW V0, V1, 4 ;Draws 4-byte sprite from I at (V0, V1)
20a:7004  ADD V0, 04    ;V0 = V0 + 04.
20c:3040  SE V0, 40     ;Skip next instruction if V0 = 40.
20e:1200  JP 200        ;Jump to location 200.
210:6000  LD V0, 00     ;Puts the value 00 into register V0.
212:7104  ADD V1, 04    ;V1 = V1 + 04.
[...]
</code></pre>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les arbres browniens - 2ème partie]]></title>
    <link href="http://lkdjiin.github.io/blog/2016/01/18/les-arbres-browniens-2eme-partie/"/>
    <updated>2016-01-18T09:54:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2016/01/18/les-arbres-browniens-2eme-partie</id>
    <content type="html"><![CDATA[<p>Dans <a href="/blog/2016/01/17/les-arbres-browniens/">le dernier article</a>, je présentais un code de base en JRuby
pour construire des arbres browniens. À partir de ce code de base on peut
tester plusieurs variations.</p>

<h2 id="des-couleurs-au-hasard">Des couleurs au hasard</h2>

<p><img class="center" src="/images/brownian-tree51.png"></p>

<p>Pour cela, quand on <em>gèle</em> une cellule on lui attribue au hasard une valeur
entre 1 et le nombre maximum de couleur (ici seulement deux).</p>

<!-- more -->

<p>```ruby
def move
  # […]
      if has_neighbors?(cell)
        @cells[cell[0]][cell[1]] = frozen
  # […]</p>

<p>def frozen
  rand(2) + 1
end</p>

<p>def update_board(g)
        # […]
      if @cells[i][j] == 1
        g.setColor(Color::MAGENTA)
        g.fillRect(i * SCALE, j * SCALE, SCALE, SCALE)
      elsif @cells[i][j] == 2
        g.setColor(Color::GREEN)
        # […]
```</p>

<h2 id="une-ligne-entire-de-graines">Une ligne entière de graines</h2>

<p><img class="center" src="/images/brownian-tree52.png"></p>

<p>En plaçant une ligne de graine, au lieu d’une seule, on obtient quelque chose
qui ressemble plus à des arbres.</p>

<h2 id="couleurs-suivant-le-temps-darrive">Couleurs suivant le temps d’arrivée</h2>

<p><img class="center" src="/images/brownian-tree53.png"></p>

<p>Par exemple cyan pour les 800 premières itérations, magenta pour les 600
suivantes, et vert pour les dernières.</p>

<p><code>ruby
  def frozen
    if @iteration &lt; 800
      1
    elsif @iteration &lt; 1400
      2
    else
      3
    end
  end
</code></p>

<h2 id="mouvement-biais">Mouvement biaisé</h2>

<p><img class="center" src="/images/brownian-tree55.png"></p>

<p>Pour produire l’image ci-dessus les cellules <em>montent</em> plus souvent qu’elles ne
descendent.</p>

<p><code>ruby
cell[1] + [-1, 0, 1, -1, -1].shuffle.first
</code></p>

<h2 id="et-encore">Et encore</h2>

<p>On peut trouver encore des tas de variations, et les mélanger. Par exemple dans
l’image suivante la couleur d’une cellule dépend du nombre de ses voisines et
la longueur du mouvement des cellules suit, en gros, une
<a href="https://en.wikipedia.org/wiki/Cauchy_distribution">distribution de Cauchy</a>.</p>

<p><img class="center" src="/images/brownian-tree56.png"></p>

<p>Si vous pensez à d’autres variations possibles, n’hésitez pas à m’en faire part.</p>

<p></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les arbres browniens]]></title>
    <link href="http://lkdjiin.github.io/blog/2016/01/17/les-arbres-browniens/"/>
    <updated>2016-01-17T23:30:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2016/01/17/les-arbres-browniens</id>
    <content type="html"><![CDATA[<p>Ce week end j’ai joué avec les arbres browniens (<em>brownian trees</em>).
Ce sont des agglomérats de cellules qui ressemblent vaguement à des arbres,
obtenus à partir d’un mouvement brownien. Et le mouvement brownien, c’est cool.</p>

<p>C’est Robert Brown, un
botaniste, qui le décrit en 1827 en observant des petites particules qui
semblaient bouger toutes seules. Il voit ses particules avoir la tremblote, mais
sans pouvoir expliquer pourquoi.</p>

<p>C’est d’autant plus cool qu’en 1905, en donnant l’explication du mouvement
brownien, Albert Enstein va fournir la preuve de l’existence des atomes.</p>

<p>Le mouvement brownien c’est simplement les atomes qui <em>cognent</em> dans tout les
sens sur des particules.</p>

<p><img class="center" src="/images/brownian-tree.png"></p>

<!-- more -->

<p>L’algorithme pour créer un arbre brownien est enfantin:</p>

<ol>
  <li>Positionner au hasard une première cellule gelée qui sert de <em>graine</em>.</li>
  <li>Positionner au hasard une cellule libre.</li>
  <li>Mouvoir au hasard la cellule libre, c’est le mouvement brownien.</li>
  <li>Quand la cellule libre <em>rencontre</em> une cellule gelée, elle gèle elle-même
et on recommence au point 2.</li>
</ol>

<p>Mettre les cellules libres une par une, c.à.d attendre qu’une rencontre avec une
cellule gelée se produise avant de passer à la cellule libre suivante est trop
long. Avec un dispositif d’affichage assez grand on pourrait y passer plusieurs
jours.
Donc je met toutes les cellules libres dès le départ, ainsi il se passe très
vite beaucoup de choses.</p>

<p>J’ai fait <a href="https://www.youtube.com/watch?v=wQnTUZHfSKA&amp;feature=youtu.be">une vidéo de la construction d’un arbre brownien</a> pour que vous puissiez visualiser comment ça fonctionne.</p>

<iframe width="420" height="315" src="https://www.youtube.com/embed/wQnTUZHfSKA" frameborder="0" allowfullscreen=""></iframe>

<p>J’ai écrit un programme en JRuby pour faire un arbre brownien basique.  Le code
n’est pas beau car il n’a pas été pensé pour durer plus que le temps d’un
week-end. Malgré tout, je pense qu’il est compréhensible et qu’il peut servir
de base pour des idées plus sophistiquées.</p>

<p>```ruby
include Java</p>

<h1 id="its-ruby-but-its-also-java-so-import">It’s Ruby… but it’s also Java… so… import…</h1>
<p>import javax.swing.JFrame
import javax.swing.JPanel
import javax.swing.Timer
import java.awt.Color
import java.awt.Dimension
import java.awt.Toolkit
import java.awt.event.ActionListener</p>

<p>SIZE = 200        # Both width and height of the <em>image</em>.
SCALE = 2         # Multiply size by scale to obtain the <em>window</em> size.
FREE_TOTAL = 6000 # Number of particles to agregate.
DELAY = 20        # Time to wait between <em>screen refreshes</em>.</p>

<p>VOID = 0   # A cell with nothing in itself.
FROZEN = 1 # A cell already agregated.</p>

<p>class BrownianTree &lt; JFrame
  include ActionListener</p>

<p>def initialize
    super(“Brownian Tree”)
    init_ui
  end</p>

<p>def init_ui
    @board = Board.new
    @board.setPreferredSize(Dimension.new(SIZE * SCALE, SIZE * SCALE))
    add(@board)
    pack
    setDefaultCloseOperation(JFrame::EXIT_ON_CLOSE)
    setVisible(true)</p>

<pre><code>@timer = Timer.new(DELAY, self)
@timer.start   end
</code></pre>

<p># Called every DELAY millisecond, thanks to the <em>magic</em> of
  # ActionListener.
  def actionPerformed(e)
    @board.move
    @board.repaint
  end</p>

<p>end</p>

<p>class Board &lt; JPanel</p>

<p>def initialize
    super
    init_board
  end</p>

<p>def init_board
    setBackground(Color.black)</p>

<pre><code># An array of SIZE x SIZE.
@cells = Array.new(SIZE) { Array.new(SIZE, VOID) }

# The cell in the middle is the seed.
@cells[SIZE / 2][SIZE / 2] = FROZEN

# All free cells from the start, at random (x y) positions.
@free_cells = Array.new(FREE_TOTAL) do
  [rand(SIZE), rand(SIZE)]
end   end
</code></pre>

<p># Called by <code>repaint</code> in BrownianTree. Yep, that’s right, <code>repaint</code>
  # call <code>paint</code>. It’s also Java, after all…
  def paint(g)
    super(g)
    update_board(g)
    Toolkit.getDefaultToolkit.sync
    g.dispose
  end</p>

<p># Display frozen cells in white and free cells in red.
  def update_board(g)
    g.setColor(Color::WHITE)
    SIZE.times do |i|
      SIZE.times do |j|
        if @cells[i][j] == FROZEN
          g.fillRect(i * SCALE, j * SCALE, SCALE, SCALE)
        end
      end
    end</p>

<pre><code>g.setColor(Color::RED)
@free_cells.each do |cell|
  g.fillRect(cell[0] * SCALE, cell[1] * SCALE, SCALE, SCALE)
end   end
</code></pre>

<p>def move
    # Move each free cell, one cell up or up-right or right or etc…
    @free_cells.map! do |cell|
      c = [
        cell[0] + [-1, 0, 1].shuffle.first,
        cell[1] + [-1, 0, 1].shuffle.first
      ]</p>

<pre><code>  if c[0] &lt; 0 || c[0] &gt;= SIZE || c[1] &lt; 0 || c[1] &gt;= SIZE
    [rand(SIZE), rand(SIZE)]
  else
    c
  end
end

# Freeze each free cell that have at least 1 neighbor.
@free_cells.map! do |cell|
  if has_neighbors?(cell)
    @cells[cell[0]][cell[1]] = FROZEN
    nil
  else
    cell
  end
end

@free_cells.compact!   end
</code></pre>

<p>def has_neighbors?(cell)
    if cell[0] &lt; 1 || cell[0] &gt; SIZE - 2 || cell[1] &lt; 1 || cell[1] &gt; SIZE - 2
      return false
    end
    if @cells[cell.first - 1][cell.last - 1] == FROZEN ||
       @cells[cell.first][cell.last - 1] == FROZEN ||
       @cells[cell.first + 1][cell.last - 1] == FROZEN ||
       @cells[cell.first + 1][cell.last] == FROZEN ||
       @cells[cell.first + 1][cell.last + 1] == FROZEN ||
       @cells[cell.first][cell.last + 1] == FROZEN ||
       @cells[cell.first - 1][cell.last + 1] == FROZEN ||
       @cells[cell.first][cell.last + 1] == FROZEN
      true
    else
      false
    end
  end</p>

<p>end</p>

<p>BrownianTree.new
```</p>

<p>On se retrouve bientôt pour que je vous parle des quelques variations que j’ai
essayé autour du thème des arbres browniens.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
