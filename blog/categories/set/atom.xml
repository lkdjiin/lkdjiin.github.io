<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : set | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/set/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2013-12-30T20:49:51+01:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ruby 2.1: Les nouvelles méthodes de Set]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/12/30/ruby-2-dot-1-les-nouvelles-methodes-de-set/"/>
    <updated>2013-12-30T19:10:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/12/30/ruby-2-dot-1-les-nouvelles-methodes-de-set</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Avec la sortie de Ruby 2.1, la bibliothèque standard <code>Set</code> s'enrichie de
deux méthodes supplémentaires: <code>disjoint?</code> et <code>intersect?</code>.</p>

<!-- more -->


<p><code>Set</code> permet de créer un ensemble d'éléments uniques:</p>

<p>``` irb</p>

<blockquote><blockquote><p>require &lsquo;set&rsquo;
Set.new [1, 2, 1, 2, 2]
=> #&lt;Set: {1, 2}>
```</p></blockquote></blockquote>

<p>La nouvelle méthode <code>intersect?</code> permet de tester si deux sets ont au moins
un élément en commun:</p>

<p>``` irb</p>

<blockquote><blockquote><p>s1 = Set.new [1, 2, 3]
s2 = Set.new [4, 5, 6]
s3 = Set.new [1, 8, 9]</p>

<p>s1.intersect? s2
=> false
s1.intersect? s3
=> true
```</p></blockquote></blockquote>

<p>La seconde méthode, <code>disjoint?</code>, est son opposée. Elle teste si deux sets n'ont
aucuns éléments communs:</p>

<p>``` irb</p>

<blockquote><blockquote><p>s1.disjoint? s2
=> true
s1.disjoint? s3
=> false
```</p></blockquote></blockquote>

<p>Ce genre de méthode n'est pas très compliqué à coder soi-même, comme le
montre le code source de <code>intersect?</code>:</p>

<p>``` ruby
def intersect?(set)
  set.is_a?(Set) or raise ArgumentError, &ldquo;value must be a set&rdquo;
  if size &lt; set.size</p>

<pre><code>any? { |o| set.include?(o) }
</code></pre>

<p>  else</p>

<pre><code>set.any? { |o| include?(o) }
</code></pre>

<p>  end
end
```</p>

<p>Mais l'avoir en standard permet de ne pas réinventer la roue…
Quant au code source de <code>disjoint?</code>, c'est très exactement comme je
le disais plus haut, l'opposé de <code>intersect?</code>:</p>

<p><code>ruby
def disjoint?(set)
  !intersect?(set)
end
</code></p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
