<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : R | Xavier Nayrac]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/r/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2016-02-02T15:21:18+01:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Un quine en R - Le retour]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/10/13/un-quine-en-r-le-retour/"/>
    <updated>2015-10-13T14:19:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/10/13/un-quine-en-r-le-retour</id>
    <content type="html"><![CDATA[<p>Dans l’article précédent <a href="http://lkdjiin.github.io/blog/2015/10/10/un-quine-en-r/">Un quine en R</a>
je présentais un <a href="https://fr.wikipedia.org/wiki/Quine_%28informatique%29">quine</a> en langage R. Le code était un peu long, 19 lignes,
surtout comparé au code Ruby de l’article original:</p>

<p><code>ruby
src = "\nputs \"src = \" + src.inspect + src"
puts "src = " + src.inspect + src
</code></p>

<p>En Ruby, c’est court en partie grâce à la méthode <code>inspect</code> qui <em>échappe</em>
automatiquement les caractères non imprimables et les guillemets:</p>

<!-- more -->

<p><code>irb
&gt;&gt; foo = "\nputs \"src\""
"\nputs \"src\""
&gt;&gt; foo.inspect
"\"\\nputs \\\"src\\\"\""
</code></p>

<p>Bien entendu j’ai cherché une fonction similaire en R, du moins pour les
chaînes de caractères. J’ai laissé tombé après un quart d’heure de recherches
infructueuses, et j’ai pondu <a href="http://lkdjiin.github.io/blog/2015/10/10/un-quine-en-r/">le code</a> de l’article précédent.</p>

<p>C’est là que Hadley Wickham <em>himself</em> m’a suggéré l’utilisation de la fonction
<code>encodeString</code>. C’est ce que j’avais cherché sans le trouver. Du coup, un
quine en R prends beaucoup moins de place et deviens plus compréhensible:</p>

<p>``` r quine2.r
src &lt;- “\nwriteLines(c(paste("src &lt;-", encodeString(src, quote=’"’)), src))”</p>

<p>writeLines(c(paste(“src &lt;-“, encodeString(src, quote=’”’)), src))
```</p>

<p>Cette version me plait bien, je l’ai donc ajouté sur le <a href="http://rosettacode.org/wiki/Quine#R">rosettacode.org</a>.</p>

<p>Comme dit la dernière fois, il est bon d’utiliser <code>diff</code> pour s’assurer qu’on
a bien écrit un quine:</p>

<p><code>bash
diff -u quine2.r &lt;(Rscript quine2.r)
</code></p>

<p>Et voilà le résultat:</p>

<p>```
$ Rscript quine3.r
src &lt;- “\nwriteLines(c(paste("src &lt;-", encodeString(src, quote=’"’)), src))”</p>

<p>writeLines(c(paste(“src &lt;-“, encodeString(src, quote=’”’)), src))
```</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Un quine en R]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/10/10/un-quine-en-r/"/>
    <updated>2015-10-10T18:11:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/10/10/un-quine-en-r</id>
    <content type="html"><![CDATA[<p>J’ai lu récemment l’article <a href="http://blog.chaps.io/2015/10/01/generating-quines-in-ruby.html">generating Quines in Ruby</a> qui m’a beaucoup plu. Et j’ai eu envie d’en faire un dans le langage R.</p>

<p>Alors c’est quoi un quine ? Un quine est un programme informatique
auto répliquant (<em>self-reproducing</em>).  Il doit satisfaire à deux conditions:</p>

<ol>
  <li>Il produit son code source en tant que unique sortie.</li>
  <li>Il ne prend aucune entrée, ce qui exclus par exemple de lire un fichier.</li>
</ol>

<!-- more -->

<p>Voici ma solution en R, elle affiche son code source sur la sortie standard
quand on l’exécute. Je me suis beaucoup inspiré de la solution en C de l’article
original:</p>

<p><code>r quine.r
src &lt;-"\nescape &lt;- function(x) {\n    cat('\"')\n    for(e in strsplit(x, '')[[1]]) {\n        if(e == '\\n') {\n            cat('\\\\n')\n        } else if(e == '\\\\') {\n            cat('\\\\\\\\')\n        } else if(e == '\"') {\n            cat('\\\\\"')\n        } else {\n            cat(e)\n        }\n    }\n    cat('\"')\n}\ncat(\"src &lt;-\")\nescape(src)\nwriteLines(src)"
escape &lt;- function(x) {
    cat('"')
    for(e in strsplit(x, '')[[1]]) {
        if(e == '\n') {
            cat('\\n')
        } else if(e == '\\') {
            cat('\\\\')
        } else if(e == '"') {
            cat('\\"')
        } else {
            cat(e)
        }
    }
    cat('"')
}
cat("src &lt;-")
escape(src)
writeLines(src)
</code></p>

<p>Comme il est noté dans l’article original, il est bon de tester sa solution à
l’aide de <code>diff</code>. Si la sortie de votre programme et le source sont identiques,
<code>diff</code> ne produira aucune sortie, sinon bon débogage ;)</p>

<p><code>bash
$ diff -u quine.r &lt;(Rscript quine.r)
</code></p>

<p>Ma solution est beaucoup plus longue que celle qui se trouve sur le <a href="http://rosettacode.org/wiki/Quine#R">rosetta code</a> par exemple. Mais c’est pas grave, c’était marrant à faire, c’était un bon petit casse-tête qui m’a bien fait réfléchir. Et j’ai même appris une fonction R qui m’était inconnue (<code>writeLines</code>).</p>

<p>À vous de jouer maintenant ; tenez moi au courant si vous écrivez un quine, quel
que soit le langage ;)</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Extraction des tags de mon blog en ligne de commande]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/07/11/extraction-des-tags-de-mon-blog-en-ligne-de-commande/"/>
    <updated>2015-07-11T17:08:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/07/11/extraction-des-tags-de-mon-blog-en-ligne-de-commande</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>J’aimerais savoir quels sont les tags que j’ai le plus employé sur ce blog.
Pour cela il va d’abord falloir les extraire, si possible dans un fichier csv.</p>

<p>Comment ? En Ruby ? En R ? Non non, en Bash, ça va être beaucoup plus drôle.</p>

<p>Petite étude de cas pour découvrir la puissance de la ligne de commande, ou
pour rafraichir ses connaissances ;)</p>

<p><img class="center" src="/images/tags-cloud.png"></p>

<!-- more -->

<p>Si vous voulez reproduire l’analyse en même temps que moi, les
<a href="https://github.com/lkdjiin/lkdjiin.github.io/tree/source/source/_posts">articles sont ici</a>.</p>

<p>Voyons à quoi ressemble le début d’un article au hasard avec <code>head</code>.
Octopress, le framework que j’utilise pour ce blog, appelle les tags des
<em>categories</em>. Mais c’est pareil.</p>

<p><code>bash
$ head 2013-10-20-les-algorithmes-genetiques-demystifies-35.markdown
---
layout: post
title: "Les algorithmes génétiques démystifiés 35"
date: 2013-10-20 21:21
comments: true
categories: [imagerie, algorithme génétique, intermédiaire, javascript]
#...
</code></p>

<p>L’entête d’un article a toujours la même structure. Avec <code>head *.markdown</code>
j’affiche le début de tous les articles, les uns à la suite des autres.
Avec <code>sed</code> je peux extraire uniquement les lignes qui commencent par <code>cat</code> :</p>

<p><code>bash
$ head *.markdown | sed -n '/^cat/p'
categories: [annonce, défi]
categories: [vim, conseil, débutant]
categories: [ruby, code propre, intermédiaire]
categories: [ruby, eigenclass, object, intermédiaire]
#...
</code></p>

<p>Gardons seulement les tableaux. <code>cut -f1</code> <em>découpe</em> le premier champ, <code>-d' '</code>
indique que le séparateur de champ est l’espace, et <code>--complement</code> indique
qu’on veut conserver le complément. Autrement dit tout sauf la première
colonne.</p>

<p><code>bash
$ head *.markdown | sed -n '/^cat/p' |
&gt; cut -f1 -d' ' --complement
[annonce, défi]
[vim, conseil, débutant]
[ruby, code propre, intermédiaire]
[ruby, eigenclass, object, intermédiaire]
#...
</code></p>

<p>Supprimons les crochets à l’aide de <code>sed</code> et d’une regex rigolote.</p>

<p><code>bash
$ head *.markdown | sed -n '/^cat/p' | cut -f1 -d' ' --complement |
&gt; sed 's/[][]//g'
annonce, défi
vim, conseil, débutant
ruby, code propre, intermédiaire
ruby, eigenclass, object, intermédiaire
#...
</code></p>

<p>Supprimons les espaces inutiles. Attention, certains tags contiennent des
espaces.</p>

<p><code>bash
$ head *.markdown | sed -n '/^cat/p' | cut -f1 -d' ' --complement |
&gt; sed 's/[][]//g' |
&gt; sed 's/, /,/g'
annonce,défi
vim,conseil,débutant
ruby,code propre,intermédiaire
ruby,eigenclass,object,intermédiaire
#...
</code></p>

<p>Grâce à <code>tr</code>, je remplace chaque virgule par un retour à la ligne. Ça
commence à prendre forme.</p>

<p><code>bash
$ head *.markdown | sed -n '/^cat/p' | cut -f1 -d' ' --complement |
&gt; sed 's/[][]//g' | sed 's/, /,/g' |
&gt; tr ',' '\n'
annonce
défi
vim
conseil
débutant
ruby
code propre
intermédiaire
ruby
eigenclass
#...
</code></p>

<p>Trions par ordre alphabétique.</p>

<p>``` bash
$ head *.markdown | sed -n ‘/^cat/p’ | cut -f1 -d’ ‘ –complement |
&gt; sed ‘s/[][]//g’ | sed ‘s/, /,/g’ | tr ‘,’ ‘\n’ |
&gt; sort</p>

<p>ack
activerecord
activerecord
ag
airline
airline
airline
airline
algorithme génétique
#…
```</p>

<p>Réduisons les occurrences et comptons les avec <code>uniq -c</code>.</p>

<p><code>bash
$ head *.markdown | sed -n '/^cat/p' | cut -f1 -d' ' --complement |
&gt; sed 's/[][]//g' | sed 's/, /,/g' | tr ',' '\n' | sort |
&gt; uniq -c
      1 
      1 ack
      2 activerecord
      1 ag
      4 airline
     70 algorithme génétique
      1 alias
     16 annonce
      3 app
      1 application
#...
</code></p>

<p>Trions à nouveau, cette fois sur le nombre et du plus grand au plus petit.</p>

<p><code>bash
$ head *.markdown | sed -n '/^cat/p' | cut -f1 -d' ' --complement |
&gt; sed 's/[][]//g' | sed 's/, /,/g' | tr ',' '\n' | sort | uniq -c |
&gt; sort -nr
    213 ruby
    176 intermédiaire
    171 débutant
     70 algorithme génétique
     55 vim
     26 tutoriel
     26 julia
     26 javascript
#...
      1 application
      1 alias
      1 ag
      1 ack
      1 
</code></p>

<p>Vous avez remarquez ? Un tag est vide. Ça pourrait poser problème pour la
suite. Avec <code>sed</code> on peut facilement supprimer la dernière ligne.</p>

<p><code>bash
$ head *.markdown | sed -n '/^cat/p' | cut -f1 -d' ' --complement |
&gt; sed 's/[][]//g' | sed 's/, /,/g' | tr ',' '\n' | sort | uniq -c |
&gt; sort -nr | sed '$d'
    213 ruby
    176 intermédiaire
    171 débutant
#...
      1 alias
      1 ag
      1 ack
</code></p>

<p>À la réflexion je préfère faire comme si il y avait plusieurs lignes vides et
les supprimer toutes. Ça pourrait être plus réutilisable.</p>

<p><code>bash
$ head *.markdown | sed -n '/^cat/p' | cut -f1 -d' ' --complement |
&gt; sed 's/[][]//g' | sed 's/, /,/g' | tr ',' '\n' |
&gt; sed '/^$/d' |
&gt; sort | uniq -c | sort -nr
</code></p>

<p>Il est temps de sortir une regex un peu plus complexe pour inverser les deux
champs et ajouter une virgule entre eux.</p>

<p><code>bash
$ head *.markdown | sed -n '/^cat/p' | cut -f1 -d' ' --complement |
&gt; sed 's/[][]//g' | sed 's/, /,/g' | tr ',' '\n' | sed '/^$/d' |
&gt; sort | uniq -c | sort -nr |
&gt; sed -r 's/\s+([0-9]+) (.*)/\2,\1/'
ruby,213
intermédiaire,176
débutant,171
algorithme génétique,70
#...
</code></p>

<p>C’est quasiment terminé. Il reste à ajouter l’entête du fichier csv. Pour cela
je vais utiliser une commande non standard mais bien pratique, <code>header</code>.</p>

<p><code>bash
$ head *.markdown | sed -n '/^cat/p' | cut -f1 -d' ' --complement |
&gt;  sed 's/[][]//g' | sed 's/, /,/g' | tr ',' '\n' | sed '/^$/d' |
&gt; sort | uniq -c | sort -nr | sed -r 's/\s+([0-9]+) (.*)/\2,\1/' |
&gt; header -a tag,frequency
tag,frequency
ruby,213
intermédiaire,176
débutant,171
algorithme génétique,70
#...
</code></p>

<p>On a terminé. C’est un beau pipeline, non ? Enregistrons le résultat dans un
fichier.</p>

<p><code>bash
$ head *.markdown | sed -n '/^cat/p' | cut -f1 -d' ' --complement |
&gt;  sed 's/[][]//g' | sed 's/, /,/g' | tr ',' '\n' | sed '/^$/d' |
&gt; sort | uniq -c | sort -nr | sed -r 's/\s+([0-9]+) (.*)/\2,\1/' |
&gt; header -a tag,frequency &gt; tags.csv
</code></p>

<p>En bonus, voici le code R qui produit l’image qui illustre cet article.</p>

<p>``` r
library(wordcloud)</p>

<p>d &lt;- read.csv(‘tags.csv’)</p>

<p>colors &lt;- brewer.pal(12, ‘Paired’)
colors &lt;- colors[seq(2, 10, by=2)]</p>

<p>wordcloud(d$tag, d$frequency, colors=colors, min.freq=1, scale=c(5, .6),
          rot.per=.25, random.order=FALSE, random.color=TRUE)
```</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les langages que j'aimerais (ré)apprendre]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/06/18/les-langages-que-jaimerais-re-apprendre/"/>
    <updated>2015-06-18T10:46:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/06/18/les-langages-que-jaimerais-re-apprendre</id>
    <content type="html"><![CDATA[<p>Ça fait 5 ans que je fais presque exclusivement du Ruby.  J’ai envie que ça
change. Je n’ai pas de problème avec Ruby ; j’aime toujours autant ce langage ;
je pense qu’il a encore pas mal d’avenir (inertie des projets rails, ruby
dans le navigateur avec opal.rb, ruby dans l’embarqué avec mruby) ; c’est juste
que j’ai besoin d’air frais.</p>

<p>Voici une liste de 8 langages informatiques que j’aimerais apprendre,
réapprendre, tester ou approfondir, plus ou moins dans l’ordre.</p>

<h2 id="r">R</h2>

<p>Le langage de base du <em>data scientist</em>. Je m’y met à fond en ce moment.
Ce langage est parfois bizarre, mais parfait pour l’exploration des données,
les statistiques et les graphes en interactif dans la console.</p>

<!-- more -->

<h2 id="jruby">JRuby</h2>

<p>Bon ok, c’est pas un langage. Mais je ne me suis jamais intéressé à JRuby.
C’est peut-être le moment d’essayer. Je me dis que JRuby pourrait pallier les
lacunes de Ruby en matière de graphisme.</p>

<h2 id="java">Java</h2>

<p>Des fois je ressens le besoin de faire des programmes rapides. J’ai fait du
Java pendant des années, il est peut-être temps de voir les nouveautés que ce
langage a à m’offrir.</p>

<h2 id="assembleur">Assembleur</h2>

<p>J’ai fait de l’assembleur il y a longtemps. Ça ne m’a jamais vraiment manqué,
mais j’explorerais bien les micro contrôleurs en assembleur, par exemple.</p>

<h2 id="elm">Elm</h2>

<p>Un langage fonctionnel, réactif, sympa pour les jeux en
2D. Pas besoin d’en dire plus, je suis intrigué et je veux l’essayer, même si
ça se passe dans le navigateur.</p>

<h2 id="julia">Julia</h2>

<p>Lui, il veut carrément remplacer R, matlab, Octave, etc. Et d’après ce que j’en
ai déjà vu, il pourrait en avoir les moyens. Par contre je ne pense pas
apprendre R <strong>et</strong> Julia en même temps, donc Julia devra attendre.</p>

<h2 id="c">C</h2>

<p>Je n’avais pas fait de C depuis plusieurs années, à part avec l’Arduino mais ça
compte pas vraiment, n’est-ce pas ? Dernièrement j’ai écris un patch en C pour
le langage R et ça m’a donné envie de m’y remettre. Mais bon, c’est juste une
envie.</p>

<h2 id="f-sharp">F sharp</h2>

<p>Certainement que ça n’arrivera jamais (parce que pas le besoin) mais je trouve la
syntaxe élégante et intrigante. J’aimerais bien l’essayer.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[R : rep vs replicate]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/06/08/r-rep-vs-replicate/"/>
    <updated>2015-06-08T15:45:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/06/08/r-rep-vs-replicate</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Nouveau venu en R, je découvre régulièrement des nouvelles fonctions qui me
simplifient la vie. Comme par exemple la fonction <code>replicate</code> dont je vais
parler aujourd’hui.</p>

<p>Partons de l’hypothèse que je veuille générer plusieurs nombres aléatoires de
1 à 10. Pour ceci je dispose de la fonction <code>random</code> suivante, qui produit
justement un nombre aléatoire entre 1 et 10 :</p>

<!-- more -->

<p>``` r
random &lt;- function() {
  sample(1:10, size=1)
}</p>

<p>random()
[1] 5</p>

<p>random()
[1] 1
```</p>

<p>Comment faire pour obtenir <em>n</em> nombres aléatoires en utilisant cette fonction ?
Mettons quatre nombres. Si je me sers de <code>rep</code>, je vais avoir quelques
surprises :</p>

<p>``` r
rep(random(), 4)
[1] 8 8 8 8</p>

<p>rep(random(), 4)
[1] 2 2 2 2
```</p>

<p>En effet, l’appel à <code>random()</code> est fait avant la répétition, j’obtiens donc
quatre fois la même valeur.</p>

<p>Pour résoudre ce problème, je peux utiliser la fonction <code>replicate</code> :</p>

<p><code>r
replicate(4, random())
[1]  3  6 10  3
</code></p>

<p>Ça fonctionne car cette fois <code>random()</code> est appelé pour chacune des
répétitions.</p>

<p>Pour la petite histoire, <code>replicate</code> est un cas spécial de la fonction plus
générale <code>sapply</code> :</p>

<p><code>r
sapply(1:4, function(x) random())
[1] 10  4  2  1
</code></p>

<p>Dans ce cas d’utilisation précis <code>replicate</code> est plus confortable à utiliser,
puisque cette méthode évite de générer un vecteur inutile (<code>1:4</code>) et de passer par une fonction anonyme qui n’utilise pas son argument.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
