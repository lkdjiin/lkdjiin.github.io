<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : R | Xavier Nayrac]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/r/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2015-06-08T16:30:12+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[R : rep vs replicate]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/06/08/r-rep-vs-replicate/"/>
    <updated>2015-06-08T15:45:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/06/08/r-rep-vs-replicate</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Nouveau venu en R, je découvre régulièrement des nouvelles fonctions qui me
simplifient la vie. Comme par exemple la fonction <code>replicate</code> dont je vais
parler aujourd’hui.</p>

<p>Partons de l’hypothèse que je veuille générer plusieurs nombres aléatoires de
1 à 10. Pour ceci je dispose de la fonction <code>random</code> suivante, qui produit
justement un nombre aléatoire entre 1 et 10 :</p>

<!-- more -->

<p>``` r
random &lt;- function() {
  sample(1:10, size=1)
}</p>

<p>random()
[1] 5</p>

<p>random()
[1] 1
```</p>

<p>Comment faire pour obtenir <em>n</em> nombres aléatoires en utilisant cette fonction ?
Mettons quatre nombres. Si je me sers de <code>rep</code>, je vais avoir quelques
surprises :</p>

<p>``` r
rep(random(), 4)
[1] 8 8 8 8</p>

<p>rep(random(), 4)
[1] 2 2 2 2
```</p>

<p>En effet, l’appel à <code>random()</code> est fait avant la répétition, j’obtiens donc
quatre fois la même valeur.</p>

<p>Pour résoudre ce problème, je peux utiliser la fonction <code>replicate</code> :</p>

<p><code>r
replicate(4, random())
[1]  3  6 10  3
</code></p>

<p>Ça fonctionne car cette fois <code>random()</code> est appelé pour chacune des
répétitions.</p>

<p>Pour la petite histoire, <code>replicate</code> est un cas spécial de la fonction plus
générale <code>sapply</code> :</p>

<p><code>r
sapply(1:4, function(x) random())
[1] 10  4  2  1
</code></p>

<p>Dans ce cas d’utilisation précis <code>replicate</code> est plus confortable à utiliser,
puisque cette méthode évite de générer un vecteur inutile (<code>1:4</code>) et de passer par une fonction anonyme qui n’utilise pas son argument.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[3 réglages pour le langage R]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/04/23/3-reglages-pour-le-langage-r/"/>
    <updated>2015-04-23T15:17:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/04/23/3-reglages-pour-le-langage-r</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Voici trois astuces pour régler/personnaliser le comportement de
l’environnement du langage R, en utilisant des fichiers de configuration.
<em>(Attention, je ne sais absolument pas si ça fonctionne sous Windows.)</em></p>

<h2 id="le-prompt">1) Le prompt</h2>

<p>Pour personnaliser votre prompt dans R, ajoutez les lignes suivantes dans un
fichier <code>~/.Rprofile</code> (créez le pour l’occasion s’il n’existe pas).</p>

<p><code>r ~/.Rprofile
options(prompt = "R&gt; ")
options(continue = "+  ")
</code></p>

<p>Exemple :</p>

<pre><code>R&gt; add2 &lt;- function(n) {
+    n + 2
+  }
R&gt; 
</code></pre>

<!-- more -->

<h2 id="la-largeur-de-la-sortie-console">2) La largeur de la sortie console</h2>

<p>La largeur de la sortie console de R est de 80 caractères. Point barre !
Si votre console est plus large (100, 120, etc) R n’utilisera quand même que
80 caractères. En mettant une petite fonction dans un fichier à part
<code>~/.Rutils</code> (par exemple) et en référençant ce fichier depuis le <code>~/.Rprofile</code>,
on peut avoir quelque chose de <em>presque</em> dynamique.</p>

<p><code>r ~/.Rprofile
if (file.exists("~/.Rutils")) {
  source("~/.Rutils")
}
</code></p>

<p><code>r ~/.Rutils
tryCatch({
  options(width = as.integer(system('tput cols', intern = TRUE)))
}, error = function(err) {
  write("Width set to 80.", stderr());
  options(width = 80)
})
</code></p>

<p>Si vous redimensionnez votre console, il faut sourcer le fichier
(<code>source('~/.Rutils')</code>) pour prendre en compte la nouvelle largeur.</p>

<h2 id="le-dossier-des-bibliothques">3) Le dossier des bibliothèques</h2>

<p>Pour éviter que R vous crée un dossier <code>R</code> dans votre home, définissez vous
même un dossier pour stocker les packages, par exemple <code>~/local/R_libs/</code>.
Ensuite spécifiez le dans votre <code>~/.bashrc</code> :</p>

<p><code>bash
# Custom repo of libraries for R.
export R_LIBS=~/local/R_libs/
</code></p>

<p>Vous connaissez d’autres trucs et astuces pour configurer R ? Dites moi ça dans
un commentaire. À bientôt.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les sous-ensembles de listes dans R]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/04/09/les-sous-ensembles-de-listes-dans-r/"/>
    <updated>2015-04-09T07:47:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/04/09/les-sous-ensembles-de-listes-dans-r</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Après avoir parlé des <a href="http://lkdjiin.github.io/blog/2015/04/07/les-sous-ensembles-dans-r/">sous-ensembles de vecteurs</a> dans le langage R,
c’est maintenant le tour des listes. En R, une liste peut contenir des
types différents, au contraire du vecteur, limité à un seul type.
Prenons par exemple la liste suivante :</p>

<p><code>rconsole
&gt; x &lt;- list(1, 2, c("a", "b"))
</code></p>

<p>À l’affichage, on remarque qu’il s’agit d’une liste grâce aux doubles crochets
(<code>[[]]</code>) :</p>

<p>``` rconsole
&gt; x
[[1]]
[1] 1</p>

<p>[[2]]
[1] 2</p>

<p>[[3]]
[1] “a” “b”
```</p>

<!-- more -->

<p>Les éléments d’une liste peuvent être nommés. Suivant votre langage de
prédilection, vous pouvez penser à une liste R comme à un hash, un dictionnaire,
un tableau associatif, etc :</p>

<p>``` rconsole
&gt; x &lt;- list(foo = 1, bar = 2, baz = c(“a”, “b”))
&gt; x
$foo
[1] 1</p>

<p>$bar
[1] 2</p>

<p>$baz
[1] “a” “b”
```</p>

<p>Que se passe-t-il si on utilise la même syntaxe qu’avec un vecteur pour extraire
un élément d’une liste ?</p>

<p><code>rconsole
&gt; x[3]
$baz
[1] "a" "b"
</code></p>

<p>L’idée c’est que l’opérateur <code>[]</code> renvoie le même type d’objet que l’objet sur
lequel il est appliqué. Donc utiliser <code>[]</code> sur une liste retourne une liste :</p>

<p><code>rconsole
&gt; class(x[3])
[1] "list"
</code></p>

<p>Pour aller chercher un élément, et pas une liste à un seul élément, il faut
utiliser l’opérateur double crochets (<code>[[]]</code>) :</p>

<p><code>rconsole
&gt; x[[3]]
[1] "a" "b"
</code></p>

<p>Lorsque les éléments sont nommés, on peut bien sûr utiliser leurs noms comme
clé :</p>

<p><code>rconsole
&gt; x$baz
[1] "a" "b"
</code></p>

<p>Nous pouvons extraire un sous-ensemble d’une liste en passant les indices à
l’opérateur crochet (<code>[]</code>) :</p>

<p>``` rconsole
&gt; x &lt;- list(1, “2”, 3, 4, 5)</p>

<blockquote>
  <p>x[c(1, 3, 5)]
[[1]]
[1] 1</p>
</blockquote>

<p>[[2]]
[1] 3</p>

<p>[[3]]
[1] 5
```</p>

<p>Ou bien en lui donnant un vecteur de booléens :</p>

<p>``` rconsole
&gt; x[c(F, T, F, T, F)]
[[1]]
[1] “2”</p>

<p>[[2]]
[1] 4
```</p>

<p>En faisant la même chose avec l’opérateur double crochets (<code>[[]]</code>) nous pouvons
extraire le nième élément d’un vecteur :</p>

<p>``` rconsole
&gt; x &lt;- list(c(1, 2, 3), c(“a”, “b”, “c”))</p>

<blockquote>
  <p>x[[c(2, 1)]]
[1] “a”
```</p>
</blockquote>

<p>Ce qu’on peut décomposer ainsi, d’abord le 2ème élément de la liste :</p>

<p><code>rconsole
&gt; x[[2]]
[1] "a" "b" "c"
</code></p>

<p>Puis le premier élément du vecteur, la syntaxe commence à devenir drôle :</p>

<p><code>rconsole
&gt; x[[2]][[1]]
[1] "a"
</code></p>

<p>Question pour les connaisseurs du langage R : le code précédent me suggère qu’un vecteur
<em>agit</em> aussi comme une liste et que l’opérateur double crochet (<code>[[]]</code>) n’est pas
limité aux listes. Par exemple :</p>

<p><code>rconsole
&gt; y &lt;- c("a", "b", "c")
&gt; y
[1] "a" "b" "c"
&gt; y[[2]]
[1] "b"
&gt; y[2]
[1] "b"
&gt; y[[2]] == y[2]
[1] TRUE
</code></p>

<p>Est-ce qu’il y a un intérêt à utiliser les double crochets avec des vecteurs ?</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les sous-ensembles dans R]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/04/07/les-sous-ensembles-dans-r/"/>
    <updated>2015-04-07T19:12:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/04/07/les-sous-ensembles-dans-r</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>J’apprends <a href="http://www.r-project.org/">le langage R</a> ! C’est cool d’apprendre de nouvelles choses.
C’est encore plus cool de les partager ;) Comme je suis vraiment tout neuf avec
R, c’est mon premier article sur ce langage. Et comme il faut bien commencer
quelque part, je vais vous parler de certains moyens d’obtenir des
sous-ensembles d’un vecteur (un vecteur c’est à peu près comme une liste).</p>

<p><img class="center" src="/images/subset.png"></p>

<!-- more -->

<p>On lance le REPL :</p>

<pre><code>$ R
</code></pre>

<p>On va créer un ensemble de notes (<em>grades</em>).  Le symbole <code>&lt;-</code> est l’opérateur
d’affectation. La fonction <code>c()</code>, elle, permet de fabriquer un vecteur, avec
ici 10 notes allant de 1 à 5. <code>c()</code> assure la concaténation :</p>

<pre><code>&gt; grades &lt;- c(1, 2, 3, 2, 3, 2, 1, 4, 5, 2)
</code></pre>

<p>On peut vérifier ce qu’il y a dans <code>grades</code>. Le <code>[1]</code> indique qu’il s’agit d’un
vecteur dont on commence l’affichage par le 1er élément. R indexe en commençant
par 1, et non pas comme souvent par zéro :</p>

<pre><code>&gt; grades
 [1] 1 2 3 2 3 2 1 4 5 2
</code></pre>

<p>Pour être sûr de comprendre cette histoire de vecteur et d’index, créons et
affichons un vecteur de 40 éléments à l’aide de la syntaxe <code>début:fin</code> :</p>

<pre><code>&gt; 1:40
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
[26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40
</code></pre>

<p>Alors ces sous-ensembles ? Et bien commençons par une indexation classique, avec
<code>[]</code>, pour retrouver un seul élément (en fait un vecteur d’un seul élément) :</p>

<pre><code>&gt; grades[1]
[1] 1
</code></pre>

<p>On peut aussi retrouver un <em>range</em>, par exemple du 6ème au 8ème élément :</p>

<pre><code>&gt; grades[6:8]
[1] 2 1 4
</code></pre>

<p>Pour retrouver seulement les notes au dessus de 2 on met la condition entre les
crochets :</p>

<pre><code>&gt; grades[grades &gt; 2]
[1] 3 3 4 5
</code></pre>

<p>Il est intéressant de voir ce qu’on obtient avec <code>grades &gt; 2</code> :</p>

<pre><code>&gt; grades &gt; 2
 [1] FALSE FALSE  TRUE FALSE  TRUE FALSE FALSE  TRUE  TRUE FALSE
</code></pre>

<p>On obtient un vecteur de valeurs booléennes ! <em>TRUE</em> si la note est supérieure
à 2, <em>FALSE</em> dans le cas contraire.</p>

<p>Rangeons ce vecteur de booléens dans une variable <code>mask</code> et servons nous de
cette nouvelle variable pour obtenir le sous-ensemble des notes supérieures
à 2 :</p>

<pre><code>&gt; mask &lt;- grades &gt; 2
&gt; grades[mask]
[1] 3 3 4 5
</code></pre>

<p>Pour finir, utilisons directement un vecteur de booléens pour récupérer les
éléments n° 4, 5, 6, 9 et 10 (<em>F</em> et <em>T</em> sont des raccourcis pour <em>FALSE</em> et
<em>TRUE</em>) :</p>

<pre><code>&gt; grades[c(F, F, F, T, T, T, F, F, T, T)]
[1] 2 3 2 5 2
</code></pre>

<p>Voilà, mon premier article sur R est terminé, je vais certainement en écrire
plein d’autres dans un futur proche. J’espère que ce sujet vous intéresse ;)</p>

<pre><code>&gt; q()
</code></pre>

<p></p>
]]></content>
  </entry>
  
</feed>
