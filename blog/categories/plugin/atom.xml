<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : plugin | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/plugin/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2014-01-25T18:40:58+01:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Installation du plugin Airline pour Vim - partie 1]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/01/25/installation-du-plugin-airline-pour-vim-partie-1/"/>
    <updated>2014-01-25T18:34:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/01/25/installation-du-plugin-airline-pour-vim-partie-1</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Pour disposer de quelques informations dans la barre de statut,
j'utilisais jusqu'ici statline, qui me convenait assez bien, rien de
tape à l'œil. Et puis j'ai décidé d'essayer quelque chose de
plus coloré, histoire de voir si ça m'était utile.</p>

<!-- more -->


<p>Avant d'installer <a href="https://github.com/bling/vim-airline">Airline</a>,
il faut bien entendu retirer Powerline, ou Statline (je n'en connais pas
d'autres).</p>

<p>Comme j'utilise Pathogen pour gérer mes plugins, voici comment rapatrier
le code d'Airline:</p>

<pre><code>git clone https://github.com/bling/vim-airline ~/.vim/bundle/vim-airline
</code></pre>

<p>La documentation est exhaustive et fournit
<a href="https://github.com/bling/vim-airline#installation">ici</a>
d'autres méthodes d'installation pour Vundle, NeoBundle et VAM.</p>

<p>Avec Pathogen, ne pas oublier de générer la documentation, vous en
aurez besoin pour personnaliser l'apparence et les fonctionnalités
de Airline:</p>

<p><code>vim
:Helptags
</code></p>

<p>Un rapide coup d'œil à la documentation, justement, montre que la
personnalisation aux petits oignons va prendre un peu plus longtemps
que quelques minutes. Bref, on va devoir se manger de la doc…</p>

<p>À ce stade, c'est à dire en ayant seulement installé Airline et rien
configuré encore, ça fonctionne déja. Mais curieusement (du moins c'est
curieux à mes yeux) Airline est configuré par défaut pour n'apparaître que
lorsqu'une fenêtre est splittée. Pour l'avoir tout le temps, il faut ajouter
ceci dans le <code>.vimrc</code>:</p>

<p><code>vim
set laststatus=2
</code></p>

<p>La prochaine fois, je m'attaquerais à la modification du thème.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Un plugin Vim pour replier/folder les commentaires]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/12/02/un-plugin-vim-pour-replier-slash-folder-les-commentaires/"/>
    <updated>2013-12-02T18:27:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/12/02/un-plugin-vim-pour-replier-slash-folder-les-commentaires</id>
    <content type="html"><![CDATA[<p>Dans un <a href="http://lkdjiin.github.io/blog/2013/11/28/vim-plier-folder-les-commentaires-de-style-unix/">article précédent</a>, je montrai comment écrire une fonction pour
folder les commentaires de style Unix dans un fichier. Cette solution avait
plusieurs limites alors j'ai eu envie d'en faire un plugin plus
intéressant. Je vous présente donc vim-foldcomments, mon premier plugin
pour Vim.</p>

<!-- more -->


<p>Pouvoir folder/replier tous les commentaires d'un fichier peut être
utile quand vous étudiez un tout nouveau code, ou au contraire, quand vous
travaillez sur un code bien connu.
Vous pouvez trouver le plugin sur Github: <a href="https://github.com/lkdjiin/vim-foldcomments">vim-foldcomments</a>.
Une fois installé, avec <a href="https://github.com/tpope/vim-pathogen">Pathogen</a> par exemple,
vous pouvez taper la commande:</p>

<pre><code>:FoldComments
</code></pre>

<p>pour replier les commentaires du fichier. Personnelement j'ai mappé cette
commande sur la touche F5 en mettant ceci dans mon .vimrc:</p>

<p><code>vim
map&lt;F5&gt; FoldComments&lt;Enter&gt;
</code></p>

<p>Le plugin est en version béta et ne gère pour l'instant que quelques
langages: Ruby, Haskell, Java, C, Javascript, Logo, Racket, Scheme, Vim,
ainsi que tous commentaires de style Unix (<code>#</code>). Les commentaires
multilignes (<code>/* … */</code> en C ou encore <code>=begin … =end</code> en Ruby) sont aussi
pris en compte.</p>

<p>N'hésitez pas à le tester et à me donner votre opinion. Vous pouvez aussi
bien sûr participer au code sur Github.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vim: Coloration syntaxique des parenthèses]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/11/02/vim-coloration-syntaxique-des-parentheses/"/>
    <updated>2013-11-02T12:04:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/11/02/vim-coloration-syntaxique-des-parentheses</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Je l'ai annoncé sur ce blog, je suis en train d'apprendre Racket (dérivé de
Scheme, de Lisp). Donc un langage qui fait un très large usage des
parenthèses.</p>

<p><img src="/images/rainbow-parentheses.png"></p>

<!-- more -->


<p>C'est là que le plugin <a href="http://www.vim.org/scripts/script.php?script_id=3772">Rainbow Parentheses</a> peut aider.
Il colore les parenthèses différement suivant le niveau d'imbrication.
Il n'est pas activé par défaut, et c'est tant mieux: ce type de coloration
syntaxique n'est pas utile tout le temps, mais seulement à certains moments,
quand on se sent un peu perdu
(<em>sinon, bonjour l'effet sapin de Noël</em>). Pour l'activer/le désactiver, il suffit de
taper:</p>

<p><code>vim
:RainbowParenthesesToggle
</code></p>

<p>Si vous l'utilsez régulièrement, il sera sûrement utile de mapper la fonction
précédente. Par exemple pour l'avoir en tapant la touche <code>leader</code> puis <code>p</code>,
vous ajouterez ceci dans votre .vimrc:</p>

<p><code>vim
map &lt;Leader&gt;p :RainbowParenthesesToggle&lt;Enter&gt;
</code></p>

<p>Le plugin Rainbow Parentheses peut aussi colorer d'autres paires de caractères,
comme <code>[]</code>, <code>{}</code> et <code>&lt;&gt;</code>. Consultez le readme pour en savoir plus.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Un plugin Octopress pour les articles connexes]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/08/22/un-plugin-octopress-pour-les-articles-connexes/"/>
    <updated>2013-08-22T15:56:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/08/22/un-plugin-octopress-pour-les-articles-connexes</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Je cherchais un plugin Octopress pour embarquer une section d'articles
connexes (<em>related posts</em>) dans certains articles et, curieusement, je
n'en ai pas trouvé. C'est donc l'occasion d'écrire mon second plugin pour
Octopress.</p>

<!-- more -->


<p>Pour voir ce que fait ce plugin, il vous suffit de regarder la section
«Articles connexes» à la fin de cet article. Le code est sur Github:
<a href="https://github.com/lkdjiin/octopress-connexe">octopress-connexe</a>.</p>

<p>Je vais commenter quelques unes des méthodes:</p>

<p>``` ruby
def my_categories(context)
  context.environments.first[&ldquo;page&rdquo;][&ldquo;categories&rdquo;]
end</p>

<p>def my_url(context)
  context.environments.first[&ldquo;page&rdquo;][&ldquo;url&rdquo;]
end
```</p>

<p>J'ai séché un certain temps là-dessus. Pour connaitre les informations
relative à l'article courant, on se sert de
<code>context.environments.first["page"]</code>.</p>

<p>Et voici comment je fais la sélection des articles connexes:</p>

<p>``` ruby
def build_posts(context)
  remove_unrelated_posts
  remove_current_post(context)
  sort_posts
end</p>

<p>def remove_unrelated_posts
  @posts = @posts.select do |post|</p>

<pre><code>result = false
@categories.each do |category|
  result = true if post.categories.include?(category)
end
result
</code></pre>

<p>  end
end</p>

<p>def remove_current_post(context)
  @posts.delete_if {|post| post.url == my_url(context)}
end</p>

<p>def sort_posts
  @posts = @posts.map do |post|</p>

<pre><code>weight = 0
@categories.each do |category|
  weight += 1 if post.categories.include?(category)
end
[weight, post]
</code></pre>

<p>  end
  @posts = @posts.sort.reverse
end
```</p>

<p>Dans un premier temps, j'écarte les articles qui n'ont pas au moins
une catégorie commune avec l'article courant. C'est le rôle de la méthode
<code>remove_unrelated_posts</code>. Puis après avoir écarter de la liste l'article
courant, il ne reste plus qu'à trier avec la méthode <code>sort_posts</code>. Dans cette
méthode, j'attribue un poid à chaque article en fonction du nombre de
catégories communes. C'est ce poid qui sert de référence pour le tri.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Comment écrire un plugin Octopress - partie 2]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/07/30/comment-ecrire-un-plugin-octopress-partie-2/"/>
    <updated>2013-07-30T08:18:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/07/30/comment-ecrire-un-plugin-octopress-partie-2</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Dans <a href="http://lkdjiin.github.io/blog/2013/07/27/comment-ecrire-un-plugin-octopress/">la première partie</a>,
je m'étais arrêté sur le code suivant:</p>

<p>``` ruby
module Jekyll
  class LevelTag &lt; Liquid::Tag</p>

<pre><code>def initialize(tagname, level, tokens)
  @level = level
end

def render(context)
  "Niveau : #{@level}"
end
</code></pre>

<p>  end
end
Liquid::Template.register_tag(&lsquo;level&rsquo;, Jekyll::LevelTag)
```</p>

<p>Aujourd'hui je montre comment permettre à l'utilisateur de personnaliser
le contenu du code Html produit.</p>

<!-- more -->


<p>Tout d'abord, voici le code du plugin terminé. Je vous rappelle que vous
pouvez trouver <a href="https://github.com/lkdjiin/octopress-level-tag">ce plugin sur Github</a>.</p>

<p>``` ruby
module Jekyll
  class LevelTag &lt; Liquid::Tag</p>

<pre><code>def initialize(tagname, level, tokens)
  @level = level.strip
end

def render(context)
  config = context.registers[:site].config
  label = config['level_tag_level'] || "Level: "
  level = case @level
  when "1" then config['level_tag_level_1'] || "easy"
  when "2" then config['level_tag_level_2'] || "medium"
  when "3" then config['level_tag_level_3'] || "hard"
  else
    "unknown"
  end
  classes = "class='level-tag level-tag-#{@level}'"
  "&lt;div #{classes}&gt;#{label}&lt;span&gt;#{level}&lt;/span&gt;&lt;/div&gt;"
end
</code></pre>

<p>  end</p>

<p>end
Liquid::Template.register_tag(&lsquo;level&rsquo;, Jekyll::LevelTag)
```</p>

<p>L'appel du plugin dans les articles sera maintenant réalisé comme ceci:</p>

<p><code>ruby
<div class='level-tag level-tag-1'>Niveau : <span>facile</span></div>
</code></p>

<p>Par rapport à la première version, la méthode <code>render</code> a bien enflée. &ndash;
<em>Je trouve qu'il y a trop de code dedans, mais ce sera peut-être le sujet
d'un prochain article sur le refactoring.</em> &ndash; C'est cette méthode qui fait
tout le travail, voici les explications:</p>

<p>``` ruby</p>

<pre><code>def render(context)
  config = context.registers[:site].config
  label = config['level_tag_level'] || "Level: "
</code></pre>

<p>```</p>

<p>C'est l'objet <code>context</code> qui va permettre de récupérer les informations
nécéssaires dans le fichier de configuration <code>_config.yml</code>. Voici par
exemple ce que j'ai ajouté dans mon <code>_config.yml</code>:</p>

<p>``` yaml</p>

<h1>LevelTag plugin</h1>

<p>level_tag_level: &ldquo;Niveau : &rdquo;
level_tag_level_1: &ldquo;facile&rdquo;
level_tag_level_2: &ldquo;intermédiaire&rdquo;
level_tag_level_3: &ldquo;avancé&rdquo;
```</p>

<p>La ligne suivante:</p>

<pre><code>label = config['level_tag_level'] || "Level: "
</code></pre>

<p>initialise la
variable <code>label</code> avec le contenu de <code>level_tag_level</code>, trouvé dans le
<code>_config.yml</code>. La partie du code <code>|| "Level: "</code> est là pour s'assurer que
si <code>level_tag_level</code> n'existe pas dans le fichier de configuration, <code>label</code>
sera bien initialisé avec une valeur par défaut.</p>

<p>``` ruby</p>

<pre><code>  level = case @level
  when "1" then config['level_tag_level_1'] || "easy"
  when "2" then config['level_tag_level_2'] || "medium"
  when "3" then config['level_tag_level_3'] || "hard"
  else
    "unknown"
  end
</code></pre>

<p>```</p>

<p>C'est la même logique que précédement. La variable <code>level</code> sera initialisée
avec du contenu trouvé dans <code>_config.yml</code> ou bien, avec une valeur par
défaut.</p>

<p>``` ruby</p>

<pre><code>  classes = "class='level-tag level-tag-#{@level}'"
  "&lt;div #{classes}&gt;#{label}&lt;span&gt;#{level}&lt;/span&gt;&lt;/div&gt;"
</code></pre>

<p>```</p>

<p>Finalement, comme dans <a href="http://lkdjiin.github.io/blog/2013/07/27/comment-ecrire-un-plugin-octopress/">la première partie</a>,
on retrouve en fin de méthode la production du code Html.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
