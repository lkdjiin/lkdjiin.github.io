<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : alias | Xavier Nayrac]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/alias/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2019-11-10T11:16:39+01:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Lister un dossier tout en nettoyant l'écran]]></title>
    <link href="http://lkdjiin.github.io/blog/2018/02/14/lister-un-dossier-tout-en-nettoyant-lecran/"/>
    <updated>2018-02-14T10:28:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2018/02/14/lister-un-dossier-tout-en-nettoyant-lecran</id>
    <content type="html"><![CDATA[<p>Deux ou trois fois dans l’année j’analyse mon usage du clavier pour tenter
d’augmenter mon confort quotidien. Lisez : Je regarde de près ce que je
tape pour faire en sorte de taper toujours moins.</p>

<p>J’ai remarqué récemment que j’aimais de plus en plus avoir un écran vide avant
d’entreprendre une série de commande. Pour effacer l’écran, on utilise la commande
<code>clear</code> ou son raccourci <code>Ctrl+L</code>. Et depuis quelques temps je me suis habitué
à systématiquement vider l’écran avant de lister le contenu d’un répertoire.
Autrement dit je répète très souvent la séquence de touche suivante :</p>

<center><b>Ctrl + l + l + s + Enter</b></center>

<p>Soit 5 touches.</p>

<p>Donc, beaucoup trop.</p>

<!-- more -->

<h2 id="alias-s">Alias S</h2>

<p>Un petit alias sera la solution pour prendre soin de mes poignets fragiles ;)
Je vais utiliser la lettre <code>s</code> parce que sa touche tombe particulièrement bien
sous mes doigts.</p>

<center><b>s + Enter</b></center>

<p>Soit 2 touches.</p>

<p>Donc, je suis content :)</p>

<h2 id="bash">Bash</h2>

<p>Avec Bash, que j’utilise essentiellement sur serveurs distants, voici comment
procéder :</p>

<p><code>bash
alias s='clear;ls' # List directory on a clean screen
</code></p>

<p>Je place mes alias Bash dans un fichier <code>~/.bash_aliases</code> que j’inclus depuis
le fichier <code>~/.bashrc</code> comme ceci :</p>

<p>```bash
# Alias definitions.
# You may want to put all your additions into a separate file like
# ~/.bash_aliases, instead of adding them here directly.
# See /usr/share/doc/bash-doc/examples in the bash-doc package.</p>

<p>if [ -f ~/.bash_aliases ]; then
    . ~/.bash_aliases
fi
```</p>

<h2 id="fish">Fish</h2>

<p>Avec Fish, que j’utilise sur mes machines perso, c’est un peu différent. Fish
n’a pas de commande <code>alias</code>, il suffit d’écrire une fonction au bon endroit.</p>

<p><code>
# Fichier ~/.config/fish/functions/s.fish
function s --description 'List directory on a clean, cleared screen'
  	clear
    ls
end
</code></p>

<h2 id="conclusion">Conclusion</h2>

<p>Je ne sais pas si je vais beaucoup me servir de cette commande <code>s</code>.
J’ai toujours eu du mal à m’habituer aux commandes d’une seule lettre, je sais
pas pourquoi. On verra bien…</p>

<p>Si vous avez des astuces dans le même genre, faites moi en part dans un
commentaire, ça pourrait servir ;)</p>

<p>À bientôt.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[De meilleurs alias avec zsh]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/07/20/de-meilleurs-alias-avec-zsh/"/>
    <updated>2015-07-20T13:12:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/07/20/de-meilleurs-alias-avec-zsh</id>
    <content type="html"><![CDATA[<h2 id="guest-post-"><code>{ Guest Post }</code></h2>

<p>Pour m’améliorer en tant que dev, j’essaye au maximum de simplifier et d’automatiser mon workflow. L’idée est de passer moins de temps à faire des choses qu’un ordinateur peut faire à ma place, et plus de temps à réfléchir aux problèmes que je cherche à résoudre.</p>

<p>C’est dans cette optique que je me suis mis à ajouter énormément d’alias très courts à mon shell. Un alias revient à automatiser l’action de taper sur les touches pour des commandes fréquentes. Malheureusement, les alias sont sous-utilisés pour plusieurs raisons : on a peur d’oublier la commande qui se cache derrière, un autre dev avec qui on est en train de faire du pair programming aura du mal à comprendre quelles commandes sont exécutées, et souvent on oublie tout simplement qu’on a un alias pour la commande qu’on est en train de taper.</p>

<p>Pour remédier à ces problèmes, j’ai trouvé des solutions que des fonctions avancées de zsh permettent d’implémenter : les alias explicites, et les alias obligatoires.</p>

<!-- more -->

<h2 id="zsh">zsh</h2>

<p>zsh est un shell Unix similaire à bash, mais en mieux. On cite souvent son autocompletion et la quantité de plugins disponibles, notamment ceux de <a href="https://github.com/robbyrussell/oh-my-zsh">oh-my-zsh</a>, comme les principales raisons de passer de bash à zsh.</p>

<p>zsh est installé par défaut sur la plupart des distributions linux et OSX. Si vous ne l’utilisez pas encore, vous pouvez en faire votre shell par défaut avec cette commande :</p>

<p><code>
chsh -s $(which zsh)
</code></p>

<h2 id="les-alias-explicites">Les alias explicites</h2>

<p>C’est une fonction que @lkdjiin connait bien puisque c’est une des premières améliorations que j’ai apporté à mes alias quand j’ai commencé à travailler avec lui.
Voilà à quoi ça ressemble:</p>

<p><img src="https://cloud.githubusercontent.com/assets/1840367/8545448/16b25cfc-24af-11e5-85ab-69f77424b532.gif" alt="explicit_aliases" /></p>

<p>Afin de ne pas oublier la commande qui se cache derrière un alias, les alias explicite la font s’afficher comme si elle avait été entrée juste après l’alias.
Voici le code à rajouter dans votre .zshrc (le fichier de config que zsh charge avant chaque session) pour activer les alias explicites:</p>

<p>```
preexec_functions=()</p>

<p>function expand_aliases {
  input_command=$1
  expanded_command=$2
  if [ $input_command != $expanded_command ]; then
    print -nP $PROMPT
    echo $expanded_command
  fi
}</p>

<p>preexec_functions+=expand_aliases
```</p>

<p>Les preexec functions de zsh sont des fonctions qui sont appelées après qu’une commande soit lue, et avant qu’elle ne soit exécutée. zsh leur donne comme argument la commande telle qu’elle est entrée par l’utilisateur, et la même commande après l’expansion des alias.</p>

<p>Cette fonction vérifie donc que la version étendue est différente de la version entrée par l’utilisateur (c’est à dire qu’un alias a été utilisé), et le cas échéant affiche un prompt en utilisant la variable <code>$PROMPT</code> suivi de la commande.</p>

<h2 id="les-alias-obligatoires">Les alias obligatoires</h2>

<p>Cette idée plaît parfois un peu moins : pour ne pas oublier l’existence d’un alias, j’ai modifié mon setup pour que zsh refuse d’exécuter une commande si je la tape en entier plutôt que de me servir d’un alias.</p>

<p><img src="https://cloud.githubusercontent.com/assets/1840367/7302861/9e437a96-e9ec-11e4-9978-9f33f21bd7d9.gif" alt="mandatory_alias" /></p>

<p>Et voici l’implémentation dans le .zshrc:</p>

<p>```
function check-alias-and-accept {
  if [ $BUFFER ]; then</p>

<pre><code>ALIAS=`alias -L | grep -e "=[\'\"]\?${BUFFER}[\'\"]\?$"`

if [ $ALIAS ]; then
  echo
  echo "You have this alias:"
  echo
  echo $ALIAS
  echo
  echo "Use it!"

  zle kill-whole-line
  zle reset-prompt
else
  zle accept-line
fi   else
zle accept-line   fi }
</code></pre>

<p>zle -N check-alias-and-accept
bindkey ‘^J’ check-alias-and-accept
bindkey ‘^M’ check-alias-and-accept
```</p>

<p>J’utilise ici une fonction peu connue de zsh: le Zsh Line Editor, ou zle. Il s’agit du programme que zsh execute pendant qu’il lit les évènements clavier de l’utilisateur (alors que les precommand functions sont exécutées après que l’utilisateur ai fini d’entrer la commande). C’est ce programme qui lance l’autocomplétion lorsque qu’on appuie sur TAB par exemple.</p>

<p>L’implémentation est un peu plus compliquée que pour les alias explicites. Regardons un peu plus en détails ce qui se passe:</p>

<ul>
  <li>Les trois dernières lignes sont pour enregistrer la fonction <code>check-alias-and-accept</code> à la liste des fonctions que zle peut appeler, et binder la touche Entrée à l’appel de cette fonction.</li>
  <li>A l’intérieur de <code>check-alias-and-accept</code>, on commence par vérifier que l’utilisateur a entré quelque chose, ce qui est indiqué par la variable <code>$BUFFER</code> initialisée par zle. Si rien n’a été entré (dans la branche du else), on appelle tout simplement la fonction <code>zle accept-line</code>, qui est celle que zle executerait normalement à l’appui sur la touche Entrée.</li>
  <li>Si il y a une commande, on cherche parmis tous les alias si il y en a un qui correspond. <code>alias -L</code> permet d’obtenir la liste de tous les alias de la config, et un grep avec une regexp un peu sauvage permet de les filtrer.</li>
  <li>Si un alias correspond, les fonctions <code>zle kill-whole-line</code> et <code>zle reset-prompt</code> permettent de revenir à un prompt vide. La commande est donc effacée et n’apparaitra même pas dans l’historique.</li>
</ul>

<h2 id="et-bien-plus-encore">Et bien plus encore</h2>

<p>zsh est un shell très puissant lorsqu’on a le courage de lire son manuel, et permet de customizer votre setup de manière très poussée. Pour plus de customization zsh et vim, jetez un coup d’oeil à mes <a href="https://github.com/victormours/dotfiles">dotfiles</a>, et si vous avez des idées pour d’autres améliorations à base de zsh, <a href="http://twitter.com/victormours">envoyez-les moi sur twitter</a> !</p>

<h1 id="qui-a-crit-cet-article-">Qui a écrit cet article ?</h1>

<p><img src="https://avatars3.githubusercontent.com/u/1840367?v=3&amp;s=200"></p>

<p><strong>Victor Mours</strong><br />
Lead developer chez sleekapp.io, obsessionnel des dotfiles</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Comment réduire les erreurs de frappe dans la console]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/04/06/comment-reduire-les-erreurs-de-frappe-dans-la-console/"/>
    <updated>2014-04-06T20:52:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/04/06/comment-reduire-les-erreurs-de-frappe-dans-la-console</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Régulièrement j’analyse mon fichier <code>~/.bash_history</code>.
Régulièrement ça veut dire 2 ou 3 fois par an. Et je regarde ce qui revient
le plus pour voir si je peux en transformer certaines en alias.
Quel rapport avec les fautes de frappe ?</p>

<!-- more -->

<p>La dernière fois que je l’ai regardé, ce fameux fichier <code>~/.bash_history</code>,
j’ai trouvé un nombre non négligeable de lignes qui débutaient par <code>gti</code>.
Et oui, j’écris souvent <code>gti</code> au lieu de <code>git</code> ! On a tous des petits
défauts de ce type, non ?</p>

<p>J’imagine que nombre d’entre vous ont déjà ce genre de choses dans
leur fichier <code>~/.bashrc</code> (ou <code>~/.bash_profile</code>), mais pour ceux qui n’y
avait pas encore pensé, la solution consiste à faire un alias:</p>

<p><code>bash
alias gti='git'
</code></p>

<p>Alors d’accord, le titre de cet article ment un peu ;) Ça ne réduit pas
mes fautes de frappes, mais ça les rend transparentes, c’est déjà très bien.</p>

<script id="fb33k8u">(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
