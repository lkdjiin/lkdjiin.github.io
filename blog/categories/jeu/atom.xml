<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : jeu | Xavier Nayrac]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/jeu/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2016-02-10T11:28:40+01:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Écrire un jeu en 2d avec Ruby et Gosu - partie 1]]></title>
    <link href="http://lkdjiin.github.io/blog/2016/02/10/ecrire-un-jeu-en-2d-avec-ruby-et-gosu-partie-1/"/>
    <updated>2016-02-10T10:44:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2016/02/10/ecrire-un-jeu-en-2d-avec-ruby-et-gosu-partie-1</id>
    <content type="html"><![CDATA[<p>Voici une série d’articles sur l’écriture d’un jeu en 2d avec Ruby et Gosu.
Dans ce premier article on verra comment installer Gosu, créer une
fenêtre et afficher des images statiques les unes au dessus des autres.</p>

<p><img class="center" src="/images/gosu0.png"></p>

<!-- more -->

<h2 id="les-outils">Les outils</h2>

<p>Avant d’écrire la première ligne de code, assurez vous d’avoir installé correctement Ruby et la
gem Gosu.</p>

<h3 id="ruby">Ruby</h3>

<p>J’utiliserai Ruby en version 2.3 (la plus récente à ce jour). Si vous
utilisez une version de Ruby plus ancienne, vous devrez peut-être adapter le
code ici ou là. Pour gérer les différentes version de Ruby, j’utilise
indifféremment <a href="https://rvm.io/">rvm</a> ou
<a href="https://github.com/postmodern/chruby">chruby</a>
<em>— mais pas les deux sur la même machine, hein ;) —</em>.</p>

<blockquote>
  <p>Si vous n’avez jamais utilisé de gestionnaire de version pour Ruby, je
conseille de commencer par <strong>chruby</strong>. Si je préfère personnellement
<strong>rvm</strong> que je trouve plus complet, <strong>chruby</strong> s’avère
indéniablement plus simple à installer, à prendre en main, et à utiliser sur le
long terme.</p>
</blockquote>

<h3 id="gosu">Gosu</h3>

<p>Gosu est la gem qui nous fournira les méthodes basiques pour développer notre
jeu. J’ai installé la dernière version en date : gosu 0.10.5.</p>

<p>Sur <strong>Debian</strong> il faut d’abord s’assurer qu’on dispose des packages suivants:</p>

<pre><code>sudo apt-get install build-essential libsdl2-dev libsdl2-ttf-dev \
                     libpango1.0-dev libgl1-mesa-dev libfreeimage-dev \
                     libopenal-dev libsndfile1-dev
</code></pre>

<p>Et ensuite seulement on peut installer la gem Gosu:</p>

<pre><code>gem install gosu
</code></pre>

<p>Vous pouvez installer Gosu sur d’autres versions de Linux, sur OS X, ou sur
Windows:</p>

<ul>
  <li><a href="https://github.com/gosu/gosu/wiki/Getting-Started-on-Linux">Installation sur Linux</a></li>
  <li><a href="https://github.com/gosu/gosu/wiki/Getting-Started-on-OS-X">Installation sur OS X</a></li>
  <li><a href="https://github.com/gosu/gosu/wiki/Getting-Started-on-Windows">Installation sur Windows</a></li>
</ul>

<p>Enfin, vous pourrez trouver de l’aide sur <a href="https://github.com/gosu/gosu/wiki">le wiki</a>
et <a href="https://www.libgosu.org/rdoc/">la documentation de Gosu</a> pour le langage Ruby.</p>

<h2 id="du-son-des-images-etc">Du son, des images, etc</h2>

<p>Dans cette série d’articles nous allons coder un jeu. Pour ce qui est du son
et des images, on va laisser faire les gens qui savent ;) Mes deux sources
préférées pour les assets open source sont <a href="http://freesound.org/browse/">freesound.org</a>
et <a href="http://opengameart.org/">opengameart.org</a>.</p>

<p>J’utilise <strong>Gimp</strong> pour retoucher les images : découpe, mise à l’échelle,
changement de couleur, etc. Et j’utilise <strong>Audacity</strong> pour retravailler les
fichiers sonores : suppression des silences en début de fichier, conversion de
format (par exemple mp3 en ogg puisque Gosu ne lit pas le mp3).</p>

<h2 id="crer-une-fentre-pour-le-jeu">Créer une fenêtre pour le jeu</h2>

<p>Ça y est ! Ruby et Gosu sont installés, vous savez où trouver des images et du
son open source, on peut commencer en créant une fenêtre. Mettez le code
suivant dans un fichier <code>window.rb</code>:</p>

<p>```ruby window.rb
require ‘gosu’</p>

<p>class Window &lt; Gosu::Window</p>

<p>def initialize
    super(640, 480)
    self.caption = “Collect The Smile!”
  end</p>

<p>end</p>

<p>window = Window.new
window.show
```</p>

<p>Le code est suffisamment simple pour que vous puissiez le comprendre sans
explications superflues. Pour savoir si vous avez bien installé Gosu, lancez
le programme:</p>

<pre><code>$ ruby window.rb
</code></pre>

<p>Et admirez le résultat:</p>

<p><img class="center" src="/images/gosu1.png"></p>

<p>Même avec si peu de code, on peut déjà refactorer. Le fichier précédent
a deux problèmes. Un, il mélange la définition d’une classe et le lancement du
jeu. Et deux, il utilise deux nombres magiques. Si on n’y prends pas garde, les
nombres magiques vont vite devenir un fléau pour notre jeu. Les jeux ont tendance
à être saturés de nombres magiques, alors autant s’atteler à ce problème dès le début.</p>

<p>Après refactoring,
nous avons donc d’une part le code de lancement, avec des constantes pour les
dimensions.  On n’a plus à deviner ce que représente les nombres 640 et 480,
c’est inscrit dans le code:</p>

<p>```ruby main.rb
require ‘gosu’</p>

<p>require_relative ‘window’</p>

<p>WindowWidth  = 640
WindowHeight = 480</p>

<p>window = Window.new(WindowWidth, WindowHeight)
window.show
```</p>

<p>Et d’autre part la classe <code>Window</code>, tranquille dans son propre fichier:</p>

<p>```ruby window.rb
class Window &lt; Gosu::Window</p>

<p>def initialize(width, height)
    super
    self.caption = “Collect The Smile!”
  end</p>

<p>end
```</p>

<p>La structure du dossier est pour l’instant la suivante:</p>

<pre><code>$ tree
.
├── window.rb
└── main.rb
</code></pre>

<p>Et nous lancerons donc le jeu avec la commande <code>ruby main.rb</code>.</p>

<h2 id="afficher-des-images">Afficher des images</h2>

<p>Maintenant qu’on sait créer une fenêtre, l’étape suivante sera l’affichage
d’images statiques. Nous allons afficher une image de fond, et par-dessus
l’image du joueur.</p>

<p>Toutes les images du jeu seront rangées dans le dossier <code>assets/images</code>:</p>

<pre><code>$ tree
.
├── assets
│   └── images
│       ├── background.png
│       └── player.png
├── window.rb
└── main.rb
</code></pre>

<p>```ruby window.rb
class Window &lt; Gosu::Window</p>

<p>def initialize(width, height)
    super
    self.caption = “Collect The Smile!”</p>

<pre><code>@background_image = Gosu::Image.new("assets/images/background.png")
@player_image = Gosu::Image.new("assets/images/player.png")   end
</code></pre>

<p>def draw
    @background_image.draw(0, 0, 0)
    @player_image.draw(width / 2, height / 2, 1)
  end</p>

<p>end
```</p>

<p>Pendant l’initialisation on charge les images en mémoire avec
<code>Gosu::Image.new</code>.  Puis l’affichage se fait avec <strong>les</strong> méthodes <code>draw</code>. La
méthode <code>draw</code> de la classe <code>Window</code> est hérité de <code>Gosu::Window</code> et appelée 60
fois par seconde.  Dans cette méthode, on appelle la méthode <code>draw</code> des images.
Celle-ci prends trois paramètres : les coordonnées <strong>x</strong>, <strong>y</strong> et <strong>z</strong>.
La coordonnée z est le plan d’affichage. Au dessus ou en dessous. Plus le
nombre est haut, plus l’image sera affichée au-dessus des autres. Ici l’image
de fond a un z de 0, et l’image du joueur a un z de 1, donc le joueur est
affiché au-dessus du fond.</p>

<p>Le joueur est affiché <em>à peu près</em> au milieu de la surface de jeu (<code>width / 2</code>
et <code>height / 2</code>). À peu près, puisque les paramètres x et y de la méthode
<code>draw</code> définissent les coordonnées du coin supérieur gauche de l’image.</p>

<p><img class="center" src="/images/gosu2.png"></p>

<p>Ce code souffre lui aussi de certains problèmes.</p>

<ol>
  <li>S’il est acceptable que l’image de fond <em>appartienne</em> à la fenêtre de jeu,
c’est absurde en ce qui concerne l’image du joueur.</li>
  <li>Il y a des nouveaux nombres magiques : les coordonnées z.</li>
</ol>

<p>On va donc créer deux nouvelles classes (en fait une classe et un module),
<code>ZOrder</code> et <code>Player</code>:</p>

<p>```ruby main.rb
require ‘gosu’</p>

<p>require_relative ‘z_order’
require_relative ‘player’
require_relative ‘window’</p>

<p>WindowWidth  = 640
WindowHeight = 480</p>

<p>window = Window.new(WindowWidth, WindowHeight)
window.show
```</p>

<p>Le contenu du module <code>ZOrder</code> est simpliste (c’est ni plus ni moins qu’un enum),
il définit les différents plans:</p>

<p>```ruby z_order.rb
module ZOrder</p>

<p>Background = 0
  Player     = 1</p>

<p>end
```</p>

<p>La classe <code>Player</code> est simple elle aussi.</p>

<blockquote>
  <p>C’est l’avantage écrasant d’éclater le code en petites classes ayant chacune
une seule responsabilité : le code devient simplissime.</p>
</blockquote>

<p>L’image <em>appartient</em> désormais au joueur, tout comme ses coordonnées. Et c’est
le joueur lui-même qui <em>sait</em> comment s’afficher. La classe <code>Window</code> aura
juste à déclencher cet affichage.</p>

<p>```ruby player.rb
class Player</p>

<p>def initialize(x, y)
    @x = x
    @y = y
    @image = Gosu::Image.new(“assets/images/player.png”)
  end</p>

<p>def draw
    @image.draw(@x, @y, ZOrder::Player)
  end</p>

<p>end
```</p>

<p>```ruby window.rb
class Window &lt; Gosu::Window</p>

<p>def initialize(width, height)
    super
    self.caption = “Collect The Smile!”</p>

<pre><code>@background_image = Gosu::Image.new("assets/images/background.png")

@player = Player.new(width / 2, height / 2)   end
</code></pre>

<p>def draw
    @background_image.draw(0, 0, ZOrder::Background)
    @player.draw
  end</p>

<p>end
```</p>

<p>Pour finir, voici le contenu du jeu pour l’instant:</p>

<pre><code>$ tree
.
├── assets
│   └── images
│       ├── background.png
│       └── player.png
├── main.rb
├── player.rb
├── window.rb
└── z_order.rb
</code></pre>

<p>Le code et les assets se trouvent <a href="https://github.com/lkdjiin/collect-the-smiles">sur Github</a>.
La version précise pour cet article est la <a href="https://github.com/lkdjiin/collect-the-smiles/releases/tag/v0.1.0">version 0.1.0</a>.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Un jeu de Simon - Étape 1]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/03/01/un-jeu-de-simon-etape-1/"/>
    <updated>2015-03-01T21:00:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/03/01/un-jeu-de-simon-etape-1</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Lors d’un projet du dimanche avec ma fille, j’ai commencé un
<a href="http://fr.wikipedia.org/wiki/Simon_%28jeu%29">jeu de Simon</a> sur l’Arduino.
Nous avons simplifié les règles au maximum (ma fille n’a pas 3 ans) et obtenu
ce que je vous propose dans cet article.</p>

<p>C’est seulement un point de départ, j’ai bien envie d’implémenter le jeu en
entier et d’en faire un objet réel. Il devrait donc y avoir d’autres articles…</p>

<p><img class="center" src="/images/simon-1.jpg"></p>

<!-- more -->

<h2 id="les-rgles">Les règles</h2>

<p>J’ai réduit les règles du jeu au plus simple : Il y a deux couleurs, rouge et
vert. La machine donne une couleur en allumant une LED et le joueur répond en
appuyant sur un bouton de couleur. Si la réponse est juste le joueur gagne et
une nouvelle partie commence. Si la réponse est fausse les LEDs clignotent
quelque temps pour signaler que le jeu est perdu et une nouvelle partie
commence.</p>

<p>Difficile de faire plus simple, hein ?</p>

<h2 id="les-composants">Les composants</h2>

<p>Nous aurons besoin de :</p>

<ul>
  <li>2 LEDs, une rouge et une verte</li>
  <li>2 boutons momentanés, si possible un rouge et un vert (sinon les gris
moches ça marche aussi)</li>
  <li>2 résistances de 220 Ohms pour les LEDs</li>
  <li>2 résistances de 10 kilo Ohms pour les boutons</li>
  <li>du câble</li>
</ul>

<h2 id="lassemblage">L’assemblage</h2>

<p><img class="center" src="/images/simon-etape1-bb.png"></p>

<h2 id="le-code">Le code</h2>

<p>Rien de spécial à dire pour le code, si ce n’est qu’il a été écrit sous la
pression de ma fille et la patience n’est pas son fort. Ça pourrait expliquer
pourquoi le code n’est pas très joli.</p>

<p>``` c
const byte RED = 0;
const byte GREEN = 1;</p>

<p>byte buttonRed = 8;
byte buttonGreen = 9;
byte ledRed = 2;
byte ledGreen = 3;
byte computerTurn = 1;
byte lastPly;</p>

<p>void setup() {
  pinMode(buttonRed, INPUT);
  pinMode(buttonGreen, INPUT);
  pinMode(ledRed, OUTPUT);
  pinMode(ledGreen, OUTPUT);</p>

<p>randomSeed(analogRead(0));
}</p>

<p>void loop() {
  if(computerTurn) {
    lastPly = random(2);
    allLedsOff();
    if(lastPly == RED) {
      digitalWrite(ledRed, HIGH);
    } else {
      digitalWrite(ledGreen, HIGH);
    }
    delay(300);
    allLedsOff();
    computerTurn = 0;
  } else {
    int stateRed = digitalRead(buttonRed);
    int stateGreen = digitalRead(buttonGreen);
    if(stateRed || stateGreen) {
      if(stateRed) {
        lightTheLed(ledRed);
      } else {
        lightTheLed(ledGreen);
      }
      if(stateRed &amp;&amp; lastPly == RED) {
        delay(2000);
      } else if(stateGreen &amp;&amp; lastPly == GREEN) {
        delay(2000);
      } else if((stateRed &amp;&amp; lastPly == GREEN) || (stateGreen &amp;&amp; lastPly == RED)) {
        blinkLeds();
        delay(2000);
      }
      computerTurn = 1;
    }
    delay(1);
  }
}</p>

<p>void allLedsOff() {
  digitalWrite(ledRed, LOW);
  digitalWrite(ledGreen, LOW);
}</p>

<p>void lightTheLed(byte led) {
  digitalWrite(led, HIGH);
  delay(200);
  digitalWrite(led, LOW);
}</p>

<p>void blinkLeds() {
  for(int i = 0; i &lt; 10; i++) {
    digitalWrite(ledRed, HIGH);
    digitalWrite(ledGreen, HIGH);
    delay(100);
    allLedsOff();
    delay(100);
  }
}
```</p>

<h2 id="la-suite">La suite</h2>

<p>Il reste beaucoup de choses à faire… Ajouter le bleu et le jaune ; ajouter du son ;
enregistrer les séquences de couleur ; le vrai jeu de Simon, quoi.
Et ensuite il faudra en faire un objet autonome, sans Arduino.</p>

<p>Alors à la prochaine.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Un space invaders avec Opal.rb - partie 16]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/06/27/un-space-invaders-avec-opal-dot-rb-partie-16/"/>
    <updated>2014-06-27T21:23:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/06/27/un-space-invaders-avec-opal-dot-rb-partie-16</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Hier on a vu comment lancer une appli rack pour le développement. Seulement
je n’ai pas envie de choisir entre les deux méthodes. Je veux les deux !
Le serveur rack pour le développement, et le build classique du fichier
javascript pour la mise en production.</p>

<p>On va se bricoler deux tâches <code>rake</code> en quelques minutes pour obtenir ça.</p>

<!-- more -->

<p>Alors j’avertis tout de suite : le script n’est pas parfait. C’est malgré une
bonne base pour commencer.</p>

<p>Voici le nouveau <code>Rakefile</code>, dans lequel j’ai ajouté une tâche <code>development</code>
et une tâche <code>production</code>:</p>

<p>``` ruby Rakefile
require ‘opal’
require ‘opal-jquery’</p>

<p>desc “Build our app to build.js”
task :build do
  env = Opal::Environment.new
  env.append_path “app”</p>

<p>File.open(“build.js”, “w+”) do |out|
    out « env[“application”].to_s
  end
end</p>

<p>desc ‘Build app for production’
task :production =&gt; :build do
  cp ‘app/templates/index_production.html’, ‘index.html’
end</p>

<p>desc ‘Run development server’
task :development do
  cp ‘app/templates/index_development.html’, ‘index.html’
  <code>bundle exec rackup</code>
end
```</p>

<p>Pour que le fichier <code>index.html</code> reflète le bon environnement, j’ai
ajouté un dossier <code>templates</code>, avec une version de chaque:</p>

<pre><code>$ tree app
app
├── application.rb
├── enemies.rb
├── enemy.rb
├── fire.rb
├── game.rb
├── player.rb
├── space_canvas.rb
└── templates
    ├── index_development.html
    └── index_production.html
</code></pre>

<p>Pour info, voici le contenu des templates:</p>

<p>``` html app/templates/index_development.html
&lt;!DOCTYPE html&gt;</p>
<html>
  <head>
    <meta charset="utf-8" />
    <script src="http://code.jquery.com/jquery-1.11.0.min.js"></script>
  </head>
  <body>
    <canvas width="700" height="600" id="canvas" />
    <script src="assets/application.js"></script>
  </body>
</html>
<p>```</p>

<p>``` html app/templates/index_production.html
&lt;!DOCTYPE html&gt;</p>
<html>
  <head>
    <meta charset="utf-8" />
    <script src="http://code.jquery.com/jquery-1.11.0.min.js"></script>
  </head>
  <body>
    <canvas width="700" height="600" id="canvas" />
    <script src="build.js"></script>
  </body>
</html>
<p>```</p>

<p>Alors oui, les templates sont redondants. Et si on doit modifier le contenu
de <code>index.html</code>, il faudra faire la modification sur les deux templates.
J’avais prévenu que ça n’était pas parfait ;) Par contre, pour cette appli
c’est bien suffisant.</p>

<script id="fb33k8u">(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Un space invaders avec Opal.rb - partie 15]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/06/26/un-space-invaders-avec-opal-dot-rb-partie-15/"/>
    <updated>2014-06-26T21:09:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/06/26/un-space-invaders-avec-opal-dot-rb-partie-15</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Vous en avez peut-être marre de tapez <code>rake build</code> à chaque petite
modification de votre code ? Moi, oui. En utilisant Sprockets, on peut
rendre le build automatique. Cool.</p>

<!-- more -->

<p>La marche à suivre est décrite dans la <a href="http://opalrb.org/docs/using_sprockets/">documentation d’Opal</a>.
Basiquement, on ajoute un fichier <code>config.ru</code> à la racine:</p>

<p>``` ruby config.ru
require ‘bundler’
Bundler.require</p>

<p>run Opal::Server.new { |s|
  s.append_path ‘app’
  s.main = ‘application’
  s.index_path = ‘index.html’
}
```</p>

<p>Et on change la localisation du script dans <code>index.html</code>:</p>

<p>``` html index.html
&lt;!DOCTYPE html&gt;</p>
<html>
  <head>
    <meta charset="utf-8" />
    <script src="http://code.jquery.com/jquery-1.11.0.min.js"></script>
  </head>
  <body>
    <canvas width="700" height="600" id="canvas" />
    <script src="assets/application.js"></script>
  </body>
</html>
<p>```</p>

<p>Après quoi on lance l’application rack:</p>

<pre><code>$ bundle exec rackup
</code></pre>

<p>Et votre appli est accessible à l’adresse <code>localhost:9292</code>.</p>

<p>Maintenant tout changement de code demande seulement un raffraichіssement
dans le navigateur.</p>

<script id="fb33k8u">(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Un space invaders avec Opal.rb - partie 14]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/06/23/un-space-invaders-avec-opal-dot-rb-partie-14/"/>
    <updated>2014-06-23T21:19:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/06/23/un-space-invaders-avec-opal-dot-rb-partie-14</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Lorsque le joueur faisait feu, le tir prenait naissance dans le coin
supérieur gauche du joueur. On le voudrait plutôt au milieu.</p>

<!-- more -->

<p>Voici donc la nouvelle classe <code>Fire</code>:</p>

<p>``` ruby app/fire.rb
class Fire
  SIDE = 4
  DELTA = 5</p>

<p>attr_reader :x, :y</p>

<p>def initialize(player)
    @x = player.x + player.w / 2
    @y = player.y - SIDE
  end</p>

<p>def w; SIDE; end</p>

<p>def h; SIDE; end</p>

<p>def color; “white”; end</p>

<p>def update_position
    @y -= DELTA
  end
end
```</p>

<p>Dans <code>initialize</code>, on calcule la position d’origine du tir par rapport
au joueur, passé en argument.</p>

<p>Il faut donc changer aussi la méthode <code>fire</code> de la classe <code>Game</code>:</p>

<p>``` ruby
class Game</p>

<p>…</p>

<p>def fire
    @fires « Fire.new(@player)
  end</p>

<p>…
end
```</p>

<p>Voilà, ça c’est fait. N’oubliez pas que le code est maintenant disponible
sur <a href="https://github.com/lkdjiin/space-invaders-in-opal-rb">Github</a>.</p>

<script id="fb33k8u">(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
