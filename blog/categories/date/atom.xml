<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : date | Xavier Nayrac]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/date/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2019-11-03T16:19:20+01:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Comment créer votre propre localisation sous Linux]]></title>
    <link href="http://lkdjiin.github.io/blog/2018/08/21/comment-creer-votre-propre-localisation-sous-linux/"/>
    <updated>2018-08-21T13:20:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2018/08/21/comment-creer-votre-propre-localisation-sous-linux</id>
    <content type="html"><![CDATA[<p>Un article récent 
<a href="https://mayeu.me/blog/configurer-linux-pour-utiliser-une-representation-de-date-logique-iso-8601/">«Configurer Linux pour utiliser une représentation de date logique (ISO 8601)»</a> a retenu mon attention. L’auteur y parle de la configuration des
variables locales sur Linux. Des variables telles que <code>LANG</code>, <code>LC_NUMERIC</code>, et plus particulièrement <code>LC_TIME</code>.
Ça m’a fait penser qu’après 21 ans d’utilisation de Linux, je n’avais jamais
pris le temps de regarder comment fonctionnent ces variables de configuration.
Quand tu écris <code>LANG=fr_FR</code>, qu’est ce qu’il se passe vraiment ?</p>

<!-- more -->

<h2 id="introduction">Introduction</h2>

<p>Pour celles et ceux qui découvrent ces variables de configuration, voici une
introduction rapide. Très rapide…</p>

<p>Pour connaitre votre configuration actuelle, utilisez <code>locale</code> :</p>

<pre><code>$ locale
LANG=fr_FR.UTF-8
LANGUAGE=
LC_CTYPE="fr_FR.UTF-8"
LC_NUMERIC="fr_FR.UTF-8"
LC_TIME="fr_FR.UTF-8"
[...]
</code></pre>

<p>Toutes les variables ne sont pas forcement renseignées, c’est normal.</p>

<p>Pour connaitre les valeurs des <em>locales</em> qui sont à votre disposition,
utilisez <code>locale -a</code> :</p>

<pre><code>$ locale -a
C
C.UTF-8
en_AG
en_AG.utf8
en_AU.utf8
en_BW.utf8
en_CA.utf8
en_DK.utf8
en_GB.utf8
[...]
fr_FR.utf8
</code></pre>

<p>Ce ne sont pas <strong>toutes les valeurs existantes</strong>, mais seulement celles que
vous pouvez utiliser tout de suite sans rien compiler. Par exemple, la
commande <code>date</code> utilise la variable <code>LC_TIME</code> pour savoir ce qu’elle doit afficher.
Par défaut, c’est la valeur <code>fr_FR</code> qui est utilisée chez moi (voir la
sortie de <code>locale</code>) :</p>

<pre><code>$ date
lundi 20 août 2018, 17:20:53 (UTC+0200)
</code></pre>

<p>Mais je peux utiliser une autre valeur, par exemple <code>en_DK</code>, ou encore
<code>en_GB</code> :</p>

<pre><code>$ LC_TIME=en_DK.utf8 date
Mon Aug 20 17:19:16 CEST 2018
$ LC_TIME=en_GB.utf8 date
Mon 20 Aug 17:19:47 CEST 2018
</code></pre>

<p>Pour connaître les autres valeurs de locales auxquelles vous avez droit,
consulter le fichier <code>/etc/locale.gen</code> :</p>

<pre><code>$ cat /etc/locale.gen
[...]
# fr_CH.UTF-8 UTF-8
# fr_FR ISO-8859-1
fr_FR.UTF-8 UTF-8
[...]
</code></pre>

<p>Les lignes qui débutent par un <code>#</code> sont les valeurs que vous pouvez compiler
(en utilisant la commande <code>locale-gen</code>).</p>

<h2 id="comment-a-marche-">Comment ça marche ?</h2>

<p>Chaque localisation possède son propre fichier de configuration. Ces fichiers
se trouvent dans <code>/usr/share/i18n/locales/</code>.</p>

<pre><code>$ cat /usr/share/i18n/locales/fr_FR
</code></pre>

<p>Dans ces fichiers chaque variable de configuration est décrite dans sa propre section,
comme <code>LC_TIME</code> à laquelle je m’intéresse ici :</p>

<pre><code>LC_TIME
[...]
END LC_TIME
</code></pre>

<p>À l’intérieur des sections on trouve des chaînes de formatage en Unicode pour
la libc. Voici la partie du fichier <code>/usr/share/i18n/locales/fr_FR</code> dont se
servira la commande <code>date</code> :</p>

<pre><code>date_fmt "&lt;U0025&gt;&lt;U0041&gt;&lt;U0020&gt;&lt;U0025&gt;&lt;U002D&gt;&lt;U0065&gt;&lt;U0020&gt;/
&lt;U0025&gt;&lt;U0042&gt;&lt;U0020&gt;&lt;U0025&gt;&lt;U0059&gt;&lt;U002C&gt;&lt;U0020&gt;/
&lt;U0025&gt;&lt;U0048&gt;&lt;U003A&gt;&lt;U0025&gt;&lt;U004D&gt;&lt;U003A&gt;&lt;U0025&gt;&lt;U0053&gt;&lt;U0020&gt;/
&lt;U0028&gt;&lt;U0055&gt;&lt;U0054&gt;&lt;U0043&gt;&lt;U0025&gt;&lt;U007A&gt;&lt;U0029&gt;"
</code></pre>

<p>Si on traduit cette chaîne Unicode (voir par ex. <a href="https://unicode-table.com/en/">cette table</a>), on obtient ce qui suit :</p>

<pre><code>%A %-e %B %Y, %H:%M:%S (UTC%z)
</code></pre>

<p>On retrouve bien le format de la sortie de <code>date</code> (<em>lundi 20 août 2018, 20:26:17 (UTC+0200)</em>).
Si vous n’êtes pas familier de cette notation, jetez un œil sur la fonction <a href="http://www.faximum.com/manual.d/client.server.d/manpages.23.html">strftime</a>
du langage C.</p>

<h2 id="je-veux-ma-propre-locale">Je veux ma propre locale</h2>

<p>Plutôt que <em>lundi 20 août 2018, 20:26:17 (UTC+0200)</em>, je veux que la date
s’affiche sous cette forme : <strong>A:2018 M:08 J:20</strong>.
Pourquoi ? Simplement parce que c’est possible !</p>

<p>Je pars d’un fichier de configuration existant que je copie dans mon répertoire
de travail :</p>

<pre><code>$ cp /usr/share/i18n/locales/fr_FR ./fr_FR@test
</code></pre>

<p>Je l’ai appelé <code>fr_FR@test</code>. J’aurais aussi pu utiliser un des nombreux codes
de régionalisation réservés pour les utilisateurs, comme <code>AA</code>, <code>OO</code>, <code>XX</code> ou
<code>ZZ</code> (voir <a href="https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2">ISO 3166-1
alpha-2</a>). Donc j’aurais pu
nommer mon fichier <code>fr_ZZ</code>.</p>

<p>Pour obtenir une date de la forme <em>A:2018 M:08 J:20</em>, il faut la chaîne de
formatage suivante : <strong>A:%Y M:%m J:%d</strong>. Traduit (si on peut dire) en Unicode,
cela donne :</p>

<pre><code>"&lt;U0041&gt;&lt;U003A&gt;&lt;U0025&gt;&lt;U0059&gt;&lt;U0020&gt;/
&lt;U004D&gt;&lt;U003A&gt;&lt;U0025&gt;&lt;U006D&gt;&lt;U0020&gt;/
&lt;U004A&gt;&lt;U003A&gt;&lt;U0025&gt;&lt;U0064&gt;"
</code></pre>

<p>Une fois que j’ai mis ça dans mon fichier <code>fr_FR@test</code>, je l’envoie dans le dossier <code>/usr/share/i18n/locales/</code> :</p>

<pre><code>$ sudo cp fr_FR@foobar /usr/share/i18n/locales/
</code></pre>

<p>Et je le compile pour qu’il soit utilisable par la libc :</p>

<pre><code>$ sudo localedef -i fr_FR@foobar -c -f UTF-8 fr_FR@test
</code></pre>

<p>Je peux maintenant utiliser ma propre locale :</p>

<pre><code>$ LANG=fr_FR.utf8@test date
A:2018 M:08 J:20
</code></pre>

<p>Et voilà.</p>

<h2 id="quelle-utilit-">Quelle utilité ?</h2>

<p>Comprendre un peu mieux Linux…</p>

<p>Si mon quartier fait sécession et devient un pays autonome, je suis prêt à
créer une nouvelle traduction…</p>

<p>Si vous avez une autre idée, laissez donc un commentaire…</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby Timecop - Comment ça marche ?]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/04/02/ruby-timecop-comment-ca-marche/"/>
    <updated>2014-04-02T21:07:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/04/02/ruby-timecop-comment-ca-marche</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Hier je vous parlais de Timecop, une gem Ruby qui <em>arrête le
temps</em>, très utile pour tester les dates. J’y ai repensé un
peu aujourd’hui sur le mode : «j’aurais pu y penser avant !».</p>

<p>Alors justement, si j’avais eu cette idée, comment j’aurais
fait ? C’est l’occasion de parler de méta-programmation.
Allez j’essaye d’écrire ma propre méthode
<code>Time.freeze</code>, on verra bien…</p>

<!-- more -->

<p>Voilà les étapes qui me semble nécessaires:</p>

<ol>
  <li>Geler le temps et le retenir.</li>
  <li>Faire un backup de Time.now.</li>
  <li>Définir une nouvelle méthode Time.now qui renvoie toujours
le même temps.</li>
  <li>Appeler le block passé à la méthode.</li>
  <li>Restaurer la méthode Time.now originale.</li>
</ol>

<p>Avant de coder, j’écris un test:</p>

<p>``` ruby
puts “Time before #{Time.now}”
sleep 3</p>

<p>Time.freeze do
  puts Time.now.to_s
  sleep 3
  puts Time.now.to_s
end</p>

<p>sleep 3
puts “Time after #{Time.now}”
```</p>

<p>Je veux donc obtenir un affichage du genre:</p>

<pre><code>Time before hh:mm:00
hh:mm:03
hh:mm:03
Time after hh:mm:09
</code></pre>

<p>Ok ? C’est parti.</p>

<h2 id="ouvrir-la-classe-time">Ouvrir la classe Time</h2>

<p><code>ruby
class Time
  def self.freeze
  end
end
</code></p>

<p>Premier truc à savoir, une classe Ruby est toujours ouverte
à la modification. Même si il s’agit d’une classe du coeur
du langage, comme Object ou Kernel. <em>Si vous êtes perdus,
faites une recherche sur «ruby open class».</em></p>

<h2 id="arrter-le-temps">Arrêter le temps</h2>

<p><code>ruby
class Time
  def self.freeze
    freezed = Time.now
  end
end
</code></p>

<p>Pas grand chose à dire. On pourra renvoyer l’objet <code>freezed</code>
chaque fois qu’on nous demandera <code>Time.now</code>.</p>

<h2 id="sauvegarder-timenow-original">Sauvegarder Time.now original</h2>

<p><code>ruby
class Time
  def self.freeze
    freezed = Time.now
    singleton_class.send(:alias_method, :old_now, :now)
  end
end
</code></p>

<p>Là il y a beaucoup à dire. On rentre dans la
méta-programmation et je n’ai pas la place (ni le temps) dans
cet article pour parler du modêle objet de Ruby.
N’hésitez pas à faire une recherche sur «ruby object model» ou
«ruby eigenclass».</p>

<p>On dit à la classe <code>Time</code> de créer un alias de la méthode de
classe <code>now</code> avec le nom <code>old_now</code>.</p>

<h2 id="un-nouveau-timenow">Un nouveau Time.now</h2>

<p><code>ruby
class Time
  def self.freeze
    freezed = Time.now
    singleton_class.send(:alias_method, :old_now, :now)
    define_singleton_method('now') { freezed }
  end
end
</code></p>

<p>Cette fois, je dis à la classe <code>Time</code> de créer une méthode de
classe qui s’appelle <code>now</code> et qui renvoie notre objet
<code>freezed</code>.</p>

<h2 id="appeler-le-block">Appeler le block</h2>

<p><code>ruby
class Time
  def self.freeze
    freezed = Time.now
    singleton_class.send(:alias_method, :old_now, :now)
    define_singleton_method('now') { freezed }
    yield
  end
end
</code></p>

<p>Bon, ça c’était facile ;)</p>

<h2 id="restaurer-timenow">Restaurer Time.now</h2>

<p><code>ruby
class Time
  def self.freeze
    freezed = Time.now
    singleton_class.send(:alias_method, :old_now, :now)
    define_singleton_method('now') { freezed }
    yield
    singleton_class.send(:alias_method, :now, :old_now)
  end
end
</code></p>

<p>Ça me semble tout bon. On teste ?</p>

<h2 id="le-test">Le test</h2>

<p>``` ruby freeze.rb
class Time
  def self.freeze
    freezed = Time.now
    singleton_class.send(:alias_method, :old_now, :now)
    define_singleton_method(‘now’) { freezed }
    yield
    singleton_class.send(:alias_method, :now, :old_now)
    # singleton_class.send(:remove_method, :old_now)
  end
end</p>

<p>puts “Time before #{Time.now}”
sleep 3</p>

<p>Time.freeze do
  puts Time.now.to_s
  sleep 3
  puts Time.now.to_s
end</p>

<p>sleep 3
puts “Time after #{Time.now}”
```</p>

<p><code>bash
$ ruby freeze.rb 
Time before 2014-04-02 21:40:57 +0200
2014-04-02 21:41:00 +0200
2014-04-02 21:41:00 +0200
Time after 2014-04-02 21:41:06 +0200
</code></p>

<p>Excellent !</p>

<p>Il reste un léger problème : la méthode <code>Time.old_now</code>
existe toujours, ce qui n’est pas très propre. On pourra
la supprimer ainsi:</p>

<pre><code>singleton_class.send(:remove_method, :old_now)
</code></pre>

<p>Voilà, j’aurais quand même pu y penser avant… J’espère
trouver du temps une prochaine fois pour jeter un coup
d’oeil au code de Timecop pour comparer avec le code
d’aujourd’hui.</p>

<script id="fb33k8u">(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tester facilement vos dates avec Timecop]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/04/01/tester-facilement-vos-dates-avec-timecop/"/>
    <updated>2014-04-01T21:06:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/04/01/tester-facilement-vos-dates-avec-timecop</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p><a href="https://github.com/travisjeffery/timecop">Timecop</a>
n’est pas une nouvelle gem. Mais je ne la découvre qu’aujourd’hui.
Ça fait pourtant 4 ans que je travaille quotidiennement avec Ruby
et/ou Rails… Et je ne me suis jamais sentis très à l’aise pour tester
les dates. Avec Timecop, ça devient un jeu d’enfant.</p>

<!-- more -->

<p>Pour voir un souci possible, prenons la classe suivante qui représente
un article:</p>

<p>``` ruby article.rb
class Article
  def initialize(name)
    @name = name
    @created_at = Time.now
  end</p>

<p>attr_reader :name, :created_at
end
```</p>

<p>Dans le monde réel, ce serait surement un ActiveRecord, mais pour
l’exemple on se contentera bien de cette classe ;)</p>

<p>Maintenant testons la création d’un article:</p>

<p>``` ruby tc_article.rb
require_relative “article”
require “test/unit”</p>

<p>class TestArticle &lt; Test::Unit::TestCase
  def test_creation
    article = Article.new(‘Foo’)
    assert_equal ‘Foo’, article.name
    assert_equal Time.now, article.created_at
  end
end
```</p>

<p>Et voilà le souci, à quelques nano-secondes près ça pète:</p>

<p>``` bash
$ ruby tc_article.rb 
Run options: </p>

<h1 id="running-tests">Running tests:</h1>

<p>[1/1] TestArticle#test_creation = 0.00 s
  1) Failure:
TestArticle#test_creation [tc_article.rb:8]:
&lt;2014-04-01 21:05:10 +0200&gt; (204201[ns]) expected but was
&lt;2014-04-01 21:05:10 +0200&gt; (176685[ns]).</p>

<p>Finished tests in 0.009979s, 100.2062 tests/s, 200.4125 assertions/s.
1 tests, 2 assertions, 1 failures, 0 errors, 0 skips
```</p>

<p>Timecop est la meilleure solution que j’ai vu jusqu’ici pour régler
ce type de problème. La gem propose tout simplement (entre autres)
<em>de geler le temps</em>:</p>

<p>``` ruby tc_article.rb
require_relative “article”
require “test/unit”
require “timecop”</p>

<p>class TestArticle &lt; Test::Unit::TestCase
  def test_creation
    Timecop.freeze do
      article = Article.new(‘Foo’)
      assert_equal ‘Foo’, article.name
      assert_equal Time.now, article.created_at
    end
  end
end
```</p>

<p>Et voilà le résultat:</p>

<p>``` bash
ruby tc_article.rb 
Run options: </p>

<h1 id="running-tests-1">Running tests:</h1>

<p>Finished tests in 0.010756s, 92.9747 tests/s, 185.9494 assertions/s.
1 tests, 2 assertions, 0 failures, 0 errors, 0 skips
```</p>

<p>J’aimerais bien savoir quelles solutions vous avez adoptés pour
régler ce genre de soucis…</p>

<script id="fb33k8u">(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
