<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : crystal | Xavier Nayrac]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/crystal/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2016-12-20T16:35:12+01:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ruby vs Crystal - 2ème partie]]></title>
    <link href="http://lkdjiin.github.io/blog/2016/01/19/ruby-vs-crystal-2eme-partie/"/>
    <updated>2016-01-19T13:58:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2016/01/19/ruby-vs-crystal-2eme-partie</id>
    <content type="html"><![CDATA[<p>J’ai testé le langage Crystal le week end dernier. Rien de très poussé, juste
140 lignes de Ruby traduites en Crystal et <a href="/blog/2016/01/19/ruby-vs-crystal/">un benchmark</a>. Je vais tenté de
synthétiser mes premières impressions sur ce langage.</p>

<p>Dans cet article
mon point de vue est celui d’un développeur Ruby qui cherche à rendre
ses programmes plus rapide avec l’aide de Crystal.</p>

<h2 id="crystal-nest-pas-ruby">Crystal n’est pas Ruby</h2>

<p>Si je devais retenir une seule chose, ce serait celle-ci: <strong>Crystal n’est pas un
Ruby compilé</strong>.  Si sa syntaxe ressemble beaucoup à celle de Ruby,
c’est vraiment un langage différent. La plus grande différence étant qu’il est
statiquement typé.</p>

<!-- more -->

<h2 id="pas-de-repl">Pas de REPL</h2>

<p>Les développeurs de Crystal ont l’air de penser que c’est compliqué de lui
ajouter un REPL, et ça l’est sûrement. Ne pas avoir accès à un REPL n’est pas
rédhibitoire pour un langage statique. Mais cela implique un processus de
développement totalement différent de celui de Ruby et des langages dynamiques,
même si le compilateur semble pour l’instant assez rapide.</p>

<h2 id="plusieurs-mthodes-sont-absentes">Plusieurs méthodes sont absentes</h2>

<p>Ou bien elles fonctionnent différemment. Il n’y a pas de <code>require_relative</code>, par
exemple:</p>

<p>```ruby
# crystal
require “./xpm”
# De plus le fichier doit être nommé <code>xpm.cr</code></p>

<h1 id="ruby">ruby</h1>
<p>require_relative “xpm”
```</p>

<p>Bien plus surprenant, il n’y a pas de <code>attr_reader</code>, il faut définir la méthode.
Peut-être que les développeurs n’ont pas encore eu le temps de s’y atteler ?</p>

<p>```ruby
# crystal
def foobar
  @foobar
end</p>

<h1 id="ruby-1">ruby</h1>
<p>attr_reader :foobar
```</p>

<h2 id="pas-de-private-global">Pas de private «global»</h2>

<p>Avec Crystal, on définit une méthode privée au coup par coup.
C’est une syntaxe qui est possible en Ruby depuis la version 2 (2.1 je crois),
mais qui n’a jamais <em>pris</em>.</p>

<p><code>ruby
# crystal
private def foo(a, b)
  a + b
end
</code></p>

<h2 id="typage-statique">Typage statique</h2>

<p>Est-ce que j’ai déjà mentionné que Crystal est un langage statiquement typé ?
Oui ?
Il est donc très <strike>gonflant</strike> tatillon avec les types.</p>

<p>```ruby
# crystal
“%i” % 1.0   #=&gt; erreur !</p>

<h1 id="ruby-2">ruby</h1>
<p>“%i” % 1.0   #=&gt; “1”
```</p>

<h2 id="linfrence-de-types">L’inférence de types</h2>

<p>L’inférence de types, c’est bien, non ? Ça permet au compilateur de <em>deviner</em> le
type d’une variable pour que nous n’ayons pas à les spécifier nous même. Sauf
que dans l’optique d’une traduction d’un programme Ruby en Crystal je ne suis
pas convaincu du truc. Si on écrit un programme Crystal <em>from scratch</em>, pas de
soucis. Mais Ruby est bourré d’idiomes et de tics en tout genres qui vont
rendre le portage pas du tout trivial, à mon avis. Par exemple le code ruby
suivant initialise le tableau <code>@free_cells</code>:</p>

<p><code>ruby
# ruby
def initialize
  @free_cells = Array.new(FREE_TOTAL) do
    [rand(SIZE), rand(SIZE)]
  end
end
</code></p>

<p>Puis, dans la méthode <code>move</code>, les éléments de ce tableau sont modifiés. Il est
possible que certains éléments soient mis à <code>nil</code>. Mais comme vous pouvez le
voir à la fin de la méthode, avant de <em>relacher le tableau dans la nature</em>,
les éléments <code>nil</code> sont supprimés. C’est pour moi un cas d’utilisation
légitime de <code>nil</code>:</p>

<p>```ruby
# ruby
def move
  # […]
  @free_cells.map! do |cell|
    # Modification des éléments, certains peuvent devenir nil.
  end</p>

<p>@free_cells.compact!
end
```</p>

<p>Mais un compilateur n’avalera pas cette belle histoire. Le tableau a été
initialisé avec un certain type et vous ne pourrez donc pas en utiliser
d’autres. Vous devrez dire à Crystal quels types peut contenir le tableau,
c’est une syntaxe spécifique à Crystal, inconnue de Ruby:</p>

<p><code>ruby
# crystal
def initialize
    @free_cells = [] of Array(Int32) | Nil
    FREE_TOTAL.times { @free_cells &lt;&lt; [rand(@size), rand(@size)] }
end
</code></p>

<p>Mais si maintenant je peux insérer des <code>nil</code> dans mon tableau, plus question de
pouvoir lire ses éléments ainsi:</p>

<p><code>ruby
@free_cells.map! do |cell|
  cell[0]
</code></p>

<p>Et non ! Puisque <code>@free_cells</code> a été déclaré comme pouvant contenir <code>nil</code> !
Même si <strong>je sais</strong> qu’à ce moment le tableau est exempt de <code>nil</code>, le
compilateur, lui, ne peut pas le savoir.
Il faut donc faire quelque chose comme ça:</p>

<p><code>ruby
@free_cells.map! do |cell|
  if cell.is_a?(Array)
    cell[0]
  else
    # ...
</code></p>

<p>Ou bien il faut repenser différemment le code. Et on commence a bien sentir
l’influence du typage statique, hein ? Encore une fois, ça n’est pas un
problème en soi, mais ça n’est pas Ruby.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Si on a de l’expérience avec les langages à typage statique, traduire un
programme Ruby en un programme Crystal n’est pas difficile et le gain de
performance peut-être intéressant.
Dans tout les cas, <strong>Crystal n’est pas Ruby</strong>. Travailler avec ce langage sera
différent et demandera des processus différents.
Reste à savoir quels programmes Ruby on va pouvoir réécrire en Crystal sans
avoir à réécrire, au hasard, tout ActiveRecord. Et là, je ne suis pas certain
qu’on va en trouver beaucoup.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby vs Crystal]]></title>
    <link href="http://lkdjiin.github.io/blog/2016/01/19/ruby-vs-crystal/"/>
    <updated>2016-01-19T09:23:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2016/01/19/ruby-vs-crystal</id>
    <content type="html"><![CDATA[<p>Après avoir produit <a href="/blog/2016/01/18/les-arbres-browniens-2eme-partie/">quelques variations</a> sur le thème des 
<a href="/blog/2016/01/17/les-arbres-browniens/">arbres browniens</a> le
week end dernier, le moment semblait idéal pour tester le langage
<a href="http://crystal-lang.org/">Crystal</a>.</p>

<p>J’ai donc réécrit le programme de base que j’avais fait pour produire des
arbres browniens, en supprimant l’UI et en enregistrant (à la place d’une
image écran)
un fichier image
<em>— au format XPM, peut-être le sujet d’un prochain article —</em>.</p>

<p>Je calcule le temps que prends la construction de l’image, sans son
enregistrement:</p>

<p><img class="center" src="/images/bench-crystal.png"></p>

<!-- more -->

<p>Les deux programmes sont quasiment identiques, la version Crystal est
l’adaption au plus près de la version Ruby. Pour ce
programme particulier, Crystal est de 3 à 7 fois plus rapide que Ruby.</p>

<p>Je suis deçu car j’attendais mieux que ça. On m’avait vendu Crystal comme étant
plus rapide. En fait environ 20 fois plus rapide que Ruby.</p>

<p>Et c’est vrai qu’avec un petit truc comme ça:</p>

<p><code>ruby
def fibonacci(n)
  return n if n &lt;= 1
  fibonacci(n - 1) + fibonacci(n - 2)
end
puts fibonacci 40
</code></p>

<p>ou alors encore ça:</p>

<p><code>ruby
x = 0
50_000_000.times do
  x += rand(11) - 5
end
</code></p>

<p>j’obtiens bien un programme Crystal 20 à 35 fois plus rapide que sa version
Ruby. Mais avec un programme plus «réel», c’est 3 à 7. Alors je ne boude pas,
hein, même un gain de 3 est toujours bon à prendre. Par contre, passer de Ruby à
Crystal a un coût, et savoir si ce coût justifie un si petit gain est une autre
histoire.</p>

<p>La prochaine fois j’espère vous donner mes premières impressions sur Crystal.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
