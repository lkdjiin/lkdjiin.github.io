<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : problème du sac à dos | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/probleme-du-sac-a-dos/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2013-12-23T16:32:54+01:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Les algorithmes génétiques démystifiés 47: Économie]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/12/23/les-algorithmes-genetiques-demystifies-47-economie/"/>
    <updated>2013-12-23T16:13:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/12/23/les-algorithmes-genetiques-demystifies-47-economie</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>La dernière fois on a vu <a href="http://lkdjiin.github.io/blog/2013/12/19/les-algorithmes-genetiques-demystifies-46-economie-la-boucle-principale/">la classe GeneticAlgorithm</a>, qui faisait usage
d'une classe IndividualFormatter. Cette classe est le sujet de l'article
d'aujourd'hui.</p>

<!-- more -->


<p>Cette classe, <code>IndividualFormatter</code>, est responsable de la transformation
d'un individu de la population en une chaîne de caractères qui véhicule
des informations <em>affichables</em> sur cet individu:</p>

<p>``` ruby
class IndividualFormatter</p>

<p>  def self.display(individual:, generation:, items:, capacity:)</p>

<pre><code>profit, cost = Score.profit_and_cost individual, items
if cost &gt; capacity
  "&lt;invalid&gt; Gen: #{generation} Profit: #{profit} Cost: #{cost}"
else
  "VALID     Gen: #{generation} Profit: #{profit} Cost: #{cost}"
end
</code></pre>

<p>  end</p>

<p>  def self.display_best_ever(individual:, items:)</p>

<pre><code>profit, cost = Score.profit_and_cost individual, items
"----------------------\n"\
"Best ever\n"\
"----------------------\n"\
"Profit: #{profit}\n"\
"Cost:   #{cost}\n"\
"Listing:\n"\
"#{Individual.listing(chromosome: individual.chromosome, items: items)}"
</code></pre>

<p>  end
end
```</p>

<p>La méthode <code>display</code> est utilisée à chaque génération, pour afficher succintement
le meilleur individu trouvé jusqu'ici.</p>

<p>La méthode <code>display_best_ever</code> est elle, utilisée à la fin de l'algorithme,
pour afficher la meilleure solution avec plus de détails.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les algorithmes génétiques démystifiés 46: Économie, la boucle principale]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/12/19/les-algorithmes-genetiques-demystifies-46-economie-la-boucle-principale/"/>
    <updated>2013-12-19T14:26:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/12/19/les-algorithmes-genetiques-demystifies-46-economie-la-boucle-principale</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Après <a href="http://lkdjiin.github.io/blog/2013/12/16/les-algorithmes-genetiques-demystifies-45-economie-calcul-du-score/">le calcul du score</a>
d'un individu, voici maintenant le coeur du programme, la classe
<code>GeneticAlgorithm</code>.</p>

<!-- more -->


<p>Cette classe est batie sur le même modèle que pour les problèmes vus
précédement, je ne vais donc pas la commenter en détails. Voici d'abord
les méthodes publiques:</p>

<p>``` ruby
class GeneticAlgorithm
  def initialize(generations:, population:, capacity:, mutation_rate:, items:)</p>

<pre><code>@generations = generations
@population = population
@capacity = capacity
@mutation_rate = mutation_rate
@items = items
@crossover = Crossover.new chromosome_size: items.size,
  mutation_rate: mutation_rate,
  items: items
@best_ever = nil
</code></pre>

<p>  end</p>

<p>  def run</p>

<pre><code>@generations.times do |generation|
  Evaluator.new(capacity: @capacity, population: @population,
    items: @items).evaluate!
  find_best_ever(generation)
  next_generation
end
puts IndividualFormatter.display_best_ever individual: @best_ever,
  items: @items
</code></pre>

<p>  end</p>

<p>  # &hellip;</p>

<p>end
```</p>

<p>L'initialisation est des plus basiques. Quant à la méthode <code>run</code>, elle
introduit une nouvelle classe : <code>IndividualFormatter</code>. Cette classe sera
discutée en détail dans le prochain article.</p>

<p>Maintenant les méthodes privées:</p>

<p>``` ruby
class GeneticAlgorithm</p>

<p>  # &hellip;</p>

<p>  private</p>

<p>  def find_best_ever(generation)</p>

<pre><code>best = @population.best
@best_ever = best if best &gt; @best_ever
puts IndividualFormatter.display individual: @best_ever,
  generation: generation,
  items: @items,
  capacity: @capacity
</code></pre>

<p>  end</p>

<p>  def next_generation</p>

<pre><code>@population.sort_by! {|i| i.score}
elite = @population.pop(4)
pool = MatingPool.new(@population)
population_size = @population.size
@population.clear
population_size.times do
  @population &lt;&lt; @crossover.two_point(pool.random, pool.random)
end
@population.concat elite
</code></pre>

<p>  end
end
```</p>

<p><code>find_best_ever</code> va trouver le meilleur individu à un moment précis, toutes
générations confondues <em>et</em> va afficher cet individu via <code>IndividualFormatter</code>
(<em>Je sais, c'est mal, cette méthode fait deux choses…</em>).</p>

<p>Quant à la méthode <code>next_generation</code>, c'est la même que pour
<a href="http://lkdjiin.github.io/blog/2013/11/16/les-algorithmes-genetiques-39-resolution-du-sac-a-dos/">le problème précédent</a>.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les algorithmes génétiques démystifiés 45: Économie, calcul du score]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/12/16/les-algorithmes-genetiques-demystifies-45-economie-calcul-du-score/"/>
    <updated>2013-12-16T18:15:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/12/16/les-algorithmes-genetiques-demystifies-45-economie-calcul-du-score</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Hier j'ai <a href="http://lkdjiin.github.io/blog/2013/12/15/les-algorithmes-genetiques-demystifies-44-economie/">survolé les trois classes/modules</a> qui s'occupent de l'évaluation,
<code>Evaluator</code>, <code>Score</code> et <code>Fitness</code>. Aujourd'hui je parle en détail du
module <code>Score</code>.</p>

<!-- more -->


<p>Revoici donc le module <code>Score</code> au complet:</p>

<p>``` ruby
module Score
  def self.profit_and_cost(individual, items)</p>

<pre><code>profit = cost = 0
individual.chromosome.each_with_index do |number, index|
  profit += items[index].profit * number
  cost += items[index].cost * number
end
[profit, cost]
</code></pre>

<p>  end</p>

<p>  def compute_score!</p>

<pre><code>@population.each {|individual| individual.score = score(individual) }
shift
</code></pre>

<p>  end</p>

<p>  def score(individual)</p>

<pre><code>profit, cost = Score.profit_and_cost individual, @items
malus(profit, cost)
</code></pre>

<p>  end</p>

<p>  def malus(profit, cost)</p>

<pre><code>profit -= 2 * (cost - @capacity) if cost &gt; @capacity
profit
</code></pre>

<p>  end</p>

<p>  def shift</p>

<pre><code>score_min = @population.map(&amp;:score).min.abs
@population.map {|individual| individual.score += score_min + 1 }
</code></pre>

<p>  end
end
```</p>

<p>Voyons d'abord rapidement la méthode <code>compute_score!</code>:</p>

<p>``` ruby
  def compute_score!</p>

<pre><code>@population.each {|individual| individual.score = score(individual) }
shift
</code></pre>

<p>  end
```</p>

<p>On calcule/affecte le score de chaque individu. Puis on appelle une méthode
<code>shift</code>, dont on verra l'utilité bientôt.</p>

<p>La méthode <code>score</code> maintenant:</p>

<p>``` ruby
  def score(individual)</p>

<pre><code>profit, cost = Score.profit_and_cost individual, @items
malus(profit, cost)
</code></pre>

<p>  end
```</p>

<p>On calcule le profit et le coût du portefeuille d'actions que représente
un individu via la méthode de classe <code>Score.profit_and_cost</code>. Puis on envoit
tout ça dans une méthode <code>malus</code>, qui va gérer les individus invalides.</p>

<p>La méthode <code>Score.profit_and_cost</code> est le <em>coeur</em> du calcul:</p>

<p>``` ruby
  def self.profit_and_cost(individual, items)</p>

<pre><code>profit = cost = 0
individual.chromosome.each_with_index do |number, index|
  profit += items[index].profit * number
  cost += items[index].cost * number
end
[profit, cost]
</code></pre>

<p>  end
```</p>

<p>Comme je vais m'en servir dans d'autres parties du programme, j'en ai fait
une méthode de classe. On calcule le profit de l'individu en additionnant
le profit généré par chacune des actions. <code>items[index].profit</code> se
réfère à la liste <code>Knapsack::ITEMS</code> et <code>number</code> est un gène de l'individu.
On procède à l'identique pour le calculer le coût.</p>

<p>On peut passer à la méthode <code>malus</code>:</p>

<p>``` ruby
  def malus(profit, cost)</p>

<pre><code>profit -= 2 * (cost - @capacity) if cost &gt; @capacity
profit
</code></pre>

<p>  end
```</p>

<p>J'ai utilisé le même principe empirique que dans notre
<a href="http://lkdjiin.github.io/blog/2013/11/19/les-algorithmes-genetiques-demystifies-41-les-individus-invalides/">dernier programme</a>,
à savoir que si le coût dépasse la capacité d'investissement
je diminue le profit de deux fois la différence entre coût
et capacité.</p>

<p>Il reste à parler de la méthode <code>shift</code>:</p>

<p>``` ruby
  def shift</p>

<pre><code>score_min = @population.map(&amp;:score).min.abs
@population.map {|individual| individual.score += score_min + 1 }
</code></pre>

<p>  end
```</p>

<p>De la façon dont on a calculé le score, celui-ci peut être négatif. Ce
qui pose un problème avec le calcul de la <em>fitness</em>, qui attend un
nombre positif. La méthode <code>shift</code> sert à regler ceci.
Tout d'abord je calcule la valeur absolue du score minimum. Puis j'ajoute
cette valeur, plus 1, à chacun des scores. Ainsi je suis sûr que le score
minimal sera 1.</p>

<p>Voilà pour aujourd'hui. Comme d'habitude, c'est l'évaluation qui demande
le plus de reflexion et d'explications.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les algorithmes génétiques démystifiés 44: Économie]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/12/15/les-algorithmes-genetiques-demystifies-44-economie/"/>
    <updated>2013-12-15T18:25:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/12/15/les-algorithmes-genetiques-demystifies-44-economie</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Maintenant que <a href="">la population initiale est créée</a>,
voyons comment l'évaluer.</p>

<!-- more -->


<p>Voici la classe <code>Evaluator</code>, qui a pris un coup de jeune:</p>

<p>``` ruby
class Evaluator
  include Score
  include Fitness</p>

<p>  def initialize(capacity:, population:, items:)</p>

<pre><code>@capacity = capacity
@population = population
@items = items
</code></pre>

<p>  end</p>

<p>  def evaluate!</p>

<pre><code>compute_score!
compute_fitness!
</code></pre>

<p>  end
end
```</p>

<p>J'ai transferé les calculs du score et de la <em>fitness</em> dans des modules
car cette classe <code>Evaluator</code> commence à enfler (et aussi car je teste
quelques idées en vue d'un futur framework).</p>

<p>Le module <code>Score</code> est bien sûr responsable de l'évaluation d'un
portefeuille d'actions. Je le présenterais demain, car je n'ai
malheureusement pas le temps nécessaire aujourd'hui. Je vous donne
malgré tout le code dès maintenant:</p>

<p>``` ruby
module Score
  def self.profit_and_cost(individual, items)</p>

<pre><code>profit = cost = 0
individual.chromosome.each_with_index do |number, index|
  profit += items[index].profit * number
  cost += items[index].cost * number
end
[profit, cost]
</code></pre>

<p>  end</p>

<p>  def compute_score!</p>

<pre><code>@population.each {|individual| individual.score = score(individual) }
shift
</code></pre>

<p>  end</p>

<p>  def score(individual)</p>

<pre><code>profit, cost = Score.profit_and_cost individual, @items
malus(profit, cost)
</code></pre>

<p>  end</p>

<p>  def malus(profit, cost)</p>

<pre><code>profit -= 2 * (cost - @capacity) if cost &gt; @capacity
profit
</code></pre>

<p>  end</p>

<p>  def shift</p>

<pre><code>score_min = @population.map(&amp;:score).min.abs
@population.map {|individual| individual.score += score_min + 1 }
</code></pre>

<p>  end
end
```</p>

<p>En ce qui concerne le module <code>Fitness</code>, le code est le même que
d'habitude.</p>

<p>``` ruby
module Fitness
  def compute_fitness!</p>

<pre><code>total = @population.inject(0) {|sum, individual| sum + individual.score }
size = @population.size
@population.each do |individual|
  individual.fitness = individual.score.to_f / total * size
end
</code></pre>

<p>  end
end
```</p>

<p>Voilà, demain on verra en détail le module <code>Score</code>.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Les algorithmes génétiques démystifiés 43: Économie, la population]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/12/13/les-algorithmes-genetiques-demystifies-43-economie-la-population/"/>
    <updated>2013-12-13T21:36:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/12/13/les-algorithmes-genetiques-demystifies-43-economie-la-population</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Après avoir vu dernièrement l'énoncé du <a href="http://lkdjiin.github.io/blog/2013/12/11/les-algorithmes-genetiques-demystifies-42-un-probleme-deconomie/">problème d'investissement</a>
que je me propose de résoudre à l'aide d'un algorithme génétique, on
peut maintenant créer la population initiale.</p>

<!-- more -->


<p>Je me base sur le programme développé pour le problème du sac à dos
<a href="https://github.com/lkdjiin/knapsack_genetic_algorithm/blob/master/knapsack3.rb">disponible sur Github</a>.
Par contre, le code nécessite la version 2.1 de Ruby (disponible en
preview2 à l'heure où j'écris ces lignes).</p>

<p>Tout d'abord la classe <code>Individual</code>, qui recueille toutes les informations
sur nos individus: chromosome, score et fitness.</p>

<p>``` ruby
class Individual</p>

<p>  class &lt;&lt; self</p>

<pre><code>def random(items)
  new(nil, items)
end

def from_chromosome(chromosome)
  new(chromosome)
end

def listing(chromosome:, items:)
  chromosome.map.with_index do |gene, index|
    "#{gene} #{items[index].name}"
  end.join("\n")
end
</code></pre>

<p>  end</p>

<p>  attr_accessor :score, :fitness
  attr_reader :chromosome</p>

<p>  def initialize(chromosome = nil, items = nil)</p>

<pre><code>if chromosome
  @chromosome = chromosome
else
  @chromosome = []
  items.each_with_index do |item, index|
    @chromosome &lt;&lt; rand(0..item.number)
  end
end
</code></pre>

<p>  end
  private_class_method :new</p>

<p>  def >(other)</p>

<pre><code>return true if other.nil?
score &gt; other.score
</code></pre>

<p>  end
end
```</p>

<p>J'ai ajouté une méthode de classe <code>listing</code>:</p>

<p>``` ruby</p>

<pre><code>def listing(chromosome:, items:)
  chromosome.map.with_index do |gene, index|
    "#{gene} #{items[index].name}"
  end.join("\n")
end
</code></pre>

<p>```</p>

<p>Elle utilise <a href="http://lkdjiin.github.io/blog/2013/11/27/du-nouveau-dans-ruby-2-dot-1-argument-nomme-et-requis/">les arguments nommés requis</a> de Ruby 2.1 et prend en
paramêtre un chromosome et la liste des actions (<code>Knapsack::ITEMS</code>,
<a href="http://lkdjiin.github.io/blog/2013/12/11/les-algorithmes-genetiques-demystifies-42-un-probleme-deconomie/">voir l'article précédent</a>). Elle servira à afficher la liste des actions,
avec le nombre retenu pour chacune d'entres elles à la fin de l'algorithme.</p>

<p>Dans la méthode <code>initialize</code>, on peut voir comment je crée les chromosomes
de la population initiale:</p>

<p>``` ruby</p>

<pre><code>else
  @chromosome = []
  items.each_with_index do |item, index|
    @chromosome &lt;&lt; rand(0..item.number)
  end
end
</code></pre>

<p>```</p>

<p><code>items</code> se réfère à la liste des actions (<code>Knapsack::ITEMS</code>). Un chromosome est
une liste de la même taille que <code>items</code>. Chaque gène (ou emplacement dans
la liste) est un nombre compris entre zéro et le nombre maximum d'actions
pour cette action particulière (voir encore une fois <code>Knapsack::ITEMS</code>).</p>

<p>Maintenant, pour la création de la population proprement dite, il n'y a
rien de nouveau:</p>

<p>``` ruby
class Population &lt; Array
  def initialize(items, population_size)</p>

<pre><code>population_size.times { self &lt;&lt; Individual.random(items) }
</code></pre>

<p>  end</p>

<p>  def best</p>

<pre><code>self.sort_by{|individual| individual.score}.last
</code></pre>

<p>  end
end
```</p>

<p>La prochaine fois on verra l'évaluation…</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
