<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : unix | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/unix/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2014-01-30T20:48:07+01:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[L'auto-complétion programmable en Bash - partie 6]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/01/29/lauto-completion-programmable-en-bash-partie-6/"/>
    <updated>2014-01-29T20:47:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/01/29/lauto-completion-programmable-en-bash-partie-6</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-3'>Niveau : <span>avancé</span></div></p>

<p>Cet article est la suite de:
<a href="/blog/2014/01/15/lauto-completion-en-bash-partie-5/">L'auto complétion programmable en bash: partie 5</a>.</p>

<h2>Un motif général et basique</h2>

<p>Nous avons écrit un petit <a href="/blog/2014/01/14/lauto-completion-programmable-en-bash-partie-4/">programme pour tester</a>,
puis nous avons écrit <a href="/blog/2014/01/15/lauto-completion-en-bash-partie-5/">un script d'auto-complétion très simple</a>.
Reprenons notre jeu de rôle: nous avons un programme <code>mytool</code> qui
attend une des trois commandes suivantes: <code>new</code>, <code>compile</code> ou
<code>test</code>. On va ajouter ceci: la commande <code>new</code> peut prendre
l'option <code>--without-test</code> et la commande <code>compile</code> peut prendre
l'option <code>--verbose</code>. Ça reste encore très simple, mais on ne peut
déjà plus se servir uniquement de la fonction <code>complete</code>, vue
la dernière fois.</p>

<p>Voyons donc le motif général utilisé par beaucoup de scripts
d'auto-complétion:</p>

<!-- more -->


<p>``` bash /etc/bash_completion.d/mytool
_mytool()
{</p>

<pre><code>local current=${COMP_WORDS[COMP_CWORD]}
COMPREPLY=( $(compgen -W "new compile test" -- $current) )
</code></pre>

<p>}
complete -F _mytool mytool
```</p>

<p>Le script ci-dessus fait exactement la même chose que notre simple
script de la dernière fois, qui était le suivant:</p>

<p><code>bash /etc/bash_completion.d/mytool
complete -W "new compile test" mytool
</code></p>

<p>Mais il le fait d'une manière plus compliquée. En effet,
pourquoi faire simple… Les explications viendront plus tard.</p>

<p>En fait, pour aller plus loin, il est important de comprendre le rôle
des variables <code>COMP_WORDS</code>, <code>COMP_CWORD</code> et <code>COMPREPLY</code>. Pour ça, on
va modifier notre script, et chercher à comprendre ce que
représente <code>COMPREPLY</code>:</p>

<p>``` bash /etc/bash_completion.d/mytool
_mytool()
{</p>

<pre><code>COMPREPLY=( this is some replacement )
</code></pre>

<p>}
complete -F _mytool mytool
```</p>

<p>Pour qu'il soit pris en compte tout de suite, il faut le sourcer:</p>

<pre><code>$ source /etc/bash_completion.d/mytool
</code></pre>

<p>Alors, que fait-il ? Si je tapes <code>mytool foo bar[TAB]</code>, voici ce que
le script sort:</p>

<pre><code>$ mytool foo bar[TAB]
is           replacement  some         this   
</code></pre>

<p>COMPREPLY accepte un tableau de chaînes, qui sont les suggestions que
nous renvoit l'auto-complétion. On note au passage que ces suggestions
sont triées alphabétiquement.</p>

<p>Modifions à nouveau notre script:</p>

<p>``` bash /etc/bash_completion.d/mytool
_mytool()
{</p>

<pre><code>COMPREPLY=( replacement )
</code></pre>

<p>}
complete -F _mytool mytool
```</p>

<p>Cette fois, COMPREPLY représente un tableau d'un seul élément.
N'oubliez pas de sourcer le script avant de le tester:</p>

<pre><code>$ mytool foo bar[TAB]
</code></pre>

<p>devient:</p>

<pre><code>$ mytool foo replacement
</code></pre>

<p>Vous devriez maintenant avoir bien compris à quoi sert la variable
<code>COMPREPLY</code>.</p>

<p>La prochaine fois, on regardera en détail les variables <code>COMP_WORDS</code>
et <code>COMP_CWORD</code>.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[L'auto-complétion en Bash - partie 5]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/01/15/lauto-completion-en-bash-partie-5/"/>
    <updated>2014-01-15T20:44:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/01/15/lauto-completion-en-bash-partie-5</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Cet article est la suite de:
<a href="http://lkdjiin.github.io/blog/2014/01/14/lauto-completion-programmable-en-bash-partie-4/">L'auto complétion programmable en bash: partie 4</a>.</p>

<h2>Les bases de l'auto complétion programmable</h2>

<p>Une application peut proposer ses services d'auto complétion en déposant
un fichier bash dans le dossier <code>/etc/bash_completion.d/</code>.
On y voit un tas de fichiers, pour des programmes bien connus:</p>

<pre><code>[~]⇒ ls /etc/bash_completion.d/
abook
ant
apache2.2-common
apache2ctl
apt
...
git
...
</code></pre>

<p>Il suffit juste de savoir quoi mettre dedans. Allons-y:</p>

<!-- more -->


<p><code>bash /etc/bash_completion.d/mytool
complete -W "new compile test" mytool
</code></p>

<p>Le fichier sera chargé automatiquement au lancement de bash. Donc pour que
ça fonctionne maintenant, soit vous le sourcez, soit vous lancez une
nouvelle console et, &ndash; <em>roulements de tambours</em>&ndash;</p>

<pre><code>[~]⇒ mytool [TAB]
compile  new      test     
[~]⇒ mytool 
</code></pre>

<p>Magique, non ? Il faut noter que l'auto complétion fonctionnera aussi
avec des options:</p>

<p><code>bash /etc/bash_completion.d/mytool
complete -W "new compile test --verbose" mytool
</code></p>

<pre><code>[~]⇒ mytool c[TAB] -[TAB]
mytool compile --verbose
</code></pre>

<p>Donc, comment ça marche ? Voici la traduction de l'aide de <code>complete</code>,
simplifiée au maximum:</p>

<p><strong>complete</strong> [<em>options</em>] <em>name</em>   <br/>
Spécifie comment les arguments doivent être complétés, pour chaque <em>name</em>.</p>

<p>L'option <code>-W</code> permet de lui passer une liste de mots. Finalement c'était
facile ? Humm… En fait ce sera rarement aussi simple. Pour continuer notre
jeu de rôle, disons que l'option <code>--verbose</code> peut s'appliquer uniquement
à l'argument <code>new</code>, et pas aux deux autres. Du coup, notre commande
<code>complete</code> ne suffit plus. Il va falloir trouver autre chose et c'est ce
qu'on verra dans un prochain article.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[L'auto-complétion programmable en bash - partie 4]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/01/14/lauto-completion-programmable-en-bash-partie-4/"/>
    <updated>2014-01-14T20:54:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/01/14/lauto-completion-programmable-en-bash-partie-4</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Cet article est la suite de:
<a href="http://lkdjiin.github.io/blog/2014/01/13/lauto-completion-programmable-en-bash-partie-3/">L'auto complétion programmable en bash: partie 3</a>.</p>

<h2>Un programme bidon pour tester</h2>

<p>On va faire un petit jeu de rôle : Vous avez écrit un nouveau langage
informatique revolutionnaire, et maintenant vous voulez lui adjoindre
un outil pour faciliter la gestion des projets. Ce fameux programme, qui
va s'appeller «mytool» aura 3 commandes: <code>new</code>, pour créer un projet,
<code>compile</code>, pour compiler le projet, et <code>test</code>, pour le tester. Et bien sûr,
vous voulez profiter des joies de l'auto complétion:</p>

<pre><code>mytool c[TAB]
</code></pre>

<p>devra devenir:</p>

<pre><code>mytool compile
</code></pre>

<!-- more -->


<p>Pour comprendre les prochains articles, on est pas obligé d'avoir un «vrai»
programme. Mais c'est quand même plus drôle pour faire tout un tas de tests.
Voici donc le magnifique programme <code>mytool</code>:</p>

<p>``` bash mytool</p>

<h1>!/usr/bin/env bash</h1>

<p>case $1 in
  new )</p>

<pre><code>echo Project created ;;
</code></pre>

<p>  test )</p>

<pre><code>echo Project tested ;;
</code></pre>

<p>  compile )</p>

<pre><code>echo Project compiled ;;
</code></pre>

<ul>
<li>)
echo error ;;
esac
```</li>
</ul>


<p>Assurez vous que le programme ait les droits d'exécution (<code>chmod +x</code>)
et qu'il soit dans votre PATH:</p>

<pre><code>[~]⇒ mytool new
Project created
[~]⇒ mytool test
Project tested
[~]⇒ mytool compile
Project compiled
[~]⇒ mytool
error
</code></pre>

<p>La prochaine, promis, on commencera vraiment à faire de l'auto-complétion.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[L'auto-complétion programmable en Bash - partie 3]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/01/13/lauto-completion-programmable-en-bash-partie-3/"/>
    <updated>2014-01-13T20:50:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/01/13/lauto-completion-programmable-en-bash-partie-3</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Cet article est la suite de:
<a href="http://lkdjiin.github.io/blog/2014/01/11/lauto-completion-en-bash-partie-2/">L'auto complétion programmable en bash: partie 2</a>.</p>

<p>Je joue donc quelques minutes avec la commande <code>compgen</code>, juste pour voir
de quoi il s'agit. L'option <code>-W</code> retient particulièrement mon attention.
On lui passe une liste de mots entre guillemets et ça nous les renvoient:</p>

<pre><code>[~]⇒ compgen -W "foo bar baz"
foo
bar
baz
</code></pre>

<!-- more -->


<p>Ok, on va pas se mentir, vous ne voyez pas tellement l'intérêt, hein ?
Et si on passait un second argument à <code>compgen</code>, comme le début d'un
mot:</p>

<pre><code>[~]⇒ compgen -W "foo bar baz" f
foo
</code></pre>

<p>Ou bien encore:</p>

<pre><code>[~]⇒ compgen -W "foo bar baz" ba
bar
baz
</code></pre>

<p>Voilà qui est intéressant. Et si on lui donne un début de mot inexistant:</p>

<pre><code>[~]⇒ compgen -W "foo bar baz" o
[~]⇒ 
</code></pre>

<p>Les sections <strong>complete</strong> et surtout <strong>programmable completion</strong> de la page
de man sont particulièrement indigestes. Je me doute que je devrais les lire
si je veux aller plus loin, mais ça attendra encore.
Donc je google «bash programmable completion» et je trouve ce qu'il me faut pour
commencer. La suite la prochaine fois.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[L'auto-complétion programmable en Bash - partie 2]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/01/11/lauto-completion-en-bash-partie-2/"/>
    <updated>2014-01-11T20:33:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/01/11/lauto-completion-en-bash-partie-2</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Cet article est la suite de:
<a href="http://lkdjiin.github.io/blog/2014/01/10/lauto-completion-programmable-en-bash-partie-1/">L'auto complétion programmable en bash: partie 1</a>.</p>

<h2>Une première piste</h2>

<p>En parcourant rapidement la page de man de bash, je tombe sur une commande
pleine de promesse: la commande <code>compgen</code>.</p>

<!-- more -->


<p>Voici un extrait de la documentation:</p>

<p><strong>compgen</strong> [<em>option</em>] [<em>word</em>] <br/>
Generate possible completion matches for word according to the options, which
may be any option accepted by the <strong>complete</strong> builtin with the exception of -p
and -r, and write the matches to the standard output. When using the -F or -C
options, the various shell variables set by the <strong>programmable completion</strong>
<em>[&hellip;]</em></p>

<p>J'ai donc une commande <code>compgen</code>, qui semble fournir les différentes
possibilités de complétions pour un mot. J'ai aussi une commande <code>complete</code>,
dont le nom sonne vraiment bien. Et on me confirme que bash peut faire de
la <code>programmable completion</code>, même si je sais pas encore trop de quoi on
parle ici… Je vais devoir fouiller un peu les options de <code>complete</code> pour
apprendre comment fonctionne <code>compgen</code>. Ah, les joies du man Unix !</p>

<p>Mon voyage dans le monde de l'auto-complétion débute avec une page de man.
Y a plus sexy, mais bon, il faut bien commencer quelque part ;)</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
