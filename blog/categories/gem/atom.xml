<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : gem | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/gem/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2014-05-01T17:01:41+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Mettre à jour des gems ayants des références circulaires avec Bundle]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/04/28/mettre-a-jour-des-gems-ayants-des-references-circulaires-avec-bundle/"/>
    <updated>2014-04-28T21:25:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/04/28/mettre-a-jour-des-gems-ayants-des-references-circulaires-avec-bundle</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Ok, c'est sûrement le titre le plus incompréhensible de l'histoire de ce
blog. Mais je n'arrive pas à trouver mieux…</p>

<p>Prenons le Gemfile fictif suivant:</p>

<pre><code>gem a
gem b
gem c
</code></pre>

<p>Je veux mettre à jour la gem a, de la version 1.0.0 vers la nouvelle version
1.0.1.</p>

<!-- more -->


<p>Pour ça je fais évidemment:</p>

<pre><code>bundle update a
</code></pre>

<p>Mais voilà que <code>bundle</code> me répond quelque chose comme ça:</p>

<pre><code>impossible de mettre à jour la gem a
la gem a 1.0.1 dépend de la gem b 1.0.1
</code></pre>

<p>D'accord, pas de souci, je fais donc:</p>

<pre><code>bundle update b
</code></pre>

<p>Et devinez ce que ce cher <code>bundle</code> me répond ?</p>

<pre><code>impossible de mettre à jour la gem b
la gem b 1.0.1 dépend de la gem c 1.0.1
</code></pre>

<p>Bon, j'espère que c'est bientôt fini. Parce que évidemment mon Gemfile
réel ne comporte pas que 3 gems, lui. Donc je me soumet:</p>

<pre><code>bundle update c
</code></pre>

<p>Et la réponse ne tarde pas:</p>

<pre><code>impossible de mettre à jour la gem c
la gem c 1.0.1 dépend de la gem a 1.0.1
</code></pre>

<p>Super :( J'ai l'impression qu'on me demande de remplir un formulaire
administratif ! La gem a dépend de b, qui elle, dépend de c, qui à son
tour dépend de a…</p>

<p>Malgré tout, la solution est très simple (merci collègue
<a href="https://twitter.com/hellvinz">@hellvinz</a>) il suffit de mettre à jour les
3 gems en même temps:</p>

<pre><code>bundle update a b c
</code></pre>

<p>Et le tour est joué. Peut-être que vous le saviez déjà ? Mais moi j'avais
raté cette partie de Bundle.</p>

<p>Aujourd'hui j'ai encore appris quelque chose :)</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sortie de coco 0.9]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/02/11/sortie-de-coco-0-dot-9/"/>
    <updated>2014-02-11T20:40:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/02/11/sortie-de-coco-0-dot-9</id>
    <content type="html"><![CDATA[<p>La version 0.9 de la gem coco est sortie il y a quelques jours.
Coco est une bibliothèque de couverture de code (code coverage) pour
Ruby de 1.9.2 à 2.1.</p>

<!-- more -->


<p>Cette nouvelle version ajoute une option de configuration qui permet
de dire à <em>coco</em> quand démarrer, ou quand ne pas démarrer.</p>

<p>Pour les projets où la suite de tests met beaucoup de temps à tourner,
on fini souvent par jouer un seul test quand on développe, et la suite
entière seulement avant de commiter et/ou pusher. Dans ce cas, le
comportement de <em>coco</em> pouvait être assez agaçant puisque la gem
reportait une longue liste de fichiers non-couverts. Maintenant c'est
arrangé, mettez ceci dans votre fichier de configuration:</p>

<pre><code>:always_run: false
</code></pre>

<p>Lorsque vous lancez les tests comme d'habitude (ou <code>rake</code>, ou un
seul fichier, etc):</p>

<pre><code>rspec spec/
</code></pre>

<p><em>Coco</em> ne démarrera pas. Pour lui dire de faire son travail, il suffit
de définir la variable d'environnement <code>COCO</code>:</p>

<pre><code>COCO=1 rspec spec/
</code></pre>

<p>Vous pouvez <a href="https://github.com/lkdjiin/coco">télécharger</a> coco sur Github.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sortie de coco 0.8]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/12/25/sortie-de-coco-0-dot-8/"/>
    <updated>2013-12-25T19:23:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/12/25/sortie-de-coco-0-dot-8</id>
    <content type="html"><![CDATA[<p>La version 0.8 de la gem coco est sortie il y a quelques jours.
Coco est une bibliothèque de couverture de code (<em>code coverage</em>) pour
Ruby.</p>

<!-- more -->


<p>Cette nouvelle version est essentiellement cosmétique. Elle améliore le
visuel de la page d'index du rapport Html, et supprime le besoin des
fichiers CSS de Yahoo!</p>

<p><img src="/images/Capture-4.png"></p>

<p>Vous pouvez <a href="https://github.com/lkdjiin/coco">télécharger coco</a> depuis Github, ou l'installer directement:</p>

<pre><code>gem install coco
</code></pre>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Remplacer Sed et Awk par Ruby 11: La gem English]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/12/14/remplacer-sed-et-awk-par-ruby-11-la-gem-english/"/>
    <updated>2013-12-14T16:59:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/12/14/remplacer-sed-et-awk-par-ruby-11-la-gem-english</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Après avoir vu <a href="http://lkdjiin.github.io/blog/2013/12/12/remplacer-sed-et-awk-par-ruby-10-un-exemple-dutilisation/">un exemple d'utilisation</a> du mode <em>sed/awk</em> de Ruby au travers
d'un <em>one liner</em>, on regarde aujourd'hui la gem English, qui facilite
énormement la
vie pour l'écriture des scripts.</p>

<!-- more -->


<p>On a vu jusqu'à présent deux variables globales, j'ai nommé <code>$_</code> et
<code>$;</code>. Ces noms sont justes barbares et imprononçables. Et des variables
globales de ce genre, il y en a quelques autres qui vont nous être utiles.
Voyons voir si vous êtes capable de deviner ce qu'elles représentent:
<code>$,</code>, <code>$\</code>, <code>$/</code> et <code>$.</code>. Vous avez deviné ? Non ? C'est là qu'entre en
jeu <a href="http://ruby-doc.org/stdlib-2.0.0/libdoc/English/rdoc/English.html">la gem English</a>. Cette gem va nous permettre d'accéder à ces
variables à l'aide de noms compréhensibles par le commun des mortels:</p>

<pre><code>   Nom court   Nom long
$; $FS         $FIELD_SEPARATOR
$, $OFS        $OUTPUT_FIELD_SEPARATOR 
$/ $RS         $INPUT_RECORD_SEPARATOR
$\ $ORS        $OUTPUT_RECORD_SEPARATOR
$. $NR         $INPUT_LINE_NUMBER
$_             $LAST_READ_LINE
</code></pre>

<p>Pour avoir accès à ceci dans un script, il faudra charger la gem dans
un bloc BEGIN:</p>

<p><code>ruby
BEGIN { require 'English' }
</code></p>

<p>Alors quand se servir des noms courts, des noms longs ? Tout dépend de
votre <em>background</em> et de votre tâche.</p>

<p>Si vous débutez en Ruby, si vous devez écrire un script long et/ou complexe,
si le script doit être maintenu pendant des mois ou plus, si il est maintenu
par plusieurs personnes, utilisez les noms longs.</p>

<p>Si vous (et votre équipe) avez une expérience de Awk, les noms courts peuvent
être une solution raisonnable.</p>

<p>Quand aux noms <em>barbares</em>, réservez les pour les <em>one liners</em>, les scripts
courts <em>one shot</em> et les séances de masochisme.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Prise en main de la gem chunky_png]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/11/07/prise-en-main-de-la-gem-chunky-png/"/>
    <updated>2013-11-07T17:32:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/11/07/prise-en-main-de-la-gem-chunky-png</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Pour un projet j'ai besoin de manipuler du format png et j'ai décidé
d'utiliser la gem <code>chunky_png</code> pour faire ça. Comme je ne la connais pas,
j'écris aujourd'hui une rapide prise en main de cette gem, histoire de me
familiariser avec.</p>

<p>Pour l'installer, c'est comme d'habitude:</p>

<pre><code>gem install chunky_png
</code></pre>

<!-- more -->


<p>Pour la documentation on pourra commencer par <a href="https://github.com/wvanbergen/chunky_png/wiki">le wiki</a> du projet.</p>

<p>La première chose que je veux faire c'est lire et écrire un fichier png.</p>

<p>``` ruby test.rb
require &ldquo;chunky_png&rdquo;</p>

<p>image = ChunkyPNG::Image.from_file(ARGV[0])
image.save(&ldquo;copy.png&rdquo;)
```</p>

<p>Après l'avoir lancé, ce programme crée une copie de l'image originale sous le
nom &ldquo;copy.png&rdquo;:</p>

<pre><code>[~]⇒ ruby test.rb test.png 
</code></pre>

<p>Super, bon début. Maintenant je voudrais accéder à la valeur RGB d'un pixel
quelconque de l'image. Voici le second programme:</p>

<p>``` ruby test2.rb
require &ldquo;chunky_png&rdquo;</p>

<p>image = ChunkyPNG::Image.from_file(ARGV[0])</p>

<p>p ChunkyPNG::Color.r(image[0, 0])
p ChunkyPNG::Color.g(image[20, 20])
p ChunkyPNG::Color.b(image[40, 40])
p ChunkyPNG::Color.to_hex(image[60, 60])
p ChunkyPNG::Color.to_truecolor_bytes(image[80, 80])
```</p>

<p>Et un exemple de sortie possible:</p>

<pre><code>[~]⇒ ruby test2.rb test.png 
255
255
255
"#000000ff"
[0, 0, 0]
</code></pre>

<p>L'image est vue comme un tableau à 2 dimensions: <code>image[x, y]</code>.
Les méthodes <code>r</code>, <code>g</code> et <code>b</code> renvoient respectivement la composante rouge,
verte ou bleue du pixel. La méthode <code>to_hex</code> formate <em>à la HTML</em> et la
méthode <code>to_truecolor_bytes</code> renvoie un tableau des trois composantes RGB.</p>

<p>J'aimerais maintenant dessiner un rectangle dans l'image:</p>

<p>``` ruby test3.rb
require &ldquo;chunky_png&rdquo;</p>

<p>image = ChunkyPNG::Image.from_file(ARGV[0])
image.rect(0, 0, 99, 99)
image.save(&ldquo;copy.png&rdquo;)
```</p>

<p>Si vous lancez ce programme (avec <code>ruby test3.rb test.png</code>), vous verrez
qu'il dessine bien un rectangle (x = 0, y = 0, largeur = 99, hauteur = 99).
Malheureusement, seul le <em>contour</em> du rectangle est dessiné.
Pour dessiner un rectangle rempli, il en faut un peu plus:</p>

<p>``` ruby test4.rb
require &ldquo;chunky_png&rdquo;</p>

<p>my_color = ChunkyPNG::Color.rgb(10, 100, 200)</p>

<p>image = ChunkyPNG::Image.from_file(ARGV[0])
image.rect(0, 0, 99, 99, my_color, my_color)
image.save(&ldquo;copy.png&rdquo;)
```</p>

<p>Cette fois on a bien un rectangle <em>rempli</em>. Et au passage on voit comment
définir une couleur au format RGB.</p>

<p>Pour finir, je voudrais créer une image:</p>

<p>``` ruby test5.png
require &ldquo;chunky_png&rdquo;</p>

<p>image = ChunkyPNG::Image.new(400,</p>

<pre><code>                         400,
                         ChunkyPNG::Color::WHITE)
</code></pre>

<p>my_color = ChunkyPNG::Color.rgb(10, 100, 200)
my_color2 = ChunkyPNG::Color.rgb(110, 10, 100)</p>

<p>image.rect(0, 0, 199, 199, my_color, my_color)
image.rect(200, 200, 399, 399, my_color2, my_color2)</p>

<p>image.save(&ldquo;new.png&rdquo;)
```</p>

<p>Le programme se lance avec <code>ruby test5.rb</code> et crée une nouvelle image <code>new.png</code>.
Le constructeur de <code>Image</code> prend tout simplement la largeur, la hauteur et
la couleur de fond de l'image.</p>

<p>En bref, <code>chunky_png</code> est une gem qui a l'air simple a utiliser.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
