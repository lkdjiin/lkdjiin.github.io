<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : racket | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/racket/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2014-10-17T21:22:34+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Le jeu de la vie dans sept langages différents]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/10/08/le-jeu-de-la-vie-dans-sept-langages-differents/"/>
    <updated>2014-10-08T12:30:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/10/08/le-jeu-de-la-vie-dans-sept-langages-differents</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Je vais écrire le <a href="http://en.wikipedia.org/wiki/Conway%27s_Game_of_Life">jeu de la vie</a> dans 7 langages, et
en utilisant le TDD (sauf pour l'affichage).
Ça va me permettre de réviser certains langages et d'en apprendre de nouveaux
d'une manière amusante. Après tout, quoi de plus <em>fun</em> qu'un jeu pour zéro
joueur.</p>

<h2>L'algorithme</h2>

<p>L'idée directrice, c'est de faire au plus simple.
L'algorithme général sera le suivant :</p>

<ol>
<li>obtenir une première génération au hasard</li>
<li>afficher la génération</li>
<li>calculer la nouvelle génération et retour au point 2.</li>
</ol>


<p>Discutons un peu chacun des trois points.</p>

<!-- more -->


<h3>Obtenir une première génération au hasard</h3>

<p>Cette génération sera stockée dans un tableau (une liste). Suivant le
langage, j'utiliserais un tableau à 1 ou 2 dimensions.</p>

<h3>Afficher la génération</h3>

<p>Il s'agit d'afficher à l'écran le tableau calculé précédement. Chaque élément
du tableau représente une cellule du jeu de la vie, et une cellule sera
représentée à l'écran par un pixel. Alors un pixel pour une cellule, ça risque
d'être assez moche sur la plupart des dispositifs, mais c'est le plus simple.
J'améliorerais peut-être cet affichage plus tard.</p>

<h3>Calculer la nouvelle génération</h3>

<p>Là encore, j'essaye d'aller au plus simple. On va calculer la
nouvelle génération dans un second tableau. Une fois ce calcul effectué, ce
second tableau remplacera le premier.</p>

<p>Pour calculer le nouvel état d'une cellule, on devra observer la cellule et
ces 8 voisins. Autrement dit on observe une fenêtre de 9 cellules et on veut
connaitre le nouvel état de la cellule centrale. Il y a 3 cas possibles:</p>

<ol>
<li>Si la somme des cellules vivantes est 3, alors la nouvelle cellule sera
vivante.</li>
<li>Si la somme des cellules vivantes est 4, alors la nouvelle cellule conserve
son ancien état.</li>
<li>Dans tous les autres cas, la nouvelle cellule est morte.</li>
</ol>


<p>Il faut encore parler du cas des cellules qui se trouvent sur les bords du
<em>plateau de jeu</em>. Normalement, le jeu de la vie est infini. Mais l'infini, c'est
pas simple. Dans une première itération, le <em>plateau de jeu</em> aura des
dimensions finies et les cellules qui se trouvent sur les bords se verront
ajoutées arbitrairement des voisins morts.</p>

<p>Une seconde itération pourrait implémenter une espèce de <a href="http://en.wikipedia.org/wiki/Torus">tore</a> pour avoir une surface
de jeu sans bordures.</p>

<h2>Les langages ciblés</h2>

<p>Je vais écrire le jeu de la vie dans 7 langages différents:</p>

<ul>
<li>ruby</li>
<li>javascript</li>
<li>racket</li>
<li>logo</li>
<li>julia</li>
<li>haskell</li>
<li>rust</li>
</ul>


<h3>Pourquoi ces langages ?</h3>

<p><strong>Ruby</strong></p>

<p>Ça peut paraitre bizarre. Après tout j'écris en Ruby toute la journée, c'est
mon métier. Pourquoi vouloir en faire encore pendant mon temps libre ?
En fait, ce qui m'intéresse vraiment ici, c'est <a href="http://opalrb.org/">Opal.rb</a>. Peut-être aussi
que j'en ferais une seconde version avec <a href="http://www.libgosu.org/">Gosu</a>.</p>

<p><strong>Javascript</strong></p>

<p>Après des années passées à tenter d'éviter d'écrire la moindre ligne de
Javascript, je m'intéresse de nouveau à ce langage. Après tout, c'est un
incontournable du Web et il commence à me plaire. Et puis j'ai trop tardé à
faire du TDD avec Javascript, je crois que <a href="http://jasmine.github.io/">Jasmine</a> est devenu très bon.</p>

<p><strong>Racket</strong></p>

<p>Je crois que tout développeur devrait étudier un <em>Lisp like</em>. Lisp t'oblige à
penser autrement et du coup tu trouves des solutions différentes à des
problèmes de programmation de tout les jours.</p>

<p><strong>Logo</strong></p>

<p>Le <a href="http://fr.wikipedia.org/wiki/Logo_%28langage%29">Logo</a>, c'est ma <a href="http://fr.wikipedia.org/wiki/Madeleine_%28cuisine%29#La_madeleine_de_Proust">madeleine de Proust</a> ! Voilà. Encore un <em>Lisp like</em>,
mais différent (on l'appelait Lisp sans parenthèses). J'espère que je trouverais
encore des ressources pour celui-ci.</p>

<p><strong>Julia</strong></p>

<p>Je pense que les langages fonctionnels ont un grand avenir. Ils résolvent au
moins deux soucis. En ce concentrant sur la transformation des données plutôt
que sur l'état de ces données, ils facilitent les tests et l'utilisation des
multi-coeurs.</p>

<p><strong>Haskell</strong></p>

<p>Encore un langage fonctionnel, et celui-ci me fait un peu peur. Mais je me dis
que je devrais y goûter.</p>

<p><strong>Rust</strong></p>

<p>Je voulais un langage système dans cette liste, ce sera <a href="http://www.rust-lang.org/">Rust</a>.</p>

<h2>Fréquence de publication</h2>

<p>Je ne m'avancerais pas sur une fréquence de publication. J'imagine qu'il y
aura 3 ou 4 articles par langage. Et suivant le temps dont je disposerais, ça
pourrat-être aussi bien un article par mois ou trois articles par semaine.</p>

<p>Allez, la prochaine fois on commence avec Ruby/Opal.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Racket: Trouves mon nombre - partie 4]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/01/16/racket-trouves-mon-nombre-partie-4/"/>
    <updated>2014-01-16T20:47:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/01/16/racket-trouves-mon-nombre-partie-4</id>
    <content type="html"><![CDATA[<p>Suite à <a href="http://lkdjiin.github.io/blog/2014/01/09/trouves-mon-nombre-partie-3/">l'article précédent</a>,
on voit aujourd'hui la fonction <code>start</code> qui permet de démarrer le jeu avec
n'importe quelle étendue de nombres.</p>

<!-- more -->


<p>Voici tout d'abord le programme complet:</p>

<p>``` racket guess.rkt</p>

<h1>lang racket</h1>

<p>(define lower 1)
(define upper 100)</p>

<p>(define (guess)
  (quotient (+ lower upper) 2))</p>

<p>(define (smaller)
  (set! upper (max lower (sub1 (guess))))
  (guess))</p>

<p>(define (bigger)
  (set! lower (min upper (add1 (guess))))
  (guess))</p>

<p>(define (start n m)
  (set! lower (min n m))
  (set! upper (max n m))
  (guess))
```</p>

<p>On peut maintenant demander à la machine de <em>deviner</em> un nombre entre
n et m:</p>

<pre><code>[~]⇒ racket
Welcome to Racket v5.3.6.
-&gt; (enter! "guess.rkt")
-&gt; (start 1 10)
5
-&gt; (bigger)
8
-&gt; (smaller)
6
</code></pre>

<p>La fonction <code>start</code> utilise des notions déjà vues dans les articles
précédents.</p>

<p><code>racket
(define (start n m)
  (set! lower (min n m))
  (set! upper (max n m))
  (guess))
</code></p>

<p>Grâce à <code>set!</code>, on redéfini la valeur des variables <code>lower</code> et <code>upper</code>. Puis
on débute le jeu en lançant <code>guess</code>.</p>

<p>La variable <code>lower</code> se voit affecter la plus petite des valeurs passées en
arguments, grâce à <code>min</code>. Et <code>upper</code> se voit affecter la plus grande
grâce à <code>max</code>. Du coup, l'ordre des arguments de <code>start</code> n'a plus
d'importance:</p>

<pre><code>-&gt; (start 1000 1)
500
-&gt; (start 1 1000)
500
</code></pre>

<p>Voilà qui conclue cette petite introduction au langage Racket.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Trouves mon nombre - partie 3]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/01/09/trouves-mon-nombre-partie-3/"/>
    <updated>2014-01-09T21:00:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/01/09/trouves-mon-nombre-partie-3</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Aujourd'hui on regarde la fonction <code>bigger</code>, qui est l'inverse de la
fonction <code>smaller</code> <a href="http://lkdjiin.github.io/blog/2014/01/05/racket-trouves-mon-nombre-partie-2/">vue la dernière fois</a>.</p>

<!-- more -->


<p>Voici donc notre nouveau fichier <code>guess.rkt</code> avec sa nouvelle fonction:</p>

<p>``` racket guess.rkt</p>

<h1>lang racket</h1>

<p>(define lower 1)
(define upper 100)</p>

<p>(define (guess)
  (quotient (+ lower upper) 2))</p>

<p>(define (smaller)
  (set! upper (max lower (sub1 (guess))))
  (guess))</p>

<p>(define (bigger)
  (set! lower (min upper (add1 (guess))))
  (guess))
```</p>

<p>La fonction <code>bigger</code> fait exactement l'inverse de <code>smaller</code>:</p>

<pre><code>[~]⇒ racket
Welcome to Racket v5.3.6.
-&gt; (enter! "guess.rkt")
-&gt; (guess)
50
-&gt; (bigger)
75
</code></pre>

<p>Et c'est tout ce qu'il nous faut pour que la machine trouve le
nombre que j'ai choisi. Si par exemple je pensais au nombre
77, on continuerait ainsi:</p>

<pre><code>-&gt; (bigger)
88
-&gt; (smaller)
81
-&gt; (smaller)
78
-&gt; (smaller)
76
-&gt; (bigger)
77
</code></pre>

<p>La prochaine fois, on verra comment démarrer le jeu avec n'importe
quelle étendue de nombres.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Racket: Trouves mon nombre - partie 2]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/01/05/racket-trouves-mon-nombre-partie-2/"/>
    <updated>2014-01-05T20:32:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/01/05/racket-trouves-mon-nombre-partie-2</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Suite de l'article d'hier, aujourd'hui on ajoute la fonction
<code>smaller</code> à notre petit jeu textuel.</p>

<!-- more -->


<p>Voici le fichier <code>guess.rkt</code> avec la nouvelle fonction:</p>

<p>``` racket guess.rkt</p>

<h1>lang racket</h1>

<p>(define lower 1)
(define upper 100)</p>

<p>(define (guess)
  (quotient (+ lower upper) 2))</p>

<p>(define (smaller)
  (set! upper (max lower (sub1 (guess))))
  (guess))
```</p>

<p>Cette fonction change l'étendue du nombre à trouver, puis fait une nouvelle
proposition:</p>

<pre><code>[~]⇒ racket
Welcome to Racket v5.3.6.
-&gt; (enter! "guess.rkt")
-&gt; (guess)
50
-&gt; (smaller)
25
</code></pre>

<p>Voyons notre nouvelle fonction en détail:</p>

<p><code>racket
(define (smaller)
  (set! upper (max lower (sub1 (guess))))
  (guess))
</code></p>

<p>Si le nombre à trouver est plus petit que 50, il est donc compris entre
1 et 49. Il faut donc changer la limite haute (<code>upper</code>) pour refléter
cette nouvelle donne.</p>

<p>Le rôle de <code>set!</code> est de redéfinir une variable. Ici, on va changer le
contenu de la variable <code>upper</code>.</p>

<p>La fonction <code>sub1</code> décremente le nombre passé en argument, donc
<code>(sub1 (guess))</code> renvoie 49. Et nous prenons, grâce à <code>max</code>, le nombre maximum entre
celui-ci (49) et la valeur de la limite basse, ce qui permet de
s'assurer que la valeur de <code>upper</code> ne sera jamais inférieure à
la valeur de <code>lower</code>. Ce qu'on peut vérifier en continuant à évaluer
<code>smaller</code>:</p>

<pre><code>-&gt; (smaller)
25
-&gt; (smaller)
12
-&gt; (smaller)
6
-&gt; (smaller)
3
-&gt; (smaller)
1
-&gt; (smaller)
1
-&gt; (smaller)
1
...
</code></pre>

<p>La prochaine fois on verra la fonction inverse: <code>bigger</code> que vous
pouvez essayer de coder par vous-même en attendant.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Racket: Trouves mon nombre - partie 1]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/01/04/racket-trouves-mon-nombre-partie-1/"/>
    <updated>2014-01-04T19:12:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/01/04/racket-trouves-mon-nombre-partie-1</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>«Devines un nombre entre 1 et 100 !» C'est le jeu que je vous propose
d'écrire en Racket pour apprendre ce langage.
Le code provient du livre <a href="http://realmofracket.com/">Realm of Racket</a>
et il est livré avec Racket. Vous pourrez le trouver dans le dossier
<code>collects/realm/chapter2</code> de votre installation de Racket.</p>

<!-- more -->


<p>Voici le morceau de code qu'on va voir aujourd'hui:</p>

<p>``` racket guess.rkt</p>

<h1>lang racket</h1>

<p>(define lower 1)
(define upper 100)</p>

<p>(define (guess)
  (quotient (+ lower upper) 2))
```</p>

<p>Enregistrez le dans un fichier <code>guess.rkt</code>. Pour le charger, lancez <code>racket</code>
et tapez <code>(enter! "guess.rkt")</code>:</p>

<pre><code>[~]⇒ racket
Welcome to Racket v5.3.6.
-&gt; (enter! "guess.rkt")
</code></pre>

<p>Si vous demandez l'évaluation de la fonction <code>guess</code>, vous obtiendrez 50:</p>

<pre><code>-&gt; (guess)
50
</code></pre>

<p>Voici quelques explications. On a tout d'abord défini deux variables,
<code>lower</code> et <code>upper</code>, qui sont les limites basses et hautes de l'étendue
sur laquelle la machine va <em>deviner</em> un nombre:</p>

<p><code>racket
(define lower 1)
(define upper 100)
</code></p>

<p>Plus tard dans le programme, le contenu de ces variables changera pour
réduire l'étendue.</p>

<p>Maintenant, voyons comment la machine <em>devine</em> un nombre:</p>

<p><code>racket
(define (guess)
  (quotient (+ lower upper) 2))
</code></p>

<p>Tout simplement en donnant le nombre qui se trouve au milieu des limites
basses et hautes. Pour trouver ce nombre, on divise par 2 la somme de la limite
basse et de la limite haute. On doit ici utiliser <code>quotient</code> pour faire
la division, et non pas <code>/</code>. En effet:</p>

<pre><code>-&gt; (/ 101 2)
101/2
</code></pre>

<p>En Racket, les nombres restent <em>exacts</em> tant qu'ils le peuvent. Comme nous
voulons un nombre entier, il faut le tronquer:</p>

<pre><code>-&gt; (truncate 101/2)
50
</code></pre>

<p>Voilà ce à quoi sert <code>quotient</code>. Autrement dit:</p>

<p><code>racket
(quotient a b)
</code></p>

<p>est égal à:</p>

<p><code>racket
(truncate (/ a b))
</code></p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
