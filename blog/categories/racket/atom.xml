<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : racket | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/racket/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2013-11-19T21:03:48+01:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Racket pour les Rubyists 8: Tests unitaires simples]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/11/17/racket-pour-les-rubyists-8-tests-unitaires-simples/"/>
    <updated>2013-11-17T19:04:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/11/17/racket-pour-les-rubyists-8-tests-unitaires-simples</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Maintenant que l'on sait <a href="http://lkdjiin.github.io/blog/2013/11/15/racket-pour-les-rubyists-7-module-basique/">écrire un module pour Racket</a>, on va pouvoir
faire des tests unitaires simples avec RackUnit, le framework de test
fournit avec le langage Racket.</p>

<!-- more -->


<h2>Notre module</h2>

<p>On va tout d'abord mettre notre fonction <code>divisors</code> dans le fichier
<code>number.rkt</code>:</p>

<p>``` racket</p>

<h1>lang racket</h1>

<p>(define (divisors n)
  ; Is i a divisor of n?
  (define (divisor? i)</p>

<pre><code>(= 0 (remainder n i)))
</code></pre>

<p>  (filter divisor? (range 1 (+ n 1))))</p>

<p>(provide divisors)
```</p>

<p>Puis on s'assure que tout fonctionne bien en appelant la fonction <code>divisors</code>
depuis une session racket:</p>

<pre><code>[~]⇒ racket
Welcome to Racket v5.3.6.
-&gt; (require "number.rkt")
-&gt; (divisors 17)
'(1 17)
-&gt; (exit)
</code></pre>

<h2>Le framework RackUnit</h2>

<p>Tout comme Ruby est fournit avec test/unit, Racket est livré avec RackUnit.
C'est un framework de tests unitaires relativement simple, surtout dans son
<em>utilisation basique</em> comme on va le voir ici.</p>

<p>Comme notre fichier à tester se nomme <code>number.rkt</code>, nous allons nommer le
fichier comportant les tests <code>number-test.rkt</code> et le placer dans le même
dossier:</p>

<p>``` racket</p>

<h1>lang racket</h1>

<p>(require rackunit</p>

<pre><code>     "number.rkt")
</code></pre>

<p>```</p>

<p>On requiert la bibliothèque <code>rackunit</code> ainsi que le fichier à tester. <em>On verra
dans un autre article pourquoi <code>rackunit</code> n'est pas placé entre guillemets.</em>
Maintenant on peut effectuer un test avec la fonction:</p>

<pre><code>(check-equal? A B)
</code></pre>

<p>qui s'assure que l'expression A est égale à l'expression B. Par exemple:</p>

<p>``` racket</p>

<h1>lang racket</h1>

<p>(require rackunit</p>

<pre><code>     "number.rkt")
</code></pre>

<p>(check-equal? (divisors 8) &lsquo;(1 2 4 8))
```</p>

<p>Et on lance les tests comme ceci:</p>

<pre><code>[~]⇒ racket number-test.rkt
[~]⇒ 
</code></pre>

<p>Quand tout les tests passent, RackUnit est silencieux.
Si on modifie notre fonction <code>divisors</code> ainsi:</p>

<pre><code>(filter divisor? (range 2 (+ n 1))))
</code></pre>

<p>On peut voir le genre de sortie produit par RackUnit sur un test qui
échoue:</p>

<pre><code>[~]⇒ racket number-test.rkt
--------------------
FAILURE
actual:     (2 4 8)
expected:   (1 2 4 8)
name:       check-equal?
location:   (#&lt;path:/number-test.rkt&gt; 7 0 92 38)
expression: (check-equal? (divisors 8) (quote (1 2 4 8)))

Check failure
--------------------
</code></pre>

<h2>Comparaison avec Ruby et unit/test</h2>

<p>Voici un test similaire pour Ruby, écrit avec le framework test/unit:</p>

<p>``` ruby
require_relative &ldquo;number&rdquo;
require &ldquo;test/unit&rdquo;</p>

<p>class TestNumber &lt; Test::Unit::TestCase
  def test_divisors</p>

<pre><code>assert_equal [1, 2, 4, 8], Number.divisors(8)
</code></pre>

<p>  end
end
```</p>

<p>Ruby est loin d'être un langage verbeux et pourtant on peut voir qu'ici il
faut écrire une classe et utiliser l'héritage rien que pour un simple petit
test de rien du tout. Alors je ne dis pas que les <em>test cases</em> sont
inutiles (et Racket permet aussi d'organiser les tests de plusieurs
manières différentes), seulement dans le cas d'un programme aussi simple
que le notre je trouve la façon de faire de Racket plus <em>naturelle</em>.</p>

<p>La prochaine fois on passera au refactoring de notre méthode <code>divisors</code>.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Racket pour les Rubyists 7: Module basique]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/11/15/racket-pour-les-rubyists-7-module-basique/"/>
    <updated>2013-11-15T10:18:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/11/15/racket-pour-les-rubyists-7-module-basique</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>La dernière fois, on a écrit notre <a href="http://lkdjiin.github.io/blog/2013/11/11/racket-pour-les-rubyists-6-une-premiere-fonction/">première fonction en Racket</a>. Et avant
d'écrire des tests unitaires pour pouvoir la passer à la moulinette du
<em>refactoring</em>, il faut explorer un peu les modules Racket.</p>

<!-- more -->


<h2>La notion de module en Racket</h2>

<p>Jusqu'ici on a utilisé le REPL, il est temps maintenant de mettre notre
code dans un fichier. Voyons le programme suivant, à mettre dans un
fichier <code>foo.rkt</code>:</p>

<p>``` racket foo.rkt</p>

<h1>lang racket</h1>

<p>(define (times-2 n)
  (* 2 n))</p>

<p>(define (times-3 n)
  (* 3 n))</p>

<p>(provide times-2)
```</p>

<p>Vous reconnaissez la définition de deux fonctions: <code>times-2</code> et <code>times-3</code>
qui multiplient respectivements leur argument par 2 et par 3. En plus de ça,
il y a trois éléments nouveaux:</p>

<h3>Spécification d'un dialecte</h3>

<p>La ligne <code>#lang racket</code> spécifie à Racket le dialecte utilisé. Il y en a
plein et je n'utiliserais que celui-ci. Il faudra penser à toujours placé
cette ligne au début de chaque fichier.</p>

<h3>Convention de nommage</h3>

<p>Un petit exemple vaut mieux qu'un long discours:</p>

<pre><code>thisIsJavaConvention

this_is_ruby_convention

this-is-racket-convention
</code></pre>

<h3>La fonction provide</h3>

<p>La fonction <code>provide</code>, qu'on peut placer n'importe où dans le fichier (donc
au début ou à la fin), permet <em>d'exporter</em> les fonctions données en
argument. Les autres fonctions (celle qui ne sont pas données à <code>provide</code>)
sont visible dans le fichier, mais pas à l'extérieur. Autrement dit,
<code>provide</code> permet de spécifier l'API, les fonctions publiques.</p>

<h2>Utilisation d'un module</h2>

<p>Dans le REPL, <em>démaré dans le même dossier que le fichier &ldquo;foo.rkt&rdquo;</em>,
on utilise la fonction <code>require</code>:</p>

<pre><code>-&gt; (require "foo.rkt")
</code></pre>

<p>On peut maintenant utiliser la fonction <em>publique</em> <code>times-2</code>:</p>

<pre><code>-&gt; (times-2 9)
18
</code></pre>

<p>Et comme attendu, on ne peut pas utiliser <code>times-3</code>:</p>

<pre><code>-&gt; (times-3 9)
; times-3: undefined;
;  cannot reference undefined identifier
</code></pre>

<h2>Comparaison avec les modules Ruby</h2>

<p>Voici le pendant du fichier <code>foo.rkt</code> écrit en Ruby:</p>

<p>``` ruby foo.rb
module Foo
  class &lt;&lt; self</p>

<pre><code>def times_2(n)
  2 * n
end

private

def times_3(n)
  3 * n
end
</code></pre>

<p>  end
end
```</p>

<p>Et voici comment on s'en sert dans une session irb:</p>

<p>``` irb</p>

<blockquote><blockquote><p>require &ldquo;foo&rdquo;
LoadError: cannot load such file &mdash; foo
require &ldquo;./foo&rdquo;
true
Foo.times_2 9
18
Foo.times_3 9
NoMethodError: private method `times_3' called for Foo:Module
```</p></blockquote></blockquote>

<p>Le comportement est assez similaire. Petite différence, Ruby oblige à définir
le fichier requis par rapport au dossier courant alors que Racket le fait
automatiquement (ok, j'aurais pu utiliser <code>require_relative</code>…).</p>

<p>Mais la <strong>grande différence</strong> est qu'un module Ruby définit un espace
de nom, pas un module Racket. <em>À l'heure actuelle je ne sais pas si Racket
possède un mécanisme pour les espaces de nom, je n'en suis pas encore là,
mais j'espère que oui…</em></p>

<p>La prochaine fois, on verra comment faire des tests unitaires simples en
Racket.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Racket pour les rubyists 6: Une première fonction]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/11/11/racket-pour-les-rubyists-6-une-premiere-fonction/"/>
    <updated>2013-11-11T20:41:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/11/11/racket-pour-les-rubyists-6-une-premiere-fonction</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Grâce à ce qu'on a appris depuis <a href="http://lkdjiin.github.io/blog/2013/11/03/racket-pour-les-rubyists-definir-une-fonction/">le début</a> de cette série d'articles,
il est enfin temps de traduire la méthode Ruby suivante en Racket:</p>

<p><code>ruby
def divisors(n)
  (1..n).select {|i| n % i == 0}
end
</code></p>

<!-- more -->


<h2>Une première fonction Racket</h2>

<p>Sans plus attendre, voici une traduction en Racket, qui suit le modèle
du <a href="http://lkdjiin.github.io/blog/2013/11/10/racket-pour-les-rubyists-5-definitions-imbriquees/">dernier article</a>:</p>

<p>``` racket
(define (divisors n)
  ; Is i a divisor of n?
  (define (divisor? i)</p>

<pre><code>(= 0 (remainder n i)))
</code></pre>

<p>  (filter divisor? (range 1 (+ n 1))))
```</p>

<p>Voici la fonction en action:</p>

<pre><code>-&gt; (divisors 1)
'(1)
-&gt; (divisors 8)
'(1 2 4 8)
-&gt; (divisors 17)
'(1 17)
-&gt; (divisors 171)
'(1 3 9 19 57 171)
</code></pre>

<p>Alors ça fait pas mal de code Racket comparé au code Ruby, mais attention de ne
pas juger le langage sur ce seul exemple. D'abord l'opérateur <code>..</code> de Ruby et
ses <em>blocks</em> permettent une syntaxe incroyablement concise, ensuite je
vous rappelle que <em>j'apprends</em> Racket, et que donc j'ai peut-être raté des
trucs…</p>

<p>Vous remarquez que je me suis senti obligé de commenté la fonction imbriquée
<code>divisor?</code>, ce qui n'est pas bon signe. Je suis un adepte du code court,
sous-entendu: une fonction devrait faire une seule chose. Or il me semble
qu'ici la fonction <code>divisors</code> fait trois choses:</p>

<ol>
<li>Elle regarde si un nombre i est un diviseur de n.</li>
<li>Elle produit une liste de 1 à n inclus.</li>
<li>Enfin, elle produit la liste des diviseurs de n.</li>
</ol>


<p>Donc <code>divisors</code> est un bon candidat au refactoring. Mais avant ça il va
falloir parler des tests unitaires avec Racket. Et avant de parler des
tests unitaires, il va falloir aborder la notion de module Racket. Si
ces sujets vous intéressent, restez à l'écoute de ce blog, c'est pour
bientôt.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Racket pour les rubyists 5: Définitions imbriquées]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/11/10/racket-pour-les-rubyists-5-definitions-imbriquees/"/>
    <updated>2013-11-10T21:17:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/11/10/racket-pour-les-rubyists-5-definitions-imbriquees</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Après avoir vu l'utilisation de la fonction <code>filter</code>, on passe aux
définitions de fonctions imbriquées en Racket, ce qui nous permet de
survoler la portée des variables.</p>

<!-- more -->


<h2>Fonctions Racket imbriquées</h2>

<p>Avec Racket les définitions de fonction peuvent s'imbriquer les unes dans les
autres.  Autrement dit, on peut définir une fonction B à l'intérieur d'une
fonction A. Dans l'exemple suivant, la fonction <code>bar</code> est définie à
l'intérieur de la fonction <code>foo</code>:</p>

<p>``` racket
(define (foo x)
  (define (bar y)</p>

<pre><code>(+ y 2))
</code></pre>

<p>  (bar x))
```</p>

<p>Dans le code ci-dessus, <code>bar</code> est une fonction qui ajoute 2 à son argument.
La fonction englobante <code>foo</code> appelle <code>bar</code> et donc son rôle est aussi d'ajouter
2 à son argument, comme on peut le voir dans la session racket suivante:</p>

<pre><code>-&gt; (foo 10)
12
</code></pre>

<p>Il est important de comprendre que <code>bar</code> est définie à l'intérieur de <code>foo</code>,
et donc <code>bar</code> est <em>indéfinie</em> à l'extérieur de <code>foo</code>:</p>

<pre><code>-&gt; (bar 10)
; bar: undefined;
;  cannot reference undefined identifier
</code></pre>

<h2>Méthodes Ruby imbriquées</h2>

<p>Ruby se comporte différement. Il permet bien de définir une méthode à
l'intérieur d'une autre:</p>

<p>``` irb</p>

<blockquote><blockquote><p>def foo(x)
  def bar(y)</p>

<pre><code>y + 2
</code></pre>

<p>  end
  bar x
end
nil
foo 10
12
```</p></blockquote></blockquote>

<p>Mais à la différence du comportement de Racket, la méthode Ruby <code>bar</code> est
<em>visible</em> à l'extérieur de <code>foo</code>:</p>

<p>``` irb</p>

<blockquote><blockquote><p>bar 10
12
```</p></blockquote></blockquote>

<p>Et c'est tout à fait normal. Il s'agit là d'une différence entre fonction
et méthode: une méthode est attachée à un objet.</p>

<h2>Retour à Racket</h2>

<p>La méthode <code>foo</code> peut être simplifiée. La revoici:</p>

<p>``` racket
(define (foo x)
  (define (bar y)</p>

<pre><code>(+ y 2))
</code></pre>

<p>  (bar x))
```</p>

<p>Pour la simplifier, il suffit de comprendre que l'argument <code>x</code> est <em>visible</em>
dans la fonction <code>bar</code>:</p>

<p>``` racket
(define (foo x)
  (define (bar)</p>

<pre><code>(+ x 2))
</code></pre>

<p>  (bar))
```</p>

<p>Évidemment, la vraie simplification serait celle-ci:</p>

<p><code>racket
(define (foo x)
  (+ x 2))
</code></p>

<p>Mais cet article parle de fonctions imbriquées…</p>

<p>La prochaine fois on réunira tout ce qu'on a appris jusqu'ici pour enfin
traduire en Racket la méthode Ruby suivante:</p>

<p><code>ruby
def divisors(n)
  (1..n).select {|i| n % i == 0}
end
</code></p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Installer Scheme]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/10/31/installer-scheme/"/>
    <updated>2013-10-31T18:50:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/10/31/installer-scheme</id>
    <content type="html"><![CDATA[<p>Avant d'apprendre Scheme, il faut l'installer. Avant de l'installer, il
faut choisir une implémentation: interpréteur ou compilateur ? Les deux ?
Quel OS ? Quel(s) dialecte(s) ? Le site
<a href="http://community.schemewiki.org/?scheme-faq-standards#implementations">community.schemewiki.org</a>
recense 75 implémentations ! Oui, j'ai compté.</p>

<!-- more -->


<p>Après prises de conseils et réflexion, j'ai décidé d'essayer trois
implémentations:
<a href="http://www.gnu.org/software/guile/">Guile</a>,
<a href="http://www.call-cc.org/">Chicken</a>
et <a href="http://racket-lang.org/">Racket</a>.
<strong>Guile</strong> parce qu'il est déjà installé sur ma machine.
<strong>Chicken</strong> pour son compilateur vers
le langage C. <strong>Racket</strong> pour ses nombreux DSL, parce qu'il a l'air très cool
pour créer de nouveaux DSL et parce qu'il semble être le plus utilisé.</p>

<h2>Guile</h2>

<p>Guile semble être déjà installé sur la plupart des Linux. En tout cas, il
l'était sur ma machine…
Le REPL n'utilise pas readline par défaut, ce qui est d'ailleurs le cas
des 3 implementations que j'ai testé.
Pour activer readline, il faut créer un fichier <code>.guile</code> dans le <code>home</code> et y mettre:</p>

<p><code>scheme .guile
(use-modules (ice-9 readline))
(activate-readline)
</code></p>

<h2>Chicken</h2>

<p>J'ai installé Chicken grâce aux paquets Debian, rien à dire… Pour activer
readline dans le REPL, il faut d'abord installer une bibliothèque (un <em>egg</em>
dans le jargon Chicken):</p>

<pre><code>sudo chicken-install readline
</code></pre>

<p>Ensuite on crée un fichier <code>~/.csirc</code> avec le contenu suivant:</p>

<p><code>scheme .csirc
(use readline)
(current-input-port (make-gnu-readline-port))
(gnu-history-install-file-manager
 (string-append (or (get-environment-variable "HOME") ".") "/.csi.history"))
</code></p>

<p>Enfin on crée le fichier d'historique:</p>

<pre><code>touch ~/.csi.history
</code></pre>

<h2>Racket</h2>

<p>Je voulais la toute dernière version, j'ai donc téléchargé les sources et
lancé une compilation. Tout a très bien fonctionné, le fichier <code>README</code> est
parfaitement clair. Pour activer readline dans le REPL de Racket, il faut
cette fois créé un fichier <code>~/.racketrc</code> avec le texte suivant:</p>

<p><code>scheme .racketrc
(require xrepl)
</code></p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
