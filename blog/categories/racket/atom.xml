<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : racket | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/racket/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2013-12-15T19:14:40+01:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Racket: première approche de lambda]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/11/21/racket-premiere-approche-de-lambda/"/>
    <updated>2013-11-21T19:53:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/11/21/racket-premiere-approche-de-lambda</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Dans un <a href="http://lkdjiin.github.io/blog/2013/11/11/racket-pour-les-rubyists-6-une-premiere-fonction/">article précédent</a>, j'ai écrit une fonction Racket pour calculer
les diviseurs d'un nombre n:</p>

<p>``` racket</p>

<h1>lang racket</h1>

<p>(define (divisors n)
  ; Is i a divisor of n?
  (define (divisor? i)</p>

<pre><code>(= 0 (remainder n i)))
</code></pre>

<p>  (filter divisor? (range 1 (+ n 1))))</p>

<p>(provide divisors)
```</p>

<p>Puis on a vu comment <a href="http://lkdjiin.github.io/blog/2013/11/17/racket-pour-les-rubyists-8-tests-unitaires-simples/">faire des tests unitaires</a>.
Il est temps maintenant de faire un peu de refactoring.</p>

<!-- more -->


<p>Tout d'abord, le plus simple, on va extraire une fonction qui calcule
un <em>range</em> de 1 à n inclus:</p>

<p>``` racket number.rkt</p>

<h1>lang racket</h1>

<p>; divisors : integer &ndash;> list of integers
; Get divisors of a number n.
(define (divisors n)
  ; Is i a divisor of n?
  (define (divisor? i)</p>

<pre><code>(= 0 (remainder n i)))
</code></pre>

<p>  (filter divisor? (range-inclusive n)))</p>

<p>; range-inclusive : integer &ndash;> list of integers
; Build a list from 1 to n inclusive.
(define (range-inclusive n)
  (range 1 (+ n 1)))</p>

<p>(provide divisors)
```</p>

<p>Vous noterez au passage que j'ai commencé à documenter mes fonctions en
spécifiant les types de données en entrée et en sortie. Vous remarquez aussi
que <code>range-inclusive</code> ne fait pas partie de l'API du module:
<code>(provide divisors)</code>.</p>

<p>Maintenant il nous faut extraire la fonction qui regarde si un nombre <em>i</em> est
un diviseur de <em>n</em>:</p>

<p><code>racket
; divisor-of? : integer integer -&gt; boolean
; Tells if i is a divisor of n.
(define (divisor-of? n i)
  (= 0 (remainder n i)))
</code></p>

<p>Le nom de la fonction a changé au passage pour <code>divisor-of?</code>. Mais surtout
nous avons du inclure <em>n</em> dans les arguments de la fonction.</p>

<p>On doit maintenant <em>insérer</em> cette fonction dans le code de la fonction
principale <code>divisors</code>. Voici une première tentative un peu naive:</p>

<p><code>racket
; Attention, ce code ne fonctionne pas.
(define (divisors n)
  (filter (divisor-of? n i) (range-inclusive n)))
</code></p>

<p>Évidemment ça ne marche pas, puisque Racket ne connait pas <em>i</em>, mais
ça nous donne une orientation. Pour que Racket sache ce que nous voulons
placer dans <em>i</em>, à savoir l'élément en cours de traitement par la fonction
<code>filter</code>, on va passer par une fonction anonyme:</p>

<p><code>racket
(define (divisors n)
  (filter (lambda (i) (divisor-of? n i)) (range-inclusive n)))
</code></p>

<p>Une fonction anonyme (lambda) prend un argument (ou plusieurs) et une
expression. À chaque itération, <code>filter</code> passe un élément tiré de
<code>(range-inclusive n)</code> à la fonction anonyme <code>(lambda (i) (divisors-of? n i))</code>.</p>

<p>Voilà donc notre module, après refactoring:</p>

<p>``` racket number.rkt</p>

<h1>lang racket</h1>

<p>; divisors : integer &ndash;> list of integers
; Get divisors of a number n.
(define (divisors n)
  (filter (lambda (i) (divisor-of? n i)) (range-inclusive n)))</p>

<p>; divisor-of? : integer integer &ndash;> boolean
; Tells if i is a divisor of n.
(define (divisor-of? n i)
  (= 0 (remainder n i)))</p>

<p>; range-inclusive : integer &ndash;> list of integers
; Build a list from 1 to n inclusive.
(define (range-inclusive n)
  (range 1 (+ n 1)))</p>

<p>(provide divisors)
```</p>

<p>On aurait aussi pu écrire ce qui suit, à la place des trois fonctions ci-dessus:</p>

<p><code>racket
; divisors : integer -&gt; list of integers
; Get divisors of a number n.
(define (divisors n)
  (filter (lambda (i) (= 0 (remainder n i))) (range 1 (+ n 1))))
</code></p>

<p>Ça fait bien sûr beaucoup moins de code… Peut-être est-ce parceque je ne suis
pas encore habitué à Racket, mais je trouve aussi cela bien moins lisible.
Si on doit réutiliser les fonctions <code>divisor-of?</code> et <code>range-inclusive</code>, il
n'y a pas de question à se poser. Sinon…? Si vous connaissez bien
Racket/Scheme/Lisp laissez donc un commentaire pour me dire quelle version
est la plus idiomatique de ce type de langages.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Racket pour les Rubyists 8: Tests unitaires simples]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/11/17/racket-pour-les-rubyists-8-tests-unitaires-simples/"/>
    <updated>2013-11-17T19:04:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/11/17/racket-pour-les-rubyists-8-tests-unitaires-simples</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Maintenant que l'on sait <a href="http://lkdjiin.github.io/blog/2013/11/15/racket-pour-les-rubyists-7-module-basique/">écrire un module pour Racket</a>, on va pouvoir
faire des tests unitaires simples avec RackUnit, le framework de test
fournit avec le langage Racket.</p>

<!-- more -->


<h2>Notre module</h2>

<p>On va tout d'abord mettre notre fonction <code>divisors</code> dans le fichier
<code>number.rkt</code>:</p>

<p>``` racket</p>

<h1>lang racket</h1>

<p>(define (divisors n)
  ; Is i a divisor of n?
  (define (divisor? i)</p>

<pre><code>(= 0 (remainder n i)))
</code></pre>

<p>  (filter divisor? (range 1 (+ n 1))))</p>

<p>(provide divisors)
```</p>

<p>Puis on s'assure que tout fonctionne bien en appelant la fonction <code>divisors</code>
depuis une session racket:</p>

<pre><code>[~]⇒ racket
Welcome to Racket v5.3.6.
-&gt; (require "number.rkt")
-&gt; (divisors 17)
'(1 17)
-&gt; (exit)
</code></pre>

<h2>Le framework RackUnit</h2>

<p>Tout comme Ruby est fournit avec test/unit, Racket est livré avec RackUnit.
C'est un framework de tests unitaires relativement simple, surtout dans son
<em>utilisation basique</em> comme on va le voir ici.</p>

<p>Comme notre fichier à tester se nomme <code>number.rkt</code>, nous allons nommer le
fichier comportant les tests <code>number-test.rkt</code> et le placer dans le même
dossier:</p>

<p>``` racket</p>

<h1>lang racket</h1>

<p>(require rackunit</p>

<pre><code>     "number.rkt")
</code></pre>

<p>```</p>

<p>On requiert la bibliothèque <code>rackunit</code> ainsi que le fichier à tester. <em>On verra
dans un autre article pourquoi <code>rackunit</code> n'est pas placé entre guillemets.</em>
Maintenant on peut effectuer un test avec la fonction:</p>

<pre><code>(check-equal? A B)
</code></pre>

<p>qui s'assure que l'expression A est égale à l'expression B. Par exemple:</p>

<p>``` racket</p>

<h1>lang racket</h1>

<p>(require rackunit</p>

<pre><code>     "number.rkt")
</code></pre>

<p>(check-equal? (divisors 8) &lsquo;(1 2 4 8))
```</p>

<p>Et on lance les tests comme ceci:</p>

<pre><code>[~]⇒ racket number-test.rkt
[~]⇒ 
</code></pre>

<p>Quand tout les tests passent, RackUnit est silencieux.
Si on modifie notre fonction <code>divisors</code> ainsi:</p>

<pre><code>(filter divisor? (range 2 (+ n 1))))
</code></pre>

<p>On peut voir le genre de sortie produit par RackUnit sur un test qui
échoue:</p>

<pre><code>[~]⇒ racket number-test.rkt
--------------------
FAILURE
actual:     (2 4 8)
expected:   (1 2 4 8)
name:       check-equal?
location:   (#&lt;path:/number-test.rkt&gt; 7 0 92 38)
expression: (check-equal? (divisors 8) (quote (1 2 4 8)))

Check failure
--------------------
</code></pre>

<h2>Comparaison avec Ruby et unit/test</h2>

<p>Voici un test similaire pour Ruby, écrit avec le framework test/unit:</p>

<p>``` ruby
require_relative &ldquo;number&rdquo;
require &ldquo;test/unit&rdquo;</p>

<p>class TestNumber &lt; Test::Unit::TestCase
  def test_divisors</p>

<pre><code>assert_equal [1, 2, 4, 8], Number.divisors(8)
</code></pre>

<p>  end
end
```</p>

<p>Ruby est loin d'être un langage verbeux et pourtant on peut voir qu'ici il
faut écrire une classe et utiliser l'héritage rien que pour un simple petit
test de rien du tout. Alors je ne dis pas que les <em>test cases</em> sont
inutiles (et Racket permet aussi d'organiser les tests de plusieurs
manières différentes), seulement dans le cas d'un programme aussi simple
que le notre je trouve la façon de faire de Racket plus <em>naturelle</em>.</p>

<p>La prochaine fois on passera au refactoring de notre méthode <code>divisors</code>.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Racket pour les Rubyists 7: Module basique]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/11/15/racket-pour-les-rubyists-7-module-basique/"/>
    <updated>2013-11-15T10:18:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/11/15/racket-pour-les-rubyists-7-module-basique</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>La dernière fois, on a écrit notre <a href="http://lkdjiin.github.io/blog/2013/11/11/racket-pour-les-rubyists-6-une-premiere-fonction/">première fonction en Racket</a>. Et avant
d'écrire des tests unitaires pour pouvoir la passer à la moulinette du
<em>refactoring</em>, il faut explorer un peu les modules Racket.</p>

<!-- more -->


<h2>La notion de module en Racket</h2>

<p>Jusqu'ici on a utilisé le REPL, il est temps maintenant de mettre notre
code dans un fichier. Voyons le programme suivant, à mettre dans un
fichier <code>foo.rkt</code>:</p>

<p>``` racket foo.rkt</p>

<h1>lang racket</h1>

<p>(define (times-2 n)
  (* 2 n))</p>

<p>(define (times-3 n)
  (* 3 n))</p>

<p>(provide times-2)
```</p>

<p>Vous reconnaissez la définition de deux fonctions: <code>times-2</code> et <code>times-3</code>
qui multiplient respectivements leur argument par 2 et par 3. En plus de ça,
il y a trois éléments nouveaux:</p>

<h3>Spécification d'un dialecte</h3>

<p>La ligne <code>#lang racket</code> spécifie à Racket le dialecte utilisé. Il y en a
plein et je n'utiliserais que celui-ci. Il faudra penser à toujours placé
cette ligne au début de chaque fichier.</p>

<h3>Convention de nommage</h3>

<p>Un petit exemple vaut mieux qu'un long discours:</p>

<pre><code>thisIsJavaConvention

this_is_ruby_convention

this-is-racket-convention
</code></pre>

<h3>La fonction provide</h3>

<p>La fonction <code>provide</code>, qu'on peut placer n'importe où dans le fichier (donc
au début ou à la fin), permet <em>d'exporter</em> les fonctions données en
argument. Les autres fonctions (celle qui ne sont pas données à <code>provide</code>)
sont visible dans le fichier, mais pas à l'extérieur. Autrement dit,
<code>provide</code> permet de spécifier l'API, les fonctions publiques.</p>

<h2>Utilisation d'un module</h2>

<p>Dans le REPL, <em>démaré dans le même dossier que le fichier &ldquo;foo.rkt&rdquo;</em>,
on utilise la fonction <code>require</code>:</p>

<pre><code>-&gt; (require "foo.rkt")
</code></pre>

<p>On peut maintenant utiliser la fonction <em>publique</em> <code>times-2</code>:</p>

<pre><code>-&gt; (times-2 9)
18
</code></pre>

<p>Et comme attendu, on ne peut pas utiliser <code>times-3</code>:</p>

<pre><code>-&gt; (times-3 9)
; times-3: undefined;
;  cannot reference undefined identifier
</code></pre>

<h2>Comparaison avec les modules Ruby</h2>

<p>Voici le pendant du fichier <code>foo.rkt</code> écrit en Ruby:</p>

<p>``` ruby foo.rb
module Foo
  class &lt;&lt; self</p>

<pre><code>def times_2(n)
  2 * n
end

private

def times_3(n)
  3 * n
end
</code></pre>

<p>  end
end
```</p>

<p>Et voici comment on s'en sert dans une session irb:</p>

<p>``` irb</p>

<blockquote><blockquote><p>require &ldquo;foo&rdquo;
LoadError: cannot load such file &mdash; foo
require &ldquo;./foo&rdquo;
true
Foo.times_2 9
18
Foo.times_3 9
NoMethodError: private method `times_3' called for Foo:Module
```</p></blockquote></blockquote>

<p>Le comportement est assez similaire. Petite différence, Ruby oblige à définir
le fichier requis par rapport au dossier courant alors que Racket le fait
automatiquement (ok, j'aurais pu utiliser <code>require_relative</code>…).</p>

<p>Mais la <strong>grande différence</strong> est qu'un module Ruby définit un espace
de nom, pas un module Racket. <em>À l'heure actuelle je ne sais pas si Racket
possède un mécanisme pour les espaces de nom, je n'en suis pas encore là,
mais j'espère que oui…</em></p>

<p>La prochaine fois, on verra comment faire des tests unitaires simples en
Racket.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Racket pour les rubyists 6: Une première fonction]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/11/11/racket-pour-les-rubyists-6-une-premiere-fonction/"/>
    <updated>2013-11-11T20:41:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/11/11/racket-pour-les-rubyists-6-une-premiere-fonction</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Grâce à ce qu'on a appris depuis <a href="http://lkdjiin.github.io/blog/2013/11/03/racket-pour-les-rubyists-definir-une-fonction/">le début</a> de cette série d'articles,
il est enfin temps de traduire la méthode Ruby suivante en Racket:</p>

<p><code>ruby
def divisors(n)
  (1..n).select {|i| n % i == 0}
end
</code></p>

<!-- more -->


<h2>Une première fonction Racket</h2>

<p>Sans plus attendre, voici une traduction en Racket, qui suit le modèle
du <a href="http://lkdjiin.github.io/blog/2013/11/10/racket-pour-les-rubyists-5-definitions-imbriquees/">dernier article</a>:</p>

<p>``` racket
(define (divisors n)
  ; Is i a divisor of n?
  (define (divisor? i)</p>

<pre><code>(= 0 (remainder n i)))
</code></pre>

<p>  (filter divisor? (range 1 (+ n 1))))
```</p>

<p>Voici la fonction en action:</p>

<pre><code>-&gt; (divisors 1)
'(1)
-&gt; (divisors 8)
'(1 2 4 8)
-&gt; (divisors 17)
'(1 17)
-&gt; (divisors 171)
'(1 3 9 19 57 171)
</code></pre>

<p>Alors ça fait pas mal de code Racket comparé au code Ruby, mais attention de ne
pas juger le langage sur ce seul exemple. D'abord l'opérateur <code>..</code> de Ruby et
ses <em>blocks</em> permettent une syntaxe incroyablement concise, ensuite je
vous rappelle que <em>j'apprends</em> Racket, et que donc j'ai peut-être raté des
trucs…</p>

<p>Vous remarquez que je me suis senti obligé de commenté la fonction imbriquée
<code>divisor?</code>, ce qui n'est pas bon signe. Je suis un adepte du code court,
sous-entendu: une fonction devrait faire une seule chose. Or il me semble
qu'ici la fonction <code>divisors</code> fait trois choses:</p>

<ol>
<li>Elle regarde si un nombre i est un diviseur de n.</li>
<li>Elle produit une liste de 1 à n inclus.</li>
<li>Enfin, elle produit la liste des diviseurs de n.</li>
</ol>


<p>Donc <code>divisors</code> est un bon candidat au refactoring. Mais avant ça il va
falloir parler des tests unitaires avec Racket. Et avant de parler des
tests unitaires, il va falloir aborder la notion de module Racket. Si
ces sujets vous intéressent, restez à l'écoute de ce blog, c'est pour
bientôt.</p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Racket pour les rubyists 5: Définitions imbriquées]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/11/10/racket-pour-les-rubyists-5-definitions-imbriquees/"/>
    <updated>2013-11-10T21:17:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/11/10/racket-pour-les-rubyists-5-definitions-imbriquees</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Après avoir vu l'utilisation de la fonction <code>filter</code>, on passe aux
définitions de fonctions imbriquées en Racket, ce qui nous permet de
survoler la portée des variables.</p>

<!-- more -->


<h2>Fonctions Racket imbriquées</h2>

<p>Avec Racket les définitions de fonction peuvent s'imbriquer les unes dans les
autres.  Autrement dit, on peut définir une fonction B à l'intérieur d'une
fonction A. Dans l'exemple suivant, la fonction <code>bar</code> est définie à
l'intérieur de la fonction <code>foo</code>:</p>

<p>``` racket
(define (foo x)
  (define (bar y)</p>

<pre><code>(+ y 2))
</code></pre>

<p>  (bar x))
```</p>

<p>Dans le code ci-dessus, <code>bar</code> est une fonction qui ajoute 2 à son argument.
La fonction englobante <code>foo</code> appelle <code>bar</code> et donc son rôle est aussi d'ajouter
2 à son argument, comme on peut le voir dans la session racket suivante:</p>

<pre><code>-&gt; (foo 10)
12
</code></pre>

<p>Il est important de comprendre que <code>bar</code> est définie à l'intérieur de <code>foo</code>,
et donc <code>bar</code> est <em>indéfinie</em> à l'extérieur de <code>foo</code>:</p>

<pre><code>-&gt; (bar 10)
; bar: undefined;
;  cannot reference undefined identifier
</code></pre>

<h2>Méthodes Ruby imbriquées</h2>

<p>Ruby se comporte différement. Il permet bien de définir une méthode à
l'intérieur d'une autre:</p>

<p>``` irb</p>

<blockquote><blockquote><p>def foo(x)
  def bar(y)</p>

<pre><code>y + 2
</code></pre>

<p>  end
  bar x
end
nil
foo 10
12
```</p></blockquote></blockquote>

<p>Mais à la différence du comportement de Racket, la méthode Ruby <code>bar</code> est
<em>visible</em> à l'extérieur de <code>foo</code>:</p>

<p>``` irb</p>

<blockquote><blockquote><p>bar 10
12
```</p></blockquote></blockquote>

<p>Et c'est tout à fait normal. Il s'agit là d'une différence entre fonction
et méthode: une méthode est attachée à un objet.</p>

<h2>Retour à Racket</h2>

<p>La méthode <code>foo</code> peut être simplifiée. La revoici:</p>

<p>``` racket
(define (foo x)
  (define (bar y)</p>

<pre><code>(+ y 2))
</code></pre>

<p>  (bar x))
```</p>

<p>Pour la simplifier, il suffit de comprendre que l'argument <code>x</code> est <em>visible</em>
dans la fonction <code>bar</code>:</p>

<p>``` racket
(define (foo x)
  (define (bar)</p>

<pre><code>(+ x 2))
</code></pre>

<p>  (bar))
```</p>

<p>Évidemment, la vraie simplification serait celle-ci:</p>

<p><code>racket
(define (foo x)
  (+ x 2))
</code></p>

<p>Mais cet article parle de fonctions imbriquées…</p>

<p>La prochaine fois on réunira tout ce qu'on a appris jusqu'ici pour enfin
traduire en Racket la méthode Ruby suivante:</p>

<p><code>ruby
def divisors(n)
  (1..n).select {|i| n % i == 0}
end
</code></p>

<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
