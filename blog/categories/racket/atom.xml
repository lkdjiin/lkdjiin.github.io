<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : racket | Xavier Nayrac]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/racket/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2015-06-16T17:37:42+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Le jeu de la vie en racket - partie 3]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/11/09/le-jeu-de-la-vie-en-racket-partie-3/"/>
    <updated>2014-11-09T15:01:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/11/09/le-jeu-de-la-vie-en-racket-partie-3</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>C’est la troisième et dernière partie du jeu de la vie en Racket.</p>

<p><img src="/images/screenshot-game-of-life-racket.png"></p>

<!-- more -->

<h2 id="trouver-le-prochain-tat-dune-cellule">Trouver le prochain état d’une cellule</h2>

<p>Vous avez l’habitude maintenant, je commence par un test très simple.</p>

<p><code>racket game-of-life-test.rkt
(check-equal? (next-cell-state '(1 1 1 0 0 0 0 0 0)) 1)
</code></p>

<p>Et une implémentation minimale.</p>

<p>``` racket generation.rkt
#lang racket</p>

<p>…</p>

<p>(define (next-cell-state neighborhood)
  1)</p>

<p>(provide create-generation
         next-cell-state)
```</p>

<p>Puis je teste d’autres cas.</p>

<p>``` racket game-of-life-test.rkt
(check-equal? (next-cell-state ‘(1 1 1 0 0 0 0 0 0)) 1)
(check-equal? (next-cell-state ‘(1 0 0 1 0 0 1 0 0)) 1)</p>

<p>(check-equal? (next-cell-state ‘(1 0 0 1 1 0 1 0 0)) 1)
(check-equal? (next-cell-state ‘(1 0 0 1 0 0 1 0 1)) 0)
```</p>

<p>La fonction <code>for/sum</code> réduit une liste à la somme de ses éléments.</p>

<p><code>racket
(define (next-cell-state neighborhood)
  (define sum (for/sum ([i neighborhood]) i))
  (if (= 3 sum)
    1
    (list-ref neighborhood 4)))
</code></p>

<p>Je teste les derniers cas.</p>

<p>``` racket game-of-life-test.rkt
(check-equal? (next-cell-state ‘(1 1 1 0 0 0 0 0 0)) 1)
(check-equal? (next-cell-state ‘(1 0 0 1 0 0 1 0 0)) 1)</p>

<p>(check-equal? (next-cell-state ‘(1 0 0 1 1 0 1 0 0)) 1)
(check-equal? (next-cell-state ‘(1 0 0 1 0 0 1 0 1)) 0)</p>

<p>(check-equal? (next-cell-state ‘(1 1 1 1 1 1 1 1 1)) 0)
(check-equal? (next-cell-state ‘(0 0 0 0 0 0 0 0 0)) 0)
```</p>

<p>Comme il y a maintenant trois cas, j’utilise <code>cond</code> au lieu de <code>if</code>.</p>

<p><code>racket
(define (next-cell-state neighborhood)
  (define sum (for/sum ([i neighborhood]) i))
  (cond [(= 3 sum) 1]
        [(= 4 sum) (list-ref neighborhood 4)]
        [else 0]))
</code></p>

<p>On pourrait aussi utiliser <code>match</code> plutôt que <code>cond</code>:</p>

<p><code>racket
(define (next-cell-state neighborhood)
  (match (for/sum ([i neighborhood]) i)
         [3 1]
         [4 (list-ref neighborhood 4)]
         [_ 0]))
</code></p>

<p>Je n’ai aucune idée de laquelle est la plus performante, même si je peux
imaginer à priori que dans ce cas là c’est <code>cond</code>.</p>

<h2 id="test-case">test-case</h2>

<p>Je pense qu’il est temps de regrouper les tests en <code>test-case</code>. Rackunit, le
framework de test de Racket est assez évolutif.</p>

<p>``` racket game-of-life-test.rkt
#lang racket</p>

<p>(require rackunit
         “generation.rkt”)</p>

<p>(test-case “create-generation”
  (check-pred list? (create-generation 3 4)
            “It returns a list”)</p>

<p>(check-equal? (length (create-generation 3 4)) 4
              “It builds a list with the right height”)</p>

<p>(check-equal? (length (first (create-generation 3 4))) 3
              “It builds a list with the right width”)</p>

<p>(let ([cell (first (first (create-generation 3 4)))])
  (check-true (or (= cell 0) (= cell 1))
              “It populates generation with 0s or 1s”))</p>

<p>((λ ()
   (random-seed 1)
   (check-equal? (create-generation 2 3) ‘((1 1) (0 1) (1 1))
                 “It populates generation uniformly”))))</p>

<p>(test-case “next-cell-state”
  (check-equal? (next-cell-state ‘(1 1 1 0 0 0 0 0 0)) 1)
  (check-equal? (next-cell-state ‘(1 0 0 1 0 0 1 0 0)) 1)</p>

<p>(check-equal? (next-cell-state ‘(1 0 0 1 1 0 1 0 0)) 1)
  (check-equal? (next-cell-state ‘(1 0 0 1 0 0 1 0 1)) 0)</p>

<p>(check-equal? (next-cell-state ‘(1 1 1 1 1 1 1 1 1)) 0)
  (check-equal? (next-cell-state ‘(0 0 0 0 0 0 0 0 0)) 0))
```</p>

<h2 id="extraire-un-voisinage-de-cellule">Extraire un voisinage de cellule</h2>

<p>Comme toujours je commence par un test simple. On peut noter les arguments
nommés de Racket (<code>#:</code>). </p>

<p><code>racket
(test-case "extract-neighborhood"
  (let ([game '((1 0 1 0)
                (0 1 0 1)
                (1 0 0 1))])
    (check-equal? (extract-neighborhood game #:x 1 #:y 1) '(1 0 1 0 1 0 1 0 0))))
</code></p>

<p>Et une implémentation encore plus simple.</p>

<p><code>racket
(define (extract-neighborhood generation #:x [x 0] #:y [y 0])
  '(1 0 1 0 1 0 1 0 0))
</code></p>

<p>La suite est classique, j’ajoute un nouveau test.</p>

<p><code>racket
(test-case "extract-neighborhood"
  (let ([game '((1 0 1 0)
                (0 1 0 1)
                (1 0 0 1))])
    (check-equal? (extract-neighborhood game #:x 1 #:y 1) '(1 0 1 0 1 0 1 0 0))
    (check-equal? (extract-neighborhood game #:x 2 #:y 1) '(0 1 0 1 0 1 0 0 1))))
</code></p>

<p>Je regarde ce test échouer.</p>

<pre><code>$ racket game-of-life-test.rkt 
--------------------
extract-neighborhood
FAILURE
actual:     (1 0 1 0 1 0 1 0 0)
expected:   (0 1 0 1 0 1 0 0 1)
</code></pre>

<p>Et j’implémente le minimum de code pour faire passer ce nouveau test.
Je vous épargne ça dans l’article, si vous êtes curieux vous pouvez trouver
<a href="https://github.com/lkdjiin/game-of-life-racket">le code sur Github</a>.</p>

<h2 id="une-nouvelle-gnration">Une nouvelle génération</h2>

<p>J’écris un test pour la production d’une nouvelle génération.</p>

<p>``` racket
(test-case “next-generation”
  (let ([game ‘((1 0 1 0)
                (0 1 0 1)
                (1 0 0 1))])</p>

<pre><code>(check-equal? (next-generation game) '((0 1 1 0) (1 1 0 1) (0 0 1 0))))) ```
</code></pre>

<p>Et voici le code qui fait passer ce test.</p>

<p><code>racket generation.rkt
(define (next-generation current)
  (for/list ([y (length current)])
    (for/list ([x (length (first current))])
      (define neighborhood (extract-neighborhood current #:x x #:y y))
      (next-cell-state neighborhood))))
</code></p>

<p>On peut maintenant lancer le jeu de la vie.</p>

<p>``` racket game-of-life.rkt
#lang racket</p>

<p>(require “generation.rkt”
         “window.rkt”)</p>

<p>(define size 100)
(define generation (create-generation size size))
(define canvas (create-window size size generation))</p>

<p>(define (loop n g)
  (send canvas change-generation g)
  (sleep 0.2)
  (when (&gt; n 0)
    (loop (sub1 n) (next-generation g))))</p>

<p>(loop 30 generation)
```
Mise à l’échelle
————————————-</p>

<p>Pour rendre les choses un peu plus intéressantes visuellement, on va faire un
zoom x4.</p>

<p>``` racket window.rkt
#lang racket/gui</p>

<p>(define (create-window w h g)
  (define scale 4)</p>

<p>(define frame (new frame%
                     [label “Game of Life”]
                     [width (* w scale)]
                     [height (* h scale)]))</p>

<p>(define canvas (new (class canvas%</p>

<pre><code>...

     (define/override (on-paint)
       (send dc set-brush (new brush% [color "black"]))
       (send dc draw-rectangle 0 0 (* w scale) (* h scale))
       (send dc set-brush (new brush% [color "white"]))
       (for ([y (length current-generation)])
         (for ([x (length (first current-generation))])
           (when (= 1 (list-ref (list-ref current-generation y) x))
             (send dc draw-rectangle (* x scale) (* y scale) scale scale))))))))   ... ```
</code></pre>

<h2 id="une-surface-de-jeu-sans-bordures">Une surface de jeu sans bordures</h2>

<p>Il reste à <em>retirer</em> les bordures du jeu. Le processus est exactement le même
que pour les versions <a href="http://lkdjiin.github.io/blog/2014/10/25/le-jeu-de-la-vie-en-ruby-opal-partie-1/">Javascript</a> et <a href="http://lkdjiin.github.io/blog/2014/10/16/le-jeu-de-la-vie-en-javascript-partie-1/">Ruby</a> et je n’ai pas envie de
réécrire les mêmes phrases. Au besoin, je vous rappelle que le
<a href="https://github.com/lkdjiin/game-of-life-racket">code complet du jeu de la vie en Racket</a> se trouve sur Github.</p>

<script id="fb33k8u">(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Le jeu de la vie en racket - partie 2]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/11/08/le-jeu-de-la-vie-en-racket-partie-2/"/>
    <updated>2014-11-08T13:46:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/11/08/le-jeu-de-la-vie-en-racket-partie-2</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>C’est le moment d’afficher à l’écran notre génération créée au hasard
<a href="http://lkdjiin.github.io/blog/2014/11/01/le-jeu-de-la-vie-en-racket-partie-1/">la dernière fois</a>.
Je rappelle que je n’écris pas de tests pour cette partie.
Pour obtenir un affichage, je me contente de suivre les exemples donnés dans la
documentation
<a href="http://mirror.racket-lang.org/releases/6.1/doc/draw/overview.html">drawing overview</a>
et <a href="http://mirror.racket-lang.org/releases/6.1/doc/gui/windowing-overview.html">windowing overview</a>.</p>

<!-- more -->

<p>Ce qui donne la première experimentation suivante:</p>

<p>``` racket game-of-life.rkt
#lang racket/gui</p>

<p>…</p>

<p>(define generation (create-generation 100 100))</p>

<p>(define frame (new frame%
  [label “Example”]
  [width 100]
  [height 100]))</p>

<p>(new canvas%
     [parent frame]
     [paint-callback
       (λ (canvas dc)
          (send dc set-brush (new brush% [color “black”]))
          (for ([y (length generation)])
            (for ([x (length (first generation))])
              (when (= 1 (list-ref (list-ref generation y) x))
                (send dc draw-rectangle x y 1 1)))))])</p>

<p>(send frame show #t)
```</p>

<p>Le truc marrant (une façon de voir comme une autre) est que si on
joue les tests, la fenêtre s’affiche. C’est pas très pratique.</p>

<p>Mais avant tout, ce code révèle une erreur précédente:</p>

<p><img src="/images/code-barre-2014-10-11.png"></p>

<p>On dirait un code barre ! Pas vraiment une distribution uniforme.</p>

<p>Alors le bug est simple à trouver, par contre je vais devoir écrire un ou
plusieurs nouveaux tests et je garde ça pour la fin de l’article.</p>

<p>Ensuite, je voudrais faire une boucle qui affiche une nouvelle génération au
hasard chaque seconde. Je dois avouer que cette histoire de canvas, je la sens
pas trop. Et le code que j’ai pondu s’en ressent. D’abord je mets ce qui a trait
à une génération dans un module à part:</p>

<p>``` racket generation.rkt
#lang racket</p>

<p>(define (create-generation width height)
  (for/list ([i (make-list height 0)])
            (make-list width (random 2))))</p>

<p>(provide create-generation)
```</p>

<p>Puis, tout le bazar de frame et de canvas, aussi dans un module:</p>

<p>``` racket window.rkt
#lang racket/gui</p>

<p>(define (create-window w h g)
  (define frame (new frame%
                     [label “Game of Life”]
                     [width w]
                     [height h]))
  (define canvas (new (class canvas%
         (super-new [parent frame] [style ‘(no-autoclear)])
         (define current-generation g)
         (define dc (send this get-dc))
         (define/public (change-generation g)
           (set! current-generation g)
           (send this refresh-now))
         (define/override (on-paint)
           (send dc set-brush (new brush% [color “black”]))
           (send dc draw-rectangle 0 0 w h)
           (send dc set-brush (new brush% [color “white”]))
           (for ([y (length current-generation)])
             (for ([x (length (first current-generation))])
               (when (= 1 (list-ref (list-ref current-generation y) x))
                 (send dc draw-rectangle x y 1 1))))))))
  (send frame show #t)
  canvas)</p>

<p>(provide create-window)
```</p>

<p>Moi qui suis habitué à des méthodes de 2 ou 3 lignes, c’est pas vraiment ça.
Et puis j’ai du mal à saisir le modèle objet de Racket.</p>

<p>Enfin le programme principal avec la boucle:</p>

<p>``` racket game-of-life.rkt
#lang racket</p>

<p>(require “generation.rkt”
         “window.rkt”)</p>

<p>(define size 100)
(define generation (create-generation size size))
(define canvas (create-window size size generation))</p>

<p>(define (loop n)
  (send canvas change-generation (create-generation size size))
  (sleep 1)
  (when (&gt; n 0)
    (loop (sub1 n))))</p>

<p>(loop 10)
```</p>

<p>Si j’ai le temps, j’essaierais d’utiliser la bibliothèque <code>2htdp/universe</code>,
qui me semble bien plus simple.</p>

<p>Maintenant le bug. Le problème est que je crée des lignes complètes de 0 ou de 1
dans la liste qui représente une génération, plutôt que de distribuer
uniformément ces 0 et ces 1. Je vais donc ajouter un test qui initialise le
générateur de nombres aléatoires toujours de la même manière.</p>

<p>``` racket game-of-life-test.rkt
#lang racket</p>

<p>(require rackunit
         “generation.rkt”)</p>

<p>…</p>

<p>((λ ()
   (random-seed 1)
   (check-equal? (create-generation 2 3) ‘((1 1) (0 1) (1 1))
                 “It populates generation uniformly”)))
```</p>

<p>Sans surprise, le test échoue.</p>

<pre><code>$ racket game-of-life-test.rkt
--------------------
FAILURE
actual:     ((1 1) (1 1) (0 0))
expected:   ((1 0) (1 0) (1 0))
name:       check-equal?
location:   (#&lt;path:/home/xavier/code/game-of-life-racket/game-of-life-test.rkt&gt; 21 3 537 112)
expression: (check-equal? (create-generation 2 3) (quote ((1 0) (1 0) (1 0))))
message:    "It populates generation uniformly"
</code></pre>

<p>Et voici le fix.</p>

<p>``` racket generation.rkt
#lang racket</p>

<p>(define (create-generation width height)
  (define (rnd _)
    (random 2))
  (for/list ([i (make-list height 0)])
            (map rnd (make-list width 0))))</p>

<p>(provide create-generation)
```</p>

<script id="fb33k8u">(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Le jeu de la vie en racket - partie 1]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/11/01/le-jeu-de-la-vie-en-racket-partie-1/"/>
    <updated>2014-11-01T12:22:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/11/01/le-jeu-de-la-vie-en-racket-partie-1</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Le troisième volet de cette série <a href="http://lkdjiin.github.io/blog/2014/10/08/le-jeu-de-la-vie-dans-sept-langages-differents/">le jeu de la vie en 7 langages</a>
sera consacré à <a href="http://racket-lang.org/">Racket</a>, un dialecte de Lisp.
Télécharger le ici: http://download.racket-lang.org/
et installez avec <code>bash ./nom-du-fichier.sh</code></p>

<!-- more -->

<p>On commence par un <em>smoke test</em> pour être sûr que Racket est bien installé et
accessible. Dans un fichier <code>game-of-life-test.rkt</code>, chargez le framework de
test et le futur fichier d’implémentation.</p>

<p>``` racket game-of-life-test.rkt
#lang racket</p>

<p>(require rackunit
         “game-of-life.rkt”)
```</p>

<p>Puis executez le :</p>

<pre><code>$ racket game-of-life-test.rkt
game-of-life-test.rkt:4:9: cannot open module file
</code></pre>

<p>Cool, Racket est là et nous dit qu’il ne peut pas ouvrir le fichier
<code>game-of-life.rkt</code>. Créons le :</p>

<pre><code>touch game-of-life.rkt
</code></pre>

<p><code>racket game-of-life.rkt
#lang racket
</code></p>

<p>Premier test maintenant, la fonction <code>create-generation</code> doit renvoyer une
liste.</p>

<p>``` racket game-of-life-test.rkt
#lang racket</p>

<p>(require rackunit
         “game-of-life.rkt”)</p>

<p>(check-pred list? (create-generation 3 4))
```</p>

<pre><code>$ racket game-of-life-test.rkt 
game-of-life-test.rkt:6:19: create-generation: unbound identifier in module
</code></pre>

<p>Ok, on renvoie donc une liste vide <code>'()</code>. Notez aussi <code>provide</code>, qui permet de
définir en quelque sorte les fonctions publiques du fichier.</p>

<p>``` racket game-of-life.rkt
#lang racket</p>

<p>(define (create-generation width height)
  ‘())</p>

<p>(provide create-generation)
```</p>

<p><code>rackunit</code>, le framework de test <em>shippé</em> avec Racket peut aussi documenter
les tests:</p>

<p><code>racket game-of-life-test.rkt
(check-equal? (length (create-generation 3 4)) 4
              "It builds a list with the right height")
</code></p>

<p>On crée une liste de la bonne taille, et comme on se fiche pour l’instant de ce
qu’elle contient, on peut l’initialiser avec des zéros.</p>

<p><code>racket game-of-life.rkt
(define (create-generation width height)
  (make-list height 0))
</code></p>

<p>Chaque élément de la liste doit aussi être une liste (la dimension <code>x</code>).</p>

<p><code>racket game-of-life-test.rkt
(check-equal? (length (first (create-generation 3 4))) 3
              "It builds a list with the right width")
</code></p>

<pre><code>$ racket game-of-life-test.rkt 
length: contract violation
  expected: list?
  given: 0
</code></pre>

<p>J’utilise <code>for/list</code> pour construire cette fameuse liste à deux dimensions. Les
différentes variantes de <code>for</code> me semble très utilisées en Racket.</p>

<p><code>racket game-of-life.rkt
(define (create-generation width height)
  (for/list ([i (make-list height 0)])
            (make-list width 0)))
</code></p>

<p>Finalement, je veux que ma liste contiennent des <code>0</code> (cellule morte) et des
<code>1</code> (cellule vivante).</p>

<p><code>racket game-of-life-test.rkt
(let ([cell (first (first (create-generation 3 4)))])
  (check-true (or (= cell 0) (= cell 1))
              "It populates generation with 0s or 1s"))
</code></p>

<p><code>racket game-of-life.rkt
(define (create-generation width height)
  (for/list ([i (make-list height 0)])
            (make-list width (random 2))))
</code></p>

<p>Ce dernier bout de code contient un bug qui n’est pas attrapé par les
tests (vous l’avez vu ?). Je <em>fixerais</em> ça dans le prochain article.</p>

<script id="fb33k8u">(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Le jeu de la vie dans sept langages différents]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/10/08/le-jeu-de-la-vie-dans-sept-langages-differents/"/>
    <updated>2014-10-08T12:30:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/10/08/le-jeu-de-la-vie-dans-sept-langages-differents</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Je vais écrire le <a href="http://en.wikipedia.org/wiki/Conway%27s_Game_of_Life">jeu de la vie</a> dans 7 langages, et
en utilisant le TDD (sauf pour l’affichage).
Ça va me permettre de réviser certains langages et d’en apprendre de nouveaux
d’une manière amusante. Après tout, quoi de plus <em>fun</em> qu’un jeu pour zéro
joueur.</p>

<h2 id="lalgorithme">L’algorithme</h2>

<p>L’idée directrice, c’est de faire au plus simple.
L’algorithme général sera le suivant :</p>

<ol>
  <li>obtenir une première génération au hasard</li>
  <li>afficher la génération</li>
  <li>calculer la nouvelle génération et retour au point 2.</li>
</ol>

<p>Discutons un peu chacun des trois points.</p>

<!-- more -->

<h3 id="obtenir-une-premire-gnration-au-hasard">Obtenir une première génération au hasard</h3>

<p>Cette génération sera stockée dans un tableau (une liste). Suivant le
langage, j’utiliserais un tableau à 1 ou 2 dimensions.</p>

<h3 id="afficher-la-gnration">Afficher la génération</h3>

<p>Il s’agit d’afficher à l’écran le tableau calculé précédement. Chaque élément
du tableau représente une cellule du jeu de la vie, et une cellule sera
représentée à l’écran par un pixel. Alors un pixel pour une cellule, ça risque
d’être assez moche sur la plupart des dispositifs, mais c’est le plus simple.
J’améliorerais peut-être cet affichage plus tard.</p>

<h3 id="calculer-la-nouvelle-gnration">Calculer la nouvelle génération</h3>

<p>Là encore, j’essaye d’aller au plus simple. On va calculer la
nouvelle génération dans un second tableau. Une fois ce calcul effectué, ce
second tableau remplacera le premier.</p>

<p>Pour calculer le nouvel état d’une cellule, on devra observer la cellule et
ces 8 voisins. Autrement dit on observe une fenêtre de 9 cellules et on veut
connaitre le nouvel état de la cellule centrale. Il y a 3 cas possibles:</p>

<ol>
  <li>Si la somme des cellules vivantes est 3, alors la nouvelle cellule sera
vivante.</li>
  <li>Si la somme des cellules vivantes est 4, alors la nouvelle cellule conserve
son ancien état.</li>
  <li>Dans tous les autres cas, la nouvelle cellule est morte.</li>
</ol>

<p>Il faut encore parler du cas des cellules qui se trouvent sur les bords du
<em>plateau de jeu</em>. Normalement, le jeu de la vie est infini. Mais l’infini, c’est
pas simple. Dans une première itération, le <em>plateau de jeu</em> aura des
dimensions finies et les cellules qui se trouvent sur les bords se verront
ajoutées arbitrairement des voisins morts.</p>

<p>Une seconde itération pourrait implémenter une espèce de <a href="http://en.wikipedia.org/wiki/Torus">tore</a> pour avoir une surface
de jeu sans bordures.</p>

<h2 id="les-langages-cibls">Les langages ciblés</h2>

<p>Je vais écrire le jeu de la vie dans 7 langages différents:</p>

<ul>
  <li>ruby</li>
  <li>javascript</li>
  <li>racket</li>
  <li>logo</li>
  <li>julia</li>
  <li>haskell</li>
  <li>rust</li>
</ul>

<h3 id="pourquoi-ces-langages-">Pourquoi ces langages ?</h3>

<p><strong>Ruby</strong></p>

<p>Ça peut paraitre bizarre. Après tout j’écris en Ruby toute la journée, c’est
mon métier. Pourquoi vouloir en faire encore pendant mon temps libre ?
En fait, ce qui m’intéresse vraiment ici, c’est <a href="http://opalrb.org/">Opal.rb</a>. Peut-être aussi
que j’en ferais une seconde version avec <a href="http://www.libgosu.org/">Gosu</a>.</p>

<p><strong>Javascript</strong></p>

<p>Après des années passées à tenter d’éviter d’écrire la moindre ligne de
Javascript, je m’intéresse de nouveau à ce langage. Après tout, c’est un
incontournable du Web et il commence à me plaire. Et puis j’ai trop tardé à
faire du TDD avec Javascript, je crois que <a href="http://jasmine.github.io/">Jasmine</a> est devenu très bon.</p>

<p><strong>Racket</strong></p>

<p>Je crois que tout développeur devrait étudier un <em>Lisp like</em>. Lisp t’oblige à
penser autrement et du coup tu trouves des solutions différentes à des
problèmes de programmation de tout les jours.</p>

<p><strong>Logo</strong></p>

<p>Le <a href="http://fr.wikipedia.org/wiki/Logo_%28langage%29">Logo</a>, c’est ma <a href="http://fr.wikipedia.org/wiki/Madeleine_%28cuisine%29#La_madeleine_de_Proust">madeleine de Proust</a> ! Voilà. Encore un <em>Lisp like</em>,
mais différent (on l’appelait Lisp sans parenthèses). J’espère que je trouverais
encore des ressources pour celui-ci.</p>

<p><strong>Julia</strong></p>

<p>Je pense que les langages fonctionnels ont un grand avenir. Ils résolvent au
moins deux soucis. En ce concentrant sur la transformation des données plutôt
que sur l’état de ces données, ils facilitent les tests et l’utilisation des
multi-coeurs.</p>

<p><strong>Haskell</strong></p>

<p>Encore un langage fonctionnel, et celui-ci me fait un peu peur. Mais je me dis
que je devrais y goûter.</p>

<p><strong>Rust</strong></p>

<p>Je voulais un langage système dans cette liste, ce sera <a href="http://www.rust-lang.org/">Rust</a>.</p>

<h2 id="frquence-de-publication">Fréquence de publication</h2>

<p>Je ne m’avancerais pas sur une fréquence de publication. J’imagine qu’il y
aura 3 ou 4 articles par langage. Et suivant le temps dont je disposerais, ça
pourrat-être aussi bien un article par mois ou trois articles par semaine.</p>

<p>Allez, la prochaine fois on commence avec Ruby/Opal.</p>

<script id="fb33k8u">(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Racket: Trouves mon nombre - partie 4]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/01/16/racket-trouves-mon-nombre-partie-4/"/>
    <updated>2014-01-16T20:47:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/01/16/racket-trouves-mon-nombre-partie-4</id>
    <content type="html"><![CDATA[<p>Suite à <a href="http://lkdjiin.github.io/blog/2014/01/09/trouves-mon-nombre-partie-3/">l’article précédent</a>,
on voit aujourd’hui la fonction <code>start</code> qui permet de démarrer le jeu avec
n’importe quelle étendue de nombres.</p>

<!-- more -->

<p>Voici tout d’abord le programme complet:</p>

<p>``` racket guess.rkt
#lang racket</p>

<p>(define lower 1)
(define upper 100)</p>

<p>(define (guess)
  (quotient (+ lower upper) 2))</p>

<p>(define (smaller)
  (set! upper (max lower (sub1 (guess))))
  (guess))</p>

<p>(define (bigger)
  (set! lower (min upper (add1 (guess))))
  (guess))</p>

<p>(define (start n m)
  (set! lower (min n m))
  (set! upper (max n m))
  (guess))
```</p>

<p>On peut maintenant demander à la machine de <em>deviner</em> un nombre entre
n et m:</p>

<pre><code>[~]⇒ racket
Welcome to Racket v5.3.6.
-&gt; (enter! "guess.rkt")
-&gt; (start 1 10)
5
-&gt; (bigger)
8
-&gt; (smaller)
6
</code></pre>

<p>La fonction <code>start</code> utilise des notions déjà vues dans les articles
précédents.</p>

<p><code>racket
(define (start n m)
  (set! lower (min n m))
  (set! upper (max n m))
  (guess))
</code></p>

<p>Grâce à <code>set!</code>, on redéfini la valeur des variables <code>lower</code> et <code>upper</code>. Puis
on débute le jeu en lançant <code>guess</code>.</p>

<p>La variable <code>lower</code> se voit affecter la plus petite des valeurs passées en
arguments, grâce à <code>min</code>. Et <code>upper</code> se voit affecter la plus grande
grâce à <code>max</code>. Du coup, l’ordre des arguments de <code>start</code> n’a plus
d’importance:</p>

<pre><code>-&gt; (start 1000 1)
500
-&gt; (start 1 1000)
500
</code></pre>

<p>Voilà qui conclue cette petite introduction au langage Racket.</p>

<script id="fb33k8u">(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>

<p>À demain.</p>

<p></p>

]]></content>
  </entry>
  
</feed>
