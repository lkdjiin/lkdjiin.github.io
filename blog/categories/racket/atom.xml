<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : racket | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/racket/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2014-01-06T21:26:59+01:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Racket: Trouves mon nombre - partie 2]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/01/05/racket-trouves-mon-nombre-partie-2/"/>
    <updated>2014-01-05T20:32:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/01/05/racket-trouves-mon-nombre-partie-2</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Suite de l'article d'hier, aujourd'hui on ajoute la fonction
<code>smaller</code> à notre petit jeu textuel.</p>

<!-- more -->


<p>Voici le fichier <code>guess.rkt</code> avec la nouvelle fonction:</p>

<p>``` racket guess.rkt</p>

<h1>lang racket</h1>

<p>(define lower 1)
(define upper 100)</p>

<p>(define (guess)
  (quotient (+ lower upper) 2))</p>

<p>(define (smaller)
  (set! upper (max lower (sub1 (guess))))
  (guess))
```</p>

<p>Cette fonction change l'étendue du nombre à trouver, puis fait une nouvelle
proposition:</p>

<pre><code>[~]⇒ racket
Welcome to Racket v5.3.6.
-&gt; (enter! "guess.rkt")
-&gt; (guess)
50
-&gt; (smaller)
25
</code></pre>

<p>Voyons notre nouvelle fonction en détail:</p>

<p><code>racket
(define (smaller)
  (set! upper (max lower (sub1 (guess))))
  (guess))
</code></p>

<p>Si le nombre à trouver est plus petit que 50, il est donc compris entre
1 et 49. Il faut donc changer la limite haute (<code>upper</code>) pour refléter
cette nouvelle donne.</p>

<p>Le rôle de <code>set!</code> est de redéfinir une variable. Ici, on va changer le
contenu de la variable <code>upper</code>.</p>

<p>La fonction <code>sub1</code> décremente le nombre passé en argument, donc
<code>(sub1 (guess))</code> renvoie 49. Et nous prenons, grâce à <code>max</code>, le nombre maximum entre
celui-ci (49) et la valeur de la limite basse, ce qui permet de
s'assurer que la valeur de <code>upper</code> ne sera jamais inférieure à
la valeur de <code>lower</code>. Ce qu'on peut vérifier en continuant à évaluer
<code>smaller</code>:</p>

<pre><code>-&gt; (smaller)
25
-&gt; (smaller)
12
-&gt; (smaller)
6
-&gt; (smaller)
3
-&gt; (smaller)
1
-&gt; (smaller)
1
-&gt; (smaller)
1
...
</code></pre>

<p>La prochaine fois on verra la fonction inverse: <code>bigger</code> que vous
pouvez essayer de coder par vous-même en attendant.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Racket: Trouves mon nombre - partie 1]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/01/04/racket-trouves-mon-nombre-partie-1/"/>
    <updated>2014-01-04T19:12:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/01/04/racket-trouves-mon-nombre-partie-1</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>«Devines un nombre entre 1 et 100 !» C'est le jeu que je vous propose
d'écrire en Racket pour apprendre ce langage.
Le code provient du livre <a href="http://realmofracket.com/">Realm of Racket</a>
et il est livré avec Racket. Vous pourrez le trouver dans le dossier
<code>collects/realm/chapter2</code> de votre installation de Racket.</p>

<!-- more -->


<p>Voici le morceau de code qu'on va voir aujourd'hui:</p>

<p>``` racket guess.rkt</p>

<h1>lang racket</h1>

<p>(define lower 1)
(define upper 100)</p>

<p>(define (guess)
  (quotient (+ lower upper) 2))
```</p>

<p>Enregistrez le dans un fichier <code>guess.rkt</code>. Pour le charger, lancez <code>racket</code>
et tapez <code>(enter! "guess.rkt")</code>:</p>

<pre><code>[~]⇒ racket
Welcome to Racket v5.3.6.
-&gt; (enter! "guess.rkt")
</code></pre>

<p>Si vous demandez l'évaluation de la fonction <code>guess</code>, vous obtiendrez 50:</p>

<pre><code>-&gt; (guess)
50
</code></pre>

<p>Voici quelques explications. On a tout d'abord défini deux variables,
<code>lower</code> et <code>upper</code>, qui sont les limites basses et hautes de l'étendue
sur laquelle la machine va <em>deviner</em> un nombre:</p>

<p><code>racket
(define lower 1)
(define upper 100)
</code></p>

<p>Plus tard dans le programme, le contenu de ces variables changera pour
réduire l'étendue.</p>

<p>Maintenant, voyons comment la machine <em>devine</em> un nombre:</p>

<p><code>racket
(define (guess)
  (quotient (+ lower upper) 2))
</code></p>

<p>Tout simplement en donnant le nombre qui se trouve au milieu des limites
basses et hautes. Pour trouver ce nombre, on divise par 2 la somme de la limite
basse et de la limite haute. On doit ici utiliser <code>quotient</code> pour faire
la division, et non pas <code>/</code>. En effet:</p>

<pre><code>-&gt; (/ 101 2)
101/2
</code></pre>

<p>En Racket, les nombres restent <em>exacts</em> tant qu'ils le peuvent. Comme nous
voulons un nombre entier, il faut le tronquer:</p>

<pre><code>-&gt; (truncate 101/2)
50
</code></pre>

<p>Voilà ce à quoi sert <code>quotient</code>. Autrement dit:</p>

<p><code>racket
(quotient a b)
</code></p>

<p>est égal à:</p>

<p><code>racket
(truncate (/ a b))
</code></p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Racket: Afficher les tables de multiplication]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/01/03/racket-afficher-les-tables-de-multiplication/"/>
    <updated>2014-01-03T17:41:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/01/03/racket-afficher-les-tables-de-multiplication</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Aujourd'hui un programme vraiment très simple pour débuter en Racket:
comment afficher les tables de multiplication de 1 à 12.
Attention: vrais débutants uniquement !</p>

<!-- more -->


<p>On commence par une fonction qui affiche une ligne d'une table de
multiplication:</p>

<p><code>racket
(define (display-table-line rank n)
  (printf "~a x ~a = ~a\n" rank n (* rank n)))
</code></p>

<p>Cette fonction se nomme <code>display-table-line</code> et prends deux
paramètres: <code>rank</code> et <code>n</code>. <code>n</code> est le numéro de la table (table des 1,
table des 2, table des 3, etc).
<code>printf</code> permet d'afficher une ligne de texte formaté, chaque occurence
de <code>~a</code> sera remplacée, dans l'ordre, par les arguments qui suivent.</p>

<p>Voici maintenant la fonction <code>display-table</code>, qui va afficher une table entière:</p>

<p>``` racket
(define (display-table n)
  (for ([rank (in-range 1 11)])</p>

<pre><code>   (display-table-line rank n)))
</code></pre>

<p>```</p>

<p>Cette fonction affiche la table des <code>n</code>. Tout se passe dans une boucle <code>for</code>.
La fonction <code>(in-range x y)</code> retourne un range de x inclus, à y non-inclus.</p>

<p>Et enfin, voici la boucle principale qui provoque l'affichage des tables de
1 à 12:</p>

<p>``` racket
(for ([num (in-range 1 13)])</p>

<pre><code> (printf "Table des ~a\n\n" num)
 (display-table num)
 (newline))
</code></pre>

<p>```</p>

<p>On peut paraphraser le code ainsi: pour chaque table de 1 à 12, écrire un
entête, afficher la table, puis passer une ligne.</p>

<p>Voici donc, pour finir, le code complet:</p>

<p>``` racket</p>

<h1>lang racket</h1>

<p>(define (display-table-line rank n)
  (printf &ldquo;~a x ~a = ~a\n&rdquo; rank n (* rank n)))</p>

<p>(define (display-table n)
  (for ([rank (in-range 1 11)])</p>

<pre><code>   (display-table-line rank n)))
</code></pre>

<p>(for ([num (in-range 1 13)])</p>

<pre><code> (printf "Table des ~a\n\n" num)
 (display-table num)
 (newline))
</code></pre>

<p>```</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Racket: première approche de lambda]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/11/21/racket-premiere-approche-de-lambda/"/>
    <updated>2013-11-21T19:53:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/11/21/racket-premiere-approche-de-lambda</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Dans un <a href="http://lkdjiin.github.io/blog/2013/11/11/racket-pour-les-rubyists-6-une-premiere-fonction/">article précédent</a>, j'ai écrit une fonction Racket pour calculer
les diviseurs d'un nombre n:</p>

<p>``` racket</p>

<h1>lang racket</h1>

<p>(define (divisors n)
  ; Is i a divisor of n?
  (define (divisor? i)</p>

<pre><code>(= 0 (remainder n i)))
</code></pre>

<p>  (filter divisor? (range 1 (+ n 1))))</p>

<p>(provide divisors)
```</p>

<p>Puis on a vu comment <a href="http://lkdjiin.github.io/blog/2013/11/17/racket-pour-les-rubyists-8-tests-unitaires-simples/">faire des tests unitaires</a>.
Il est temps maintenant de faire un peu de refactoring.</p>

<!-- more -->


<p>Tout d'abord, le plus simple, on va extraire une fonction qui calcule
un <em>range</em> de 1 à n inclus:</p>

<p>``` racket number.rkt</p>

<h1>lang racket</h1>

<p>; divisors : integer &ndash;> list of integers
; Get divisors of a number n.
(define (divisors n)
  ; Is i a divisor of n?
  (define (divisor? i)</p>

<pre><code>(= 0 (remainder n i)))
</code></pre>

<p>  (filter divisor? (range-inclusive n)))</p>

<p>; range-inclusive : integer &ndash;> list of integers
; Build a list from 1 to n inclusive.
(define (range-inclusive n)
  (range 1 (+ n 1)))</p>

<p>(provide divisors)
```</p>

<p>Vous noterez au passage que j'ai commencé à documenter mes fonctions en
spécifiant les types de données en entrée et en sortie. Vous remarquez aussi
que <code>range-inclusive</code> ne fait pas partie de l'API du module:
<code>(provide divisors)</code>.</p>

<p>Maintenant il nous faut extraire la fonction qui regarde si un nombre <em>i</em> est
un diviseur de <em>n</em>:</p>

<p><code>racket
; divisor-of? : integer integer -&gt; boolean
; Tells if i is a divisor of n.
(define (divisor-of? n i)
  (= 0 (remainder n i)))
</code></p>

<p>Le nom de la fonction a changé au passage pour <code>divisor-of?</code>. Mais surtout
nous avons du inclure <em>n</em> dans les arguments de la fonction.</p>

<p>On doit maintenant <em>insérer</em> cette fonction dans le code de la fonction
principale <code>divisors</code>. Voici une première tentative un peu naive:</p>

<p><code>racket
; Attention, ce code ne fonctionne pas.
(define (divisors n)
  (filter (divisor-of? n i) (range-inclusive n)))
</code></p>

<p>Évidemment ça ne marche pas, puisque Racket ne connait pas <em>i</em>, mais
ça nous donne une orientation. Pour que Racket sache ce que nous voulons
placer dans <em>i</em>, à savoir l'élément en cours de traitement par la fonction
<code>filter</code>, on va passer par une fonction anonyme:</p>

<p><code>racket
(define (divisors n)
  (filter (lambda (i) (divisor-of? n i)) (range-inclusive n)))
</code></p>

<p>Une fonction anonyme (lambda) prend un argument (ou plusieurs) et une
expression. À chaque itération, <code>filter</code> passe un élément tiré de
<code>(range-inclusive n)</code> à la fonction anonyme <code>(lambda (i) (divisors-of? n i))</code>.</p>

<p>Voilà donc notre module, après refactoring:</p>

<p>``` racket number.rkt</p>

<h1>lang racket</h1>

<p>; divisors : integer &ndash;> list of integers
; Get divisors of a number n.
(define (divisors n)
  (filter (lambda (i) (divisor-of? n i)) (range-inclusive n)))</p>

<p>; divisor-of? : integer integer &ndash;> boolean
; Tells if i is a divisor of n.
(define (divisor-of? n i)
  (= 0 (remainder n i)))</p>

<p>; range-inclusive : integer &ndash;> list of integers
; Build a list from 1 to n inclusive.
(define (range-inclusive n)
  (range 1 (+ n 1)))</p>

<p>(provide divisors)
```</p>

<p>On aurait aussi pu écrire ce qui suit, à la place des trois fonctions ci-dessus:</p>

<p><code>racket
; divisors : integer -&gt; list of integers
; Get divisors of a number n.
(define (divisors n)
  (filter (lambda (i) (= 0 (remainder n i))) (range 1 (+ n 1))))
</code></p>

<p>Ça fait bien sûr beaucoup moins de code… Peut-être est-ce parceque je ne suis
pas encore habitué à Racket, mais je trouve aussi cela bien moins lisible.
Si on doit réutiliser les fonctions <code>divisor-of?</code> et <code>range-inclusive</code>, il
n'y a pas de question à se poser. Sinon…? Si vous connaissez bien
Racket/Scheme/Lisp laissez donc un commentaire pour me dire quelle version
est la plus idiomatique de ce type de langages.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Racket pour les Rubyists 8: Tests unitaires simples]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/11/17/racket-pour-les-rubyists-8-tests-unitaires-simples/"/>
    <updated>2013-11-17T19:04:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/11/17/racket-pour-les-rubyists-8-tests-unitaires-simples</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Maintenant que l'on sait <a href="http://lkdjiin.github.io/blog/2013/11/15/racket-pour-les-rubyists-7-module-basique/">écrire un module pour Racket</a>, on va pouvoir
faire des tests unitaires simples avec RackUnit, le framework de test
fournit avec le langage Racket.</p>

<!-- more -->


<h2>Notre module</h2>

<p>On va tout d'abord mettre notre fonction <code>divisors</code> dans le fichier
<code>number.rkt</code>:</p>

<p>``` racket</p>

<h1>lang racket</h1>

<p>(define (divisors n)
  ; Is i a divisor of n?
  (define (divisor? i)</p>

<pre><code>(= 0 (remainder n i)))
</code></pre>

<p>  (filter divisor? (range 1 (+ n 1))))</p>

<p>(provide divisors)
```</p>

<p>Puis on s'assure que tout fonctionne bien en appelant la fonction <code>divisors</code>
depuis une session racket:</p>

<pre><code>[~]⇒ racket
Welcome to Racket v5.3.6.
-&gt; (require "number.rkt")
-&gt; (divisors 17)
'(1 17)
-&gt; (exit)
</code></pre>

<h2>Le framework RackUnit</h2>

<p>Tout comme Ruby est fournit avec test/unit, Racket est livré avec RackUnit.
C'est un framework de tests unitaires relativement simple, surtout dans son
<em>utilisation basique</em> comme on va le voir ici.</p>

<p>Comme notre fichier à tester se nomme <code>number.rkt</code>, nous allons nommer le
fichier comportant les tests <code>number-test.rkt</code> et le placer dans le même
dossier:</p>

<p>``` racket</p>

<h1>lang racket</h1>

<p>(require rackunit</p>

<pre><code>     "number.rkt")
</code></pre>

<p>```</p>

<p>On requiert la bibliothèque <code>rackunit</code> ainsi que le fichier à tester. <em>On verra
dans un autre article pourquoi <code>rackunit</code> n'est pas placé entre guillemets.</em>
Maintenant on peut effectuer un test avec la fonction:</p>

<pre><code>(check-equal? A B)
</code></pre>

<p>qui s'assure que l'expression A est égale à l'expression B. Par exemple:</p>

<p>``` racket</p>

<h1>lang racket</h1>

<p>(require rackunit</p>

<pre><code>     "number.rkt")
</code></pre>

<p>(check-equal? (divisors 8) &lsquo;(1 2 4 8))
```</p>

<p>Et on lance les tests comme ceci:</p>

<pre><code>[~]⇒ racket number-test.rkt
[~]⇒ 
</code></pre>

<p>Quand tout les tests passent, RackUnit est silencieux.
Si on modifie notre fonction <code>divisors</code> ainsi:</p>

<pre><code>(filter divisor? (range 2 (+ n 1))))
</code></pre>

<p>On peut voir le genre de sortie produit par RackUnit sur un test qui
échoue:</p>

<pre><code>[~]⇒ racket number-test.rkt
--------------------
FAILURE
actual:     (2 4 8)
expected:   (1 2 4 8)
name:       check-equal?
location:   (#&lt;path:/number-test.rkt&gt; 7 0 92 38)
expression: (check-equal? (divisors 8) (quote (1 2 4 8)))

Check failure
--------------------
</code></pre>

<h2>Comparaison avec Ruby et unit/test</h2>

<p>Voici un test similaire pour Ruby, écrit avec le framework test/unit:</p>

<p>``` ruby
require_relative &ldquo;number&rdquo;
require &ldquo;test/unit&rdquo;</p>

<p>class TestNumber &lt; Test::Unit::TestCase
  def test_divisors</p>

<pre><code>assert_equal [1, 2, 4, 8], Number.divisors(8)
</code></pre>

<p>  end
end
```</p>

<p>Ruby est loin d'être un langage verbeux et pourtant on peut voir qu'ici il
faut écrire une classe et utiliser l'héritage rien que pour un simple petit
test de rien du tout. Alors je ne dis pas que les <em>test cases</em> sont
inutiles (et Racket permet aussi d'organiser les tests de plusieurs
manières différentes), seulement dans le cas d'un programme aussi simple
que le notre je trouve la façon de faire de Racket plus <em>naturelle</em>.</p>

<p>La prochaine fois on passera au refactoring de notre méthode <code>divisors</code>.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
