<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : lambda | Xavier Nayrac]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/lambda/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2016-02-05T17:21:02+01:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Racket: première approche de lambda]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/11/21/racket-premiere-approche-de-lambda/"/>
    <updated>2013-11-21T19:53:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/11/21/racket-premiere-approche-de-lambda</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Dans un <a href="http://lkdjiin.github.io/blog/2013/11/11/racket-pour-les-rubyists-6-une-premiere-fonction/">article précédent</a>, j’ai écrit une fonction Racket pour calculer
les diviseurs d’un nombre n:</p>

<p>``` racket
#lang racket</p>

<p>(define (divisors n)
  ; Is i a divisor of n?
  (define (divisor? i)
    (= 0 (remainder n i)))
  (filter divisor? (range 1 (+ n 1))))</p>

<p>(provide divisors)
```</p>

<p>Puis on a vu comment <a href="http://lkdjiin.github.io/blog/2013/11/17/racket-pour-les-rubyists-8-tests-unitaires-simples/">faire des tests unitaires</a>.
Il est temps maintenant de faire un peu de refactoring.</p>

<!-- more -->

<p>Tout d’abord, le plus simple, on va extraire une fonction qui calcule
un <em>range</em> de 1 à n inclus:</p>

<p>``` racket number.rkt
#lang racket</p>

<p>; divisors : integer -&gt; list of integers
; Get divisors of a number n.
(define (divisors n)
  ; Is i a divisor of n?
  (define (divisor? i)
    (= 0 (remainder n i)))
  (filter divisor? (range-inclusive n)))</p>

<p>; range-inclusive : integer -&gt; list of integers
; Build a list from 1 to n inclusive.
(define (range-inclusive n)
  (range 1 (+ n 1)))</p>

<p>(provide divisors)
```</p>

<p>Vous noterez au passage que j’ai commencé à documenter mes fonctions en
spécifiant les types de données en entrée et en sortie. Vous remarquez aussi
que <code>range-inclusive</code> ne fait pas partie de l’API du module:
<code>(provide divisors)</code>.</p>

<p>Maintenant il nous faut extraire la fonction qui regarde si un nombre <em>i</em> est
un diviseur de <em>n</em>:</p>

<p><code>racket
; divisor-of? : integer integer -&gt; boolean
; Tells if i is a divisor of n.
(define (divisor-of? n i)
  (= 0 (remainder n i)))
</code></p>

<p>Le nom de la fonction a changé au passage pour <code>divisor-of?</code>. Mais surtout
nous avons du inclure <em>n</em> dans les arguments de la fonction.</p>

<p>On doit maintenant <em>insérer</em> cette fonction dans le code de la fonction
principale <code>divisors</code>. Voici une première tentative un peu naive:</p>

<p><code>racket
; Attention, ce code ne fonctionne pas.
(define (divisors n)
  (filter (divisor-of? n i) (range-inclusive n)))
</code></p>

<p>Évidemment ça ne marche pas, puisque Racket ne connait pas <em>i</em>, mais
ça nous donne une orientation. Pour que Racket sache ce que nous voulons
placer dans <em>i</em>, à savoir l’élément en cours de traitement par la fonction
<code>filter</code>, on va passer par une fonction anonyme:</p>

<p><code>racket
(define (divisors n)
  (filter (lambda (i) (divisor-of? n i)) (range-inclusive n)))
</code></p>

<p>Une fonction anonyme (lambda) prend un argument (ou plusieurs) et une
expression. À chaque itération, <code>filter</code> passe un élément tiré de
<code>(range-inclusive n)</code> à la fonction anonyme <code>(lambda (i) (divisors-of? n i))</code>.</p>

<p>Voilà donc notre module, après refactoring:</p>

<p>``` racket number.rkt
#lang racket</p>

<p>; divisors : integer -&gt; list of integers
; Get divisors of a number n.
(define (divisors n)
  (filter (lambda (i) (divisor-of? n i)) (range-inclusive n)))</p>

<p>; divisor-of? : integer integer -&gt; boolean
; Tells if i is a divisor of n.
(define (divisor-of? n i)
  (= 0 (remainder n i)))</p>

<p>; range-inclusive : integer -&gt; list of integers
; Build a list from 1 to n inclusive.
(define (range-inclusive n)
  (range 1 (+ n 1)))</p>

<p>(provide divisors)
```</p>

<p>On aurait aussi pu écrire ce qui suit, à la place des trois fonctions ci-dessus:</p>

<p><code>racket
; divisors : integer -&gt; list of integers
; Get divisors of a number n.
(define (divisors n)
  (filter (lambda (i) (= 0 (remainder n i))) (range 1 (+ n 1))))
</code></p>

<p>Ça fait bien sûr beaucoup moins de code… Peut-être est-ce parceque je ne suis
pas encore habitué à Racket, mais je trouve aussi cela bien moins lisible.
Si on doit réutiliser les fonctions <code>divisor-of?</code> et <code>range-inclusive</code>, il
n’y a pas de question à se poser. Sinon…? Si vous connaissez bien
Racket/Scheme/Lisp laissez donc un commentaire pour me dire quelle version
est la plus idiomatique de ce type de langages.</p>

<script id="fb33k8u">(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>

<p>À demain.</p>

<p></p>

]]></content>
  </entry>
  
</feed>
