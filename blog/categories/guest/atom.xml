<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : guest | Xavier Nayrac]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/guest/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2015-12-13T17:22:09+01:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Commencer le développement web en Ruby]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/09/16/commencer-le-developpement-web-en-ruby/"/>
    <updated>2015-09-16T15:10:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/09/16/commencer-le-developpement-web-en-ruby</id>
    <content type="html"><![CDATA[<h2 id="guest-post-"><code>{ Guest Post }</code></h2>

<p>Grâce au framework <a href="http://rubyonrails.org/">Ruby on Rails</a>, Ruby est maintenant très populaire pour le développement d’application web.
Ce domaine est un pleine croissance et Ruby on Rails attire beaucoup de débutants de tout horizons.</p>

<p>Je pense que commencer l’apprentissage d’un framework web nécessite de bien comprendre le rôle de chacun de ses composants.
Des composants, Ruby on Rails en comporte beaucoup et chacun d’entre eux répond à une problématique bien précise.
ORM, routeur, templates, controlleurs, tâches de fond et bien d’autres ; il y a de quoi se perdre.</p>

<p>Mon conseil à ceux qui débutent dans le domaine est de bien comprendre la raison d’être de chaque chose.
Une manière amusante de cerner les problématiques qui ont donnés naissance aux frameworks tel que Rails,
c’est de se passer complètement de ces briques. C’est à dire partir du strict minimum et ajouter, petit à petit,
les composants dont on ressent le besoin.</p>

<!-- more -->

<h2 id="rack">Rack</h2>

<p><a href="https://rack.github.io/">Rack</a> est la brique de base de la plupart des frameworks web Ruby actuels. Rack est avant tout une API définissant
la manière pour un programme Ruby de prendre en charge et de répondre à une requête HTTP. Voici un exemple simple :</p>

<p>``` ruby
# ./config.ru</p>

<p>app = Proc.new do |env|
  [
    200,
    { “Content-Type” =&gt; “text/html” },
    [ “&lt;h1&gt;Hello world&lt;/h1&gt;” ]
  ]
end</p>

<p>run app
```</p>

<p>Dans cet exemple, on voit que l’on declare une variable <code>app</code> à laquelle on assigne un object <code>Proc</code>.
Cet objet <code>app</code> est ensuite passé à la méthode <code>Rack::Builder#run</code> indiquant ainsi au serveur compatible
ce qu’il faut exectuter lorsqu’une requête arrivera.</p>

<p>Regardons de plus près comment se comporte le <code>Proc</code> ci-dessus. On voit qu’il prend un argument que l’on
appelle <em>l’environement Rack</em>. Le <code>Proc</code> retourne une <em>réponse Rack</em> qui est un tableau contenant les
informations nécessaire à la construction de la réponse HTTP : le code de retour, les entêtes et le corps
de la reponse.</p>

<p>Rack ne nécessite pas d’utiliser un <code>Proc</code>. La seule contrainte est d’être un objet répondant à la méthode
<code>#call</code> prenant en argument un environement Rack et retournant une réponse Rack telle que nous venons de le voir.</p>

<h3 id="excuter-lapplication">Exécuter l’application</h3>

<p>Pour executer ce <code>config.ru</code> on peut utiliser l’outil <code>rackup</code> fourni avec la gem <code>rack</code>:</p>

<p><code>
$ gem install rack
$ rackup config.ru
[2015-07-21 10:54:21] INFO  WEBrick 1.3.1
[2015-07-21 10:54:21] INFO  ruby 2.2.2 (2015-04-13) [x86_64-linux]
[2015-07-21 10:54:21] INFO  WEBrick::HTTPServer#start: pid=24457 port=9292
</code></p>

<p>Cette commande va écouter sur le port 9292 et pour chaque requête appeller la méthode <code>#call</code> de l’objet <code>app</code>.</p>

<p>Lorsque l’on apportera es modification à notre code, il faudra bien penser à redémarrer le serveur : <code>CTRL-C</code> pour l’arrêter et le relancer avec la commande que l’on vient de voir.</p>

<h3 id="quy-a-t-il-dans-lenv">Qu’y a-t-il dans l’env</h3>

<p>Pour voir ce qui se trouve dans l’environement je vais utiliser <code>JSON.pretty_generate</code> qui va m’afficher la variable
<code>env</code> au format JSON.</p>

<p>``` ruby
# ./config.ru</p>

<p>require “json”</p>

<p>app = Proc.new do |env|
  puts JSON.pretty_generate(env)
  [
    200,
    { “Content-Type” =&gt; “text/html” },
    [ “&lt;h1&gt;Hello world&lt;/h1&gt;” ]
  ]
end</p>

<p>run app
```</p>

<p>Après avoir modifié le <code>config.ru</code>, il faut redémarrer le serveur.</p>

<p>Pour faire une requête, j’utilise <a href="https://github.com/jkbrzt/httpie">httpie</a> qui permet simplement d’envoyer des requêtes HTTP depuis le terminal et qui est équivalent à <code>curl</code> avec de jolies couleurs en plus. Vous pouvez utiliser le client de votre choix bien entendu. Chez moi cela donne :</p>

<p>```
$ http -v localhost:9292
GET / HTTP/1.1
Accept: <em>/</em>
Accept-Encoding: gzip, deflate
Connection: keep-alive
Host: localhost:9292
User-Agent: HTTPie/0.9.2</p>

<p>HTTP/1.1 200 OK
Connection: Keep-Alive
Content-Type: text/html
Date: Tue, 21 Jul 2015 11:21:16 GMT
Server: WEBrick/1.3.1 (Ruby/2.2.2/2015-04-13)
Transfer-Encoding: chunked</p>

<h1>Hello world</h1>
<p>```</p>

<p>À l’issue de cette requête, on a bien le body <code>&lt;h1&gt;Hello world&lt;/h1&gt;</code> qui s’affiche.
On remarque également que dans le terminal où notre serveur est lancé, on voit s’afficher
sur la sortie standard :</p>

<p>``` javascript
{
  “GATEWAY_INTERFACE”: “CGI/1.1”,
  “PATH_INFO”: “/”,
  “QUERY_STRING”: “”,
  “REMOTE_ADDR”: “127.0.0.1”,
  “REMOTE_HOST”: “localhost”,
  “REQUEST_METHOD”: “GET”,
  “REQUEST_URI”: “http://localhost:9292/”,
  “SCRIPT_NAME”: “”,
  “SERVER_NAME”: “localhost”,
  “SERVER_PORT”: “9292”,
  “SERVER_PROTOCOL”: “HTTP/1.1”,
  “SERVER_SOFTWARE”: “WEBrick/1.3.1 (Ruby/2.2.2/2015-04-13)”,
  “HTTP_HOST”: “localhost:9292”,
  “HTTP_CONNECTION”: “keep-alive”,
  “HTTP_ACCEPT_ENCODING”: “gzip, deflate”,
  “HTTP_ACCEPT”: “<em>/</em>”,
  “HTTP_USER_AGENT”: “HTTPie/0.9.2”,
  “rack.version”: [
    1,
    3
  ],
  “rack.input”: “#<rack::lint::inputwrapper:0x007fcac62086c0>",
  "rack.errors": "#<rack::lint::errorwrapper:0x007fcac6208698>",
  "rack.multithread": true,
  "rack.multiprocess": false,
  "rack.run_once": false,
  "rack.url_scheme": "http",
  "rack.hijack?": true,
  "rack.hijack": "#&lt;Proc:0x007fcac6208b70@/home/n25/.gem/ruby/2.2.2/gems/rack-1.6.4/lib/rack/lint.rb:525&gt;",
  "rack.hijack_io": null,
  "HTTP_VERSION": "HTTP/1.1",
  "REQUEST_PATH": "/",
  "rack.tempfiles": [</rack::lint::errorwrapper:0x007fcac6208698></rack::lint::inputwrapper:0x007fcac62086c0></p>

<p>]
}
```</p>

<p>C’est uniquement à partir de cette variable <code>env</code> que notre application devra formuler une réponse Rack !</p>

<h2 id="de-rack-au-frameworks-web">De Rack au frameworks Web</h2>

<p>Dans cette partie, essayons de trouver des solutions a de petits problèmes.
Bien sûr on n’utilisera que Rack.</p>

<p>Comme support nous nous mettrons dans le cas d’un réseau social très simplifié.</p>

<h3 id="le-routage">Le routage</h3>

<p>Chaque membre de notre réseau social va avoir une page qui lui est propre.
Pour y accéder nous utilisons le chemin suivant : <code>/members/&lt;id&gt;</code> où <code>&lt;id&gt;</code> sera <em>l’identifiant du membre</em>.</p>

<p>Avec Rack nous pouvons écrire le code suivant pour parvenir à isoler l’identifiant du membre :</p>

<p><code>ruby
def member(env)
  env["PATH_INFO"] =~ %r{\A/members/([A-Za-z0-9]+)\z} &amp;&amp; $1
end
</code></p>

<p>Cette méthode va nous permettre d’obtenir l’identifiant du membre en fonction de l’environement Rack.
On peut introduire ce code dans notre application :</p>

<p><code>ruby
app = Proc.new do |env|
  member_id = member(env)
  [
    200,
    { "Content-Type" =&gt; "text/html" },
    [ "&lt;h1&gt;Hello #{member_id}&lt;/h1&gt;" ]
  ]
end
</code></p>

<p>Ici on a extrait un paramètre de l’URL. Si on visite <code>/members/Nicolas</code> on verra le texte <em>Hello Nicolas</em> s’afficher.
Par contre, si on visite <code>/signup</code>, on verra <em>Hello</em> s’afficher seul puisque <code>member_id</code> sera égal à <code>nil</code>.</p>

<p>En pratique, notre réseau social va avoir besoin d’identifier des dixaines voir des centaines d’URLs différentes.
Avec ce volume, il est nécessaire de s’organiser autrement et d’associer les URLs gérée par notre application avec
le code responsable de répondre à la requête. Dans le cas ou une URL n’est pas gérée, on souhaite répondre par un code
d’erreur.</p>

<p>Voici un extrait de code permettant de répondre à cette problématique :</p>

<p>``` ruby
class ShowMember
  def self.match?(env)
    env[“PATH_INFO”] =~ %r{\A/members/[A-Za-z0-9]+\z}
  end</p>

<p>def self.call(env)
    member_id = env[“PATH_INFO”].sub(“/members/”, “”)
    headers = { “Content-Type” =&gt; “text/html” }
    body = “&lt;h1&gt;Hello #{member_id}&lt;/h1&gt;”
    [ 200, headers, [ body ] ]
  end
end</p>

<p>actions = [ ShowMember ]</p>

<p>app = Proc.new do |env|
  action = actions.find { |action| action.match?(env) }
  action ? action.call(env) : [ 404, {}, [ “Not Found” ] ]
end
```</p>

<p>On voit que j’ai implicitement définit une interface : <code>#match?(env)</code> et <code>call(env)</code> pour les actions que
l’application peut réaliser. Chaque action est responsable de formuler une réponse Rack lors d’un appel à la
méthode <code>call</code> et de savoir, via <code>match?</code>, si oui ou non elle doit s’executer.</p>

<p>L’ensemble des frameworks web font un traitement semblable en utilisant une solution que l’on appelle le routage.
Différentes approches concernant le routage existent, voir <a href="http://roda.jeremyevans.net/">Roda</a>, <a href="http://www.sinatrarb.com/">Sinatra</a> et <a href="http://guides.rubyonrails.org/routing.html">Rails</a>.</p>

<p>Voici par exemple un extrait de code qui utilise Sinatra pour faire exactement ce que nous avons fait :</p>

<p>``` ruby
require “sinatra”</p>

<p>get “/members/:member_id” do
  member_id = params[“member_id”]
  “&lt;h1&gt;Hello #{member_id}&lt;/h1&gt;”
end
```</p>

<p><em>Remarque</em> :On voit dans cet exemple que Sinatra permet d’extraire les paramètres de l’URL automatiquement.</p>

<h3 id="les-templates">Les templates</h3>

<p>Lorsque l’on développe une fonctionnalité d’un site web, il est fréquent de le faire en deux phases.
Une phase de design où l’on va écrire HTML et CSS afin de visualiser le résultat voulu. Une autre phase
où l’on écrira le code métier qui va injecter les bonnes valeurs dans le HTML en fonction de l’action
effectuée.</p>

<p>Par exemple dans notre code : <code>"&lt;h1&gt;Hello #{member_id}&lt;/h1&gt;"</code> on injecte la variable <code>member_id</code> dans
du HTML. De manière générale, le HTML est beaucoup plus volumineux que dans notre exemple.</p>

<p>Dans la vie de tout les jours, il est fréquent qu’une équipe soit en charge de la phase plus visuelle
(HTML / CSS) et une autre en charge du code métier. Il est donc fréquent de séparer ces deux composantes
de notre code.</p>

<p>Pour effectuer cette séparation, on a recours à des <em>moteurs de templates</em>. Ces briques logicielles vont
nous permettre de séparer notre présentation du code métier. Voici un exemple, toujours en utilisant
Rack :</p>

<p>``` ruby
require “erb”
require “ostruct”</p>

<p>module Template
  def erb(template_path, locals={})
    file_content = File.read(template_path)
    context = OpenStruct.new(locals).instance_eval { binding }
    ERB.new(file_content).result(context)
  end
end</p>

<p>class ShowMember
  extend Templating</p>

<p>def self.call(env)
    member_id = env[“PATH_INFO”].sub(“/members/”, “”)
    headers = { “Content-Type” =&gt; “text/html” }
    body = Template.erb(“template.html.erb”, member_id: member_id)
    [ 200, headers, [ body ] ]
  end
end
```</p>

<p>``` erb</p>
<h1>Hello &lt;%= member_id %&gt;</h1>
<p>```</p>

<p>Ici, on va utiliser <code>ERB</code> pour charger le fichier <code>template.html.erb</code>. Au sein de ce fichier,
la variable <code>member_id</code> sera injectée dans le HTML grâce à la notation <code>&lt;%= ... %&gt;</code>.</p>

<p>Les moteurs de templates sont nombreux : <a href="http://ruby-doc.org/stdlib-2.2.2/libdoc/erb/rdoc/ERB.html">erb</a>, <a href="http://haml.info/">haml</a>, <a href="http://slim-lang.com/">slim</a>, <a href="https://github.com/jimweirich/builder">builder</a>,
<a href="http://www.liquidmarkup.org/">liquid</a> etc. Leur usage va plus loin que la simple séparation du code de présentation et
du code métier (voir les <a href="http://guides.rubyonrails.org/layouts_and_rendering.html#using-partials">partials</a>, <a href="http://www.rubydoc.info/gems/slim/frames#Control_code_-">stuctures de controle</a>…).</p>

<h3 id="tester-son-application">Tester son application</h3>

<p>Avant de continuer je vais déplacer le code de l’application du fichier <code>config.ru</code> vers <code>app.rb</code>.
Au passage, j’en profite pour extraire une classe <code>Router</code> ainsi qu’une constante <code>App</code> qui contiendra
notre application.</p>

<p>Les tests sont indispensables lors du développement d’une application. Tester une application Rack est
assez aisé grâce aux outils inclus dans la gem <code>rack-test</code>. Voici un exemple d’un fichier de test écrit
avec minitest :</p>

<p>``` ruby
# ./app_test.rb</p>

<p>require “minitest/autorun”
require “rack/test”</p>

<p>require_relative “app”</p>

<p>describe App do
  include Rack::Test::Methods</p>

<p>describe “when the URL match no known action” do
    it “returns a 404 status code” do
      get “/unknown/path”
      last_response.status.must_equal 404
    end
  end</p>

<p>describe “when the URL match the members’s path” do
    it “displays the member’s id” do
      get “/members/Nicolas”
      last_response.body.must_include “Nicolas”
    end
  end</p>

<p>def app
    App
  end
end
```</p>

<p>Pour lancer les tests, la commande : <code>bundle exec ruby -Ilib:test *_test.rb --pride</code> suffit.</p>

<p>Le frameworks web tels que Rails instaurent des conventions et des outils par défaut pour le test
de ses applications. Les outils de tests fonctionnent également hors des frameworks comme le montre
notre exemple.</p>

<h2 id="pour-finir">Pour finir</h2>

<p>En continuant sur cette lancée, on peut rencontrer d’autres problématiques comme les sessions, la persistance,
l’organisation du coe métier, le caching et bien d’autres. Il est très facile, avec un peu de recul, de créer
son propre framework ou d’utiliser un micro-framework puis d’y ajouter ses propres conventions ainsi que les
outils de son choix.</p>

<p>Même si ce billet s’adresse principalement aux débutants, j’espère qu’il touchera également quelques
enseignants ou mentors. Peu importe votre profil, n’hésitez pas à partager vos premiers pas avec le
développement web en Ruby ainsi que la manière dont vous l’aborderiez aujourd’hui.</p>

<h1 id="qui-a-crit-cet-article-">Qui a écrit cet article ?</h1>

<p><img src="https://secure.gravatar.com/avatar/510312aa405bc675fc275fad7648eb1c?s=200"></p>

<p><strong>Nicolas Zermati</strong><br />
Software writer, building the backend of Sleekapp.io at Tigerlily</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to stay productive while working from home]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/07/27/how-to-stay-productive-while-working-from-home/"/>
    <updated>2015-07-27T13:25:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/07/27/how-to-stay-productive-while-working-from-home</id>
    <content type="html"><![CDATA[<p><em>Pour la première fois voici un article en anglais écrit par une développeuse qui
travaille pour une entreprise française, depuis le Mexique et le Brésil.</em></p>

<h2 id="guest-post-"><code>{ Guest Post }</code></h2>

<p>It’s been a bit more than year since I started remote working from Mexico and Brazil. I must admit it wasn’t easy to adapt myself to this way of working, as I consider myself someone who likes to talk and share some fun moments with my colleagues and friends.</p>

<!-- more -->

<p>The reasons why I took the decision of working remotely were purely personal, from spending more time with my family to visit friends in other countries. I took all this as my main motivation in this new adventure. </p>

<p>But even with this, motivation is not the only thing that can get you through a successful to remote working.</p>

<h2 id="distractions">Distractions</h2>

<p>If you don’t live alone, you won’t be the only one at your home adapting to remote working. Your family or roommates will have to adapt too.
Having your own space at your house, where you can focus during your working hours will help you a lot. It is a good idea to avoid common areas such as the living room or dinning. Neither working from your bedroom the best option. 
You should find a place dedicated only for work and where you feel confortable, that way you can disconnect from your duties once your working hours are finished, and the people in your house will think twice before interrupting you.</p>

<p>From time to time is nice to work from co working spaces, there you can meet other people that do remote working as well, it is nice to chat about their projects, and even how they handle remote working. If you will be doing remote working while travelling maybe it is worth for you to take a look at  <a href="https://www.desktimeapp.com/">Desktime App</a> there you can look for co working space by city.</p>

<h2 id="organization">Organization</h2>

<p>Organizing your day is one of the things that will lead you to achieving your objectives easily. 
People tend to think that remote working equals to “working in your own schedule”, which for some people might be true, I strongly advice to organize your day as if you were in your office or in a “regular job”. This way you can maintain a routine, stick to lunch hours and mainly you work only the hours you should work. Without a schedule you can easily find yourself having 2 lunches a day or working more time than you should. Resting is always important to maintain your productivity.</p>

<h2 id="communication">Communication</h2>

<p>One of trickiest thing about remote working is communication among your team, first off you have to work a lot in your writing and speaking skills. 
Also, I think it is important to maintain meetings like: <strong>Retrospective meetings</strong> so everyone can talk about the issues they encounter during the week and find a solution with your team.
Standups are important too, it is a really good way to communicate to your team what you are currently doing and if you might need a hand from them. 
In my case, communication is even harder, as I’m the only one in my team that works outside France, which means I start my day at 2 p.m. (Paris time). To handle this, we do asynchronous standups, which are written in Slack (our main communication tool), pinging if necessary the people we need to talk with. </p>

<p>At Tigerlily we even have a Slack room, where we come to say hi to everyone when we arrive and aware people if we will be away for some reason. This channel is also use to share articles or even fun stuff we found on the Internet is like a water cooler room.</p>

<p>Besides Slack, we use a lot Google Hangouts to do our meetings, and lately we have started using appear.in, which is a very simple app that allows you to start a video call without signing in, just by sharing a dedicated URL.</p>

<h2 id="breaks">Breaks</h2>

<p>It is important to take small breaks during your working hours, as you could do in your office. Some people find pomodoring a good way to manage their time, if you haven’t use it give it a try.</p>

<p>Finally, working from home or remotely doesn’t mean you don’t get to socialize with other people. With the extra time you gain from commuting you can use it to enroll in outside activities, or any kind of hobby you have been willing to practice, even assisting to your local meet up or why not organizing one :) </p>

<h1 id="qui-a-crit-cet-article-">Qui a écrit cet article ?</h1>

<p><img src="/images/Ana.jpg"></p>

<p><strong>Ana Rosas</strong><br />
Full-stack developer, working remotely at Tigerlily from Mexico and Brazil.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Comment j'ai amélioré mon Ruby avec des contrats]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/07/13/comment-jai-ameliore-mon-ruby-avec-des-contrats/"/>
    <updated>2015-07-13T12:42:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/07/13/comment-jai-ameliore-mon-ruby-avec-des-contrats</id>
    <content type="html"><![CDATA[<h2 id="guest-post-"><code>{ Guest Post }</code></h2>

<p>Mes aventures avec une quantité de langages m’ont permis d’entrevoir de nouvelles approches et techniques.
Par exemple, un des gros apports d’Haskell sont les <a href="http://lyah.haskell.fr/creer-nos-propres-types-et-classes-de-types">Types</a> et dans Erlang/Elixir le <a href="http://learnyousomeerlang.com/syntax-in-functions">Pattern-matching</a> est roi.
Professionnellement je code principalement en Ruby et je rêvais d’avoir un système de Types avancé ainsi que du pattern-matching.
C’est ainsi que j’ai découvert une super gem <a href="https://github.com/egonSchiele/contracts.ruby">Contracts.ruby</a> et dans cet article je vais essayer de vous présenter le <a href="https://en.wikipedia.org/wiki/Design_by_contract">Design par Contrats</a> à travers l’utilisation de cette gem.</p>

<!-- more -->

<h2 id="quest-ce-quun-contrat-">Qu’est-ce qu’un contrat ?</h2>

<p>Un contrat permet de s’assurer de ce qu’une méthode attend en entrée (pré-condition), de ce qu’elle produit en sortie (post-condition). Il va définir comment notre méthode se comporte mais aussi vérifier ce comportement.
La gem <code>Contracts.ruby</code> nous permet de décorer nos méthodes avec du code qui va vérifier que les entrées et les sorties correspondent à ce que le contrat spécifie. Bien sûr, on est pas obligé d’annoter chacune de nos méthodes mais je pense que spécifier le contrat sur toutes celles qui sont publiques ne peut qu’être bénéfique.</p>

<h2 id="un-premier-exemple">Un premier exemple</h2>

<p><code>ruby
Contract Num, Num =&gt; Num
def add(a, b)
  a + b
end
</code></p>

<p>Le contrat de ma méthode est <code>Contract Num, Num =&gt; Num</code> ce qui nous indique que la méthode <em>add</em> prend deux nombres en entrée et retourne un nombre. Simple, non ?
Vous allez me dire que ok, c’est de la documentation, j’aurais pu juste ajouter un commentaire. Mais, puisqu’il s’agit d’un contrat, la gem Contracts.ruby va permettre de nous assurer que celui-ci est respecté.</p>

<p>```ruby
require ‘contracts’</p>

<p>class Foo
  include Contracts</p>

<p>Contract Num, Num =&gt; Num
  def self.add(a, b)
    a + b
  end
end
```</p>

<p><code>Foo.add(1, 2)</code> nous retourne évidemmement <code>3</code> par contre <code>Foo.add(1, '2')</code> va retourner:</p>

<p><code>ruby
ParamContractError: Contract violation for argument 2 of 2:
        Expected: Num,
        Actual: "2"
        Value guarded in: Foo::add
        With Contract: Num, Num =&gt; Num
</code></p>

<p>L’erreur nous montre que le contrat de la méthode <em>add</em> n’a pas été respecté par le second paramètre que nous lui avons passé, ‘2’, car il n’est pas du type <em>Num</em>.</p>

<p>Notez que l’on doit toujours spécifier le type de la valeur retournée même si la méthode ne retourne rien:</p>

<p><code>ruby
Contract String =&gt; nil
def hello(name)
  puts "hello, #{name}!"
end
</code></p>

<p>Par exemple, si notre méthode retourne plusieurs valeurs, sa signature sera <code>Contract Num =&gt; [Num, Num]</code>.</p>

<h2 id="les-diffrents-types--notre-disposition">Les différents Types à notre disposition</h2>

<p>Outre les classiques <em>Num</em>, <em>String</em>, <em>Bool</em>, nous avons à notre disposition des types plus intéressants comme:</p>

<ul>
  <li><code>Any</code> lorsque votre argument n’a pas de contrainte</li>
  <li><code>None</code> lorsqu’on n’a pas d’argument</li>
  <li><code>Or</code> si notre argument peut être de plusieurs types, par exemple <code>Or[Fixnum, Float]</code></li>
  <li><code>Not</code> si notre argument ne peut pas être d’un certain type, par exemple <code>Not[nil]</code></li>
  <li><code>Maybe</code> si notre argument est optionnel, par exemple <code>Maybe[String]</code></li>
</ul>

<p>Et bien d’autres que vous pourrez découvrir dans la documentation.</p>

<h2 id="contrats-sur-des-types-avancs">Contrats sur des Types avancés</h2>

<p>On peut utiliser des contrats avec des Types plus avancés comme des listes:</p>

<p><code>ruby
Contract ArrayOf[Num] =&gt; Num
def multiply(vals)
  vals.reduce(:*)
end
</code></p>

<p>Le contrat de la méthode <em>multiply</em> nous indique qu’elle attend une liste de valeurs du type Num. Par conséquent on peut faire <code>multiply([2, 4, 16])</code> mais pas <code>multiply([2, 4, 'foo'])</code>.</p>

<p>Des Hash:</p>

<p><code>ruby
Contract ({ nom: String, age: Num, ville: String }) =&gt; nil
</code></p>

<p>Des méthodes:</p>

<p><code>ruby
Contract ArrayOf[Any], Proc =&gt; ArrayOf[Any]
</code></p>

<p>Si vous utilisez les arguments nommés de Ruby 2.x, le contrat ressemblera à:</p>

<p><code>ruby
Contract KeywordArgs[foo: String, bar: Num] =&gt; String
</code></p>

<p>On peut aussi définir nos propres contrats grâce aux <code>synonymes</code>:</p>

<p>```ruby
Token = String
Client = Or[Hash, nil]</p>

<p>Contract Token =&gt; Client
def authenticate(token)
```</p>

<p>Notre méthode est ainsi plus claire quant à ce qu’elle attend et ce qu’elle permet de faire. On désire un <code>Token</code> qui est de type <code>String</code> en entrée et on retourne un <code>Client</code> qui peut être un <code>Hash</code> ou rien (nil).</p>

<h2 id="le-pattern-matching">Le pattern-matching</h2>

<p>Le pattern-matching consiste, pour une valeur donnée, à tester si elle correspond à un motif ou pas. Si c’est le cas une action est déclenchée. C’est un peu comme de l’overloading de méthode en Java. On pourrait l’imaginer comme un switch case géant mais en beaucoup plus élégant.</p>

<p>Un exemple simple avec le calcul (pas efficace du tout) de la suite de Fibonacci:</p>

<p>```ruby
Contract 0 =&gt; 0
def fib(n)
  0
end</p>

<p>Contract 1 =&gt; 1
def fib(n)
  1
end</p>

<p>Contract Num =&gt; Num
def fib(n)
  fib(n-1) + fib(n-2)
end
```</p>

<p>Pour un argument donné, chaque méthode va être essayée dans l’ordre. La première méthode qui ne génère pas d’erreur sera utilisée.</p>

<p>Un exemple un peu plus utile, la gestion d’une réponse HTTP en fonction de son code:</p>

<p>```ruby
Contract 200, JsonString =&gt; JsonString
def handle_response(status, response)
  transform_response(response)
end</p>

<p>Contract Num, JsonString =&gt; JsonString
def handle_response(status, response)
  response
end
```</p>

<p>Si le code de la réponse HTTP est 200 on va transformer la réponse, sinon on se contentera de retourner la réponse.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Les bénéfices sont nombreux. Les contrats nous permettent d’avoir une plus grande cohérence dans les entrées et les sorties. Le flux des données dans notre système est plus clair. Et la plupart des erreurs liées aux types dans notre système peuvent être corrigées rapidement et simplement. De plus ils permettent de rapidement comprendre ce que fait une méthode, ce qu’elle attend et ce qu’elle retourne, un peu comme de la documentation mais qui serait tout le temps à jour :p.
Je pense que l’on peut ainsi économiser pas mal de tests unitaires sur le type d’argument reçu par une méthode et se concentrer sur ce qu’elle produit avec ce système de contrats.</p>

<p>Voilà j’espère que cet article vous aura convaincu de l’utilité des contrats et du pattern-matching dans votre Ruby quotidien et vous donnera aussi l’envie d’explorer d’autres langages avec d’autres paradigmes.</p>

<h1 id="qui-a-crit-cet-article-">Qui a écrit cet article ?</h1>

<p><img src="/images/julien.jpeg"></p>

<p><strong>Julien Blanchard</strong><br />
M-x CTO RET Sush.io</p>
]]></content>
  </entry>
  
</feed>
