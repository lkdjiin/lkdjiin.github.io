<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : haskell | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/haskell/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2014-12-29T15:15:39+01:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Le jeu de la vie en Haskell - partie 2]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/12/29/le-jeu-de-la-vie-en-haskell-partie-2/"/>
    <updated>2014-12-29T15:07:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/12/29/le-jeu-de-la-vie-en-haskell-partie-2</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Je vais commencer par une amélioration du code du
<a href="http://lkdjiin.github.io/blog/2014/12/28/le-jeu-de-la-vie-en-haskell-partie-1/">dernier article</a>
(merci <a href="https://twitter.com/julienXX">@julienXX</a> pour les indices).</p>

<p>La fonction <code>createGeneration</code> était comme ceci:</p>

<p>``` haskell
createGeneration :: [Int] &ndash;> Int &ndash;> [[Int]] &ndash;> [[Int]]
createGeneration [] width generation = generation
createGeneration cells width generation =</p>

<pre><code>let line = take width cells
 in createGeneration (drop width cells) width (line:generation)
</code></pre>

<p>```</p>

<p>Je l'ai transformé comme cela:</p>

<p>``` haskell
type Cell = Int</p>

<p>createGeneration :: Int &ndash;> [Cell] &ndash;> [[Cell]]
createGeneration _ [] = []
createGeneration width cells = line:(createGeneration width rest)
  where (line, rest) = splitAt width cells
```</p>

<!-- more -->


<p>Elle utilise maintenant <code>splitAt</code>, une fonction de base, qui simplifie la
transformation d'une liste en une liste de listes. J'ai aussi créé un type
<code>Cell</code>, qui me semble utile à des fins de documentation.</p>

<h2>Affichage d'une génération</h2>

<p>Le sujet principal de cet article, c'est l'affichage d'une génération dans le
terminal. Voici ma solution:</p>

<p>``` haskell
import Data.List</p>

<p>formatGeneration :: [[Cell]] &ndash;> String
formatGeneration generation =
  let rows = intercalate &ldquo;\n&rdquo; (map (concatMap show) generation)
   in map replaceChar rows</p>

<p>replaceChar :: Char &ndash;> Char
replaceChar &lsquo;1&rsquo; = &lsquo;@&rsquo;
replaceChar &lsquo;0&rsquo; = &lsquo; &rsquo;
replaceChar c   = c
```</p>

<p>En avant pour les explications pas à pas. <code>concat</code> concatène une liste de
<em>string</em> et <code>show</code> transforme un élément en <em>string</em>.</p>

<pre><code>&gt; concat ["1", "0"]
"10"
&gt; show 1
"1"
</code></pre>

<p>Je <em>mappe</em> la fonction <code>show</code> sur chaque élément d'une liste de nombres.</p>

<pre><code>&gt; map show [1,0]
["1","0"]
</code></pre>

<p>Puis je peux les concaténer.</p>

<pre><code>&gt; concat (map show [1,0])
"10"
</code></pre>

<p><code>concatMap</code> est un raccourci pour <code>concat (map ...)</code>.</p>

<pre><code>&gt; concatMap show [1,0]
"10"
</code></pre>

<p>On <em>mappe</em> le code précédent sur une génération complête.</p>

<pre><code>&gt; map (concatMap show) [[1,0], [0,0], [1,1]]
["10","00","11"]
</code></pre>

<p>Puis, grâce à <code>intercalate</code>, on joint les éléments avec un saut de ligne.</p>

<pre><code>&gt; import Data.List
&gt; intercalate "\n" (map (concatMap show) [[1,0], [0,0], [1,1]]) 
"10\n00\n11"
</code></pre>

<p>Pour ce qui est de <code>replaceChar</code>, l'exemple suivant parle de lui-même.</p>

<pre><code>&gt; :load gol.hs 
&gt; map replaceChar "10\n00\n11"
"@ \n  \n@@"
</code></pre>

<p>Voici le code actuel, n'hésitez pas à me faire part des améliorations possibles.</p>

<p>``` haskell gol.hs
import System.Random
import Data.List</p>

<p>type Cell = Int</p>

<p>randomCells :: Int &ndash;> StdGen &ndash;> [Cell]
randomCells size gen = take size $ randomRs (0, 1) gen</p>

<p>createGeneration :: Int &ndash;> [Cell] &ndash;> [[Cell]]
createGeneration _ [] = []
createGeneration width cells = line:(createGeneration width rest)
  where (line, rest) = splitAt width cells</p>

<p>formatGeneration :: [[Cell]] &ndash;> String
formatGeneration generation =
  let rows = intercalate &ldquo;\n&rdquo; (map (concatMap show) generation)
   in map replaceChar rows</p>

<p>replaceChar :: Char &ndash;> Char
replaceChar &lsquo;1&rsquo; = &lsquo;@&rsquo;
replaceChar &lsquo;0&rsquo; = &lsquo; &rsquo;
replaceChar c   = c</p>

<p>main :: IO()
main =</p>

<pre><code>let width = 80
    height = 24
    cells = randomCells (width * height) (mkStdGen 123)
    generation = createGeneration width cells
 in putStrLn $ formatGeneration generation
</code></pre>

<p>```</p>

<pre><code>$ runhaskell gol.hs
@@@    @  @ @@@ @@@@@@ @ @  @ @   @ @ @  @@@@   @   @@  @  @@@@ @ @ @@@ @@  @  @
  @  @ @@ @@@ @@@@  @@ @@@@ @ @@@    @@ @ @ @@  @          @ @@@ @ @@@ @@@ @  @ 
  @ @@@ @@ @ @@ @@      @   @@@  @@    @  @ @@ @@ @@@   @@@@@@     @@  @@@@ @@ @
[...]
</code></pre>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Le jeu de la vie en Haskell - partie 1]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/12/28/le-jeu-de-la-vie-en-haskell-partie-1/"/>
    <updated>2014-12-28T18:05:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/12/28/le-jeu-de-la-vie-en-haskell-partie-1</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<h2>Première rencontre avec Haskell</h2>

<p>L'histoire qui suit a du arriver à de nombreux développeurs rencontrant Haskell
pour la première fois.</p>

<p>— Bon, comment produire un nombre aléatoire ?<br/>
— Ah OK, je vois.<br/>
— Euh, attends, tu veux dire que je dois passer un générateur avec une <em>seed</em> à
chaque fois ?<br/>
— Ah OK, c'est l'histoire des fonctions <em>pures</em>, quand tu as le même argument en
entrée, tu produis <strong>toujours</strong> la même valeur en sortie. Du coup, tu ne peux
pas avoir une fonction <code>random</code> qui te sortirait une valeur différente à chaque
appel. Oui, d'accord, c'est logique.<br/>
— Ah mais non, attends, je fais comment pour lui donner une <em>seed</em> différente à
chaque lancement du programme ? Ah, bin oui, j'ai qu'a prendre l'heure système,
ou un truc comme ça.<br/>
— Comment ça le générateur n'accepte pas mon heure système comme <em>seed</em> !?
— Comment ça c'est pas le bon type ?! Qu'est-ce que c'est que cette histoire de
monade IO ? Qu'est-ce que c'est que ce langage où je ne peux pas convertir
l'heure système en un entier qui me servirait à quelque chose ???!!!</p>

<p>Bref, bonjour Haskell…</p>

<!-- more -->


<h2>Création d'une génération</h2>

<p>Toute cette histoire n'est peut-être pas si importante. Une fois
accepté que Haskell a certainement une bonne raison de ne pas nous laisser faire
une chose particulière, on peut avancer. Finalement, si je produis toujours les
mêmes nombres, ça devrait être plus simple pour tester.</p>

<p>Le code suivant produit une liste de <code>0</code> et de <code>1</code>. En entrée, la fonction
prend la taille de la liste et un générateur de nombre aléatoire.</p>

<p>``` haskell gol.hs
import System.Random</p>

<p>randomCells :: Int &ndash;> StdGen &ndash;> [Int]
randomCells size gen = take size $ randomRs (0, 1) gen
```</p>

<p>Pour essayer ce code, j'utilise <code>ghci</code>, le REPL Haskell. C'est une vieille
version qui était déjà installée sur ma machine.</p>

<pre><code>$ ghci
GHCi, version 6.12.1: http://www.haskell.org/ghc/  :? for help
</code></pre>

<p>Dans <code>ghci</code>, on charge notre fichier avec <code>:l gol.hs</code>. (<code>:l</code> est l'abbréviation
de <code>:load</code>).</p>

<pre><code>Prelude&gt; :l gol.hs 
[1 of 1] Compiling Main             ( gol.hs, interpreted )
Ok, modules loaded: Main.
</code></pre>

<p>On va produire une liste de 12 nombres. Pour obtenir un générateur de nombre
aléatoire, on utilise <code>mkStdGen</code>, que j'initialise ici avec le nombre <code>4567</code>.</p>

<pre><code>*Main&gt; randomCells 12 (mkStdGen 4567)
[1,0,1,0,1,1,1,1,1,0,1,0]
</code></pre>

<p>Alors, on pourrait s'arrêter là pour la création des cellules. On pourrait très
bien se débrouiller avec une liste simple. Mais je préfère quand même avoir une
liste de listes (une liste de rangées).</p>

<p>Voilà donc une jolie fonction récursive <code>createGeneration</code> qui prend en entrée
la liste de cellules aléatoires, la largeur d'une rangée, et la génération en
cours de production (l'accumulateur).</p>

<p>``` haskell
createGeneration :: [Int] &ndash;> Int &ndash;> [[Int]] &ndash;> [[Int]]
createGeneration [] width generation = generation
createGeneration cells width generation =</p>

<pre><code>let line = take width cells
 in createGeneration (drop width cells) width (line:generation)
</code></pre>

<p>```</p>

<pre><code>*Main&gt; let cells = randomCells 12 (mkStdGen 4567)
*Main&gt; createGeneration cells 4 []
[[1,0,1,0],[1,1,1,1],[1,0,1,0]]
</code></pre>

<p>Pour finir, voici le listing complet du fichier <code>gol.hs</code>.</p>

<p>``` haskell gol.hs
import System.Random</p>

<p>randomCells :: Int &ndash;> StdGen &ndash;> [Int]
randomCells size gen = take size $ randomRs (0, 1) gen</p>

<p>createGeneration :: [Int] &ndash;> Int &ndash;> [[Int]] &ndash;> [[Int]]
createGeneration [] width generation = generation
createGeneration cells width generation =</p>

<pre><code>let line = take width cells
 in createGeneration (drop width cells) width (line:generation)
</code></pre>

<p>main =</p>

<pre><code>let cells = randomCells 12 (mkStdGen 123)
 in print (createGeneration cells 4 [])
</code></pre>

<p>```</p>

<pre><code>$ runhaskell gol.hs 
[[0,0,1,0],[0,0,0,1],[1,1,1,0]]
</code></pre>

<p>Comme il s'agit de mon tout premier code en Haskell, n'hésitez surtout pas à me
remonter mes erreurs, ou bien des trucs pour améliorer le code.</p>

<p><strong>P.S.</strong></p>

<p>Vous avez peut-être remarqué que je n'ai pas écrit de tests ?
J'avais remarqué <a href="http://hspec.github.io/">Hspec</a>, que j'aurais aimé utilisé.
Mais <code>cabal</code> refuse de l'installer. Je pense que ma version d'Haskell est trop
datée et qu'il me faudrait refaire une installation sans passer par les paquets
de mon OS. Je sais qu'il y a <a href="https://www.haskell.org/haskellwiki/HUnit_1.0_User%27s_Guide">HUnit</a>
de base, mais ça m'a l'air bien compliqué à mettre en place pour mon niveau de
débutant. Si je continue Haskell après avoir écrit le jeu de la vie, il est sûr
que je m'y mettrais.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Le jeu de la vie dans sept langages différents]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/10/08/le-jeu-de-la-vie-dans-sept-langages-differents/"/>
    <updated>2014-10-08T12:30:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/10/08/le-jeu-de-la-vie-dans-sept-langages-differents</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Je vais écrire le <a href="http://en.wikipedia.org/wiki/Conway%27s_Game_of_Life">jeu de la vie</a> dans 7 langages, et
en utilisant le TDD (sauf pour l'affichage).
Ça va me permettre de réviser certains langages et d'en apprendre de nouveaux
d'une manière amusante. Après tout, quoi de plus <em>fun</em> qu'un jeu pour zéro
joueur.</p>

<h2>L'algorithme</h2>

<p>L'idée directrice, c'est de faire au plus simple.
L'algorithme général sera le suivant :</p>

<ol>
<li>obtenir une première génération au hasard</li>
<li>afficher la génération</li>
<li>calculer la nouvelle génération et retour au point 2.</li>
</ol>


<p>Discutons un peu chacun des trois points.</p>

<!-- more -->


<h3>Obtenir une première génération au hasard</h3>

<p>Cette génération sera stockée dans un tableau (une liste). Suivant le
langage, j'utiliserais un tableau à 1 ou 2 dimensions.</p>

<h3>Afficher la génération</h3>

<p>Il s'agit d'afficher à l'écran le tableau calculé précédement. Chaque élément
du tableau représente une cellule du jeu de la vie, et une cellule sera
représentée à l'écran par un pixel. Alors un pixel pour une cellule, ça risque
d'être assez moche sur la plupart des dispositifs, mais c'est le plus simple.
J'améliorerais peut-être cet affichage plus tard.</p>

<h3>Calculer la nouvelle génération</h3>

<p>Là encore, j'essaye d'aller au plus simple. On va calculer la
nouvelle génération dans un second tableau. Une fois ce calcul effectué, ce
second tableau remplacera le premier.</p>

<p>Pour calculer le nouvel état d'une cellule, on devra observer la cellule et
ces 8 voisins. Autrement dit on observe une fenêtre de 9 cellules et on veut
connaitre le nouvel état de la cellule centrale. Il y a 3 cas possibles:</p>

<ol>
<li>Si la somme des cellules vivantes est 3, alors la nouvelle cellule sera
vivante.</li>
<li>Si la somme des cellules vivantes est 4, alors la nouvelle cellule conserve
son ancien état.</li>
<li>Dans tous les autres cas, la nouvelle cellule est morte.</li>
</ol>


<p>Il faut encore parler du cas des cellules qui se trouvent sur les bords du
<em>plateau de jeu</em>. Normalement, le jeu de la vie est infini. Mais l'infini, c'est
pas simple. Dans une première itération, le <em>plateau de jeu</em> aura des
dimensions finies et les cellules qui se trouvent sur les bords se verront
ajoutées arbitrairement des voisins morts.</p>

<p>Une seconde itération pourrait implémenter une espèce de <a href="http://en.wikipedia.org/wiki/Torus">tore</a> pour avoir une surface
de jeu sans bordures.</p>

<h2>Les langages ciblés</h2>

<p>Je vais écrire le jeu de la vie dans 7 langages différents:</p>

<ul>
<li>ruby</li>
<li>javascript</li>
<li>racket</li>
<li>logo</li>
<li>julia</li>
<li>haskell</li>
<li>rust</li>
</ul>


<h3>Pourquoi ces langages ?</h3>

<p><strong>Ruby</strong></p>

<p>Ça peut paraitre bizarre. Après tout j'écris en Ruby toute la journée, c'est
mon métier. Pourquoi vouloir en faire encore pendant mon temps libre ?
En fait, ce qui m'intéresse vraiment ici, c'est <a href="http://opalrb.org/">Opal.rb</a>. Peut-être aussi
que j'en ferais une seconde version avec <a href="http://www.libgosu.org/">Gosu</a>.</p>

<p><strong>Javascript</strong></p>

<p>Après des années passées à tenter d'éviter d'écrire la moindre ligne de
Javascript, je m'intéresse de nouveau à ce langage. Après tout, c'est un
incontournable du Web et il commence à me plaire. Et puis j'ai trop tardé à
faire du TDD avec Javascript, je crois que <a href="http://jasmine.github.io/">Jasmine</a> est devenu très bon.</p>

<p><strong>Racket</strong></p>

<p>Je crois que tout développeur devrait étudier un <em>Lisp like</em>. Lisp t'oblige à
penser autrement et du coup tu trouves des solutions différentes à des
problèmes de programmation de tout les jours.</p>

<p><strong>Logo</strong></p>

<p>Le <a href="http://fr.wikipedia.org/wiki/Logo_%28langage%29">Logo</a>, c'est ma <a href="http://fr.wikipedia.org/wiki/Madeleine_%28cuisine%29#La_madeleine_de_Proust">madeleine de Proust</a> ! Voilà. Encore un <em>Lisp like</em>,
mais différent (on l'appelait Lisp sans parenthèses). J'espère que je trouverais
encore des ressources pour celui-ci.</p>

<p><strong>Julia</strong></p>

<p>Je pense que les langages fonctionnels ont un grand avenir. Ils résolvent au
moins deux soucis. En ce concentrant sur la transformation des données plutôt
que sur l'état de ces données, ils facilitent les tests et l'utilisation des
multi-coeurs.</p>

<p><strong>Haskell</strong></p>

<p>Encore un langage fonctionnel, et celui-ci me fait un peu peur. Mais je me dis
que je devrais y goûter.</p>

<p><strong>Rust</strong></p>

<p>Je voulais un langage système dans cette liste, ce sera <a href="http://www.rust-lang.org/">Rust</a>.</p>

<h2>Fréquence de publication</h2>

<p>Je ne m'avancerais pas sur une fréquence de publication. J'imagine qu'il y
aura 3 ou 4 articles par langage. Et suivant le temps dont je disposerais, ça
pourrat-être aussi bien un article par mois ou trois articles par semaine.</p>

<p>Allez, la prochaine fois on commence avec Ruby/Opal.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p></p>
]]></content>
  </entry>
  
</feed>
