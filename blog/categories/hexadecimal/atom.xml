<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : hexadécimal | Xavier Nayrac]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/hexadecimal/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2015-07-15T13:44:39+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Comment convertir un nombre décimal en binaire en Bash ?]]></title>
    <link href="http://lkdjiin.github.io/blog/2015/05/02/comment-convertir-un-nombre-decimal-en-binaire-en-bash/"/>
    <updated>2015-05-02T12:20:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2015/05/02/comment-convertir-un-nombre-decimal-en-binaire-en-bash</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Pour convertir un nombre décimal en binaire, en Bash, suivez ce tweet :
<a href="https://twitter.com/climagic/status/593842202314420224">https://twitter.com/climagic/status/593842202314420224</a>.</p>

<p>Et voici la conversion du décimal 27 en son équivalent binaire :</p>

<p><code>bash
$ Dec2Bin=({0..1}{0..1}{0..1}{0..1}{0..1}{0..1}{0..1}{0..1});echo ${Dec2Bin[27]} 
00011011
</code></p>

<p>Alors, comment ça marche ?</p>

<p><img class="center" src="/images/binary.jpg"></p>

<!-- more -->

<p>Pour commencer, voici comment faire un tableau en bash, qui va contenir les 3
chaînes <code>foo</code>, <code>bar</code>, et <code>baz</code>. Ne soyez pas surpris par le manque de guillemets
autour des chaînes, Bash est fait pour traiter du texte.</p>

<p><code>bash
$ myarray=(foo bar baz)
</code></p>

<p>Et voici comment afficher le contenu de ce tableau.</p>

<p><code>bash
$ echo ${myarray[@]}
foo bar baz
</code></p>

<p>On peut bien sûr accéder aux éléments du tableau séparément :</p>

<p><code>bash
$ echo ${myarray[0]}
foo
$ echo ${myarray[1]}
bar
$ echo ${myarray[2]}
baz
</code></p>

<p>Pour connaître la taille d’un tableau, voici la syntaxe :</p>

<p><code>bash
$ echo ${#myarray[@]}
3
</code></p>

<p>Appliquons ce nouveau savoir au tableau <code>Dec2Bin</code>, qui contient…</p>

<p>…</p>

<p>…des trucs :</p>

<p><code>bash
$ Dec2Bin=({0..1}{0..1}{0..1}{0..1}{0..1}{0..1}{0..1}{0..1})
</code></p>

<p>Combien a-t-il d’éléments ?</p>

<p><code>bash
$ echo ${#Dec2Bin[@]}
256
</code></p>

<p>256 ? Et ça ressemble à quoi ?</p>

<p><code>bash
$ echo ${Dec2Bin[@]}
00000000 00000001 00000010 00000011 00000100 00000101 00000110 00000111 00001000 
00001001 00001010 00001011 00001100 00001101 00001110 00001111 00010000 00010001
...
11101010 11101011 11101100 11101101 11101110 11101111 11110000 11110001 11110010 
11110011 11110100 11110101 11110110 11110111 11111000 11111001 11111010 11111011 
11111100 11111101 11111110 11111111
</code></p>

<p>Tranquille, <code>Dec2Bin</code> est un tableau qui contient 256 chaînes représentant les
nombres binaires de 0 à 255.</p>

<p>Les crochets <code>{}</code> créent un <em>range</em> :</p>

<p><code>bash
$ echo {0..1}
0 1
$ echo {a..f}
a b c d e f
</code></p>

<p>Plusieurs crochets <code>{}</code> les uns à la suite des autres produisent toutes les
permutations possibles :</p>

<p><code>bash
$ echo {0..1}{0..1}
00 01 10 11
</code></p>

<p>Et on peut mettre tout ça dans un tableau :</p>

<p><code>bash
$ a=({0..1})
$ echo ${a[@]}
0 1
$ a=({0..1}{0..1})
$ echo ${a[@]}
00 01 10 11
$ a=({0..1}{0..1}{0..1})
$ echo ${a[@]}
000 001 010 011 100 101 110 111
</code></p>

<p>Et voilà, il faut encore savoir qu’ici, le point-virgule sert à joindre 2 lignes de
code en une seule :</p>

<p><code>bash
$ Dec2Bin=({0..1}{0..1}{0..1}{0..1}{0..1}{0..1}{0..1}{0..1})
$ echo ${Dec2Bin[27]}
00011011
</code></p>

<h2 id="bonus-1---le-mme-en-hexadcimal">Bonus 1 - Le même en hexadécimal</h2>

<p>Et si on voulait convertir un nombre décimal en hexadécimal plutôt qu’en
binaire ? Il faudrait générer toutes les permutations entre deux suites
<code>0 1 2 3 4 5 6 7 8 9 A B C D E F</code> :</p>

<p>
<code>bash
$ echo {{0..9},{A..F}}{{0..9},{A..F}}
00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F 10 11 12 13 14 15 16 17 18 19 1A 
1B 1C 1D 1E 1F 20 21 22 23 24 25 26 27 28 29 2A 2B 2C 2D 2E 2F 30 31 32 33 34 35 
36 37 38 39 3A 3B 3C 3D 3E 3F 40 41 42 43 44 45 46 47 48 49 4A 4B 4C 4D 4E 4F 50 
51 52 53 54 55 56 57 58 59 5A 5B 5C 5D 5E 5F 60 61 62 63 64 65 66 67 68 69 6A 6B 
6C 6D 6E 6F 70 71 72 73 74 75 76 77 78 79 7A 7B 7C 7D 7E 7F 80 81 82 83 84 85 86 
87 88 89 8A 8B 8C 8D 8E 8F 90 91 92 93 94 95 96 97 98 99 9A 9B 9C 9D 9E 9F A0 A1 
A2 A3 A4 A5 A6 A7 A8 A9 AA AB AC AD AE AF B0 B1 B2 B3 B4 B5 B6 B7 B8 B9 BA BB BC 
BD BE BF C0 C1 C2 C3 C4 C5 C6 C7 C8 C9 CA CB CC CD CE CF D0 D1 D2 D3 D4 D5 D6 D7 
D8 D9 DA DB DC DD DE DF E0 E1 E2 E3 E4 E5 E6 E7 E8 E9 EA EB EC ED EE EF F0 F1 F2 
F3 F4 F5 F6 F7 F8 F9 FA FB FC FD FE FF
</code>
</p>

<p>
<code>bash
$ Dec2Hex=({{0..9},{A..F}}{{0..9},{A..F}});echo ${Dec2Hex[27]}
1B
</code>
</p>

<h2 id="bonus-2---le-mme-en-ruby">Bonus 2 - Le même en Ruby</h2>

<p>On peut faire la même chose en Ruby en utilisant <code>repeated_permutation</code> :</p>

<p><code>irb
&gt;&gt; [0,1].repeated_permutation(8).to_a.each{|e| puts e.join}
00000000
00000001
00000010
00000011
00000100
00000101
...
11111010
11111011
11111100
11111101
11111110
11111111
</code></p>

<p>Il peut-être intéressant de comparer les deux versions :</p>

<p><code>bash
$ ruby -e "puts [0,1].repeated_permutation(8).to_a[27].join"
00011011
</code></p>

<p><code>bash
$ Dec2Bin=({0..1}{0..1}{0..1}{0..1}{0..1}{0..1}{0..1}{0..1});echo ${Dec2Bin[27]} 
00011011
</code></p>

<h2 id="bonus-3---encore-plus-court">Bonus 3 - Encore plus court</h2>

<p>Pour finir, on peut faire plus court avec Bash en utilisant <code>{0,1}</code> au lieu de
<code>{0..1}</code> puisqu’il y a seulement deux éléments :</p>

<p><code>bash
$ Dec2Bin=({0,1}{0,1}{0,1}{0,1}{0,1}{0,1}{0,1}{0,1});echo ${Dec2Bin[27]} 
00011011
</code></p>

<p></p>
]]></content>
  </entry>
  
</feed>
