<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : vim | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/vim/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2014-01-04T20:23:33+01:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Remplacer Sed et Awk par Ruby 10: Un exemple d'utilisation]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/12/12/remplacer-sed-et-awk-par-ruby-10-un-exemple-dutilisation/"/>
    <updated>2013-12-12T21:05:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/12/12/remplacer-sed-et-awk-par-ruby-10-un-exemple-dutilisation</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Dans un <a href="http://lkdjiin.github.io/blog/2013/12/11/les-algorithmes-genetiques-demystifies-42-un-probleme-deconomie/">article précédent</a>
sur les algorithmes génétiques, je devais générer des valeurs aléatoires
<em>en dur</em> dans un fichier source Ruby. Le code ressemble à ce qui suit:</p>

<p>``` ruby
KnapsackItem.new(&lsquo;ACCOR&rsquo;, 32, 9, 60),
KnapsackItem.new(&lsquo;AIR_LIQUIDE&rsquo;, 97, 7, 32),
KnapsackItem.new(&lsquo;ALSTOM&rsquo;, 25, 5, 6),
KnapsackItem.new(&lsquo;ARCELORMITTAL_REG&rsquo;, 12, 9, 43),
KnapsackItem.new(&lsquo;AXA&rsquo;, 18, 2, 65),
KnapsackItem.new(&lsquo;BNP_PARIBAS&rsquo;, 53, 3, 24),</p>

<h1>&hellip;</h1>

<p>```</p>

<p>Le dernier nombre de chaque ligne doit être compris entre 1 et 100.
Voici comment faire en utilisant ce qu'on a appris depuis le début
de cette série <a href="http://lkdjiin.github.io/blog/2013/11/29/remplacer-sed-et-awk-par-ruby/">Remplacer Sed et Awk par Ruby</a>.</p>

<!-- more -->


<p>J'ai tout d'abord écrit mes lignes en mettant la chaîne <code>ABC</code> là où je voulais
un nombre aléatoire:</p>

<p>``` ruby
KnapsackItem.new(&lsquo;ACCOR&rsquo;, 32, 9, ABC),
KnapsackItem.new(&lsquo;AIR_LIQUIDE&rsquo;, 97, 7, ABC),
KnapsackItem.new(&lsquo;ALSTOM&rsquo;, 25, 5, ABC),
KnapsackItem.new(&lsquo;ARCELORMITTAL_REG&rsquo;, 12, 9, ABC),
KnapsackItem.new(&lsquo;AXA&rsquo;, 18, 2, ABC),
KnapsackItem.new(&lsquo;BNP_PARIBAS&rsquo;, 53, 3, ABC),</p>

<h1>&hellip;</h1>

<p>```</p>

<p>Cela va permettre au script de <em>trouver</em> l'endroit où substituer un nombre.</p>

<p>Puis, on lance le script suivant depuis une console:</p>

<p><code>bash
ruby -ple 'r=rand(100)+1;$_.sub!(/ABC/,r.to_s)' fichier_source
</code></p>

<p>Explications: <code>rand(100)+1</code> génère un nombre aléatoire entre 1 inclus et
100 inclus. <code>$_.sub!(/ABC/,r.to_s)</code> opère une substitution de la ligne en
cours de traitement: ABC est remplacé par le contenu de <code>r</code>, soit le nombre
aléatoire.</p>

<p>En réalité, je n'ai pas lancé ce script depuis une console, mais directement
dans Vim:</p>

<p><code>vim
:%! ruby -ple 'r=rand(100)+1;$_.sub\!(/ABC/,r.to_s)'
</code></p>

<p>Dans ce cas, il faut faire attention à échapper le <code>!</code>, sans quoi Vim
n'aimeras pas…</p>

<p>Voilà un exemple simple d'utilisation du mode <em>sed/awk</em> de Ruby.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Un plugin Vim pour replier/folder les commentaires]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/12/02/un-plugin-vim-pour-replier-slash-folder-les-commentaires/"/>
    <updated>2013-12-02T18:27:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/12/02/un-plugin-vim-pour-replier-slash-folder-les-commentaires</id>
    <content type="html"><![CDATA[<p>Dans un <a href="http://lkdjiin.github.io/blog/2013/11/28/vim-plier-folder-les-commentaires-de-style-unix/">article précédent</a>, je montrai comment écrire une fonction pour
folder les commentaires de style Unix dans un fichier. Cette solution avait
plusieurs limites alors j'ai eu envie d'en faire un plugin plus
intéressant. Je vous présente donc vim-foldcomments, mon premier plugin
pour Vim.</p>

<!-- more -->


<p>Pouvoir folder/replier tous les commentaires d'un fichier peut être
utile quand vous étudiez un tout nouveau code, ou au contraire, quand vous
travaillez sur un code bien connu.
Vous pouvez trouver le plugin sur Github: <a href="https://github.com/lkdjiin/vim-foldcomments">vim-foldcomments</a>.
Une fois installé, avec <a href="https://github.com/tpope/vim-pathogen">Pathogen</a> par exemple,
vous pouvez taper la commande:</p>

<pre><code>:FoldComments
</code></pre>

<p>pour replier les commentaires du fichier. Personnelement j'ai mappé cette
commande sur la touche F5 en mettant ceci dans mon .vimrc:</p>

<p><code>vim
map&lt;F5&gt; FoldComments&lt;Enter&gt;
</code></p>

<p>Le plugin est en version béta et ne gère pour l'instant que quelques
langages: Ruby, Haskell, Java, C, Javascript, Logo, Racket, Scheme, Vim,
ainsi que tous commentaires de style Unix (<code>#</code>). Les commentaires
multilignes (<code>/* … */</code> en C ou encore <code>=begin … =end</code> en Ruby) sont aussi
pris en compte.</p>

<p>N'hésitez pas à le tester et à me donner votre opinion. Vous pouvez aussi
bien sûr participer au code sur Github.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vim: Plier (folder) les commentaires de style Unix]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/11/28/vim-plier-folder-les-commentaires-de-style-unix/"/>
    <updated>2013-11-28T16:39:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/11/28/vim-plier-folder-les-commentaires-de-style-unix</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Certains fichiers sources contiennent une proportion non négligeable de
commentaires, ou documentation interne. Par exemple, le fichier
<a href="https://github.com/ruby/ruby/blob/trunk/lib/csv.rb">ruby/lib/csv.rb</a> de
Ruby contient à ce jour 46% de lignes qui sont des commentaires. Quand on
cherche à étudier ces sources  pour la première fois, le nombre
important de commentaire est un frein pour naviguer ou se repérer dans
un tel fichier. Aujourd'hui je montre comment replier facilement les
ensembles de lignes commençant par <code>#</code>.</p>

<!-- more -->


<h2>Présentation</h2>

<p>Les fonctions de Vim qu'on va utiliser sont les suivantes:</p>

<pre><code>Fonction      Raccourci
=======================
foldmethod    fdm
foldexpr      fde
</code></pre>

<p>Vim comporte plusieurs méthodes de pliage (<em>folding</em>) de code, qu'on
spécifie avec <code>foldmethod</code>. Ici on va utiliser la méthode <code>expr</code>, qui
permet de faire à peu près tout ce qu'on veut. L'expression sera
spécifiée avec <code>foldexpr</code>.</p>

<h2>Essai en direct</h2>

<p>On va d'abord voir comment ça marche en entrant les commandes en direct live.
Ouvrez le fichier
<a href="https://github.com/ruby/ruby/blob/trunk/lib/csv.rb">ruby/lib/csv.rb</a>
(ou un autre avec beaucoup de commentaires de style Unix) et entrez ce qui
suit:</p>

<p><code>vim
:set fdm=expr
:set fde=getline(v:lnum)=~'^\\s*#'
</code></p>

<p>Badaboum ! Tout les commentaires sont pliés. Explications:</p>

<pre><code>getline(v:lnum)
</code></pre>

<p>Cette fonction retrouve une ligne du fichier. <code>v:lnum</code> est une variable
prédéfinie qui contient le numéro de la ligne courante.</p>

<pre><code>=~
</code></pre>

<p>Cet opérateur a le même sens qu'en Ruby, par exemple. Autrement dit,
est-ce que la chaîne à ma gauche correspond à la regex à ma droite ?</p>

<pre><code>'^\\s*#'
</code></pre>

<p>C'est notre regex: début de ligne (<code>^</code>), suivi par un nombre quelconque
de blancs (<code>\\s*</code>), suivi par le caractère <code>#</code>.</p>

<p>L'expression spécifiée dans <code>foldexpr</code> (ou comme ici <code>fde</code>) sera appelée
par Vim sur chaque ligne du fichier.</p>

<h2>Embarqué dans le fichier</h2>

<p>Maintenant qu'on sait comment ça marche, voyons comment faire pour ne pas
avoir à taper ces 2 lignes à chaque fois.</p>

<p>Si vous écrivez la ligne suivante dans un fichier, typiquement à la fin, les
commandes seront executées automatiquement à l'ouverture du fichier.
C'est un truc utile à connaitre.</p>

<p>``` vim</p>

<h1>vim:fdm=expr:fde=getline(v\:lnum)=~&lsquo;^\s*#&rsquo;:</h1>

<p>```</p>

<p>Notez qu'il a fallu échapper le <code>:</code> de <code>v:lnum</code> pour que ça fonctionne.</p>

<h2>Une fonction</h2>

<p>Une fonction dans le <code>.vimrc</code> sera plus intéressante:</p>

<p><code>vim
function FoldUnixComments()
  set foldmethod=expr
  set foldexpr=getline(v:lnum)=~'^\\s*#'
endfunction
</code></p>

<p>Pour l'executer:</p>

<p><code>vim
:call FoldUnixComments()
</code></p>

<h2>Conclusion</h2>

<p>La méthode présentée ici n'est pas parfaite. En effet <code>foldmethod=expr</code>
<em>écrase</em> votre ancienne méthode. Néanmoins, elle me semble suffisante
quand il s'agit juste d'étudier un fichier.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Utiliser Vim comme un tableur sur Linux (enfin presque)]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/11/24/utiliser-vim-comme-un-tableur-sur-linux-enfin-presque/"/>
    <updated>2013-11-24T20:55:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/11/24/utiliser-vim-comme-un-tableur-sur-linux-enfin-presque</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-3'>Niveau : <span>avancé</span></div></p>

<p><a href="http://lkdjiin.github.io/blog/2013/11/23/pourcentage-des-issues-par-langages-sur-github/">Hier</a> j'ai donné une liste des rapports issues/nombre de dépots
par langages sur Github. Aujourd'hui je montre comment j'ai utilisé
Vim (sur linux) pour calculer ce rapport et formater la liste.</p>

<!-- more -->


<p>Voici la liste de départ, à récupérer <a href="http://hubreports.yougeezer.co.uk/languages">ici</a>, il s'agit juste d'un
copier/coller de la page web et je n'ai pris ici que les 5 premiers,
c'est suffisant pour la démonstration:</p>

<pre><code>1   JavaScript .js  560,116 891,531 319,537 4,951   1,147   343,483
2   Ruby .rb    466,411 469,913 175,577 2,726   607 147,339
3   Java .java  388,610 376,683 231,186 4,185   825 161,136
4   Python .py  281,835 323,858 130,034 2,538   685 184,908
5   PHP .php    275,411 289,899 155,941 2,331   454 150,024
</code></pre>

<p>Alors on n'y comprend rien puisque les colonnes sont invisibles. On va
former de belles colonnes à l'aide de l'utilitaire unix <strong>column</strong>:</p>

<p><code>vim
:%! column -t
</code></p>

<p>Et voici le résultat:</p>

<pre><code>1  JavaScript  .js    560,116  891,531  319,537  4,951  1,147  343,483
2  Ruby        .rb    466,411  469,913  175,577  2,726  607    147,339
3  Java        .java  388,610  376,683  231,186  4,185  825    161,136
4  Python      .py    281,835  323,858  130,034  2,538  685    184,908
5  PHP         .php   275,411  289,899  155,941  2,331  454    150,024
</code></pre>

<p>Les colonnes qui m'intéresse sont la 1 (rang), la 2 (langage), la 4
(nombre de dépots) et la dernière (nombre d'issues actives).
Je vais donc sélectionner la 3ème colonne à l'aide de <code>Ctrl-v</code> et la
supprimer (avec <code>d</code>). Voici ce que donne la sélection d'une colonne en
image si vous n'êtes pas familier de Vim:</p>

<p><img src="/images/vim-column.png"></p>

<p>Je répète ensuite la sélection/suppression pour les autres colonnes et
j'obtiens:</p>

<pre><code>1  JavaScript  560,116  343,483
2  Ruby        466,411  147,339
3  Java        388,610  161,136
4  Python      281,835  184,908
5  PHP         275,411  150,024
</code></pre>

<p>Il faut maintenant ajouter une colonne de chiffre qui contiendras le rapport
d'issues par dépots en pourcentage. C'est à dire la 4ème colonne divisée par
la 3ème colonne, le tout multiplié par 100. C'est classiquement un boulot
qu'on confierai au langage Awk, mais j'ai décidé il y a quelques temps de
faire le plus possible de choses avec Ruby, voici donc ce que j'ai écrit
dans Vim:</p>

<p><code>vim
:%! ruby -aple '$_ += " \#{(($F[3].to_f/$F[2].to_f)*100).to_i}"'
</code></p>

<p>Un peu cryptique ? Je l'avoue bien volontiers, mais les one-shots sont
rarement fait pour (peuvent rarement) être lisible… Je ferais certainement
un article sur les switchs a, p, l et e de <code>ruby</code>. Quoiqu'il en soit, voici
le résultat:</p>

<pre><code>1  JavaScript  560,116  343,483 61
2  Ruby        466,411  147,339 31
3  Java        388,610  161,136 41
4  Python      281,835  184,908 65
5  PHP         275,411  150,024 54
</code></pre>

<p>Il reste à trier cette liste sur la 5ème et dernière colonne, un jeu d'enfant
avec l'utilitaire unix <code>sort</code>:</p>

<p><code>vim
:%! sort -k5nr
</code></p>

<pre><code>4  Python      281,835  184,908 65
1  JavaScript  560,116  343,483 61
5  PHP         275,411  150,024 54
3  Java        388,610  161,136 41
2  Ruby        466,411  147,339 31
</code></pre>

<p>Voilà, ça prend un certain temps à décrire mais c'est rapide à faire quand
vous avez sous le coude une paire d'utilitaires qui déchirent !</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Écrire une fonction Vim avec Ruby]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/11/04/ecrire-une-fonction-vim-avec-ruby/"/>
    <updated>2013-11-04T17:01:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/11/04/ecrire-une-fonction-vim-avec-ruby</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Parfois, pas besoin de faire appel à un plugin, une simple petite fonction
suffit pour ce qu'on veut faire. Mais il faut avouer que le Vim Script est
un langage qui est loin de faire l'unanimité. Si on pouvait faire appel
à Ruby (ou Python, etc) pour écrire en partie nos fonctions Vim, ce serait
cool, non ?</p>

<!-- more -->


<h2>Un cas d'utilisation simple</h2>

<p>Prenons un cas habituel: supprimer les espaces en fin de ligne dans tout un
fichier. Pour cela il nous suffit d'écrire directement dans Vim:</p>

<p><code>vim
:%s/\s\+$//
</code></p>

<p>Mouais… Ça fonctionne, c'est sûr. Mais j'ai deux petits problèmes:</p>

<ol>
<li>Je ne veux pas taper ça à chaque fois, parce qu'il faut que je me
concentre un minimum pour bien écrire une regex, même si là y a pas
de quoi fouetter un chat. En même temps, ça ne vaut pas le coup
d'écrire un plugin juste pour ça.</li>
<li>Y'a rien à faire, je ne me rappelle jamais comment fonctionnent les
regex Vim, quels sont les méta-caractères et tout et tout. 9 fois
sur 10 j'oublierais par exemple d'échapper le <code>+</code>.</li>
</ol>


<h2>Une fonction Vim</h2>

<p>Si ça ne vaut pas un plugin, ça vaut bien une petite fonction à mettre,
par exemple, dans son <code>.vimrc</code>:</p>

<p><code>vim
function RemoveTrailingSpaces()
  %s/\s\+$//
endfunction
</code></p>

<p>Maintenant, on peut appeler notre fonction ainsi:</p>

<p><code>vim
:call RemoveTrailingSpaces()
</code></p>

<p>Ou bien la mapper sur une touche, si on l'utilise souvent:</p>

<p><code>vim
map &lt;Leader&gt;r :call RemoveTrailingSpaces()&lt;Enter&gt;
</code></p>

<p>Premier problème réglé, au suivant.</p>

<h2>Utiliser Ruby dans une fonction Vim</h2>

<p>Il faut bien sûr que votre Vim ait été compilé avec le support de Ruby.
Pour le savoir vous pouvez taper la ligne suivante dans votre console,
si &ldquo;+ruby&rdquo; s'affiche, c'est bon:</p>

<p><code>bash
[~]⇒ vim --version | grep --color -i \+ruby
+printer +profile +python -python3 +quickfix +reltime +rightleft +ruby
</code></p>

<p>Voilà ce que donnerait notre fonction en utilisant Ruby:</p>

<p><code>vim
function RemoveTrailingSpaces()
  rubydo gsub /\s+$/, ''
endfunction
</code></p>

<p>C'est tout, <code>rubydo</code> suivi de l'instruction en Ruby !  Et vous, vous auriez des
petites astuces de ce genre à partager ?</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
