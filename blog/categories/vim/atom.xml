<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : vim | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/vim/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2014-01-18T09:53:19+01:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Sauvegarde automatique des fichiers dans Vim]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/01/18/sauvegarde-automatique-des-fichiers-dans-vim/"/>
    <updated>2014-01-18T09:45:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/01/18/sauvegarde-automatique-des-fichiers-dans-vim</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Aujourd'hui je parle d'un petit truc qui me facilite
énormément la vie sous Vim: la sauvegarde automatique.</p>

<!-- more -->


<p>Grâce à ce truc, je n'enregistre pratiquement jamais
<em>intentionnellement</em> un fichier. Ce qui fait que je
n'oublie jamais de le faire. Vous savez ? : On modifie
un fichier, on lance l'appli et… arg… ça fonctionne pas !
Tout ça parce qu'on a oublié d'enregistrer les
modifications.</p>

<p>Donc pour enregistrer le fichier courant, la commande est:</p>

<p><code>vim
:w
</code></p>

<p>Pour enregistrer tous les fichiers:</p>

<p><code>vim
:wall
</code></p>

<p>Pour les accros du Ctrl-S, on peut le reproduire avec le mapping
suivant dans le <code>.vimrc</code>:</p>

<p><code>vim
map &lt;C-s&gt; :w&lt;Enter&gt;
</code></p>

<p><strong>Et maintenant le truc promis</strong>. Je veux que mes fichiers soient enregistrés
quand un onglet perds le focus, ou quand Vim lui-même perds le focus:</p>

<p><code>vim
autocmd FocusLost,TabLeave * :wall
</code></p>

<p>Avec cette commande dans votre <code>.vimrc</code>, il est rare de devoir
enregistrer manuellement un fichier ;)</p>

<p>Et si vous voulez comprendre ce que fais exactement cette commande, je
vous laisse regarder l'aide:</p>

<p><code>vim
:h autocmd
:h FocusLost
:h TabLeave
</code></p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vim et les digraphes]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/01/12/vim-et-les-digraphes/"/>
    <updated>2014-01-12T11:27:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/01/12/vim-et-les-digraphes</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Comment saisir facilement et rapidement des caractères tels que ¡, ¿ ou encore
ß dans Vim ?</p>

<!-- more -->


<p>Pour voir à quoi ressemble ces fameux digraphes dans Vim, tapez la commande
<code>:digraphs</code>. Vous allez obtenir la liste des digraphes qui sont définis.
La définition d'un digraphe ressemble à ceci:</p>

<pre><code>?I ¿  191
</code></pre>

<p>Ici, seules les deux premières colonnes nous intéressent. La première colonne
est le code de deux caractères qu'il faut saisir pour obtenir le caractère
de la seconde colonne.</p>

<p>Pour saisir un digraphe, il faut être en mode insertion et entrer
Control + k, puis les deux caractères du code. Donc <code>Control</code>, puis <code>k</code>,
puis <code>?</code>, puis <code>I</code> donnera le caractère <code>¿</code>.</p>

<p>Voici quelques exemples:</p>

<pre><code>!I ¡
?I ¿
ss ß
%0 ‰
13 ⅓
78 ⅞
l* λ
p* π
-&gt; →
=&gt; ⇒
</code></pre>

<p>Si vous utilisez régulièrement certains digraphes, il existe une manière
plus rapide de les saisir. Activez tout d'abord l'option <code>digraph</code> dans
votre <code>.vimrc</code>:</p>

<p><code>vim
set digraph
</code></p>

<p>Maintenant vous pouvez saisir un digraphe en entrant le premier caractère
du code, puis la touche Backspace, puis le second caractère du code.
Donc <code>p</code>, puis <code>Backspace</code>, puis <code>*</code> vous donneront le caractère Pi (<code>π</code>).
Attention quand même avec cette option, si vous faites régulièrement des
fautes de frappes, vous risquez de voir apparaître assez souvent des caractères
étranges et inattendus ;)</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Remplacer Sed et Awk par Ruby 10: Un exemple d'utilisation]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/12/12/remplacer-sed-et-awk-par-ruby-10-un-exemple-dutilisation/"/>
    <updated>2013-12-12T21:05:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/12/12/remplacer-sed-et-awk-par-ruby-10-un-exemple-dutilisation</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Dans un <a href="http://lkdjiin.github.io/blog/2013/12/11/les-algorithmes-genetiques-demystifies-42-un-probleme-deconomie/">article précédent</a>
sur les algorithmes génétiques, je devais générer des valeurs aléatoires
<em>en dur</em> dans un fichier source Ruby. Le code ressemble à ce qui suit:</p>

<p>``` ruby
KnapsackItem.new(&lsquo;ACCOR&rsquo;, 32, 9, 60),
KnapsackItem.new(&lsquo;AIR_LIQUIDE&rsquo;, 97, 7, 32),
KnapsackItem.new(&lsquo;ALSTOM&rsquo;, 25, 5, 6),
KnapsackItem.new(&lsquo;ARCELORMITTAL_REG&rsquo;, 12, 9, 43),
KnapsackItem.new(&lsquo;AXA&rsquo;, 18, 2, 65),
KnapsackItem.new(&lsquo;BNP_PARIBAS&rsquo;, 53, 3, 24),</p>

<h1>&hellip;</h1>

<p>```</p>

<p>Le dernier nombre de chaque ligne doit être compris entre 1 et 100.
Voici comment faire en utilisant ce qu'on a appris depuis le début
de cette série <a href="http://lkdjiin.github.io/blog/2013/11/29/remplacer-sed-et-awk-par-ruby/">Remplacer Sed et Awk par Ruby</a>.</p>

<!-- more -->


<p>J'ai tout d'abord écrit mes lignes en mettant la chaîne <code>ABC</code> là où je voulais
un nombre aléatoire:</p>

<p>``` ruby
KnapsackItem.new(&lsquo;ACCOR&rsquo;, 32, 9, ABC),
KnapsackItem.new(&lsquo;AIR_LIQUIDE&rsquo;, 97, 7, ABC),
KnapsackItem.new(&lsquo;ALSTOM&rsquo;, 25, 5, ABC),
KnapsackItem.new(&lsquo;ARCELORMITTAL_REG&rsquo;, 12, 9, ABC),
KnapsackItem.new(&lsquo;AXA&rsquo;, 18, 2, ABC),
KnapsackItem.new(&lsquo;BNP_PARIBAS&rsquo;, 53, 3, ABC),</p>

<h1>&hellip;</h1>

<p>```</p>

<p>Cela va permettre au script de <em>trouver</em> l'endroit où substituer un nombre.</p>

<p>Puis, on lance le script suivant depuis une console:</p>

<p><code>bash
ruby -ple 'r=rand(100)+1;$_.sub!(/ABC/,r.to_s)' fichier_source
</code></p>

<p>Explications: <code>rand(100)+1</code> génère un nombre aléatoire entre 1 inclus et
100 inclus. <code>$_.sub!(/ABC/,r.to_s)</code> opère une substitution de la ligne en
cours de traitement: ABC est remplacé par le contenu de <code>r</code>, soit le nombre
aléatoire.</p>

<p>En réalité, je n'ai pas lancé ce script depuis une console, mais directement
dans Vim:</p>

<p><code>vim
:%! ruby -ple 'r=rand(100)+1;$_.sub\!(/ABC/,r.to_s)'
</code></p>

<p>Dans ce cas, il faut faire attention à échapper le <code>!</code>, sans quoi Vim
n'aimeras pas…</p>

<p>Voilà un exemple simple d'utilisation du mode <em>sed/awk</em> de Ruby.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Un plugin Vim pour replier/folder les commentaires]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/12/02/un-plugin-vim-pour-replier-slash-folder-les-commentaires/"/>
    <updated>2013-12-02T18:27:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/12/02/un-plugin-vim-pour-replier-slash-folder-les-commentaires</id>
    <content type="html"><![CDATA[<p>Dans un <a href="http://lkdjiin.github.io/blog/2013/11/28/vim-plier-folder-les-commentaires-de-style-unix/">article précédent</a>, je montrai comment écrire une fonction pour
folder les commentaires de style Unix dans un fichier. Cette solution avait
plusieurs limites alors j'ai eu envie d'en faire un plugin plus
intéressant. Je vous présente donc vim-foldcomments, mon premier plugin
pour Vim.</p>

<!-- more -->


<p>Pouvoir folder/replier tous les commentaires d'un fichier peut être
utile quand vous étudiez un tout nouveau code, ou au contraire, quand vous
travaillez sur un code bien connu.
Vous pouvez trouver le plugin sur Github: <a href="https://github.com/lkdjiin/vim-foldcomments">vim-foldcomments</a>.
Une fois installé, avec <a href="https://github.com/tpope/vim-pathogen">Pathogen</a> par exemple,
vous pouvez taper la commande:</p>

<pre><code>:FoldComments
</code></pre>

<p>pour replier les commentaires du fichier. Personnelement j'ai mappé cette
commande sur la touche F5 en mettant ceci dans mon .vimrc:</p>

<p><code>vim
map&lt;F5&gt; FoldComments&lt;Enter&gt;
</code></p>

<p>Le plugin est en version béta et ne gère pour l'instant que quelques
langages: Ruby, Haskell, Java, C, Javascript, Logo, Racket, Scheme, Vim,
ainsi que tous commentaires de style Unix (<code>#</code>). Les commentaires
multilignes (<code>/* … */</code> en C ou encore <code>=begin … =end</code> en Ruby) sont aussi
pris en compte.</p>

<p>N'hésitez pas à le tester et à me donner votre opinion. Vous pouvez aussi
bien sûr participer au code sur Github.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vim: Plier (folder) les commentaires de style Unix]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/11/28/vim-plier-folder-les-commentaires-de-style-unix/"/>
    <updated>2013-11-28T16:39:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/11/28/vim-plier-folder-les-commentaires-de-style-unix</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-2'>Niveau : <span>intermédiaire</span></div></p>

<p>Certains fichiers sources contiennent une proportion non négligeable de
commentaires, ou documentation interne. Par exemple, le fichier
<a href="https://github.com/ruby/ruby/blob/trunk/lib/csv.rb">ruby/lib/csv.rb</a> de
Ruby contient à ce jour 46% de lignes qui sont des commentaires. Quand on
cherche à étudier ces sources  pour la première fois, le nombre
important de commentaire est un frein pour naviguer ou se repérer dans
un tel fichier. Aujourd'hui je montre comment replier facilement les
ensembles de lignes commençant par <code>#</code>.</p>

<!-- more -->


<h2>Présentation</h2>

<p>Les fonctions de Vim qu'on va utiliser sont les suivantes:</p>

<pre><code>Fonction      Raccourci
=======================
foldmethod    fdm
foldexpr      fde
</code></pre>

<p>Vim comporte plusieurs méthodes de pliage (<em>folding</em>) de code, qu'on
spécifie avec <code>foldmethod</code>. Ici on va utiliser la méthode <code>expr</code>, qui
permet de faire à peu près tout ce qu'on veut. L'expression sera
spécifiée avec <code>foldexpr</code>.</p>

<h2>Essai en direct</h2>

<p>On va d'abord voir comment ça marche en entrant les commandes en direct live.
Ouvrez le fichier
<a href="https://github.com/ruby/ruby/blob/trunk/lib/csv.rb">ruby/lib/csv.rb</a>
(ou un autre avec beaucoup de commentaires de style Unix) et entrez ce qui
suit:</p>

<p><code>vim
:set fdm=expr
:set fde=getline(v:lnum)=~'^\\s*#'
</code></p>

<p>Badaboum ! Tout les commentaires sont pliés. Explications:</p>

<pre><code>getline(v:lnum)
</code></pre>

<p>Cette fonction retrouve une ligne du fichier. <code>v:lnum</code> est une variable
prédéfinie qui contient le numéro de la ligne courante.</p>

<pre><code>=~
</code></pre>

<p>Cet opérateur a le même sens qu'en Ruby, par exemple. Autrement dit,
est-ce que la chaîne à ma gauche correspond à la regex à ma droite ?</p>

<pre><code>'^\\s*#'
</code></pre>

<p>C'est notre regex: début de ligne (<code>^</code>), suivi par un nombre quelconque
de blancs (<code>\\s*</code>), suivi par le caractère <code>#</code>.</p>

<p>L'expression spécifiée dans <code>foldexpr</code> (ou comme ici <code>fde</code>) sera appelée
par Vim sur chaque ligne du fichier.</p>

<h2>Embarqué dans le fichier</h2>

<p>Maintenant qu'on sait comment ça marche, voyons comment faire pour ne pas
avoir à taper ces 2 lignes à chaque fois.</p>

<p>Si vous écrivez la ligne suivante dans un fichier, typiquement à la fin, les
commandes seront executées automatiquement à l'ouverture du fichier.
C'est un truc utile à connaitre.</p>

<p>``` vim</p>

<h1>vim:fdm=expr:fde=getline(v\:lnum)=~&lsquo;^\s*#&rsquo;:</h1>

<p>```</p>

<p>Notez qu'il a fallu échapper le <code>:</code> de <code>v:lnum</code> pour que ça fonctionne.</p>

<h2>Une fonction</h2>

<p>Une fonction dans le <code>.vimrc</code> sera plus intéressante:</p>

<p><code>vim
function FoldUnixComments()
  set foldmethod=expr
  set foldexpr=getline(v:lnum)=~'^\\s*#'
endfunction
</code></p>

<p>Pour l'executer:</p>

<p><code>vim
:call FoldUnixComments()
</code></p>

<h2>Conclusion</h2>

<p>La méthode présentée ici n'est pas parfaite. En effet <code>foldmethod=expr</code>
<em>écrase</em> votre ancienne méthode. Néanmoins, elle me semble suffisante
quand il s'agit juste d'étudier un fichier.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
