<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Catégorie : refactoring | lkdjiin's blog]]></title>
  <link href="http://lkdjiin.github.io/blog/categories/refactoring/atom.xml" rel="self"/>
  <link href="http://lkdjiin.github.io/"/>
  <updated>2014-05-23T21:35:40+02:00</updated>
  <id>http://lkdjiin.github.io/</id>
  <author>
    <name><![CDATA[Xavier Nayrac]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Demandez conseil régulièrement]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/04/22/demandez-conseil-regulierement/"/>
    <updated>2014-04-22T21:43:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/04/22/demandez-conseil-regulierement</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Aujourd'hui je réparais un bug, rien de très compliqué, juste un
évènement qui n'était pas appelé. Et j'en ai profité pour faire un
refactoring: passer d'une grosse méthode de classe à quelque chose de
plus construit.</p>

<!-- more -->


<p>En gros on avait cette structure:</p>

<p>``` ruby
module Machin
  class Truc</p>

<pre><code>def self.foo(des, arguments)
  # Plusieurs
  # lignes
  # d'initialisation
  # de variables.
  # Plusieurs
  # lignes
  # de calculs
  # divers.
  # Et j'en passe
  # ...
end
</code></pre>

<p>  end
end
```</p>

<p>J'ai fait un refactoring dans ce genre:</p>

<p>```
module Machin
  class Truc</p>

<pre><code>def self.foo
  implementation = TrucImplementation.new(des, arguments)
  implementation.fait_ce_que_tu_as_a_faire
end

class TrucImplementation
  def initialize(des, arguments)
    # Initialisation.
  end

  def fait_ce_que_tu_as_a_faire
    # Ceci.
    # Cela.
  end

  private

  def ceci
    # ...
  end

  def cela
    # ...
  end
end
</code></pre>

<p>  end
end
```</p>

<p>Mais j'étais vraiment ennuyé avec ce nom <code>TrucImplementation</code>. Je trouvais
que ça ne faisait pas très Ruby. Bref j'avais un sentiment bizarre sur ce
code donc j'ai demandé aux collègues une revue de code en disant que
j'aimerais bien nommé ça autrement…</p>

<p>La réponse n'a pas tardée, simple et sybilline: «Tu passes juste les méthodes de
<code>TrucImplementation</code> dans <code>Truc</code> et plus de soucis».</p>

<p>Pourquoi je raconte ça ? Pour me rappeler que parfois, avoir le nez dans le
code trop longtemps fait que tu ne vois plus ce qui est évident. Il ne faut
pas hésiter à demander un coup de main ; un point de vue différent, ou juste
plus frais, peut vite faire une différence.</p>

<p>Je pense que je n'ai pas fini d'être chambré là-dessus ;)</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Plugin vim-refactor pour Ruby]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/04/15/plugin-vim-refactor-pour-ruby/"/>
    <updated>2014-04-15T21:23:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/04/15/plugin-vim-refactor-pour-ruby</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Voici un plugin Vim issu d'une expérience qu'on mène avec un collègue:
<a href="https://github.com/lkdjiin/vim-refactor">vim-refactor</a>.
Il fonctionne pour l'instant sur du code Ruby et permet d'extraire une
méthode.</p>

<!-- more -->


<p>À partir de ce genre de code:</p>

<p>``` ruby
class HelloWorld</p>

<p>  def greet</p>

<pre><code>greeting = "Hello World!"
puts greeting
</code></pre>

<p>  end</p>

<p>end
```</p>

<p>En étant positionné sur la ligne 4, et en appelant <code>:ExtractMethod</code>
(ou bien sûr un mapping quelconque) vous obtenez ceci:</p>

<p>``` ruby
class HelloWorld</p>

<p>  def greet</p>

<pre><code>puts greeting
</code></pre>

<p>  end</p>

<p>  def greeting</p>

<pre><code>"Hello World!"
</code></pre>

<p>  end
end
```</p>

<p>C'est vraiment une version <em>alpha</em>. On espère implémenter d'autres types
de refactoring et supporter d'autres langages.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby - Utiliser les blocs pour faire du refactoring - partie 2]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/03/10/ruby-utiliser-les-blocs-pour-faire-du-refactoring-partie-2/"/>
    <updated>2014-03-10T15:58:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/03/10/ruby-utiliser-les-blocs-pour-faire-du-refactoring-partie-2</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Suite à l'article d'hier
(<a href="/blog/2014/03/09/ruby-utiliser-les-blocs-pour-faire-du-refactoring/">Utiliser les blocs pour faire du refactoring</a>),
on m'a demandé la différence entre <code>block.call</code> et <code>yield</code>. C'est parti.</p>

<!-- more -->


<p>On s'était arrêté là:</p>

<p>``` ruby test.rb
class Bidule
  def un</p>

<pre><code>helper('un') { puts 'Au milieu de la méthode un' }
</code></pre>

<p>  end</p>

<p>  def deux</p>

<pre><code>helper('deux') do
  puts 'Ceci est le milieu de la méthode deux'
end
</code></pre>

<p>  end</p>

<p>  private</p>

<p>  def helper(argument, &amp;block)</p>

<pre><code>puts "Début de la méthode #{argument}"
block.call
puts "Fin de la méthode #{argument}"
</code></pre>

<p>  end
end</p>

<p>bidule = Bidule.new
bidule.un
bidule.deux
```</p>

<p>Essayons de remplacer <code>block.call</code> par <code>yield</code>:</p>

<p>``` ruby test.rb
class Bidule
  def un</p>

<pre><code>helper('un') { puts 'Au milieu de la méthode un' }
</code></pre>

<p>  end</p>

<p>  def deux</p>

<pre><code>helper('deux') do
  puts 'Ceci est le milieu de la méthode deux'
end
</code></pre>

<p>  end</p>

<p>  private</p>

<p>  def helper(argument, &amp;block)</p>

<pre><code>puts "Début de la méthode #{argument}"
yield
puts "Fin de la méthode #{argument}"
</code></pre>

<p>  end
end</p>

<p>bidule = Bidule.new
bidule.un
bidule.deux
```</p>

<p>Lorsqu'on lance le programme, on voit qu'il n'y a pas de différences:</p>

<p><code>bash
$ ruby test.rb
Début de la méthode un
Au milieu de la méthode un
Fin de la méthode un
Début de la méthode deux
Ceci est le milieu de la méthode deux
Fin de la méthode deux
</code></p>

<p>Ok, donc <code>block.call</code> et <code>yield</code> c'est pareil ? Attends encore. Essayons
maintenant de supprimer le <code>&amp;block</code>:</p>

<p>``` ruby test.rb
class Bidule
  def un</p>

<pre><code>helper('un') { puts 'Au milieu de la méthode un' }
</code></pre>

<p>  end</p>

<p>  def deux</p>

<pre><code>helper('deux') do
  puts 'Ceci est le milieu de la méthode deux'
end
</code></pre>

<p>  end</p>

<p>  private</p>

<p>  def helper(argument)</p>

<pre><code>puts "Début de la méthode #{argument}"
yield
puts "Fin de la méthode #{argument}"
</code></pre>

<p>  end
end</p>

<p>bidule = Bidule.new
bidule.un
bidule.deux
```</p>

<p>Toujours pas de différences ! Par contre, on ne pourra pas appeler
<code>block.call</code> sans avoir défini <code>&amp;block</code>:</p>

<p>``` ruby
  def helper(argument)</p>

<pre><code>puts "Début de la méthode #{argument}"
block.call
puts "Fin de la méthode #{argument}"
</code></pre>

<p>  end
```</p>

<p>Le code ci-dessus donnera évidemment une erreur:</p>

<p><code>`` bash
$ ruby test.rb
Début de la méthode un
test.rb:16:in</code>helper': undefined local variable or method `block' for</p>

<h1>&lt;Bidule:0x9eaf6ec> (NameError)</h1>

<p>```</p>

<p>Toutes ces expérimentations nous ammène à une première conclusion: <em>Les
blocs sont implicites, et donc ils sont partout</em>. Ce que confirme, s'il en
est encore besoin, la session irb suivante:</p>

<p>``` irb</p>

<blockquote><blockquote><p>def foo(arg)
  puts arg
end
=> :foo
foo(&lsquo;ok&rsquo;) { puts &lsquo;I am in a block&rsquo; }
ok
```</p></blockquote></blockquote>

<p>Le contenu du bloc n'est jamais évalué, mais ne provoque pas d'erreur
lors de l'appel de <code>foo</code>.</p>

<p>Seconde conclusion, <code>block.call</code> et <code>yield</code> fonctionnent à l'identique.
Bien que je préfère <code>block.call</code>, qui me force à documenter la méthode
avec le <code>&amp;block</code>.</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby - Utiliser les blocs pour faire du refactoring]]></title>
    <link href="http://lkdjiin.github.io/blog/2014/03/09/ruby-utiliser-les-blocs-pour-faire-du-refactoring/"/>
    <updated>2014-03-09T15:50:00+01:00</updated>
    <id>http://lkdjiin.github.io/blog/2014/03/09/ruby-utiliser-les-blocs-pour-faire-du-refactoring</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Suivant le(s) langage(s) que vous pratiquiez avant de vous mettre à Ruby,
les blocs peuvent vous sembler plus ou moins obscurs. Voici un
exemple d'utilisation possible, lorsque vous faites du refactoring.</p>

<!-- more -->


<p>Prenons le programme suivant:</p>

<p>``` ruby test1.rb
class Bidule
  def un</p>

<pre><code>puts 'Début de la méthode un'
puts 'Au milieu de la méthode un'
puts 'Fin de la méthode un'
</code></pre>

<p>  end</p>

<p>  def deux</p>

<pre><code>puts 'Début de la méthode deux'
puts 'Au milieu de la méthode deux'
puts 'Fin de la méthode deux'
</code></pre>

<p>  end
end</p>

<p>bidule = Bidule.new
bidule.un
bidule.deux
```</p>

<p>Voici ce que ça donne quand on le lance:</p>

<p><code>bash
$ ruby test1.rb
Début de la méthode un
Au milieu de la méthode un
Fin de la méthode un
Début de la méthode deux
Au milieu de la méthode deux
Fin de la méthode deux
</code></p>

<p>Le problème de la classe <code>Bidule</code> est que ses méthodes <code>un</code> et <code>deux</code>
sont identiques (ou presque). On aura donc intérêt à extraire une
méthode helper:</p>

<p>``` ruby test1.rb
class Bidule
  def un</p>

<pre><code>helper('un')
</code></pre>

<p>  end</p>

<p>  def deux</p>

<pre><code>helper('deux')
</code></pre>

<p>  end</p>

<p>  private</p>

<p>  def helper(argument)</p>

<pre><code>puts "Début de la méthode #{argument}"
puts "Au milieu de la méthode #{argument}"
puts "Fin de la méthode #{argument}"
</code></pre>

<p>  end
end
```</p>

<p>Voilà, c'était du refactoring classique.</p>

<p>Maintenant imaginons que la classe <code>Bidule</code> soit ainsi:</p>

<p>``` ruby test1.rb
class Bidule
  def un</p>

<pre><code>puts 'Début de la méthode un'
puts 'Au milieu de la méthode un'
puts 'Fin de la méthode un'
</code></pre>

<p>  end</p>

<p>  def deux</p>

<pre><code>puts 'Début de la méthode deux'
puts 'Ceci est le milieu de la méthode deux'
puts 'Fin de la méthode deux'
</code></pre>

<p>  end
end
```</p>

<p>Vous avez remarqué la différence:</p>

<p>``` ruby
  def un</p>

<pre><code>#
puts 'Au milieu de la méthode un'
#
</code></pre>

<p>  end</p>

<p>  def deux</p>

<pre><code>#
puts 'Ceci est le milieu de la méthode deux'
#
</code></pre>

<p>  end
```</p>

<p>Cette fois les méthodes <code>un</code> et <code>deux</code> se distinguent un peu plus, bien
que la logique reste identique. On peux donc tirer avantage des blocs:</p>

<p>``` ruby test1.rb
class Bidule
  def un</p>

<pre><code>helper('un') { puts 'Au milieu de la méthode un' }
</code></pre>

<p>  end</p>

<p>  def deux</p>

<pre><code>helper('deux') do
  puts 'Ceci est le milieu de la méthode deux'
end
</code></pre>

<p>  end</p>

<p>  private</p>

<p>  def helper(argument, &amp;block)</p>

<pre><code>puts "Début de la méthode #{argument}"
block.call
puts "Fin de la méthode #{argument}"
</code></pre>

<p>  end
end
```</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Code propre: Non aux abréviations]]></title>
    <link href="http://lkdjiin.github.io/blog/2013/08/21/code-propre-non-aux-abreviations/"/>
    <updated>2013-08-21T14:46:00+02:00</updated>
    <id>http://lkdjiin.github.io/blog/2013/08/21/code-propre-non-aux-abreviations</id>
    <content type="html"><![CDATA[<p><div class='level-tag level-tag-1'>Niveau : <span>facile</span></div></p>

<p>Pour l'écriture du
<a href="http://lkdjiin.github.io/blog/2013/08/01/implementer-un-langage-sur-la-machine-virtuelle-parrot-partie-1/">langage Naam</a>,
je cherchais une implémentation toute
prête de l'algorithme
<a href="http://en.wikipedia.org/wiki/Shunting_yard_algorithm">Shunting Yard</a>
en Ruby. Je suis tombé sur
<a href="http://www.hokstad.com/operator-precedence-parser">cet article</a>
qui a retenu mon attention car l'auteur propose en plus
la sortie dans un arbre syntaxique. Ce qui est exactement ce que je voulais.
Par contre le code est une horreur à lire. Ça m'a donné l'idée d'une série
d'articles sur le refactoring (et ce que je pense être un code propre),
à partir d'exemples réels.</p>

<!-- more -->


<h2>Une abréviation ne veut pas forcement dire ce que vous pensez</h2>

<p>Du moins 99 fois sur 100 une abréviation est ambigue. Voyez le code suivant:</p>

<p><code>ruby
Oper = Struct.new(:pri,:sym,:type)
</code></p>

<p>Une seule ligne de code et trois abréviations (même quatre en comptant le
<code>Struct</code>, mais là dessus je n'ai pas la main). Que peut bien vouloir dire
<code>Oper</code> ? Operator, Operand, Operation ? Et que veut dire <code>pri</code> ? Primary,
priority, private ? Et pour <code>sym</code>, est-ce symbol ou symlink ou autre chose ?</p>

<p>Comparez avec la version suivante:</p>

<p><code>ruby
Operator = Struct.new(:priority, :symbol, :type)
</code></p>

<p>Laquelle vous semble la plus lisible ?  De prime abord on peut penser qu'il est
simple de déduire la signification d'un nom grâce au contexte. Mais je suis
persuadé du contraire.</p>

<p>D'abord, penser au contexte demande au lecteur de fournir un effort
intellectuel. Et cette énergie serait mieux utilisée à résoudre un
problème, à étendre le code, plutôt qu'à le décrypter.
Un code est souvent assez complexe par lui-même, pourquoi
demander un effort supplémentaire inutile au lecteur ?</p>

<p>Ensuite ça n'est pas seulement une question de contexte, mais aussi
de personne. Pour untel, oper est clairement l'abréviation d'operand, alors
que pour tel autre c'est clairement l'abréviation d'operator. Tout dépend
du vécu de la personne en question. Pourquoi mettre de l'ambiguité dans
nos codes ?</p>

<p>Voici un autre exemple:</p>

<p><code>ruby
o = @ostack.pop
if o.type == :lp
  @ostack &lt;&lt; o if pri &gt; 0
  return
end
@out.oper(o)
</code></p>

<p>Qu'est-ce que <code>o</code>, <code>lp</code>, <code>ostack</code> ? Imaginez le temps que prendra
la compréhension d'une trentaine de lignes comme celles-ci. Et maintenant
comparez avec ce qui suit:</p>

<p><code>ruby
operator = @operators.pop
if operator.type == :left_parenthesis
  @operators &lt;&lt; operator if priority &gt; 0
  return
end
@output.operator(operator)
</code></p>

<p>C'est plus verbeux, mais même si vous ne connaissez pas Ruby, une simple
lecture suffit pour comprendre ce que fait le code. Remarquez que j'ai
seulement supprimé les abréviations, il y aurait d'autres choses à dire
sur le refactoring de ce code mais ce sera pour un autre article.</p>

<p>J'espère avoir convaincu les sceptiques.
Pour finir je dois faire mon meaculpa: je me rends compte que j'utilise
bien trop d'abréviations dans mon code. À partir d'aujourd'hui, j'arrête ;)</p>

<script id='fb33k8u'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=lkdjiin&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=62;f.width=55;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fb33k8u');</script>


<p>À demain.</p>

<p></p>
]]></content>
  </entry>
  
</feed>
