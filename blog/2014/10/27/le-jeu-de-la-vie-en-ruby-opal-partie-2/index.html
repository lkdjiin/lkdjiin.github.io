<!DOCTYPE html>
<html lang="fr"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://lkdjiin.github.io/atom.xml" title="Xavier Nayrac" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Xavier Nayrac</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">À propos</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Le jeu de la vie en ruby (opal) - partie 2</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2014-10-27T21:09:00+01:00" itemprop="datePublished">27 October 2014
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>Deuxième partie du jeu de la vie en Ruby/Opal.rb, on va calculer le prochain
état d’une cellule, et extraire un <em>voisinage</em> de cellules d’une génération.
Après l’avoir écrit en Javascript, j’avoue que cette partie est quelque peu
ennuyeuse à reproduire. Je vais montrer du code, mais il y aura peu
d’explications, la logique étant la même qu’en Javascript (quoiqu’à base de
classes cette fois-ci).</p>

<!-- more -->

<p>Premier test et première classe pour spécifier une API.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="nb">require</span> <span class="s1">'./app/neighborhood.rb'</span>

<span class="n">describe</span> <span class="no">Neighborhood</span> <span class="k">do</span>

  <span class="n">let</span><span class="p">(</span><span class="ss">:alive</span><span class="p">)</span> <span class="p">{</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="p">}</span>

  <span class="n">describe</span> <span class="s1">'#next_state'</span> <span class="k">do</span>

    <span class="n">it</span> <span class="s1">'returns 1 when it will be alive'</span> <span class="k">do</span>
      <span class="n">neighborhood</span> <span class="o">=</span> <span class="no">Neighborhood</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">alive</span><span class="p">)</span>
      <span class="n">expect</span><span class="p">(</span><span class="n">neighborhood</span><span class="p">.</span><span class="nf">next_state</span><span class="p">).</span><span class="nf">to</span> <span class="n">eq</span> <span class="mi">1</span>
    <span class="k">end</span>

  <span class="k">end</span>

<span class="k">end</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">Neighborhood</span>

  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">cells</span><span class="p">)</span>
    <span class="vi">@cells</span> <span class="o">=</span> <span class="n">cells</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">next_state</span>
    <span class="mi">1</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre></figure>

<p><code class="language-plaintext highlighter-rouge">next_state</code> doit être capable de determiner que la cellule va mourrir.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="nb">require</span> <span class="s1">'./app/neighborhood.rb'</span>

<span class="n">describe</span> <span class="no">Neighborhood</span> <span class="k">do</span>

  <span class="n">let</span><span class="p">(</span><span class="ss">:alive</span><span class="p">)</span>       <span class="p">{</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="p">}</span>
  <span class="n">let</span><span class="p">(</span><span class="ss">:dead</span><span class="p">)</span>        <span class="p">{</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="p">}</span>
  <span class="n">let</span><span class="p">(</span><span class="ss">:dead2</span><span class="p">)</span>       <span class="p">{</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="p">}</span>
  <span class="n">let</span><span class="p">(</span><span class="ss">:dead3</span><span class="p">)</span>       <span class="p">{</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="p">}</span>

  <span class="n">describe</span> <span class="s1">'#next_state'</span> <span class="k">do</span>

    <span class="o">...</span>

    <span class="n">it</span> <span class="s1">'returns 0 when it will be dead'</span> <span class="k">do</span>
      <span class="p">[</span><span class="n">dead</span><span class="p">,</span> <span class="n">dead2</span><span class="p">,</span> <span class="n">dead3</span><span class="p">].</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">cells</span><span class="o">|</span>
        <span class="n">neighborhood</span> <span class="o">=</span> <span class="no">Neighborhood</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">cells</span><span class="p">)</span>
        <span class="n">expect</span><span class="p">(</span><span class="n">neighborhood</span><span class="p">.</span><span class="nf">next_state</span><span class="p">).</span><span class="nf">to</span> <span class="n">eq</span> <span class="mi">0</span>
      <span class="k">end</span>
    <span class="k">end</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">Neighborhood</span>

  <span class="no">ALIVE</span> <span class="o">=</span> <span class="mi">3</span>

  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">cells</span><span class="p">)</span>
    <span class="vi">@sum</span> <span class="o">=</span> <span class="n">cells</span><span class="p">.</span><span class="nf">reduce</span><span class="p">(:</span><span class="o">+</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">next_state</span>
    <span class="vi">@sum</span> <span class="o">==</span> <span class="no">ALIVE</span> <span class="p">?</span> <span class="mi">1</span> <span class="p">:</span> <span class="mi">0</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre></figure>

<p>Quand le nombre de cellules vivantes du voisinage est 4, le prochain état de
la cellule est le même que l’état actuel.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="nb">require</span> <span class="s1">'./app/neighborhood.rb'</span>

<span class="n">describe</span> <span class="no">Neighborhood</span> <span class="k">do</span>

  <span class="o">...</span>

  <span class="n">let</span><span class="p">(</span><span class="ss">:status_quo1</span><span class="p">)</span> <span class="p">{</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="p">}</span>
  <span class="n">let</span><span class="p">(</span><span class="ss">:status_quo2</span><span class="p">)</span> <span class="p">{</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="p">}</span>

  <span class="n">describe</span> <span class="s1">'#next_state'</span> <span class="k">do</span>

    <span class="o">...</span>

    <span class="n">it</span> <span class="s1">'returns old state in other cases'</span> <span class="k">do</span>
      <span class="n">neighborhood</span> <span class="o">=</span> <span class="no">Neighborhood</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">status_quo1</span><span class="p">)</span>
      <span class="n">expect</span><span class="p">(</span><span class="n">neighborhood</span><span class="p">.</span><span class="nf">next_state</span><span class="p">).</span><span class="nf">to</span> <span class="n">eq</span> <span class="mi">0</span>

      <span class="n">neighborhood</span> <span class="o">=</span> <span class="no">Neighborhood</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">status_quo2</span><span class="p">)</span>
      <span class="n">expect</span><span class="p">(</span><span class="n">neighborhood</span><span class="p">.</span><span class="nf">next_state</span><span class="p">).</span><span class="nf">to</span> <span class="n">eq</span> <span class="mi">1</span>
    <span class="k">end</span>
  <span class="k">end</span>

<span class="k">end</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">Neighborhood</span>

  <span class="no">ALIVE</span> <span class="o">=</span> <span class="mi">3</span>
  <span class="no">STATUS_QUO</span> <span class="o">=</span> <span class="mi">4</span>

  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">cells</span><span class="p">)</span>
    <span class="vi">@subject</span> <span class="o">=</span> <span class="n">cells</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
    <span class="vi">@sum</span> <span class="o">=</span> <span class="n">cells</span><span class="p">.</span><span class="nf">reduce</span><span class="p">(:</span><span class="o">+</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">next_state</span>
    <span class="k">case</span> <span class="vi">@sum</span>
    <span class="k">when</span> <span class="no">ALIVE</span> <span class="k">then</span> <span class="mi">1</span>
    <span class="k">when</span> <span class="no">STATUS_QUO</span> <span class="k">then</span> <span class="vi">@subject</span>
    <span class="k">else</span>
      <span class="mi">0</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre></figure>

<h2 id="extraire-un-voisinage-de-cellules">Extraire un voisinage de cellules</h2>

<p>Il faut pouvoir extraire un ensemble de 9 cellules (le <em>voisinage</em>) d’une
génération.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="nb">require</span> <span class="s1">'./app/neighborhood_extractor.rb'</span>

<span class="n">describe</span> <span class="no">NeighborhoodExtractor</span> <span class="k">do</span>

  <span class="n">let</span><span class="p">(</span><span class="ss">:generation</span><span class="p">)</span> <span class="k">do</span>
    <span class="p">[</span>
      <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
      <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
      <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="p">]</span>
  <span class="k">end</span>

  <span class="n">it</span> <span class="s1">'returns 9 cells'</span> <span class="k">do</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span>
    <span class="n">extractor</span> <span class="o">=</span> <span class="no">NeighborhoodExtractor</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">generation</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="n">expect</span><span class="p">(</span><span class="n">extractor</span><span class="p">.</span><span class="nf">cells</span><span class="p">.</span><span class="nf">size</span><span class="p">).</span><span class="nf">to</span> <span class="n">eq</span> <span class="mi">9</span>
  <span class="k">end</span>

<span class="k">end</span></code></pre></figure>

<p>Ça, c’est juste la mise en train.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">NeighborhoodExtractor</span>

  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">generation</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">cells</span>
    <span class="no">Array</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre></figure>

<p>Là, on commence à faire quelque chose d’utile.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">describe</span> <span class="no">NeighborhoodExtractor</span> <span class="k">do</span>

  <span class="n">let</span><span class="p">(</span><span class="ss">:generation</span><span class="p">)</span> <span class="k">do</span>
    <span class="p">[</span>
      <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
      <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
      <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="p">]</span>
  <span class="k">end</span>

  <span class="o">...</span>

  <span class="n">describe</span> <span class="s1">'inner position'</span> <span class="k">do</span>
    <span class="n">specify</span> <span class="s1">'x=1 y=1'</span> <span class="k">do</span>
      <span class="n">extractor</span> <span class="o">=</span> <span class="no">NeighborhoodExtractor</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">generation</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
      <span class="n">expect</span><span class="p">(</span><span class="n">extractor</span><span class="p">.</span><span class="nf">cells</span><span class="p">).</span><span class="nf">to</span> <span class="n">eq</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">NeighborhoodExtractor</span> <span class="o">&lt;</span> <span class="no">Struct</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">:generation</span><span class="p">,</span> <span class="ss">:x</span><span class="p">,</span> <span class="ss">:y</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">cells</span>
    <span class="p">[</span>
      <span class="o">*</span><span class="n">generation</span><span class="p">[</span><span class="n">y</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="o">..</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span>
      <span class="o">*</span><span class="n">generation</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="o">..</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span>
      <span class="o">*</span><span class="n">generation</span><span class="p">[</span><span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="o">..</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span>
    <span class="p">]</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre></figure>

<p>Maintenant, voyons le problème des bordures.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby">  <span class="n">describe</span> <span class="s1">'borders'</span> <span class="k">do</span>
    <span class="n">specify</span> <span class="s1">'x=1 y=0'</span> <span class="k">do</span>
      <span class="n">extractor</span> <span class="o">=</span> <span class="no">NeighborhoodExtractor</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">generation</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
      <span class="n">expect</span><span class="p">(</span><span class="n">extractor</span><span class="p">.</span><span class="nf">cells</span><span class="p">).</span><span class="nf">to</span> <span class="n">eq</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="k">end</span>
  <span class="k">end</span></code></pre></figure>

<p>La manière dont le test échoue est intéressante. C’est du à la façon dont Ruby
gère les indexs négatifs pour les tableaux, ceux-cis sont parfaitement
autorisés.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Failures:

  1) NeighborhoodExtractor borders x=1 y=0
     Failure/Error: expect(extractor.cells).to eq [0, 0, 0, 0, 1, 0, 1, 0, 1]
       
       expected: [0, 0, 0, 0, 1, 0, 1, 0, 1]
            got: [0, 1, 1, 0, 1, 0, 1, 0, 1]
       
       (compared using ==)
     # ./spec/neighborhood_extractor_spec.rb:29:in `block (3 levels) in &lt;top (required)&gt;'
</code></pre></div></div>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">NeighborhoodExtractor</span> <span class="o">&lt;</span> <span class="no">Struct</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">:generation</span><span class="p">,</span> <span class="ss">:x</span><span class="p">,</span> <span class="ss">:y</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">cells</span>
    <span class="p">[</span>
      <span class="o">*</span><span class="n">row1</span><span class="p">,</span>
      <span class="o">*</span><span class="n">generation</span><span class="p">[</span><span class="n">y</span><span class="p">][</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="o">..</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span>
      <span class="o">*</span><span class="n">generation</span><span class="p">[</span><span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="o">..</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span>
    <span class="p">]</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">row1</span>
    <span class="k">if</span> <span class="n">y</span> <span class="o">==</span> <span class="mi">0</span>
      <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span>
      <span class="n">generation</span><span class="p">[</span><span class="n">y</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="o">..</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre></figure>

<p>Testons avec la bordure du bas.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby">    <span class="n">specify</span> <span class="s1">'x=2 y=2'</span> <span class="k">do</span>
      <span class="n">extractor</span> <span class="o">=</span> <span class="no">NeighborhoodExtractor</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">generation</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
      <span class="n">expect</span><span class="p">(</span><span class="n">extractor</span><span class="p">.</span><span class="nf">cells</span><span class="p">).</span><span class="nf">to</span> <span class="n">eq</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="k">end</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">NeighborhoodExtractor</span> <span class="o">&lt;</span> <span class="no">Struct</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">:generation</span><span class="p">,</span> <span class="ss">:x</span><span class="p">,</span> <span class="ss">:y</span><span class="p">)</span>

  <span class="o">...</span>

  <span class="k">def</span> <span class="nf">row3</span>
    <span class="k">if</span> <span class="n">y</span> <span class="o">==</span> <span class="n">generation</span><span class="p">.</span><span class="nf">size</span> <span class="o">-</span> <span class="mi">1</span>
      <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span>
      <span class="n">generation</span><span class="p">[</span><span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="o">..</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre></figure>

<p>Un peu de refactoring.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">NeighborhoodExtractor</span> <span class="o">&lt;</span> <span class="no">Struct</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">:generation</span><span class="p">,</span> <span class="ss">:x</span><span class="p">,</span> <span class="ss">:y</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">cells</span>
    <span class="p">[</span> <span class="o">*</span><span class="n">group_of_tree</span><span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="o">*</span><span class="n">group_of_tree</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="o">*</span><span class="n">group_of_tree</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">]</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">group_of_tree</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">row</span> <span class="o">==</span> <span class="n">generation</span><span class="p">.</span><span class="nf">size</span>
      <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span>
      <span class="n">generation</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="o">..</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">end</span>
  <span class="k">end</span>

<span class="k">end</span></code></pre></figure>

<p>La bordure de gauche.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby">    <span class="n">specify</span> <span class="s1">'x=0 y=1'</span> <span class="k">do</span>
      <span class="n">extractor</span> <span class="o">=</span> <span class="no">NeighborhoodExtractor</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">generation</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
      <span class="n">expect</span><span class="p">(</span><span class="n">extractor</span><span class="p">.</span><span class="nf">cells</span><span class="p">).</span><span class="nf">to</span> <span class="n">eq</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="k">end</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">NeighborhoodExtractor</span> <span class="o">&lt;</span> <span class="no">Struct</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">:generation</span><span class="p">,</span> <span class="ss">:x</span><span class="p">,</span> <span class="ss">:y</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">cells</span>
    <span class="p">[</span> <span class="o">*</span><span class="n">group_of_tree</span><span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="o">*</span><span class="n">group_of_tree</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="o">*</span><span class="n">group_of_tree</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">]</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">group_of_tree</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">row</span> <span class="o">==</span> <span class="n">generation</span><span class="p">.</span><span class="nf">size</span>
      <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span>
      <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="p">[</span> <span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="n">generation</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">x</span><span class="o">..</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="p">]</span>
      <span class="k">else</span>
        <span class="n">generation</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="o">..</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>

<span class="k">end</span></code></pre></figure>

<p>Et enfin celle de droite.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby">    <span class="n">specify</span> <span class="s1">'x=3 y=1'</span> <span class="k">do</span>
      <span class="n">extractor</span> <span class="o">=</span> <span class="no">NeighborhoodExtractor</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">generation</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
      <span class="n">expect</span><span class="p">(</span><span class="n">extractor</span><span class="p">.</span><span class="nf">cells</span><span class="p">).</span><span class="nf">to</span> <span class="n">eq</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="k">end</span></code></pre></figure>

<p>Ok, c’est moche, mais ça fonctionne.</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="k">class</span> <span class="nc">NeighborhoodExtractor</span> <span class="o">&lt;</span> <span class="no">Struct</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="ss">:generation</span><span class="p">,</span> <span class="ss">:x</span><span class="p">,</span> <span class="ss">:y</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">cells</span>
    <span class="p">[</span> <span class="o">*</span><span class="n">group_of_tree</span><span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="o">*</span><span class="n">group_of_tree</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="o">*</span><span class="n">group_of_tree</span><span class="p">(</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">]</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">group_of_tree</span><span class="p">(</span><span class="n">row_index</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">row_index</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">row_index</span> <span class="o">==</span> <span class="n">generation</span><span class="p">.</span><span class="nf">size</span>
      <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span>
      <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="p">[</span> <span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="n">generation</span><span class="p">[</span><span class="n">row_index</span><span class="p">][</span><span class="n">x</span><span class="o">..</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="p">]</span>
      <span class="k">elsif</span> <span class="n">x</span> <span class="o">==</span> <span class="n">generation</span><span class="p">.</span><span class="nf">first</span><span class="p">.</span><span class="nf">size</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="p">[</span><span class="o">*</span><span class="n">generation</span><span class="p">[</span><span class="n">row_index</span><span class="p">][</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="o">..</span><span class="n">x</span><span class="p">],</span> <span class="mi">0</span><span class="p">]</span>
      <span class="k">else</span>
        <span class="n">generation</span><span class="p">[</span><span class="n">row_index</span><span class="p">][</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="o">..</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>

<span class="k">end</span></code></pre></figure>

<p>Je devrais <em>refactorer</em> ce code, mais comme je sais qu’il va bientôt changer
(quand on va supprimer les bordures de la surface de jeu) je me dis qu’on verra
bien à ce moment là.</p>

<p>À noter pour finir que je ne teste pas les cas des cellules de coin. Nous avons
vu dans la version Javascript que si les cellules des bords droits, gauches,
hauts et bas fonctionnent, alors les coins fonctionnent aussi.</p>

<p>La prochaine fois on verra la classe <code class="language-plaintext highlighter-rouge">Game</code> et une petite astuce pour faire
un <code class="language-plaintext highlighter-rouge">sleep</code> like en Opal.rb.</p>


  </div>

  <br/>
  <br/>
  <div style="text-align: center">/ / / / / / / / / /</div>
  <br/>
  <br/>

  <div style="text-align: center">
    
      <a href="/blog/2014/10/25/le-jeu-de-la-vie-en-ruby-opal-partie-1/" title="Article précédent: Le jeu de la vie en ruby (opal) - partie 1">&laquo; Le jeu de la vie en ruby (opal) - partie 1</a> ---//---
    
    
      <a href="/blog/2014/10/29/le-jeu-de-la-vie-en-ruby-opal-partie-3/" title="Article suivant: Le jeu de la vie en ruby (opal) - partie 3">Le jeu de la vie en ruby (opal) - partie 3 &raquo;</a>
    
  </div>

  <br/>
  <br/><a class="u-url" href="/blog/2014/10/27/le-jeu-de-la-vie-en-ruby-opal-partie-2/" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <div>
    <p class="rss-subscribe">s'abonner <a href="/atom.xml">via RSS</a></p>
    </div>

    <h2 class="footer-heading">Xavier Nayrac</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">
            Copyright 2013 - 2025
            </li><li><a class="u-email" href="mailto:"></a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list">

  <li style="margin-bottom:10px;">
    <a href="https://github.com/lkdjiin">
      <img src="/images/github.png" />
      <span class="username">lkdjiin</span>
    </a>
  </li>

  <li style="margin-bottom:10px;">
    <a href="https://ruby.social/@lkdjiin">
      <img src="/images/mastodon.png" />
      <span class="username">lkdjiin</span>
    </a>
  </li>

  <li style="margin-bottom:10px;">
    <a href="/atom.xml">
      <img src="/images/atom.png" />
      <span class="username">RSS</span>
    </a>
  </li>
</ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Dev accro au TDD, brasseur d&#39;appartement, musicien, maker, ex créateur d&#39;effets pour guitare, heureux utilisateur de Vim.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
